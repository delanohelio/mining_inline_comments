{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxODM2MDQ3", "number": 1433, "title": "[HUDI-728]: Implement custom key generator", "bodyText": "Tips\n\nThank you very much for contributing to Apache Hudi.\nPlease review https://hudi.apache.org/contributing.html before opening a pull request.\n\nWhat is the purpose of the pull request\nWe have TimestampBasedKeyGenerator for defining custom partition paths and we have ComplexKeyGenerator for supporting having combination of fields as record key or partition key.\nHowever we do not have support for the case where one wants to have combination of fields as record key along with being able to define custom partition paths.\nThis PR aims to give a generic implementation where we can define key generator for every field in partition path.\nBrief change log\n\n\nIntroduced PartitionKeyType in KeyGenerator, also added 2 new functions\nString getPartitionPath(GenericRecord record, String partitionPathField)\nString getRecordKey(GenericRecord record)\n\n\nIntroduced a new class CustomKeyGenerator which accepts input for partition path field in form -> field1:PartitionKeyType1,field2:PartitionKeyType2\n\n\nAll the corner cases have been handled. Added a test class TestCustomKeyGenerator with only one test case for now. Will be adding more.\n\n\nVerify this pull request\n(Please pick either of the following options)\nThis pull request is a trivial rework / code cleanup without any test coverage.\n(or)\nThis pull request is already covered by existing tests, such as (please describe tests).\n(or)\nThis change added tests and can be verified as follows:\n(example:)\n\nAdded integration tests for end-to-end.\nAdded HoodieClientWriteTest to verify the change.\nManually verified the change by running a job locally.\n\nCommitter checklist\n\n\n Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-03-21T09:20:33Z", "url": "https://github.com/apache/hudi/pull/1433", "merged": true, "mergeCommit": {"oid": "c7f1a781ab4ff3784d53a102364fd85e379811d1"}, "closed": true, "closedAt": "2020-07-09T11:35:07Z", "author": {"login": "pratyakshsharma"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcS15qMAFqTM4NDI1Nzk5Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwoqDbgBqjM1MDIwNDAzMjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjU3OTk3", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-384257997", "createdAt": "2020-03-30T21:51:33Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMTo1MTozM1rOF99kxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjowNDowNFrOF997Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjI5NA==", "bodyText": "java docs. Also try to see if having an example would help devs.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400516294", "createdAt": "2020-03-30T21:51:33Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxNjkwNw==", "bodyText": "do you think we need to check for empty as well?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400516907", "createdAt": "2020-03-30T21:52:51Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUxOTE0OQ==", "bodyText": "Do you think adding a field called \"KeyGeneratorType\" in KeyGenerator would make sense. Looking to avoid typos with these string vals. So that we can use getKeyGenerateType()", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400519149", "createdAt": "2020-03-30T21:57:39Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMDY0NQ==", "bodyText": "ah, you have defined an enum. May I know why using strings back there ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400520645", "createdAt": "2020-03-30T22:00:50Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTc0Ng==", "bodyText": "Do you think we can add tests for these cases as well?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521746", "createdAt": "2020-03-30T22:03:27Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case \"timestampBased\":\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case \"noPartition\":\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTg5MA==", "bodyText": "same here. In general, lets try to see if we can add tests for all happy and exception paths if doable.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521890", "createdAt": "2020-03-30T22:03:48Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (fieldWithType[1]) {\n+        case \"simple\":\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case \"timestampBased\":\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case \"noPartition\":\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyMTk5NA==", "bodyText": "Can we have test covering this line?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r400521994", "createdAt": "2020-03-30T22:04:04Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.util.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDM3NzM4", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-396037738", "createdAt": "2020-04-19T16:38:14Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NTkwMjcw", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-396590270", "createdAt": "2020-04-20T15:57:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1NzoxN1rOGIbqEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNTozODoxMFrOGLHSbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NDkzMQ==", "bodyText": "please name enum elements like constants.. all caps", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411494931", "createdAt": "2020-04-20T15:57:17Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {\n+    simple(\"simple\"), complex(\"complex\"), timestampBased(\"timestampBased\"), noPartition(\"noPartition\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NTQ0NA==", "bodyText": "this is not needed right? we can just use ordinal/name from the name itself?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411495444", "createdAt": "2020-04-20T15:57:59Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);\n+\n+  public abstract String getRecordKey(GenericRecord record);\n+\n+  public enum PartitionKeyType {\n+    simple(\"simple\"), complex(\"complex\"), timestampBased(\"timestampBased\"), noPartition(\"noPartition\");\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjM5Ng==", "bodyText": "javadocs for these abstract methods?\nAlso I am not sure if it makes sense to add these component methods here.. We already have a top level one getKey()", "url": "https://github.com/apache/hudi/pull/1433#discussion_r411496396", "createdAt": "2020-04-20T15:59:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDA4MQ==", "bodyText": "I assume this whol;e change is just restructuring code", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414304081", "createdAt": "2020-04-24T05:30:06Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -64,6 +62,32 @@ public HoodieKey getKey(GenericRecord record) {\n       throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n     }\n \n+    String recordKey = getRecordKey(record);\n+    StringBuilder partitionPath = new StringBuilder();\n+    for (String partitionPathField : partitionPathFields) {\n+      partitionPath.append(getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return new HoodieKey(recordKey, partitionPath.toString());\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA==", "bodyText": "all this needs to be documented for the user?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414304790", "createdAt": "2020-04-24T05:31:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNTQyMw==", "bodyText": "let's turn this into an enum?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414305423", "createdAt": "2020-04-24T05:33:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record, null);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String pathField) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    KeyGenerator keyGenerator;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case simple:\n+          keyGenerator = new SimpleKeyGenerator(properties);\n+          break;\n+        case timestampBased:\n+          keyGenerator = new TimestampBasedKeyGenerator(properties);\n+          break;\n+        case noPartition:\n+          keyGenerator = new NonpartitionedKeyGenerator(properties);\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(keyGenerator.getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {\n+    switch (type) {\n+      case \"simple\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ==", "bodyText": "or can they leave the partitionPathFields as empty?  that seems more intuitive?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414306395", "createdAt": "2020-04-24T05:36:37Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjkyNw==", "bodyText": "I understand you want to reuse the other key generators.. I suggest exposing the methods in those concrete classes without leaking it to the abstract class here.. This will otherwise break all custom key generator implementations out there..", "url": "https://github.com/apache/hudi/pull/1433#discussion_r414306927", "createdAt": "2020-04-24T05:38:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/KeyGenerator.java", "diffHunk": "@@ -40,4 +40,22 @@ protected KeyGenerator(TypedProperties config) {\n    * Generate a Hoodie Key out of provided generic record.\n    */\n   public abstract HoodieKey getKey(GenericRecord record);\n+\n+  public abstract String getPartitionPath(GenericRecord record, String partitionPathField);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjM5Ng=="}, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMjk5MDQx", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-401299041", "createdAt": "2020-04-27T20:25:13Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDoyNToxNFrOGM2KPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDozOToxOVrOGM2rbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyMzQ1NQ==", "bodyText": "yes..\nis the CustomKeyGenerator compatible with the SimpleKeyGenerator configs? I am wondering if we can replace the default with this, without forcing user to do any additional work.. I think this is worth pursuing.. (We can then rename this DefaultKeyGenerator", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416123455", "createdAt": "2020-04-27T20:25:14Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNDc5MA=="}, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNDQ3MA==", "bodyText": "If you think, it will improve user experience we can do it. I mean not specifying partition field can default to noPartition and it wont be a surprising outcome for the user, right?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416124470", "createdAt": "2020-04-27T20:26:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.noPartition;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.simple;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.timestampBased;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwNjM5NQ=="}, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNTM3MQ==", "bodyText": "we can can skip the \"Based\" ? just timestamp ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416125371", "createdAt": "2020-04-27T20:28:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.NOPARTITION;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.SIMPLE;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.TIMESTAMP_BASED;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP_BASED:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case NOPARTITION:\n+          NonpartitionedKeyGenerator nonpartitionedKeyGenerator = new NonpartitionedKeyGenerator(properties);\n+          partitionPath.append(nonpartitionedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {\n+    switch (type) {\n+      case \"simple\":\n+        return SIMPLE;\n+      case \"timestampBased\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzU4Ng==", "bodyText": "why do we need this method? would n't PartitionKeyType.valueOf(type.toUpper()) help?  I think its better if we keep the enum names mapping 1-1 to the strings they are constructed from.. thoughts?\nfield1:SIMPLE,field2:TIMESTAMP for e.g", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416127586", "createdAt": "2020-04-27T20:31:39Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.NOPARTITION;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.SIMPLE;\n+import static org.apache.hudi.keygen.KeyGenerator.PartitionKeyType.TIMESTAMP_BASED;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, use field1:noPartition.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null || partitionPathFields.isEmpty()) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+    boolean nonPartitionedTable = false;\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      switch (getPartitionKeyType(fieldWithType[1])) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP_BASED:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case NOPARTITION:\n+          NonpartitionedKeyGenerator nonpartitionedKeyGenerator = new NonpartitionedKeyGenerator(properties);\n+          partitionPath.append(nonpartitionedKeyGenerator.getPartitionPath(record, partitionPathField));\n+          nonPartitionedTable = true;\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");\n+      }\n+\n+      if (nonPartitionedTable) {\n+        return \"\";\n+      }\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return partitionPath.toString();\n+  }\n+\n+  private PartitionKeyType getPartitionKeyType(String type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDE0Mg==", "bodyText": "just one line new HoodieKey(getRecordKey(record), EMPTY....) ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416130142", "createdAt": "2020-04-27T20:36:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/GlobalDeleteKeyGenerator.java", "diffHunk": "@@ -52,6 +52,11 @@ public HoodieKey getKey(GenericRecord record) {\n       throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n     }\n \n+    String recordKey = getRecordKey(record);\n+    return new HoodieKey(recordKey, EMPTY_PARTITION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTk1MA==", "bodyText": "ok.. this is just overriding from SimpleKeyGenerator . ack", "url": "https://github.com/apache/hudi/pull/1433#discussion_r416131950", "createdAt": "2020-04-27T20:39:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -88,6 +86,13 @@ public TimestampBasedKeyGenerator(TypedProperties config) {\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n+    String recordKey = getRecordKey(record);\n+    String partitionPath = getPartitionPath(record, partitionPathField);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMzIwMTkz", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-412320193", "createdAt": "2020-05-15T03:17:47Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzoyMTowM1rOGV1Kkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwMzo0Mjo0MFrOGV1d7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NDMzOQ==", "bodyText": "does this needs to be public? why not protected or package private?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425544339", "createdAt": "2020-05-15T03:21:03Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -49,21 +50,44 @@\n \n   public ComplexKeyGenerator(TypedProperties props) {\n     super(props);\n-    this.recordKeyFields = Arrays.asList(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\"))\n-            .stream().map(String::trim).collect(Collectors.toList());\n-    this.partitionPathFields =\n-        Arrays.asList(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\"))\n-                .stream().map(String::trim).collect(Collectors.toList());\n+    DataSourceUtils.checkRequiredProperties(props, Arrays.asList(\n+        DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(),\n+        DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY())\n+    );\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\"))\n+        .map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields = Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\"))\n+        .map(String::trim).collect(Collectors.toList());\n     this.hiveStylePartitioning = props.getBoolean(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(),\n         Boolean.parseBoolean(DataSourceWriteOptions.DEFAULT_HIVE_STYLE_PARTITIONING_OPT_VAL()));\n   }\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n-    if (recordKeyFields == null || partitionPathFields == null) {\n-      throw new HoodieKeyException(\"Unable to find field names for record key or partition path in cfg\");\n+    String recordKey = getRecordKey(record);\n+    StringBuilder partitionPath = new StringBuilder();\n+    for (String partitionPathField : partitionPathFields) {\n+      partitionPath.append(getPartitionPath(record, partitionPathField));\n+      partitionPath.append(DEFAULT_PARTITION_PATH_SEPARATOR);\n+    }\n+    partitionPath.deleteCharAt(partitionPath.length() - 1);\n+\n+    return new HoodieKey(recordKey, partitionPath.toString());\n+  }\n+\n+  public String getPartitionPath(GenericRecord record, String partitionPathField) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NTcwOA==", "bodyText": "minor typo. \"customize\"", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425545708", "createdAt": "2020-05-15T03:27:15Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzIzNw==", "bodyText": "same here. does this need to be public?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425547237", "createdAt": "2020-05-15T03:33:13Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/SimpleKeyGenerator.java", "diffHunk": "@@ -66,6 +68,14 @@ public HoodieKey getKey(GenericRecord record) {\n       partitionPath = partitionPathField + \"=\" + partitionPath;\n     }\n \n-    return new HoodieKey(recordKey, partitionPath);\n+    return partitionPath;\n+  }\n+\n+  public String getRecordKey(GenericRecord record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0NzcxOQ==", "bodyText": "did you think if we need to make this an abstract method in KeyGenerator?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425547719", "createdAt": "2020-05-15T03:35:15Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/SimpleKeyGenerator.java", "diffHunk": "@@ -66,6 +68,14 @@ public HoodieKey getKey(GenericRecord record) {\n       partitionPath = partitionPathField + \"=\" + partitionPath;\n     }\n \n-    return new HoodieKey(recordKey, partitionPath);\n+    return partitionPath;\n+  }\n+\n+  public String getRecordKey(GenericRecord record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA==", "bodyText": "a naive question. May I know why some key generators of them are extending from SimpleKeyGenerator and some are extending KeyGenerators. Even those extending from SimpleKeyGen, I don't see any obvious need to extend from SimpleKeyGenerator. Can you throw some light.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548350", "createdAt": "2020-05-15T03:38:16Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -88,6 +86,13 @@ public TimestampBasedKeyGenerator(TypedProperties config) {\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n+    String recordKey = getRecordKey(record);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU1MQ==", "bodyText": "why all these methods are public ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548551", "createdAt": "2020-05-15T03:39:19Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkyOQ==", "bodyText": "sorry, if size = 1, how is it a no partition case ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425548929", "createdAt": "2020-05-15T03:41:10Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTIyMw==", "bodyText": "can we do it in one line.\npartitionPath.append(new SimpleKeyGenerator(properties).getPartitionPath(record, partitionPathField));", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425549223", "createdAt": "2020-05-15T03:42:27Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTI5NQ==", "bodyText": "same here. can we do it in one line.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r425549295", "createdAt": "2020-05-15T03:42:40Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customise some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  public String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          SimpleKeyGenerator simpleKeyGenerator = new SimpleKeyGenerator(properties);\n+          partitionPath.append(simpleKeyGenerator.getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP:\n+          TimestampBasedKeyGenerator timestampBasedKeyGenerator = new TimestampBasedKeyGenerator(properties);\n+          partitionPath.append(timestampBasedKeyGenerator.getPartitionPath(record, partitionPathField));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjA1OTc4", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-413205978", "createdAt": "2020-05-17T22:43:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjo0Mzo1NlrOGWkGIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMjo1MTo1NFrOGWkIsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzI0OQ==", "bodyText": "do you think adding the invalid key type here would help ?", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426313249", "createdAt": "2020-05-17T22:43:56Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields.\n+ * Similarly partition path can be configured to have multiple fields or only one field. This class expects value for prop\n+ * \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider:\n+ * 1. If you want to customize some partition path field on a timestamp basis, you can use field1:timestampBased\n+ * 2. If you simply want to have the value of your configured field in the partition path, use field1:simple\n+ * 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class CustomKeyGenerator extends KeyGenerator {\n+\n+  protected final List<String> recordKeyFields;\n+  protected final List<String> partitionPathFields;\n+  protected final TypedProperties properties;\n+  private static final String DEFAULT_PARTITION_PATH_SEPARATOR = \"/\";\n+  private static final String SPLIT_REGEX = \":\";\n+\n+  /**\n+   * Used as a part of config in CustomKeyGenerator.java.\n+   */\n+  public enum PartitionKeyType {\n+    SIMPLE, TIMESTAMP\n+  }\n+\n+  public CustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.properties = props;\n+    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields =\n+      Arrays.stream(props.getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY()).split(\",\")).map(String::trim).collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public HoodieKey getKey(GenericRecord record) {\n+    //call function to get the record key\n+    String recordKey = getRecordKey(record);\n+    //call function to get the partition key based on the type for that partition path field\n+    String partitionPath = getPartitionPath(record);\n+    return new HoodieKey(recordKey, partitionPath);\n+  }\n+\n+  private String getPartitionPath(GenericRecord record) {\n+    if (partitionPathFields == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (partitionPathFields.size() == 1 && partitionPathFields.get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : partitionPathFields) {\n+      String[] fieldWithType = field.split(SPLIT_REGEX);\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          partitionPath.append(new SimpleKeyGenerator(properties).getPartitionPath(record, partitionPathField));\n+          break;\n+        case TIMESTAMP:\n+          partitionPath.append(new TimestampBasedKeyGenerator(properties).getPartitionPath(record, partitionPathField));\n+          break;\n+        default:\n+          throw new HoodieDeltaStreamerException(\"Please provide valid PartitionKeyType with fields!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMzkwNA==", "bodyText": "Usually its a good practice to use for logical reasons and not just for variables. If you think TimestampBasedKeyGenerator is an extension to Simple, it is fine. But will let you take a call. Just my 2 cents.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r426313904", "createdAt": "2020-05-17T22:51:54Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -88,6 +86,13 @@ public TimestampBasedKeyGenerator(TypedProperties config) {\n \n   @Override\n   public HoodieKey getKey(GenericRecord record) {\n+    String recordKey = getRecordKey(record);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM1MA=="}, "originalCommit": null, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTQxMzI2", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-416541326", "createdAt": "2020-05-21T22:43:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjo0MzowMVrOGZFSvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjo0Mzo1MFrOGZFTrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDMwMA==", "bodyText": "need a new line", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954300", "createdAt": "2020-05-21T22:43:01Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java", "diffHunk": "@@ -154,4 +153,4 @@ private long convertLongTimeToMillis(Long partitionVal) {\n \n     return MILLISECONDS.convert(partitionVal, timeUnit);\n   }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDM3MQ==", "bodyText": "same here", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954371", "createdAt": "2020-05-21T22:43:16Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestComplexKeyGenerator.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestComplexKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps(boolean getComplexRecordKey) {\n+    TypedProperties properties = new TypedProperties();\n+    if (getComplexRecordKey) {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key, pii_col\");\n+    } else {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    }\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesWithoutPartitionPathProp() {\n+    return getCommonProps(false);\n+  }\n+\n+  private TypedProperties getPropertiesWithoutRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getWrongRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_wrong_key\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp,ts_ms\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testNullPartitionPathFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new ComplexKeyGenerator(getPropertiesWithoutPartitionPathProp()));\n+  }\n+\n+  @Test\n+  public void testNullRecordKeyFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new ComplexKeyGenerator(getPropertiesWithoutRecordKeyProp()));\n+  }\n+\n+  @Test\n+  public void testWrongRecordKeyField() {\n+    ComplexKeyGenerator keyGenerator = new ComplexKeyGenerator(getWrongRecordKeyFieldProps());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testHappyFlow() {\n+    ComplexKeyGenerator keyGenerator = new ComplexKeyGenerator(getProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686/ts_ms=2020-03-21\");\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDQxNw==", "bodyText": "same here", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954417", "createdAt": "2020-05-21T22:43:25Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestCustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.config.TypedProperties;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestCustomKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps(boolean getComplexRecordKey) {\n+    TypedProperties properties = new TypedProperties();\n+    if (getComplexRecordKey) {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key, pii_col\");\n+    } else {\n+      properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    }\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesForSimpleKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getImproperPartitionFieldFormatProp() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getInvalidPartitionKeyTypeProps() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:dummy\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyWithSimplePartitionProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyAndPartitionPathProps() {\n+    TypedProperties properties = getCommonProps(true);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple,ts_ms:timestamp\");\n+    populateNecessaryPropsForTimestampBasedKeyGen(properties);\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropsWithoutRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp:simple\");\n+    return properties;\n+  }\n+\n+  private void populateNecessaryPropsForTimestampBasedKeyGen(TypedProperties properties) {\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.timestamp.type\", \"DATE_STRING\");\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.input.dateformat\", \"yyyy-MM-dd\");\n+    properties.put(\"hoodie.deltastreamer.keygen.timebased.output.dateformat\", \"yyyyMMdd\");\n+  }\n+\n+  private TypedProperties getPropertiesForTimestampBasedKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"ts_ms:timestamp\");\n+    populateNecessaryPropsForTimestampBasedKeyGen(properties);\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesForNonPartitionedKeyGen() {\n+    TypedProperties properties = getCommonProps(false);\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testSimpleKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForSimpleKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+\n+  @Test\n+  public void testTimestampBasedKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForTimestampBasedKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"ts_ms=20200321\");\n+  }\n+\n+  @Test\n+  public void testNonPartitionedKeyGenerator() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getPropertiesForNonPartitionedKeyGen());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertTrue(key.getPartitionPath().isEmpty());\n+  }\n+\n+  @Test\n+  public void testInvalidPartitionKeyType() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getInvalidPartitionKeyTypeProps());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when invalid PartitionKeyType is provided!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"No enum constant org.apache.hudi.keygen.CustomKeyGenerator.PartitionKeyType.DUMMY\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testNoRecordKeyFieldProp() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getPropsWithoutRecordKeyFieldProps());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when record key field is not provided!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"Property hoodie.datasource.write.recordkey.field not found\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testPartitionFieldsInImproperFormat() {\n+    try {\n+      KeyGenerator keyGenerator = new CustomKeyGenerator(getImproperPartitionFieldFormatProp());\n+      keyGenerator.getKey(getRecord());\n+      Assertions.fail(\"should fail when partition key field is provided in improper format!\");\n+    } catch (Exception e) {\n+      Assertions.assertTrue(e.getMessage().contains(\"Unable to find field names for partition path in proper format\"));\n+    }\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeyWithSimplePartitionPath() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getComplexRecordKeyWithSimplePartitionProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeysWithComplexPartitionPath() {\n+    KeyGenerator keyGenerator = new CustomKeyGenerator(getComplexRecordKeyAndPartitionPathProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"_row_key:key1,pii_col:pi\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686/ts_ms=20200321\");\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDQ5OQ==", "bodyText": "here as well", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954499", "createdAt": "2020-05-21T22:43:42Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestSimpleKeyGenerator.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.exception.HoodieKeyException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+public class TestSimpleKeyGenerator extends TestKeyGeneratorUtilities {\n+\n+  private TypedProperties getCommonProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    properties.put(DataSourceWriteOptions.HIVE_STYLE_PARTITIONING_OPT_KEY(), \"true\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getPropertiesWithoutPartitionPathProp() {\n+    return getCommonProps();\n+  }\n+\n+  private TypedProperties getPropertiesWithoutRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getWrongRecordKeyFieldProps() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_wrong_key\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getComplexRecordKeyProp() {\n+    TypedProperties properties = new TypedProperties();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    properties.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key,pii_col\");\n+    return properties;\n+  }\n+\n+  private TypedProperties getProps() {\n+    TypedProperties properties = getCommonProps();\n+    properties.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"timestamp\");\n+    return properties;\n+  }\n+\n+  @Test\n+  public void testNullPartitionPathFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new SimpleKeyGenerator(getPropertiesWithoutPartitionPathProp()));\n+  }\n+\n+  @Test\n+  public void testNullRecordKeyFields() {\n+    Assertions.assertThrows(IllegalArgumentException.class, () -> new SimpleKeyGenerator(getPropertiesWithoutRecordKeyProp()));\n+  }\n+\n+  @Test\n+  public void testWrongRecordKeyField() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getWrongRecordKeyFieldProps());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testComplexRecordKeyField() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getComplexRecordKeyProp());\n+    Assertions.assertThrows(HoodieKeyException.class, () -> keyGenerator.getRecordKey(getRecord()));\n+  }\n+\n+  @Test\n+  public void testHappyFlow() {\n+    SimpleKeyGenerator keyGenerator = new SimpleKeyGenerator(getProps());\n+    HoodieKey key = keyGenerator.getKey(getRecord());\n+    Assertions.assertEquals(key.getRecordKey(), \"key1\");\n+    Assertions.assertEquals(key.getPartitionPath(), \"timestamp=4357686\");\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NDU0Mw==", "bodyText": "sam here.", "url": "https://github.com/apache/hudi/pull/1433#discussion_r428954543", "createdAt": "2020-05-21T22:43:50Z", "author": {"login": "nsivabalan"}, "path": "hudi-spark/src/test/java/org/apache/hudi/keygen/TestTimestampBasedKeyGenerator.java", "diffHunk": "@@ -95,4 +95,4 @@ public void testScalar() {\n     HoodieKey hk5 = new TimestampBasedKeyGenerator(properties).getKey(baseRecord);\n     assertEquals(hk5.getPartitionPath(), \"2024-10-04 12\");\n   }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzg0NjM2", "url": "https://github.com/apache/hudi/pull/1433#pullrequestreview-440784636", "createdAt": "2020-07-01T11:30:00Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3094f6ca1dd43f263f9005291861321fb58b24a", "author": {"user": {"login": "pratyakshsharma", "name": "Pratyaksh Sharma"}}, "url": "https://github.com/apache/hudi/commit/f3094f6ca1dd43f263f9005291861321fb58b24a", "committedDate": "2020-07-01T11:35:50Z", "message": "[HUDI-728]: implemented custom key generator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f3094f6ca1dd43f263f9005291861321fb58b24a", "author": {"user": {"login": "pratyakshsharma", "name": "Pratyaksh Sharma"}}, "url": "https://github.com/apache/hudi/commit/f3094f6ca1dd43f263f9005291861321fb58b24a", "committedDate": "2020-07-01T11:35:50Z", "message": "[HUDI-728]: implemented custom key generator"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4018, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}