{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNzQ4ODcy", "number": 2349, "title": "[HUDI-1474] Add additional unit tests to TestHBaseIndex", "bodyText": "What is the purpose of the pull request\nAdd additional unit tests to TestHBaseIndex to cover the following scenarios:\n\nAfter a commit has been rolled back (missing in timeline and commit is not archived yet) ensure that tagLocation() resets the tags.\nEnsure taglocation() uses the completed commit timeline to validate the commitTS stored in HBase.\nEnsure HBaseIndex is tagging records belonging to an archived commit as valid.\n\nBrief change log\nAdded 3 test cases to TestHBaseIndex.\nVerify this pull request\nAdded test cases.\nCommitter checklist\n\n\n[ x] Has a corresponding JIRA in PR title & commit\n\n\n[x ] Commit message is descriptive of the change\n\n\n[x ] CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-12-18T20:03:42Z", "url": "https://github.com/apache/hudi/pull/2349", "merged": true, "mergeCommit": {"oid": "da51aa64fcaf8cd3099ef9c085c207283999306f"}, "closed": true, "closedAt": "2020-12-29T04:04:39Z", "author": {"login": "nbalajee"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdndlQEgH2gAyNTQyNzQ4ODcyOjcxZGY4NGY4NTE0MTNlMWJiYTE2NmY3NmY1YzFmZDYyMWZhODc1NGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdqyrEYgFqTU1OTM3MDkwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "71df84f851413e1bba166f76f5c1fd621fa8754a", "author": {"user": {"login": "nbalajee", "name": "Balajee Nagasubramaniam"}}, "url": "https://github.com/apache/hudi/commit/71df84f851413e1bba166f76f5c1fd621fa8754a", "committedDate": "2020-12-18T19:48:13Z", "message": "[HUDI-1474] Add additional unit tests to TestHBaseIndex"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4ODg1NTY0", "url": "https://github.com/apache/hudi/pull/2349#pullrequestreview-558885564", "createdAt": "2020-12-26T18:14:49Z", "commit": {"oid": "71df84f851413e1bba166f76f5c1fd621fa8754a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQxODoxNDo1MFrOILlVyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQxODoxNDo1MFrOILlVyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAxNzAzMw==", "bodyText": "sorry, shouldn't this return 0 since the commit is rolled back? I see a test in this class testSimpleTagLocationAndUpdateWithRollback which tests that rolledback records don't have current location set. am I missing something?", "url": "https://github.com/apache/hudi/pull/2349#discussion_r549017033", "createdAt": "2020-12-26T18:14:50Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/index/hbase/TestHBaseIndex.java", "diffHunk": "@@ -307,6 +308,125 @@ public void testSimpleTagLocationAndUpdateWithRollback() throws Exception {\n     assertEquals(0, records3.stream().filter(record -> record.getCurrentLocation() != null).count());\n   }\n \n+  /*\n+   * Test case to verify that for taglocation entries present in HBase, if the corresponding commit instant is missing\n+   * in timeline and the commit is not archived, taglocation would reset the current record location to null.\n+   */\n+  @Test\n+  public void testSimpleTagLocationWithInvalidCommit() throws Exception {\n+    // Load to memory\n+    HoodieWriteConfig config = getConfig();\n+    SparkHoodieHBaseIndex index = new SparkHoodieHBaseIndex(config);\n+    SparkRDDWriteClient writeClient = getHoodieWriteClient(config);\n+\n+    String newCommitTime = writeClient.startCommit();\n+    // make a commit with 199 records\n+    JavaRDD<HoodieRecord> writeRecords = generateAndCommitRecords(writeClient, 199);\n+\n+    // make a second commit with a single record\n+    String invalidCommit = writeClient.startCommit();\n+    JavaRDD<HoodieRecord> invalidWriteRecords = generateAndCommitRecords(writeClient, 1, invalidCommit);\n+\n+    // verify location is tagged.\n+    HoodieTable hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD0 = index.tagLocation(invalidWriteRecords, context(), hoodieTable);\n+    assert (javaRDD0.collect().size() == 1);   // one record present\n+    assert (javaRDD0.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 1); // it is tagged\n+    assert (javaRDD0.collect().get(0).getCurrentLocation().getInstantTime().equals(invalidCommit));\n+\n+    // rollback the invalid commit, so that hbase will be left with a stale entry.\n+    writeClient.rollback(invalidCommit);\n+\n+    // Now tagLocation for the valid records, hbaseIndex should tag them\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD1 = index.tagLocation(writeRecords, context(), hoodieTable);\n+    assert (javaRDD1.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 199);\n+\n+    // tagLocation for the invalid record - commit is not present in timeline due to rollback.\n+    JavaRDD<HoodieRecord> javaRDD2 = index.tagLocation(invalidWriteRecords, context(), hoodieTable);\n+    assert (javaRDD2.collect().size() == 1);   // one record present\n+    assert (javaRDD2.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 0); // it is not tagged\n+  }\n+\n+  /*\n+   * Test case to verify that taglocation() uses the commit timeline to validate the commitTS stored in hbase.\n+   * When CheckIfValidCommit() in HbaseIndex uses the incorrect timeline filtering, this test would fail.\n+   */\n+  @Test\n+  public void testEnsureTagLocationUsesCommitTimeline() throws Exception {\n+    // Load to memory\n+    HoodieWriteConfig config = getConfig();\n+    SparkHoodieHBaseIndex index = new SparkHoodieHBaseIndex(config);\n+    SparkRDDWriteClient writeClient = getHoodieWriteClient(config);\n+\n+    String commitTime1 = writeClient.startCommit();\n+    JavaRDD<HoodieRecord> writeRecords1 = generateAndCommitRecords(writeClient, 20, commitTime1);\n+\n+    // rollback the commit - leaves a clean file in timeline.\n+    writeClient.rollback(commitTime1);\n+\n+    // create a second commit with 20 records\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    generateAndCommitRecords(writeClient, 20);\n+\n+    // Now tagLocation for the first set of rolledback records, hbaseIndex should tag them\n+    metaClient = HoodieTableMetaClient.reload(metaClient);\n+    HoodieTable hoodieTable = HoodieSparkTable.create(config, context, metaClient);\n+    JavaRDD<HoodieRecord> javaRDD1 = index.tagLocation(writeRecords1, context(), hoodieTable);\n+    assert (javaRDD1.filter(HoodieRecord::isCurrentLocationKnown).collect().size() == 20);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71df84f851413e1bba166f76f5c1fd621fa8754a"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzcwOTA2", "url": "https://github.com/apache/hudi/pull/2349#pullrequestreview-559370906", "createdAt": "2020-12-29T04:04:21Z", "commit": {"oid": "71df84f851413e1bba166f76f5c1fd621fa8754a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4026, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}