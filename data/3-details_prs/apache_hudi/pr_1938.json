{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1MDg4NDg2", "number": 1938, "title": "[HUDI-920] Support Incremental query for MOR table", "bodyText": "What is the purpose of the pull request\nSupport incremental query for MOR table\nhttps://issues.apache.org/jira/browse/HUDI-920\nBrief change log\n\nAdd MergeOnReadIncrementalRelation\nAdd test on TestMORDatasource\n\nVerify this pull request\nThis change added tests and can be verified as follows:\n\nAdded unit tests in TestMORDatasource\n\nCommitter checklist\n\n\n Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-08-09T00:11:50Z", "url": "https://github.com/apache/hudi/pull/1938", "merged": true, "mergeCommit": {"oid": "79ec7b4894b997183a6e10fdc19d34f5ab4ea437"}, "closed": true, "closedAt": "2021-01-09T16:02:09Z", "author": {"login": "garyli1019"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9EhP-ABqjM2MzYxMzA0MDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABduWDc7ABqjQxODY3MzE5Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27c0b488bede7bd5ad5be825267454d92c8989e4", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/27c0b488bede7bd5ad5be825267454d92c8989e4", "committedDate": "2020-08-09T00:08:47Z", "message": "[HUDI-920] Support Incremental query for MOR table"}, "afterCommit": {"oid": "80f21122584fe10e07cb6cd4597958750b722c4c", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/80f21122584fe10e07cb6cd4597958750b722c4c", "committedDate": "2020-08-09T02:51:13Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80f21122584fe10e07cb6cd4597958750b722c4c", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/80f21122584fe10e07cb6cd4597958750b722c4c", "committedDate": "2020-08-09T02:51:13Z", "message": "[HUDI-920] Support Incremental query for MOR table"}, "afterCommit": {"oid": "3caed0144c9cb7c5f1986d29699a14df5fe7c3c7", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/3caed0144c9cb7c5f1986d29699a14df5fe7c3c7", "committedDate": "2020-08-09T03:16:44Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3caed0144c9cb7c5f1986d29699a14df5fe7c3c7", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/3caed0144c9cb7c5f1986d29699a14df5fe7c3c7", "committedDate": "2020-08-09T03:16:44Z", "message": "[HUDI-920] Support Incremental query for MOR table"}, "afterCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/44f571fee63a8deab642a3accb4410b99428895d", "committedDate": "2020-08-09T23:13:03Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODEyMTc1", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-478812175", "createdAt": "2020-08-31T17:40:39Z", "commit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0MDozOVrOHKCO9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0MDozOVrOHKCO9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NDQwNg==", "bodyText": "we need to guard this with a flag. query types are fundamental to design. I prefer not to overload them", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480284406", "createdAt": "2020-08-31T17:40:39Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "diffHunk": "@@ -49,6 +49,7 @@ object DataSourceReadOptions {\n   val QUERY_TYPE_SNAPSHOT_OPT_VAL = \"snapshot\"\n   val QUERY_TYPE_READ_OPTIMIZED_OPT_VAL = \"read_optimized\"\n   val QUERY_TYPE_INCREMENTAL_OPT_VAL = \"incremental\"\n+  val QUERY_TYPE_MOR_INCREMENTAL_OPT_VAL = \"mor_incremental\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODE0NDI0", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-478814424", "createdAt": "2020-08-31T17:43:57Z", "commit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0Mzo1N1rOHKCWDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0Mzo1N1rOHKCWDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjIyMA==", "bodyText": "this does not seem to be indented correctly?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480286220", "createdAt": "2020-08-31T17:43:57Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieMergeOnReadRDD.scala", "diffHunk": "@@ -102,6 +104,44 @@ class HoodieMergeOnReadRDD(@transient sc: SparkContext,\n     rows\n   }\n \n+  private def logFileIterator(split: HoodieMergeOnReadFileSplit,\n+                             config: Configuration): Iterator[InternalRow] =\n+  new Iterator[InternalRow] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODE3MjM1", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-478817235", "createdAt": "2020-08-31T17:48:13Z", "commit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0ODoxM1rOHKCevw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0ODoxM1rOHKCevw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODQ0Nw==", "bodyText": "should these be left to the user on how sparkSession/sqlContext is configured instead?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480288447", "createdAt": "2020-08-31T17:48:13Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODIyODI4", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-478822828", "createdAt": "2020-08-31T17:56:29Z", "commit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo1NjoyOVrOHKCwbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo1NjoyOVrOHKCwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw==", "bodyText": "IIUC, your approach here is to find all the file groups impacted in commit range, then pull affected records from the latest file slice? the mergeOnReadRDD will handle the merging of such an file slice, with the commit filters applied.\nlet me know @garyli1019 if I am understanding this correctly. it will help me review the code.\nin the meantime, can we add a separate flag/option to turn on new.incremental.relation=true or sth, to control this and push the changes", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480292973", "createdAt": "2020-08-31T17:56:29Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/44f571fee63a8deab642a3accb4410b99428895d", "committedDate": "2020-08-09T23:13:03Z", "message": "[HUDI-920] Support Incremental query for MOR table"}, "afterCommit": {"oid": "9e275c2d4677d1dd8221d2cf8e900b1f9bb0d67c", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/9e275c2d4677d1dd8221d2cf8e900b1f9bb0d67c", "committedDate": "2020-09-08T04:24:05Z", "message": "Update file listing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e275c2d4677d1dd8221d2cf8e900b1f9bb0d67c", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/9e275c2d4677d1dd8221d2cf8e900b1f9bb0d67c", "committedDate": "2020-09-08T04:24:05Z", "message": "Update file listing"}, "afterCommit": {"oid": "eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20", "committedDate": "2020-09-08T06:08:12Z", "message": "Update file listing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzODU3MDcx", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-483857071", "createdAt": "2020-09-08T07:18:24Z", "commit": {"oid": "eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxODoyNFrOHOP27A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxODoyNFrOHOP27A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMTkzMg==", "bodyText": "Copied and changed this method from #1817 , will apply this change to that PR after merged.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r484701932", "createdAt": "2020-09-08T07:18:24Z", "author": {"login": "garyli1019"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -443,4 +444,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20"}, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20", "committedDate": "2020-09-08T06:08:12Z", "message": "Update file listing"}, "afterCommit": {"oid": "1847bd3803acf3aa415f7c6a3dd686cfd92ebc12", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/1847bd3803acf3aa415f7c6a3dd686cfd92ebc12", "committedDate": "2020-12-31T06:57:10Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "452be51154c5b4302469e9810b5569884d61c238", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/452be51154c5b4302469e9810b5569884d61c238", "committedDate": "2021-01-07T15:37:18Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1847bd3803acf3aa415f7c6a3dd686cfd92ebc12", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/1847bd3803acf3aa415f7c6a3dd686cfd92ebc12", "committedDate": "2020-12-31T06:57:10Z", "message": "[HUDI-920] Support Incremental query for MOR table"}, "afterCommit": {"oid": "518917a10fcbd3166892f74975a080e7ea232f98", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/518917a10fcbd3166892f74975a080e7ea232f98", "committedDate": "2020-12-05T11:13:21Z", "message": "Update file listing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "518917a10fcbd3166892f74975a080e7ea232f98", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/518917a10fcbd3166892f74975a080e7ea232f98", "committedDate": "2020-12-05T11:13:21Z", "message": "Update file listing"}, "afterCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/452be51154c5b4302469e9810b5569884d61c238", "committedDate": "2021-01-07T15:37:18Z", "message": "[HUDI-920] Support Incremental query for MOR table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNjkwMzA2", "url": "https://github.com/apache/hudi/pull/1938#pullrequestreview-563690306", "createdAt": "2021-01-07T17:41:49Z", "commit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0MTo0OVrOIP11PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo1MjoxOVrOIP2LsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MTUzMw==", "bodyText": "can we just have this in hudi-spark for now. thats the only module that needs to call this.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553481533", "createdAt": "2021-01-07T17:41:49Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MjA3OA==", "bodyText": "Can we redo this such that it can use the metadata table for obtaining the listing? You can see how this is done in HoodieParquetInputFormat.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553482078", "createdAt": "2021-01-07T17:42:52Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4Mjc0Ng==", "bodyText": "a little bit more clearer doc? does this method obtain all the file status that were affected by the list of commits to check?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553482746", "createdAt": "2021-01-07T17:43:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NDIwMQ==", "bodyText": "you can just pick the latest such file now. it will have the latest log size using getFileSizeInBytes(). No need to do the addition here.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553484201", "createdAt": "2021-01-07T17:46:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?\n+    HashMap<String, HashMap<String, FileStatus>> partitionToFileStatusesMap = new HashMap<>();\n+    for (HoodieInstant commit: commitsToCheck) {\n+      HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(timeline.getInstantDetails(commit).get(),\n+          HoodieCommitMetadata.class);\n+      for (Map.Entry<String, List<HoodieWriteStat>> entry: commitMetadata.getPartitionToWriteStats().entrySet()) {\n+        if (!partitionToFileStatusesMap.containsKey(entry.getKey())) {\n+          partitionToFileStatusesMap.put(entry.getKey(), new HashMap<>());\n+        }\n+        for (HoodieWriteStat stat : entry.getValue()) {\n+          String relativeFilePath = stat.getPath();\n+          Path fullPath = relativeFilePath != null ? FSUtils.getPartitionPath(basePath, relativeFilePath) : null;\n+          if (fullPath != null) {\n+            if (partitionToFileStatusesMap.get(entry.getKey()).containsKey(fullPath.getName())) {\n+              // If filesystem support Append. Update the FileStatus of log file if being appended.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NTUzNg==", "bodyText": "can we subclass IncrementalRelation and reuse some of the code esp lines 54-66 etc? worth it?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553485536", "createdAt": "2021-01-07T17:48:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzI4MQ==", "bodyText": "this is the secret sauce to do the filtering at the record level, I guess", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553487281", "createdAt": "2021-01-07T17:52:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.filterPushdown\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71299741c0c42a5def873d2d51dfd4e9bb5880cb", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/71299741c0c42a5def873d2d51dfd4e9bb5880cb", "committedDate": "2021-01-09T04:59:12Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac1513ccf313ef517e83252d69e7e1140112dadf", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/ac1513ccf313ef517e83252d69e7e1140112dadf", "committedDate": "2021-01-09T04:48:56Z", "message": "address comments"}, "afterCommit": {"oid": "71299741c0c42a5def873d2d51dfd4e9bb5880cb", "author": {"user": {"login": "garyli1019", "name": "Gary Li"}}, "url": "https://github.com/apache/hudi/commit/71299741c0c42a5def873d2d51dfd4e9bb5880cb", "committedDate": "2021-01-09T04:59:12Z", "message": "address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4809, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}