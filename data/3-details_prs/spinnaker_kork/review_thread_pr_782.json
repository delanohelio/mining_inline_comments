{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MDE1OTMw", "number": 782, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNDowNToyMlrOEjaUDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyMjoyM1rOEjsVtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTY2NzM1OnYy", "diffSide": "RIGHT", "path": "kork-web/src/main/java/com/netflix/spinnaker/config/ServiceEndpoint.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNDowNToyMlrOHRvvGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNDowNToyMlrOHRvvGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2OTk0NA==", "bodyText": "I'll follow up where necessary (Gate and internal libraries) with this change.", "url": "https://github.com/spinnaker/kork/pull/782#discussion_r488369944", "createdAt": "2020-09-15T04:05:22Z", "author": {"login": "jonsie"}, "path": "kork-web/src/main/java/com/netflix/spinnaker/config/ServiceEndpoint.java", "diffHunk": "@@ -33,7 +33,7 @@\n \n   /** Misc. config necessary for the service client. */\n   @Nonnull\n-  public Map<String, Object> getConfig();\n+  public Map<String, String> getConfig();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1cd88feb404034eab777fda06bb0eed9e23cce4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1ODYyMDY4OnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/test/kotlin/com/netflix/spinnaker/kork/plugins/remote/extension/RemoteExtensionTest.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyMjoyM1rOHSMHpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxODo1NzoxMlrOHSP2hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNDk4Mg==", "bodyText": "Interesting thought: We should support an in-process transport. I think it could be beneficial to converge on \"remote-first\" extension points, but still allowing in-process plugins to implement them. What do you think?", "url": "https://github.com/spinnaker/kork/pull/782#discussion_r488834982", "createdAt": "2020-09-15T17:22:23Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/test/kotlin/com/netflix/spinnaker/kork/plugins/remote/extension/RemoteExtensionTest.kt", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.netflix.spinnaker.kork.plugins.remote.extension\n+\n+\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionPayload\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionQuery\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionResponse\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionTransport\n+import dev.minutest.junit.JUnit5Minutests\n+import dev.minutest.rootContext\n+import io.mockk.every\n+import io.mockk.mockk\n+import strikt.api.expectThat\n+import strikt.assertions.isA\n+\n+class RemoteExtensionTest : JUnit5Minutests {\n+  fun tests() = rootContext<Fixture> {\n+    fixture {\n+      Fixture()\n+    }\n+\n+    test (\"Get config type\") {\n+      val result = subject.getTypedConfig<ConfigType>()\n+      expectThat(result).isA<ConfigType>()\n+    }\n+\n+    test(\"Invoke is void\") {\n+      val result = subject.invoke(remoteExtensionPayload)\n+      expectThat(result).isA<Unit>()\n+    }\n+\n+    test(\"Returns the write response\") {\n+      every { transport.write(any()) } returns writeResponse\n+      val result = subject.write<WriteResponse>(remoteExtensionPayload)\n+      expectThat(result).isA<WriteResponse>()\n+    }\n+\n+    test(\"Returns the read response\") {\n+      every { transport.read(any()) } returns readResponse\n+      val result = subject.read<ReadResponse>(remoteExtensionQuery)\n+      expectThat(result).isA<ReadResponse>()\n+    }\n+  }\n+\n+  private class Fixture {\n+    val writeResponse = WriteResponse()\n+    val readResponse = ReadResponse()\n+    val remoteExtensionPayload = Payload()\n+    val remoteExtensionQuery = Query()\n+    val transport: RemoteExtensionTransport = mockk(relaxed = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5bb4fc4074c9cde59ffd9e01d6730a74713b760"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5NjEzNA==", "bodyText": "Yes.  This goes in-line with what I was thinking WRT making the OkHttp client provider an in-process extension point.  I think building remote extension points on-top of an extensible in-process transport is going to provide the flexibility we'll need for this to have wider adoption.", "url": "https://github.com/spinnaker/kork/pull/782#discussion_r488896134", "createdAt": "2020-09-15T18:57:12Z", "author": {"login": "jonsie"}, "path": "kork-plugins/src/test/kotlin/com/netflix/spinnaker/kork/plugins/remote/extension/RemoteExtensionTest.kt", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.netflix.spinnaker.kork.plugins.remote.extension\n+\n+\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionPayload\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionQuery\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionResponse\n+import com.netflix.spinnaker.kork.plugins.remote.extension.transport.RemoteExtensionTransport\n+import dev.minutest.junit.JUnit5Minutests\n+import dev.minutest.rootContext\n+import io.mockk.every\n+import io.mockk.mockk\n+import strikt.api.expectThat\n+import strikt.assertions.isA\n+\n+class RemoteExtensionTest : JUnit5Minutests {\n+  fun tests() = rootContext<Fixture> {\n+    fixture {\n+      Fixture()\n+    }\n+\n+    test (\"Get config type\") {\n+      val result = subject.getTypedConfig<ConfigType>()\n+      expectThat(result).isA<ConfigType>()\n+    }\n+\n+    test(\"Invoke is void\") {\n+      val result = subject.invoke(remoteExtensionPayload)\n+      expectThat(result).isA<Unit>()\n+    }\n+\n+    test(\"Returns the write response\") {\n+      every { transport.write(any()) } returns writeResponse\n+      val result = subject.write<WriteResponse>(remoteExtensionPayload)\n+      expectThat(result).isA<WriteResponse>()\n+    }\n+\n+    test(\"Returns the read response\") {\n+      every { transport.read(any()) } returns readResponse\n+      val result = subject.read<ReadResponse>(remoteExtensionQuery)\n+      expectThat(result).isA<ReadResponse>()\n+    }\n+  }\n+\n+  private class Fixture {\n+    val writeResponse = WriteResponse()\n+    val readResponse = ReadResponse()\n+    val remoteExtensionPayload = Payload()\n+    val remoteExtensionQuery = Query()\n+    val transport: RemoteExtensionTransport = mockk(relaxed = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNDk4Mg=="}, "originalCommit": {"oid": "d5bb4fc4074c9cde59ffd9e01d6730a74713b760"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3507, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}