{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDY3NTU0", "number": 526, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTowNTowNFrODh-zCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNTozMlrODi5fSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTU4NDczOnYy", "diffSide": "RIGHT", "path": "kork-core/src/main/java/com/netflix/spinnaker/kork/version/ManifestVersionResolver.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTowNTowNFrOFtBb6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxNDo0MVrOFuRwZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mzc3MA==", "bodyText": "I don't understand the purpose of this flag. Can't the logic just be something like this:\nval version = attributes.getValue(\"Implementation-OSS-Version\") ?: attributes.getValue(\"Implementation-Version\")", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382753770", "createdAt": "2020-02-21T19:05:04Z", "author": {"login": "robzienert"}, "path": "kork-core/src/main/java/com/netflix/spinnaker/kork/version/ManifestVersionResolver.java", "diffHunk": "@@ -35,18 +35,28 @@\n  *\n  * <p>This class iterates through matching JARs, rather than looking directly at itself, to support\n  * the use case where OSS services are being extended via a library pattern.\n+ *\n+ * <p>This class also supports reading the custom attribute `Implementation-OSS-Version`. This\n+ * attribute is useful if JARs are built in a process outside the context of OSS, but you need a\n+ * mechanism to get the underlining OSS version.\n  */\n @Slf4j\n public class ManifestVersionResolver implements VersionResolver {\n \n   private static final String GROUP = \"com.netflix.spinnaker\";\n \n   private final String group;\n+  private boolean ossAttribute = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjIyMQ==", "bodyText": "Actually, my original intention here was to not fallback to Implementation-Version if Implementation-OSS-Version is desired (which I didn't do, got distracted but I will revisit this now).  I don't think we want to fallback if the OSS version is desired since that'll basically throw off all our service version constraint stuff.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382756221", "createdAt": "2020-02-21T19:10:15Z", "author": {"login": "jonsie"}, "path": "kork-core/src/main/java/com/netflix/spinnaker/kork/version/ManifestVersionResolver.java", "diffHunk": "@@ -35,18 +35,28 @@\n  *\n  * <p>This class iterates through matching JARs, rather than looking directly at itself, to support\n  * the use case where OSS services are being extended via a library pattern.\n+ *\n+ * <p>This class also supports reading the custom attribute `Implementation-OSS-Version`. This\n+ * attribute is useful if JARs are built in a process outside the context of OSS, but you need a\n+ * mechanism to get the underlining OSS version.\n  */\n @Slf4j\n public class ManifestVersionResolver implements VersionResolver {\n \n   private static final String GROUP = \"com.netflix.spinnaker\";\n \n   private final String group;\n+  private boolean ossAttribute = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mzc3MA=="}, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgxOTc1MQ==", "bodyText": "This will now not fall through to Implementation-Version if the property use-oss-version-manifest-attribute is set in spinnaker.extensibility.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382819751", "createdAt": "2020-02-21T21:43:37Z", "author": {"login": "jonsie"}, "path": "kork-core/src/main/java/com/netflix/spinnaker/kork/version/ManifestVersionResolver.java", "diffHunk": "@@ -35,18 +35,28 @@\n  *\n  * <p>This class iterates through matching JARs, rather than looking directly at itself, to support\n  * the use case where OSS services are being extended via a library pattern.\n+ *\n+ * <p>This class also supports reading the custom attribute `Implementation-OSS-Version`. This\n+ * attribute is useful if JARs are built in a process outside the context of OSS, but you need a\n+ * mechanism to get the underlining OSS version.\n  */\n @Slf4j\n public class ManifestVersionResolver implements VersionResolver {\n \n   private static final String GROUP = \"com.netflix.spinnaker\";\n \n   private final String group;\n+  private boolean ossAttribute = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mzc3MA=="}, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2OTczNQ==", "bodyText": "nit: How about spinnaker.extensibility.versioning.use-oss-version-manifest-attribute instead? I suspect we'll end up having other config informing Spinnaker how to resolve versions in the future, it'd be nice to have them all under one place.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384069735", "createdAt": "2020-02-25T19:14:41Z", "author": {"login": "robzienert"}, "path": "kork-core/src/main/java/com/netflix/spinnaker/kork/version/ManifestVersionResolver.java", "diffHunk": "@@ -35,18 +35,28 @@\n  *\n  * <p>This class iterates through matching JARs, rather than looking directly at itself, to support\n  * the use case where OSS services are being extended via a library pattern.\n+ *\n+ * <p>This class also supports reading the custom attribute `Implementation-OSS-Version`. This\n+ * attribute is useful if JARs are built in a process outside the context of OSS, but you need a\n+ * mechanism to get the underlining OSS version.\n  */\n @Slf4j\n public class ManifestVersionResolver implements VersionResolver {\n \n   private static final String GROUP = \"com.netflix.spinnaker\";\n \n   private final String group;\n+  private boolean ossAttribute = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mzc3MA=="}, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTU5MDAwOnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/SpinnakerServiceVersionManager.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTowNjo0OFrOFtBfTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTowNjo0OFrOFtBfTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NDYzNg==", "bodyText": "Should make this match case insensitive.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382754636", "createdAt": "2020-02-21T19:06:48Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/SpinnakerServiceVersionManager.kt", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.spinnaker.kork.plugins\n+\n+import com.github.zafarkhaja.semver.Version\n+import org.pf4j.VersionManager\n+import org.pf4j.util.StringUtils\n+\n+/**\n+ * Since plugins can require multiple services, this class is necessary to ensure we are making the\n+ * constraint check against the correct service.\n+ */\n+class SpinnakerServiceVersionManager(\n+  private val serviceName: String\n+) : VersionManager {\n+\n+  override fun checkVersionConstraint(version: String, requires: String): Boolean {\n+    val serviceVersionRequirements =\n+      VersionRequirementsParser\n+        .parseAll(requires)\n+        .find { it.service == serviceName }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTU5NzIyOnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/update/PluginDownloadService.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOTowOToyNFrOFtBj8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMDowMDo1MFrOFtC_sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NTgyNw==", "bodyText": "Hmm, what object is this run on?", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382755827", "createdAt": "2020-02-21T19:09:24Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/update/PluginDownloadService.kt", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.spinnaker.kork.plugins.update\n+\n+import com.netflix.spinnaker.kork.exceptions.IntegrationException\n+import com.netflix.spinnaker.kork.plugins.SpinnakerPluginManager\n+import com.netflix.spinnaker.kork.plugins.SpringPluginStatusProvider\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded.Status.SUCCEEDED\n+import org.pf4j.PluginRuntimeException\n+import org.slf4j.LoggerFactory\n+import org.springframework.context.ApplicationEventPublisher\n+import java.io.File\n+import java.io.IOException\n+import java.lang.UnsupportedOperationException\n+import java.nio.file.Files\n+import java.nio.file.Path\n+import java.nio.file.StandardCopyOption\n+\n+/**\n+ * The [PluginDownloadService] is responsible for downloading the correct plugins from the plugin\n+ * update repositories.\n+ *\n+ * Plugins will not be loaded or started from this service.  All plugin loading and starting occurs\n+ * via [com.netflix.spinnaker.kork.plugins.ExtensionBeanDefinitionRegistryPostProcessor].\n+ *\n+ */\n+class PluginDownloadService(\n+  internal val updateManager: SpinnakerUpdateManager,\n+  internal val pluginManager: SpinnakerPluginManager,\n+  private val pluginStatusProvider: SpringPluginStatusProvider,\n+  private val applicationEventPublisher: ApplicationEventPublisher\n+) {\n+\n+  private val log by lazy { LoggerFactory.getLogger(javaClass) }\n+\n+  /**\n+   * This is the algorithm for determining which plugins to download.\n+   *\n+   * This function first retrieves all available plugins from the plugin info cache.  It then filters\n+   * based on plugins that are enabled in the configuration for the service.  After that, it checks\n+   * the plugin version for the enabled plugin.  If the plugin version does not exist, then the latest\n+   * plugin release is selected.  Otherwise, it checks if the plugin has a version that matches the\n+   * configured plugin version AND the constraint for that version satisfies the service version\n+   * constraint (i.e., orca>=1.0.0 & <2.0.0).\n+   *\n+   * TODO(jonsie): Consider removing the fallback and throwing PluginNotFoundException once\n+   *  plugins are out of beta.\n+   */\n+  internal fun downloadPlugins() {\n+    val availablePlugins = updateManager.availablePlugins as MutableList<SpinnakerPluginInfo>\n+    log.info(\"Found '{}' available plugins\", availablePlugins.size)\n+\n+    availablePlugins\n+      .filter { !pluginStatusProvider.isPluginDisabled(it.id) }\n+      .forEach { enabledPlugin ->\n+        val configuredPluginVersion = pluginStatusProvider.configuredPluginVersion(enabledPlugin.id)\n+\n+        val pluginRelease = if (configuredPluginVersion == null) {\n+          val fallbackRelease = updateManager.getLastPluginRelease(enabledPlugin.id)\n+            ?: throw PluginNotFoundException(enabledPlugin.id, configuredPluginVersion)\n+          run {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3OTMxMw==", "bodyText": "it runs on PluginDownloadService but it's unnecessary - I removed this.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382779313", "createdAt": "2020-02-21T20:00:50Z", "author": {"login": "jonsie"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/update/PluginDownloadService.kt", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.spinnaker.kork.plugins.update\n+\n+import com.netflix.spinnaker.kork.exceptions.IntegrationException\n+import com.netflix.spinnaker.kork.plugins.SpinnakerPluginManager\n+import com.netflix.spinnaker.kork.plugins.SpringPluginStatusProvider\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded.Status.SUCCEEDED\n+import org.pf4j.PluginRuntimeException\n+import org.slf4j.LoggerFactory\n+import org.springframework.context.ApplicationEventPublisher\n+import java.io.File\n+import java.io.IOException\n+import java.lang.UnsupportedOperationException\n+import java.nio.file.Files\n+import java.nio.file.Path\n+import java.nio.file.StandardCopyOption\n+\n+/**\n+ * The [PluginDownloadService] is responsible for downloading the correct plugins from the plugin\n+ * update repositories.\n+ *\n+ * Plugins will not be loaded or started from this service.  All plugin loading and starting occurs\n+ * via [com.netflix.spinnaker.kork.plugins.ExtensionBeanDefinitionRegistryPostProcessor].\n+ *\n+ */\n+class PluginDownloadService(\n+  internal val updateManager: SpinnakerUpdateManager,\n+  internal val pluginManager: SpinnakerPluginManager,\n+  private val pluginStatusProvider: SpringPluginStatusProvider,\n+  private val applicationEventPublisher: ApplicationEventPublisher\n+) {\n+\n+  private val log by lazy { LoggerFactory.getLogger(javaClass) }\n+\n+  /**\n+   * This is the algorithm for determining which plugins to download.\n+   *\n+   * This function first retrieves all available plugins from the plugin info cache.  It then filters\n+   * based on plugins that are enabled in the configuration for the service.  After that, it checks\n+   * the plugin version for the enabled plugin.  If the plugin version does not exist, then the latest\n+   * plugin release is selected.  Otherwise, it checks if the plugin has a version that matches the\n+   * configured plugin version AND the constraint for that version satisfies the service version\n+   * constraint (i.e., orca>=1.0.0 & <2.0.0).\n+   *\n+   * TODO(jonsie): Consider removing the fallback and throwing PluginNotFoundException once\n+   *  plugins are out of beta.\n+   */\n+  internal fun downloadPlugins() {\n+    val availablePlugins = updateManager.availablePlugins as MutableList<SpinnakerPluginInfo>\n+    log.info(\"Found '{}' available plugins\", availablePlugins.size)\n+\n+    availablePlugins\n+      .filter { !pluginStatusProvider.isPluginDisabled(it.id) }\n+      .forEach { enabledPlugin ->\n+        val configuredPluginVersion = pluginStatusProvider.configuredPluginVersion(enabledPlugin.id)\n+\n+        val pluginRelease = if (configuredPluginVersion == null) {\n+          val fallbackRelease = updateManager.getLastPluginRelease(enabledPlugin.id)\n+            ?: throw PluginNotFoundException(enabledPlugin.id, configuredPluginVersion)\n+          run {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NTgyNw=="}, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTU5OTQ4OnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/update/PluginDownloadService.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOToxMDoxMVrOFtBlXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxOToxMDoxMVrOFtBlXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjE4OQ==", "bodyText": "Great exception message.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r382756189", "createdAt": "2020-02-21T19:10:11Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/update/PluginDownloadService.kt", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2019 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.spinnaker.kork.plugins.update\n+\n+import com.netflix.spinnaker.kork.exceptions.IntegrationException\n+import com.netflix.spinnaker.kork.plugins.SpinnakerPluginManager\n+import com.netflix.spinnaker.kork.plugins.SpringPluginStatusProvider\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded\n+import com.netflix.spinnaker.kork.plugins.events.PluginDownloaded.Status.SUCCEEDED\n+import org.pf4j.PluginRuntimeException\n+import org.slf4j.LoggerFactory\n+import org.springframework.context.ApplicationEventPublisher\n+import java.io.File\n+import java.io.IOException\n+import java.lang.UnsupportedOperationException\n+import java.nio.file.Files\n+import java.nio.file.Path\n+import java.nio.file.StandardCopyOption\n+\n+/**\n+ * The [PluginDownloadService] is responsible for downloading the correct plugins from the plugin\n+ * update repositories.\n+ *\n+ * Plugins will not be loaded or started from this service.  All plugin loading and starting occurs\n+ * via [com.netflix.spinnaker.kork.plugins.ExtensionBeanDefinitionRegistryPostProcessor].\n+ *\n+ */\n+class PluginDownloadService(\n+  internal val updateManager: SpinnakerUpdateManager,\n+  internal val pluginManager: SpinnakerPluginManager,\n+  private val pluginStatusProvider: SpringPluginStatusProvider,\n+  private val applicationEventPublisher: ApplicationEventPublisher\n+) {\n+\n+  private val log by lazy { LoggerFactory.getLogger(javaClass) }\n+\n+  /**\n+   * This is the algorithm for determining which plugins to download.\n+   *\n+   * This function first retrieves all available plugins from the plugin info cache.  It then filters\n+   * based on plugins that are enabled in the configuration for the service.  After that, it checks\n+   * the plugin version for the enabled plugin.  If the plugin version does not exist, then the latest\n+   * plugin release is selected.  Otherwise, it checks if the plugin has a version that matches the\n+   * configured plugin version AND the constraint for that version satisfies the service version\n+   * constraint (i.e., orca>=1.0.0 & <2.0.0).\n+   *\n+   * TODO(jonsie): Consider removing the fallback and throwing PluginNotFoundException once\n+   *  plugins are out of beta.\n+   */\n+  internal fun downloadPlugins() {\n+    val availablePlugins = updateManager.availablePlugins as MutableList<SpinnakerPluginInfo>\n+    log.info(\"Found '{}' available plugins\", availablePlugins.size)\n+\n+    availablePlugins\n+      .filter { !pluginStatusProvider.isPluginDisabled(it.id) }\n+      .forEach { enabledPlugin ->\n+        val configuredPluginVersion = pluginStatusProvider.configuredPluginVersion(enabledPlugin.id)\n+\n+        val pluginRelease = if (configuredPluginVersion == null) {\n+          val fallbackRelease = updateManager.getLastPluginRelease(enabledPlugin.id)\n+            ?: throw PluginNotFoundException(enabledPlugin.id, configuredPluginVersion)\n+          run {\n+              log.warn(\"'{}' is enabled but does not have a configured version, falling back to \" +\n+                \"version '{}'.\", enabledPlugin.id, fallbackRelease.version)\n+              fallbackRelease\n+          }\n+        } else {\n+          enabledPlugin.getReleases()\n+            .filter { release ->\n+              release.version == configuredPluginVersion\n+            }\n+            .firstOrNull { release ->\n+              pluginManager.versionManager.checkVersionConstraint(release.version, release.requires)\n+            } ?: throw PluginNotFoundException(enabledPlugin.id, configuredPluginVersion)\n+        }\n+\n+        log.debug(\"Downloading plugin '{}' with version '{}'\", enabledPlugin.id, pluginRelease.version)\n+        val downloaded = updateManager.downloadPluginRelease(enabledPlugin.id, pluginRelease.version)\n+        val succeeded = pluginManager.pluginsRoot.write(downloaded)\n+\n+        if (succeeded) {\n+          log.debug(\"Downloaded plugin '{}'\", enabledPlugin.id)\n+          applicationEventPublisher.publishEvent(\n+            PluginDownloaded(this, SUCCEEDED, enabledPlugin.id, pluginRelease.version)\n+          )\n+        } else {\n+          throw PluginDownloadException(enabledPlugin.id, pluginRelease.version)\n+        }\n+      }\n+  }\n+\n+  /**\n+   * Write the plugin, creating the the plugins root directory defined in [pluginManager] if\n+   * necessary.\n+   */\n+  private fun Path.write(downloaded: Path): Boolean {\n+    if (pluginManager.pluginsRoot == this) {\n+      val file = this.resolve(downloaded.fileName)\n+      File(this.toString()).mkdirs()\n+      try {\n+        return Files.move(downloaded, file, StandardCopyOption.REPLACE_EXISTING)\n+          .contains(downloaded.fileName)\n+      } catch (e: IOException) {\n+        throw PluginRuntimeException(e, \"Failed to write file '{}' to plugins folder\", file)\n+      }\n+    } else {\n+      throw UnsupportedOperationException(\"This operation is only supported on the specified plugins root directory.\")\n+    }\n+  }\n+\n+  internal class PluginNotFoundException(pluginId: String, configuredPluginVersion: String?) :\n+    IntegrationException(\n+      \"'$pluginId' is enabled with version '${configuredPluginVersion ?: \"undefined\" }', but a \" +\n+        \"release version could not be found that satisfies the version and/or the service \" +\n+        \"requirement constraints.\"\n+  )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51dd25a8e91b9aaeb2de41eb1d56ab9914f12aeb"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODIwNTIxOnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/ExtensionBeanDefinitionRegistryPostProcessor.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODozMDoyNlrOFuQRfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxOTozN1rOFuR6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NTQzNw==", "bodyText": "pluginManager.loadPlugins() needs to run before we download plugins so we know what is loaded and if there is a new version that should be downloaded.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384045437", "createdAt": "2020-02-25T18:30:26Z", "author": {"login": "jonsie"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/ExtensionBeanDefinitionRegistryPostProcessor.kt", "diffHunk": "@@ -47,8 +49,10 @@ class ExtensionBeanDefinitionRegistryPostProcessor(\n   override fun postProcessBeanDefinitionRegistry(registry: BeanDefinitionRegistry) {\n     val start = System.currentTimeMillis()\n     log.debug(\"Preparing plugins\")\n-    updateManagerService.checkForUpdates()\n     pluginManager.loadPlugins()\n+    updateManager.downloadPlugins(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6c3a8fcd729e9ac1c113647b6fe5f00f8be2a6c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjMyMQ==", "bodyText": "Code comment instead of PR comment. That's valuable context that shouldn't require hunting for this PR comment.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384072321", "createdAt": "2020-02-25T19:19:37Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/ExtensionBeanDefinitionRegistryPostProcessor.kt", "diffHunk": "@@ -47,8 +49,10 @@ class ExtensionBeanDefinitionRegistryPostProcessor(\n   override fun postProcessBeanDefinitionRegistry(registry: BeanDefinitionRegistry) {\n     val start = System.currentTimeMillis()\n     log.debug(\"Preparing plugins\")\n-    updateManagerService.checkForUpdates()\n     pluginManager.loadPlugins()\n+    updateManager.downloadPlugins(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA0NTQzNw=="}, "originalCommit": {"oid": "c6c3a8fcd729e9ac1c113647b6fe5f00f8be2a6c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODM3MzUyOnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/java/com/netflix/spinnaker/config/PluginsConfigurationProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOToxOTowOFrOFuR5rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoxMjoyMlrOFuToLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjEwOA==", "bodyText": "Worded a little confusingly. Perhaps:\n\nDefines what MANIFEST.MF attribute to use in determining a service version. By default, a service version is determined by reading the \"Implementation-Version\" attribute. If this property is set to true, however, \"Implementation-OSS-Version\" will be used to support use cases where services are being extended and rebuilt. Unless you're re-building services, this should remain its default value.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384072108", "createdAt": "2020-02-25T19:19:08Z", "author": {"login": "robzienert"}, "path": "kork-plugins/src/main/java/com/netflix/spinnaker/config/PluginsConfigurationProperties.java", "diffHunk": "@@ -98,4 +98,12 @@ public boolean isEnabled() {\n       return enabled;\n     }\n   }\n+\n+  /**\n+   * If set to true, the service version resolution will use the MANIFEST.MF attribute\n+   * \"Implementation-OSS-Version\". By default, this is false which means the version attribute\n+   * lookup will be \"Implementation-Version\" -- for most OSS users that will still be the OSS\n+   * version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a037be30609e3a0b3cb6c863743db0698a05ca8"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDM5OA==", "bodyText": "Appreciated.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384100398", "createdAt": "2020-02-25T20:12:22Z", "author": {"login": "jonsie"}, "path": "kork-plugins/src/main/java/com/netflix/spinnaker/config/PluginsConfigurationProperties.java", "diffHunk": "@@ -98,4 +98,12 @@ public boolean isEnabled() {\n       return enabled;\n     }\n   }\n+\n+  /**\n+   * If set to true, the service version resolution will use the MANIFEST.MF attribute\n+   * \"Implementation-OSS-Version\". By default, this is false which means the version attribute\n+   * lookup will be \"Implementation-Version\" -- for most OSS users that will still be the OSS\n+   * version.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjEwOA=="}, "originalCommit": {"oid": "2a037be30609e3a0b3cb6c863743db0698a05ca8"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTIwMDc1OnYy", "diffSide": "RIGHT", "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/ExtensionBeanDefinitionRegistryPostProcessor.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNTozMlrOFuZ23A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDowNTozMlrOFuZ23A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIwMjQ2MA==", "bodyText": "Feels like steps 1-4 could eventually be broken out into a separate service class - would make it much easier to test.", "url": "https://github.com/spinnaker/kork/pull/526#discussion_r384202460", "createdAt": "2020-02-26T00:05:32Z", "author": {"login": "jonsie"}, "path": "kork-plugins/src/main/kotlin/com/netflix/spinnaker/kork/plugins/ExtensionBeanDefinitionRegistryPostProcessor.kt", "diffHunk": "@@ -47,8 +49,19 @@ class ExtensionBeanDefinitionRegistryPostProcessor(\n   override fun postProcessBeanDefinitionRegistry(registry: BeanDefinitionRegistry) {\n     val start = System.currentTimeMillis()\n     log.debug(\"Preparing plugins\")\n-    updateManagerService.checkForUpdates()\n+\n+    // 1) Load plugins prior to downloading so we can resolve what needs to be updated\n     pluginManager.loadPlugins()\n+\n+    // 2) Determine the plugins for release from the list of available plugins\n+    val releases = pluginInfoReleaseProvider.getReleases(updateManager.availablePlugins)\n+\n+    // 3) Download releases, updating previously loaded plugins where necessary\n+    updateManager.downloadPluginReleases(releases).forEach { pluginPath ->\n+      pluginManager.loadPlugin(pluginPath)\n+    }\n+\n+    // 4) Start plugins - should only be called once in kork-plugins\n     pluginManager.startPlugins()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60bebe9cd79b5896f4c78bd84f3a37e82e34350c"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3598, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}