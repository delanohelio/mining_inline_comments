{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMjIwMDM3", "number": 7485, "title": "[1.16] Vanilla packet splitting", "bodyText": "This pull request is a workaround for the size limitations of the vanilla protocol, which causes issues when a huge number of recipes or tags is present.\nTo work around this, the system added in #7369 is enhanced to also act on forge<=>forge connections.\nIf it is detected that a packet is too large, it is split and sent as a series of custom payload packets instead.\nThis fixes #6703.", "createdAt": "2020-11-12T23:26:09Z", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485", "merged": true, "mergeCommit": {"oid": "5363dc5d9907ee4e27e4b43368e7ade8d9e2741a"}, "closed": true, "closedAt": "2021-03-04T20:14:53Z", "author": {"login": "diesieben07"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdb69_uAH2gAyNTIwMjIwMDM3OmI2NmQxZjVlNzhkODEzMDllOTY2M2YxNTgyZTgxZTlhYzNlNTFkOTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvDTdpgH2gAyNTIwMjIwMDM3OjAzMjU2NTk2NWZkYjNjNGI3ZjE5MWVlYTMwZDI2ZTk4YzIwZWE5OTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b66d1f5e78d81309e9663f1582e81e9ac3e51d96", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/b66d1f5e78d81309e9663f1582e81e9ac3e51d96", "committedDate": "2020-11-12T23:15:24Z", "message": "Packet splitting for vanilla packets on Forge connections.\nCurrently only for SUpdateRecipesPacket and STagsListPacket that blow up with huge datapacks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "045443c38875a8e8374072d0c567722f78510194", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/045443c38875a8e8374072d0c567722f78510194", "committedDate": "2020-11-12T23:20:02Z", "message": "Some Javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "487720b501679ef93cd18beb58806fba65653b30", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/487720b501679ef93cd18beb58806fba65653b30", "committedDate": "2020-11-12T23:27:03Z", "message": "Don't split on local connections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NjQxMjgy", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#pullrequestreview-529641282", "createdAt": "2020-11-13T01:40:20Z", "commit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0MDoyMFrOHyWOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzozMToyN1rOHyYdsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDk3OA==", "bodyText": "This event must be ServerCustomPayloadEvent to receive clientbound packets.", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522554978", "createdAt": "2020-11-13T01:40:20Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MTk0Nw==", "bodyText": "This buffer is released after this packet is processed*, either a copy of the buffer should be created or a switch to writing buffer bytes to a single cumulation buffer should be made.\n*should be released, as after confirming this, it is not in fact due to a patch port error introducing a memory leak for what it was intended to fix, new issue report in progress.", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522571947", "createdAt": "2020-11-13T02:28:15Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU5MTY2NQ==", "bodyText": "A call to ctx.setPacketHandled(true) is missing, meaning the log will get filled with \"unknown custom packet.\"", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522591665", "createdAt": "2020-11-13T03:31:27Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);\n+        if (state == STATE_LAST)\n+        {\n+            PacketBuffer full = new PacketBuffer(Unpooled.wrappedBuffer(receivedBuffers.toArray(new PacketBuffer[0])));\n+            int packetId = full.readVarInt();\n+            IPacket<?> packet = protocol.getPacket(direction, packetId);\n+            if (packet == null)\n+            {\n+                LOGGER.error(\"Received invalid packet ID {} in forge:split\", packetId);\n+            }\n+            else if (!ALLOWED_PACKETS.contains(packet.getClass()))\n+            {\n+                LOGGER.error(\"Received not allowed packet type {} in forge:split\", packet);\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    packet.readPacketData(full);\n+                }\n+                catch (IOException e)\n+                {\n+                    throw new UncheckedIOException(e);\n+                }\n+                ctx.enqueueWork(() -> ((IPacket<ClientPlayNetHandler>)packet).processPacket(Minecraft.getInstance().getConnection()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f56767e75c63db2d9cb02d7b719fd5f00d36e8f", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/0f56767e75c63db2d9cb02d7b719fd5f00d36e8f", "committedDate": "2020-11-13T08:47:33Z", "message": "Fix packet not actually doing anything\nProperly release/retain ByteBufs\nreduce ByteBuf copying"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "983f7c91dfe945ab2860fa83e9371976ee85183b", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/983f7c91dfe945ab2860fa83e9371976ee85183b", "committedDate": "2021-01-11T09:39:25Z", "message": "Merge remote-tracking branch 'upstream/1.16.x' into vanilla-packet-splitting\n\n# Conflicts:\n#\tsrc/main/java/net/minecraftforge/network/VanillaConnectionNetworkFilter.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "032565965fdb3c4b7f191eea30d26e98c20ea993", "author": {"user": {"login": "diesieben07", "name": "Take Weiland"}}, "url": "https://github.com/MinecraftForge/MinecraftForge/commit/032565965fdb3c4b7f191eea30d26e98c20ea993", "committedDate": "2021-01-11T09:42:39Z", "message": "Remove todo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2215, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}