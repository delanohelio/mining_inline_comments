{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMjIwMDM3", "number": 7485, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0MDoyMFrOE4br1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzozMToyNlrOE4dI4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjA5MzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0MDoyMFrOHyWOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMTo0MDoyMFrOHyWOYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDk3OA==", "bodyText": "This event must be ServerCustomPayloadEvent to receive clientbound packets.", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522554978", "createdAt": "2020-11-13T01:40:20Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjIwMzE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjoyODoxNVrOHyXQqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjoyODoxNVrOHyXQqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MTk0Nw==", "bodyText": "This buffer is released after this packet is processed*, either a copy of the buffer should be created or a switch to writing buffer bytes to a single cumulation buffer should be made.\n*should be released, as after confirming this, it is not in fact due to a patch port error introducing a memory leak for what it was intended to fix, new issue report in progress.", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522571947", "createdAt": "2020-11-13T02:28:15Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjMzMTIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzozMToyN1rOHyYdsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMzozMToyN1rOHyYdsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU5MTY2NQ==", "bodyText": "A call to ctx.setPacketHandled(true) is missing, meaning the log will get filled with \"unknown custom packet.\"", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522591665", "createdAt": "2020-11-13T03:31:27Z", "author": {"login": "pau101"}, "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);\n+        if (state == STATE_LAST)\n+        {\n+            PacketBuffer full = new PacketBuffer(Unpooled.wrappedBuffer(receivedBuffers.toArray(new PacketBuffer[0])));\n+            int packetId = full.readVarInt();\n+            IPacket<?> packet = protocol.getPacket(direction, packetId);\n+            if (packet == null)\n+            {\n+                LOGGER.error(\"Received invalid packet ID {} in forge:split\", packetId);\n+            }\n+            else if (!ALLOWED_PACKETS.contains(packet.getClass()))\n+            {\n+                LOGGER.error(\"Received not allowed packet type {} in forge:split\", packet);\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    packet.readPacketData(full);\n+                }\n+                catch (IOException e)\n+                {\n+                    throw new UncheckedIOException(e);\n+                }\n+                ctx.enqueueWork(() -> ((IPacket<ClientPlayNetHandler>)packet).processPacket(Minecraft.getInstance().getConnection()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "487720b501679ef93cd18beb58806fba65653b30"}, "originalPosition": 162}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 774, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}