{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4ODUxNzM5", "number": 1435, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo1ODoyOVrOEpBLOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo0NjozNVrOErvtkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDQ2MzI5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo1ODoyOVrOHacR2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo1ODoyOVrOHacR2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4ODM0NQ==", "bodyText": "Good point to update the used bytes while doing this cleanup. I am wondering what this would mean with multiple key version support in the future. We do not seem to store the \"version\" of the current open key.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r497488345", "createdAt": "2020-09-30T12:58:29Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -553,17 +554,43 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume.\n+   * Return volume info for the specified volume. If the volume does not\n+   * exist, returns {@code null}.\n    * @param omMetadataManager\n    * @param volume\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n   protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n       String volume) {\n-    return omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n-        .getCacheValue();\n+\n+    OmVolumeArgs volumeArgs = null;\n+\n+    CacheValue<OmVolumeArgs> value =\n+        omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n+\n+    if (value != null) {\n+      volumeArgs = value.getCacheValue();\n+    }\n+\n+    return volumeArgs;\n+  }\n+\n+  /**\n+   * @return the number of bytes used by blocks pointed to by {@code omKeyInfo}.\n+   */\n+  protected static long sumBlockLengths(OmKeyInfo omKeyInfo) {\n+    long bytesUsed = 0;\n+    int keyFactor = omKeyInfo.getFactor().getNumber();\n+    OmKeyLocationInfoGroup keyLocationGroup =\n+        omKeyInfo.getLatestVersionLocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc0MDc4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODowNzo1MlrOHb24vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODowNzo1MlrOHb24vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3Mjg2MQ==", "bodyText": "Instead of streams, use for loop and compute, as request execution is in hot code path.\nI see a few recent jira's to not to use streams and helped perf improvement.\nCan we use good old for loop here?", "url": "https://github.com/apache/ozone/pull/1435#discussion_r498972861", "createdAt": "2020-10-02T18:07:52Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzc5MDkwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoyMjo1N1rOHb3a3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNToyOTo1NFrOHdNfnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTU5OQ==", "bodyText": "Looks like we need a volume lock here, as we are updating the bytesUsed.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r498981599", "createdAt": "2020-10-02T18:22:57Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NTM4NA==", "bodyText": "I think we are safe because the bytes used value is stored in a thread safe LongAdder internally. See the original PR where this was introduced. If there is still an issue with this approach, then most of the request classes will need to be modified after HDDS-4053. We should discuss further, as this is really an issue with the design already introduced in master for HDDS-4053 rather than this PR.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499585384", "createdAt": "2020-10-05T13:09:26Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTU5OQ=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5MTgzNw==", "bodyText": "Volume byte usage updates will be removed from the open keys delete request and response classes. See this comment.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r500391837", "createdAt": "2020-10-06T15:29:54Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTU5OQ=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzgwOTQ0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoyODozMFrOHb3l6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODoyODozMFrOHb3l6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDQyNA==", "bodyText": "Same here avoid stream here.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r498984424", "createdAt": "2020-10-02T18:28:30Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);\n+            subtractUsedBytes(volumeArgs, deleted.values());\n+          }\n+        }\n+      }\n+\n+      omClientResponse = new OMOpenKeysDeleteResponse(omResponse.build(),\n+          deletedOpenKeys, ozoneManager.isRatisEnabled(),\n+          modifiedVolumes.values());\n+\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse =\n+          new OMKeyDeleteResponse(createErrorOMResponse(omResponse, exception));\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+              omDoubleBufferHelper);\n+    }\n+\n+    processResults(omMetrics, numSubmittedOpenKeys, deletedOpenKeys.size(),\n+        deleteOpenKeysRequest, result);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void processResults(OMMetrics omMetrics, long numSubmittedOpenKeys,\n+      long numDeletedOpenKeys,\n+      OzoneManagerProtocolProtos.DeleteOpenKeysRequest request, Result result) {\n+\n+    switch (result) {\n+    case SUCCESS:\n+      LOG.debug(\"Deleted {} open keys out of {} submitted keys.\",\n+          numDeletedOpenKeys, numSubmittedOpenKeys);\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumOpenKeyDeleteRequestFails();\n+      LOG.error(\"Failure occurred while trying to delete {} submitted open \" +\n+              \"keys.\", numSubmittedOpenKeys);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized result for OMOpenKeysDeleteRequest: {}\",\n+          request);\n+    }\n+  }\n+\n+  private Map<String, OmKeyInfo> updateOpenKeyTableCache(\n+      OzoneManager ozoneManager, long trxnLogIndex, OpenKeyBucket keysPerBucket)\n+      throws IOException {\n+\n+    Map<String, OmKeyInfo> deletedKeys = new HashMap<>();\n+\n+    boolean acquiredLock = false;\n+    String volumeName = keysPerBucket.getVolumeName();\n+    String bucketName = keysPerBucket.getBucketName();\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    try {\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      for (OpenKey key: keysPerBucket.getKeysList()) {\n+        String fullKeyName = omMetadataManager.getOpenKey(volumeName,\n+                bucketName, key.getName(), key.getClientID());\n+\n+        // If an open key is no longer present in the table, it was committed\n+        // and should not be deleted.\n+        OmKeyInfo omKeyInfo =\n+            omMetadataManager.getOpenKeyTable().get(fullKeyName);\n+        if (omKeyInfo != null) {\n+          // Set the UpdateID to current transactionLogIndex\n+          omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+          deletedKeys.put(fullKeyName, omKeyInfo);\n+\n+          // Update table cache.\n+          omMetadataManager.getOpenKeyTable().addCacheEntry(\n+                  new CacheKey<>(fullKeyName),\n+                  new CacheValue<>(Optional.absent(), trxnLogIndex));\n+\n+          ozoneManager.getMetrics().incNumOpenKeysDeleted();\n+          LOG.debug(\"Open key {} deleted.\", fullKeyName);\n+\n+          // No need to add cache entries to delete table. As delete table will\n+          // be used by DeleteKeyService only, not used for any client response\n+          // validation, so we don't need to add to cache.\n+        } else {\n+          LOG.debug(\"Key {} was not deleted, as it was not \" +\n+                  \"found in the open key table.\", fullKeyName);\n+        }\n+      }\n+    } finally {\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+                bucketName);\n+      }\n+    }\n+\n+    return deletedKeys;\n+  }\n+\n+  /**\n+   * Subtracts all bytes used by the blocks pointed to by {@code keyInfos}\n+   * from {@code volumeArgs}.\n+   */\n+  private void subtractUsedBytes(OmVolumeArgs volumeArgs,\n+      Collection<OmKeyInfo> keyInfos) {\n+\n+    long quotaReleased = keyInfos.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzgyNjEwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxODozMzo0NlrOHb3wKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNToyNzo0NlrOHdNXiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA1MA==", "bodyText": "And also here getting a cached object will cause issues.\nIf double buffer flush has not flushed this to DB, and other thread uses same volumeArgs reference and update volumeArgs, we will be updating to DB inconsistent state.\nSo getVolumeInfo should use Table#get API.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r498987050", "createdAt": "2020-10-02T18:33:46Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyOTQ0Ng==", "bodyText": "Just to clarify, is this the execution you are talking about?\n\nRequest1 deletes key1 from volume1 in cache.\nRequest2 deletes key2 from volume1 in cache.\nRequest1 sets cached VolumeArgs object volArgs.bytesUsed -= key1.bytesUsed.\n\ndivergence 1: The cache shows key1 and key2 as deleted, but cache byte usage only reflects key1's deletion.\n\n\nRequest2 sets cached VolumeArgs object volArgs.bytesUsed -= key2.bytesUsed.\n\nAt this point, byte usage in the cache is consistent with the keys it shows as deleted.\n\n\nResponse1 is processed, committing volArgs and the deletion of key1 to the DB.\n\ndivergence 2: the DB shows only key1 deleted, but volume byte usage has been set as if both key1 and key2 were deleted.\n\n\nResponse2 is processed, committing volArgs to the DB again, and committing the deletion of key2 to the DB.\n\nNow the keys deleted and bytes used align in the DB.\n\n\n\nIIRC the entire volume table is stored in memory and only persisted to the DB to save state. Reads only happen from the in memory cache for volume metadata. In this case, divergence 2 will never be detected by callers since it only happens at the DB level. divergence 1 my exist briefly and be detected by callers. Again, this is really an issue with all requests modified in HDDS-4053 and not just this PR. We should discuss to determine whether the slight inconsistency warrants a whole volume lock on all requests that modify byte usage.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499629446", "createdAt": "2020-10-05T14:13:12Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA1MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4Mzc4Ng==", "bodyText": "Not exactly, what I mean here is by the time we process request1, as we add the same object to double buffer, and if other thread processing request2 and updating it, there might be a chance of updating DB state also (Technically this should happen after adding response to double buffer)\nCache is for holding in flight updates if it is not committed to DB, I see no issues with that, this is by design.\nDiveregence 1 should not exist, if volume locks are held.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499683786", "createdAt": "2020-10-05T15:26:51Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA1MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4NjI0OQ==", "bodyText": "https://issues.apache.org/jira/browse/HDDS-2344 Jira but here just value updating (Might not be bringing ConcurrentModificationException, but it can provide some context)", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499686249", "createdAt": "2020-10-05T15:30:09Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA1MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM4OTc2OQ==", "bodyText": "Thanks for the explanation @bharatviswa504. I now see that divergence 2 in the above example poses an issue in the event of an OM crash happening between steps 5 and 6. This will cause the byte usage update to be applied twice in the DB after OM restart. Volume byte usage updates will be removed from the open key requests and responses. Since this is really a larger problem with all requests/responses operating in this way under HDDS-541, we can add the byte usage updates when a solution is developed for all requests/responses as part of HDDS-4308.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r500389769", "createdAt": "2020-10-06T15:27:46Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA1MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzkxMjA0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxOTowNTowNVrOHb4m-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxOTowNTowNVrOHb4m-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwMTA4MQ==", "bodyText": "OMKeyDeleteResponse -> OMOpenKeysDeleteResponse", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499001081", "createdAt": "2020-10-02T19:05:05Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMOpenKeysDeleteRequest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.key.OMKeyRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKeyBucket;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OpenKey;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles requests to move open keys from the open key table to the delete\n+ * table. Modifies the open key table cache only, and no underlying databases.\n+ * The delete table cache does not need to be modified since it is not used\n+ * for client response validation.\n+ */\n+public class OMOpenKeysDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMOpenKeysDeleteRequest.class);\n+\n+  public OMOpenKeysDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumOpenKeyDeleteRequests();\n+\n+    OzoneManagerProtocolProtos.DeleteOpenKeysRequest deleteOpenKeysRequest =\n+            getOmRequest().getDeleteOpenKeysRequest();\n+\n+    List<OpenKeyBucket> submittedOpenKeyBucket =\n+            deleteOpenKeysRequest.getOpenKeysPerBucketList();\n+\n+    long numSubmittedOpenKeys = submittedOpenKeyBucket.stream()\n+        .mapToLong(OpenKeyBucket::getKeysCount).sum();\n+\n+    LOG.debug(\"{} open keys submitted for deletion.\", numSubmittedOpenKeys);\n+    omMetrics.incNumOpenKeysSubmittedForDeletion(numSubmittedOpenKeys);\n+\n+    OzoneManagerProtocolProtos.OMResponse.Builder omResponse =\n+            OmResponseUtil.getOMResponseBuilder(getOmRequest());\n+\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+    Map<String, OmKeyInfo> deletedOpenKeys = new HashMap<>();\n+\n+    try {\n+      // Open keys are grouped by bucket, but there may be multiple buckets\n+      // per volume. This maps volume name to volume args to track\n+      // all volume updates for this request.\n+      Map<String, OmVolumeArgs> modifiedVolumes = new HashMap<>();\n+      OMMetadataManager metadataManager = ozoneManager.getMetadataManager();\n+\n+      for (OpenKeyBucket openKeyBucket: submittedOpenKeyBucket) {\n+        // For each bucket where keys will be deleted from,\n+        // get its bucket lock and update the cache accordingly.\n+        Map<String, OmKeyInfo> deleted = updateOpenKeyTableCache(ozoneManager,\n+            trxnLogIndex, openKeyBucket);\n+\n+        deletedOpenKeys.putAll(deleted);\n+\n+        // If open keys were deleted from this bucket and its volume still\n+        // exists, update the volume's byte usage in the cache.\n+        if (!deleted.isEmpty()) {\n+          String volumeName = openKeyBucket.getVolumeName();\n+          // Returns volume args from the cache if the volume is present,\n+          // null otherwise.\n+          OmVolumeArgs volumeArgs = getVolumeInfo(metadataManager, volumeName);\n+\n+          // If this volume still exists, decrement bytes used based on open\n+          // keys deleted.\n+          // The volume args object being updated is a reference from the\n+          // cache, so this serves as a cache update.\n+          if (volumeArgs != null) {\n+            // If we already encountered the volume, it was a reference to\n+            // the same object from the cache, so this will update it.\n+            modifiedVolumes.put(volumeName, volumeArgs);\n+            subtractUsedBytes(volumeArgs, deleted.values());\n+          }\n+        }\n+      }\n+\n+      omClientResponse = new OMOpenKeysDeleteResponse(omResponse.build(),\n+          deletedOpenKeys, ozoneManager.isRatisEnabled(),\n+          modifiedVolumes.values());\n+\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse =\n+          new OMKeyDeleteResponse(createErrorOMResponse(omResponse, exception));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzkzOTcxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxOToxNTo0M1rOHb44eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTozMTo0MVrOHdNmRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwNTU2MA==", "bodyText": "Looks some of the logic is common for OMKeyDeleteResponse and OMOpenKeysDeleteResponse like isKeyEmpty and deleteFromTable can be used from OMKeyDeleteResponse.\nCan we consolidate them and use this AbstractOMKeyDeleteResponse as base class for both of them", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499005560", "createdAt": "2020-10-02T19:15:43Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Response for DeleteKey request.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    deleteFromTable(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo, long trxnLogIndex) throws IOException {\n+\n+    // For OmResponse with failure, this should do nothing. This method is\n+    // not called in failure scenario in OM code.\n+    fromTable.deleteWithBatch(batchOperation, keyName);\n+\n+    // If Key is not empty add this to delete table.\n+    if (!isKeyEmpty(omKeyInfo)) {\n+      // If a deleted key is put in the table where a key with the same\n+      // name already exists, then the old deleted key information would be\n+      // lost. To avoid this, first check if a key with same name exists.\n+      // deletedTable in OM Metadata stores <KeyName, RepeatedOMKeyInfo>.\n+      // The RepeatedOmKeyInfo is the structure that allows us to store a\n+      // list of OmKeyInfo that can be tied to same key name. For a keyName\n+      // if RepeatedOMKeyInfo structure is null, we create a new instance,\n+      // if it is not null, then we simply add to the list and store this\n+      // instance in deletedTable.\n+      RepeatedOmKeyInfo repeatedOmKeyInfo =\n+          omMetadataManager.getDeletedTable().get(keyName);\n+      repeatedOmKeyInfo = OmUtils.prepareKeyForDelete(\n+          omKeyInfo, repeatedOmKeyInfo, trxnLogIndex,\n+          isRatisEnabled);\n+      omMetadataManager.getDeletedTable().putWithBatch(\n+          batchOperation, keyName, repeatedOmKeyInfo);\n+    }\n+  }\n+\n+  protected void addVolumeArgsToBatch(OMMetadataManager metadataManager,\n+      BatchOperation batch, OmVolumeArgs volumeArgs) throws IOException {\n+\n+    Table<String, OmVolumeArgs> volumeTable = metadataManager.getVolumeTable();\n+    String volumeKey = metadataManager.getVolumeKey(volumeArgs.getVolume());\n+    volumeTable.putWithBatch(batch, volumeKey, volumeArgs);\n+  }\n+\n+  @Override\n+  public abstract void addToDBBatch(OMMetadataManager omMetadataManager,\n+        BatchOperation batchOperation) throws IOException;\n+\n+  /**\n+   * Check if the key is empty or not. Key will be empty if it does not have\n+   * blocks.\n+   *\n+   * @param keyInfo\n+   * @return if empty true, else false.\n+   */\n+  private boolean isKeyEmpty(@Nullable OmKeyInfo keyInfo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3ODU0Mw==", "bodyText": "Yes, the idea of creating this abstract class was to eventually consolidate the duplicate code between OMOpenKeysDeleteResponse, OMKeyDeleteResponse, and OMKeysDeleteResponse. I had originally refactored the other classes as well to use this code, but since HDDS-451 (quota support) is moving along at a brisk pace, I could not keep up with the merge conflicts as the other response classes kept changing, and decided it was better to do this in a later PR.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r499578543", "createdAt": "2020-10-05T12:58:27Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Response for DeleteKey request.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    deleteFromTable(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo, long trxnLogIndex) throws IOException {\n+\n+    // For OmResponse with failure, this should do nothing. This method is\n+    // not called in failure scenario in OM code.\n+    fromTable.deleteWithBatch(batchOperation, keyName);\n+\n+    // If Key is not empty add this to delete table.\n+    if (!isKeyEmpty(omKeyInfo)) {\n+      // If a deleted key is put in the table where a key with the same\n+      // name already exists, then the old deleted key information would be\n+      // lost. To avoid this, first check if a key with same name exists.\n+      // deletedTable in OM Metadata stores <KeyName, RepeatedOMKeyInfo>.\n+      // The RepeatedOmKeyInfo is the structure that allows us to store a\n+      // list of OmKeyInfo that can be tied to same key name. For a keyName\n+      // if RepeatedOMKeyInfo structure is null, we create a new instance,\n+      // if it is not null, then we simply add to the list and store this\n+      // instance in deletedTable.\n+      RepeatedOmKeyInfo repeatedOmKeyInfo =\n+          omMetadataManager.getDeletedTable().get(keyName);\n+      repeatedOmKeyInfo = OmUtils.prepareKeyForDelete(\n+          omKeyInfo, repeatedOmKeyInfo, trxnLogIndex,\n+          isRatisEnabled);\n+      omMetadataManager.getDeletedTable().putWithBatch(\n+          batchOperation, keyName, repeatedOmKeyInfo);\n+    }\n+  }\n+\n+  protected void addVolumeArgsToBatch(OMMetadataManager metadataManager,\n+      BatchOperation batch, OmVolumeArgs volumeArgs) throws IOException {\n+\n+    Table<String, OmVolumeArgs> volumeTable = metadataManager.getVolumeTable();\n+    String volumeKey = metadataManager.getVolumeKey(volumeArgs.getVolume());\n+    volumeTable.putWithBatch(batch, volumeKey, volumeArgs);\n+  }\n+\n+  @Override\n+  public abstract void addToDBBatch(OMMetadataManager omMetadataManager,\n+        BatchOperation batchOperation) throws IOException;\n+\n+  /**\n+   * Check if the key is empty or not. Key will be empty if it does not have\n+   * blocks.\n+   *\n+   * @param keyInfo\n+   * @return if empty true, else false.\n+   */\n+  private boolean isKeyEmpty(@Nullable OmKeyInfo keyInfo) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwNTU2MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5MzU0MQ==", "bodyText": "Looks like development on the key(s) delete request and response classes has taken a break. I have refactored them to use these shared methods now.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r500393541", "createdAt": "2020-10-06T15:31:41Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OmVolumeArgs;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Response for DeleteKey request.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    deleteFromTable(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void deleteFromTable(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo, long trxnLogIndex) throws IOException {\n+\n+    // For OmResponse with failure, this should do nothing. This method is\n+    // not called in failure scenario in OM code.\n+    fromTable.deleteWithBatch(batchOperation, keyName);\n+\n+    // If Key is not empty add this to delete table.\n+    if (!isKeyEmpty(omKeyInfo)) {\n+      // If a deleted key is put in the table where a key with the same\n+      // name already exists, then the old deleted key information would be\n+      // lost. To avoid this, first check if a key with same name exists.\n+      // deletedTable in OM Metadata stores <KeyName, RepeatedOMKeyInfo>.\n+      // The RepeatedOmKeyInfo is the structure that allows us to store a\n+      // list of OmKeyInfo that can be tied to same key name. For a keyName\n+      // if RepeatedOMKeyInfo structure is null, we create a new instance,\n+      // if it is not null, then we simply add to the list and store this\n+      // instance in deletedTable.\n+      RepeatedOmKeyInfo repeatedOmKeyInfo =\n+          omMetadataManager.getDeletedTable().get(keyName);\n+      repeatedOmKeyInfo = OmUtils.prepareKeyForDelete(\n+          omKeyInfo, repeatedOmKeyInfo, trxnLogIndex,\n+          isRatisEnabled);\n+      omMetadataManager.getDeletedTable().putWithBatch(\n+          batchOperation, keyName, repeatedOmKeyInfo);\n+    }\n+  }\n+\n+  protected void addVolumeArgsToBatch(OMMetadataManager metadataManager,\n+      BatchOperation batch, OmVolumeArgs volumeArgs) throws IOException {\n+\n+    Table<String, OmVolumeArgs> volumeTable = metadataManager.getVolumeTable();\n+    String volumeKey = metadataManager.getVolumeKey(volumeArgs.getVolume());\n+    volumeTable.putWithBatch(batch, volumeKey, volumeArgs);\n+  }\n+\n+  @Override\n+  public abstract void addToDBBatch(OMMetadataManager omMetadataManager,\n+        BatchOperation batchOperation) throws IOException;\n+\n+  /**\n+   * Check if the key is empty or not. Key will be empty if it does not have\n+   * blocks.\n+   *\n+   * @param keyInfo\n+   * @return if empty true, else false.\n+   */\n+  private boolean isKeyEmpty(@Nullable OmKeyInfo keyInfo) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwNTU2MA=="}, "originalCommit": {"oid": "14a2241c5a0f7bc4726a7e6a28f0577ce471d559"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzA1OTM5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODo0NjozNVrOHer6IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMzo1MTo1MVrOHfKm-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODcyMA==", "bodyText": "Minor: Can we merge these two functions.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r501938720", "createdAt": "2020-10-08T18:46:35Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Base class for responses that need to move keys from an arbitrary table to\n+ * the deleted table.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void addDeletionToBatch(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    addDeletionToBatch(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void addDeletionToBatch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "089605d7b85bcd72b59ff79c614be7495f83b52d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3NjM0Mg==", "bodyText": "This is actually related to a mistake I made in OMKeysDeleteResponse. The original implementation had one trxnLogIndex it used for all the keys. All other calls to this method are using the updateID of the keyInfo provided as the trxnLogIndex. If the way I am doing it currently (OMKeysDeleteResponse uses the updateID of each key as its trxnLogIndex instead of one value for all keys deleted), then I can remove the overload. If not, I can fix OMKeysDeleteResponse to call the overload, giving it identical behavior to its original implementation.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r501976342", "createdAt": "2020-10-08T19:55:44Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Base class for responses that need to move keys from an arbitrary table to\n+ * the deleted table.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void addDeletionToBatch(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    addDeletionToBatch(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void addDeletionToBatch(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODcyMA=="}, "originalCommit": {"oid": "089605d7b85bcd72b59ff79c614be7495f83b52d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTM0Mw==", "bodyText": "Previously we used to use updateID for detecting replay of transaction. Now we are not using updateID any more.\nBut from my understanding updateID should be set with transactionIndex even before.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r502165343", "createdAt": "2020-10-09T03:31:26Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Base class for responses that need to move keys from an arbitrary table to\n+ * the deleted table.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void addDeletionToBatch(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    addDeletionToBatch(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void addDeletionToBatch(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODcyMA=="}, "originalCommit": {"oid": "089605d7b85bcd72b59ff79c614be7495f83b52d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ0MTcyMQ==", "bodyText": "Got it. A closer look at the OMKeysDeleteRequest looks like this was happening anyways. Instead of setting the update ID for the key info to be the trxnLogIndex and submitting the key info to the response, it was just passing the trxnLogIndex separately with the key info to the response. I will update OMKeysDeleteRequest/Response to be consistent with the other request/responses in how they do this, and remove the overload of this method.", "url": "https://github.com/apache/ozone/pull/1435#discussion_r502441721", "createdAt": "2020-10-09T13:51:51Z", "author": {"login": "errose28"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/AbstractOMKeyDeleteResponse.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.RepeatedOmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+\n+import java.io.IOException;\n+import javax.annotation.Nullable;\n+import javax.annotation.Nonnull;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.DELETED_TABLE;\n+\n+/**\n+ * Base class for responses that need to move keys from an arbitrary table to\n+ * the deleted table.\n+ */\n+@CleanupTableInfo(cleanupTables = {DELETED_TABLE})\n+public abstract class AbstractOMKeyDeleteResponse extends OMClientResponse {\n+\n+  private boolean isRatisEnabled;\n+\n+  public AbstractOMKeyDeleteResponse(\n+      @Nonnull OMResponse omResponse, boolean isRatisEnabled) {\n+\n+    super(omResponse);\n+    this.isRatisEnabled = isRatisEnabled;\n+  }\n+\n+  /**\n+   * For when the request is not successful.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public AbstractOMKeyDeleteResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   * The log transaction index used will be retrieved by calling\n+   * {@link OmKeyInfo#getUpdateID} on {@code omKeyInfo}.\n+   */\n+  protected void addDeletionToBatch(\n+      OMMetadataManager omMetadataManager,\n+      BatchOperation batchOperation,\n+      Table<String, ?> fromTable,\n+      String keyName,\n+      OmKeyInfo omKeyInfo) throws IOException {\n+\n+    addDeletionToBatch(omMetadataManager, batchOperation, fromTable, keyName,\n+        omKeyInfo, omKeyInfo.getUpdateID());\n+  }\n+\n+  /**\n+   * Adds the operation of deleting the {@code keyName omKeyInfo} pair from\n+   * {@code fromTable} to the batch operation {@code batchOperation}. The\n+   * batch operation is not committed, so no changes are persisted to disk.\n+   */\n+  protected void addDeletionToBatch(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzODcyMA=="}, "originalCommit": {"oid": "089605d7b85bcd72b59ff79c614be7495f83b52d"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4923, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}