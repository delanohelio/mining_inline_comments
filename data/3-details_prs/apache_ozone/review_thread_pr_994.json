{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MjAwNDc4", "number": 994, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToxOToxMlrOEBAjIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMDo0ODoyNFrOEBErzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDkzMDI1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToxOToxMlrOGcpFyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDozNjozMlrOGdGCbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjUzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds to\" +", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686537", "createdAt": "2020-05-29T19:19:12Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDgxMw==", "bodyText": "Well spotted. I have fixed this.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433160813", "createdAt": "2020-06-01T10:36:32Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjUzNw=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDkzMTIxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToxOTo0M1rOGcpGkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDozNjo0MlrOGdGCpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjczOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds for\" +", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686738", "createdAt": "2020-05-29T19:19:43Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDg3MQ==", "bodyText": "Well spotted. I have fixed this.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433160871", "createdAt": "2020-06-01T10:36:42Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjczOA=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk1MDI4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToyNjo1N1rOGcpSlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDozNzo1MVrOGdGEag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTgxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Container not found while finding missing containers\", e);\n          \n          \n            \n                  LOG.error(\"Container not found while processing container in Container Health task\", e);", "url": "https://github.com/apache/ozone/pull/994#discussion_r432689814", "createdAt": "2020-05-29T19:26:57Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MTMyMg==", "bodyText": "Fixed.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433161322", "createdAt": "2020-06-01T10:37:51Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTgxNA=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk2NTg4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozMjo0OFrOGcpcew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0NTowMFrOGdGPyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjM0Nw==", "bodyText": "Can you please add JavaDoc for this method?", "url": "https://github.com/apache/ozone/pull/994#discussion_r432692347", "createdAt": "2020-05-29T19:32:48Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDIzMg==", "bodyText": "Done.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164232", "createdAt": "2020-06-01T10:45:00Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjM0Nw=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk3MjI1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozNToxOVrOGcpgmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0NToyMVrOGdGQVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzQwMQ==", "bodyText": "Please fix the dangling statement", "url": "https://github.com/apache/ozone/pull/994#discussion_r432693401", "createdAt": "2020-05-29T19:35:19Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.UNDER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.UNDER_REPLICATED, time));\n+      }\n+\n+      if (container.isOverReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.OVER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.OVER_REPLICATED, time));\n+      }\n+\n+      if (container.isMisReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MIS_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.MIS_REPLICATED, time));\n+      }\n+      return records;\n+    }\n+\n+    static private UnhealthyContainers recordForState(\n+        ContainerHealthStatus container, UnHealthyContainerStates state,\n+        long time) {\n+      UnhealthyContainers rec = new UnhealthyContainers();\n+      rec.setContainerId(container.getContainerID());\n+      if (state == UnHealthyContainerStates.MIS_REPLICATED) {\n+        rec.setExpectedReplicaCount(container.expectedPlacementCount());\n+        rec.setActualReplicaCount(container.actualPlacementCount());\n+        rec.setReplicaDelta(container.misReplicatedDelta());\n+        rec.setReason(container.misReplicatedReason());\n+      } else {\n+        rec.setExpectedReplicaCount(container.getReplicationFactor());\n+        rec.setActualReplicaCount(container.getReplicaCount());\n+        rec.setReplicaDelta(container.replicaDelta());\n+      }\n+      rec.setContainerState(state.toString());\n+      rec.setInStateSince(time);\n+      return rec;\n+    }\n+\n+    static private boolean keepOverReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isOverReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepUnderReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isUnderReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepMisReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isMisReplicated()) {\n+        updateExpectedReplicaCount(rec, container.expectedPlacementCount());\n+        updateActualReplicaCount(rec, container.actualPlacementCount());\n+        updateReplicaDelta(rec, container.misReplicatedDelta());\n+        updateReason(rec, container.misReplicatedReason());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * With a Jooq record, if you update any field in the record, the record\n+     * is marked as changed, even if you updated it to the same value as it is\n+     * already set to. We only need to run a DB update statement if the record\n+     * has really changed. The methods below ensure we do not update the Jooq\n+     * record unless the values have changed and hence save a DB execution\n+     * when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDM3NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164374", "createdAt": "2020-06-01T10:45:21Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.UNDER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.UNDER_REPLICATED, time));\n+      }\n+\n+      if (container.isOverReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.OVER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.OVER_REPLICATED, time));\n+      }\n+\n+      if (container.isMisReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MIS_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.MIS_REPLICATED, time));\n+      }\n+      return records;\n+    }\n+\n+    static private UnhealthyContainers recordForState(\n+        ContainerHealthStatus container, UnHealthyContainerStates state,\n+        long time) {\n+      UnhealthyContainers rec = new UnhealthyContainers();\n+      rec.setContainerId(container.getContainerID());\n+      if (state == UnHealthyContainerStates.MIS_REPLICATED) {\n+        rec.setExpectedReplicaCount(container.expectedPlacementCount());\n+        rec.setActualReplicaCount(container.actualPlacementCount());\n+        rec.setReplicaDelta(container.misReplicatedDelta());\n+        rec.setReason(container.misReplicatedReason());\n+      } else {\n+        rec.setExpectedReplicaCount(container.getReplicationFactor());\n+        rec.setActualReplicaCount(container.getReplicaCount());\n+        rec.setReplicaDelta(container.replicaDelta());\n+      }\n+      rec.setContainerState(state.toString());\n+      rec.setInStateSince(time);\n+      return rec;\n+    }\n+\n+    static private boolean keepOverReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isOverReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepUnderReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isUnderReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepMisReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isMisReplicated()) {\n+        updateExpectedReplicaCount(rec, container.expectedPlacementCount());\n+        updateActualReplicaCount(rec, container.actualPlacementCount());\n+        updateReplicaDelta(rec, container.misReplicatedDelta());\n+        updateReason(rec, container.misReplicatedReason());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * With a Jooq record, if you update any field in the record, the record\n+     * is marked as changed, even if you updated it to the same value as it is\n+     * already set to. We only need to run a DB update statement if the record\n+     * has really changed. The methods below ensure we do not update the Jooq\n+     * record unless the values have changed and hence save a DB execution\n+     * when", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzQwMQ=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 314}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk4MzE5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthStatus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozODoyMlrOGcpnSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0NjoxNFrOGdGRsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTExNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Test to ensure the correct container state is return by a\n          \n          \n            \n             * ContainerHealthyStatus instance.\n          \n          \n            \n             * Test to ensure the correct container state is returned by a\n          \n          \n            \n             * ContainerHealthStatus instance.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432695115", "createdAt": "2020-05-29T19:38:22Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthStatus.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test to ensure the correct container state is return by a\n+ * ContainerHealthyStatus instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDcyMg==", "bodyText": "Fixed.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164722", "createdAt": "2020-06-01T10:46:14Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthStatus.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test to ensure the correct container state is return by a\n+ * ContainerHealthyStatus instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTExNQ=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk4OTMyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozOTo0M1rOGcprGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0Njo1N1rOGdGSxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NjA5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Class to test single run of Missing Container Task.\n          \n          \n            \n             * Class to test single run of Container Health Task.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432696090", "createdAt": "2020-05-29T19:39:43Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto.State;\n+import org.apache.hadoop.hdds.scm.ContainerPlacementStatus;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconStorageContainerManagerFacade;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition;\n+import org.hadoop.ozone.recon.schema.tables.daos.ContainerHistoryDao;\n+import org.apache.hadoop.ozone.recon.persistence.AbstractReconSqlDBTest;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.daos.UnhealthyContainersDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.ReconTaskStatus;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test single run of Missing Container Task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDk5OA==", "bodyText": "Fixed.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164998", "createdAt": "2020-06-01T10:46:57Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto.State;\n+import org.apache.hadoop.hdds.scm.ContainerPlacementStatus;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconStorageContainerManagerFacade;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition;\n+import org.hadoop.ozone.recon.schema.tables.daos.ContainerHistoryDao;\n+import org.apache.hadoop.ozone.recon.persistence.AbstractReconSqlDBTest;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.daos.UnhealthyContainersDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.ReconTaskStatus;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test single run of Missing Container Task.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NjA5MA=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTU0MDUxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMzozOTo1NlrOGcvABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo1NToyN1rOGdGfrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzM2NQ==", "bodyText": "Nit. It would be good to add Javadoc for this method since it is doing some complex operations.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432783365", "createdAt": "2020-05-29T23:39:56Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2ODMwMg==", "bodyText": "Done.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433168302", "createdAt": "2020-06-01T10:55:27Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzM2NQ=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTU1MTgzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMzo0OTo0MFrOGcvHFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowMToyMVrOGdGo_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTE3Mw==", "bodyText": "Can add .filter(c -> !processedContainers.contains(c)) here instead of adding a check inside the processContainer method.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785173", "createdAt": "2020-05-29T23:49:40Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MDY4NQ==", "bodyText": "Good idea. I have changed this.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433170685", "createdAt": "2020-06-01T11:01:21Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTE3Mw=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTU1NzE3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMzo1Mzo1MVrOGcvKTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMToxOToyNVrOGdHFVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTk5OA==", "bodyText": "I am wondering why this check is not written like\nif (currentContainer != null && currentContainer.getContainerID() != rec.getContainerId()) {\nIn Line #145, we can remove the 'currentContainer = null'.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785998", "createdAt": "2020-05-29T23:53:51Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3Nzk0Mw==", "bodyText": "On the first pass through, currentContainer will be null, so we cannot called currentContainer.getContainerID() on it, so I think we need the null check.\nIf could be changed to something like:\nif (container == null) {\n  currentContainer = setCurrentContainer(rec.getContainerId());\n} else if (currentContainer.getContainerID() != rec.getContainerId()) {\n  completeProcessingContainer(currentContainer, existingRecords, currentTime);\n  existingRecords.clear(); \n  currentContainer = setCurrentContainer(rec.getContainerId());\n}\n\nI am not sure that is much better though.\nWe will also still need a null check in completeProcessingContainer or around the call to it, to handle the case where there are no containers processed in the cursor.", "url": "https://github.com/apache/ozone/pull/994#discussion_r433177943", "createdAt": "2020-06-01T11:19:25Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTk5OA=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTYwNzgzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMDo0ODoyNFrOGcvoCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDo0ODo1M1rOGdZmsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ==", "bodyText": "Can we add an 'else' after the isMissing() check? A missing container cannot be in any other state right?", "url": "https://github.com/apache/ozone/pull/994#discussion_r432793609", "createdAt": "2020-05-30T00:48:24Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDE1Mg==", "bodyText": "You are correct. Rather than next the rest of the method in the else block, I added a return statement in the missing branch. Does that look ok?", "url": "https://github.com/apache/ozone/pull/994#discussion_r433174152", "createdAt": "2020-06-01T11:09:26Z", "author": {"login": "sodonnel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MTM5Mg==", "bodyText": "+1", "url": "https://github.com/apache/ozone/pull/994#discussion_r433481392", "createdAt": "2020-06-01T20:48:53Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ=="}, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 231}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4201, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}