{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjk4NDM2", "number": 450, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDowNzo0OFrODbaiVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0MDo1MFrODcHw3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDcyOTE5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDowNzo0OFrOFi45gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDowNzo0OFrOFi45gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyODEzMQ==", "bodyText": "objectID  -> updatedID", "url": "https://github.com/apache/ozone/pull/450#discussion_r372128131", "createdAt": "2020-01-29T00:07:48Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc5OTM2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDo1MTozOFrOFi5ksw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDo1MTozOFrOFi5ksw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzOTE4Nw==", "bodyText": "As discussed offline.\nHere there is a chance of not deleting the old keyInfo from RepeatedKeyInfo when a new Key with transaction ID greater than the transactionLogIndex of purgeKeyRequest.", "url": "https://github.com/apache/ozone/pull/450#discussion_r372139187", "createdAt": "2020-01-29T00:51:38Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so\n+    // that in case this transaction is a replay, we do not purge keys\n+    // created after the original purge request.\n+    // PurgeKeys request has keys belonging to same bucket grouped together.\n+    // We get each bucket lock and check the above condition.\n+    for (DeletedKeys bucketWithDeleteKeys : bucketDeletedKeysList) {\n+      boolean acquiredLock = false;\n+      String volumeName = bucketWithDeleteKeys.getVolumeName();\n+      String bucketName = bucketWithDeleteKeys.getBucketName();\n+      try {\n+        acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+            volumeName, bucketName);\n+        for (String deletedKey : bucketWithDeleteKeys.getKeysList()) {\n+          RepeatedOmKeyInfo repeatedOmKeyInfo =\n+              omMetadataManager.getDeletedTable().get(deletedKey);\n+          boolean purgeKey = true;\n+          if (repeatedOmKeyInfo != null) {\n+            for (OmKeyInfo omKeyInfo : repeatedOmKeyInfo.getOmKeyInfoList()) {\n+              // Discard those keys whose updateID is > transactionLogIndex.\n+              // This could happen when the PurgeRequest is replayed.\n+              if (isReplay(ozoneManager, omKeyInfo.getUpdateID(),\n+                  transactionLogIndex)) {\n+                purgeKey = false;\n+                break;\n+              }\n+            }\n+            if (purgeKey) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDgxMzQ0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMTowMDoxNVrOFi5tew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMTowMDoxNVrOFi5tew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0MTQzNQ==", "bodyText": "Can we add some logging for replay case and normal logging also which will help in debugging", "url": "https://github.com/apache/ozone/pull/450#discussion_r372141435", "createdAt": "2020-01-29T01:00:15Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so\n+    // that in case this transaction is a replay, we do not purge keys\n+    // created after the original purge request.\n+    // PurgeKeys request has keys belonging to same bucket grouped together.\n+    // We get each bucket lock and check the above condition.\n+    for (DeletedKeys bucketWithDeleteKeys : bucketDeletedKeysList) {\n+      boolean acquiredLock = false;\n+      String volumeName = bucketWithDeleteKeys.getVolumeName();\n+      String bucketName = bucketWithDeleteKeys.getBucketName();\n+      try {\n+        acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+            volumeName, bucketName);\n+        for (String deletedKey : bucketWithDeleteKeys.getKeysList()) {\n+          RepeatedOmKeyInfo repeatedOmKeyInfo =\n+              omMetadataManager.getDeletedTable().get(deletedKey);\n+          boolean purgeKey = true;\n+          if (repeatedOmKeyInfo != null) {\n+            for (OmKeyInfo omKeyInfo : repeatedOmKeyInfo.getOmKeyInfoList()) {\n+              // Discard those keys whose updateID is > transactionLogIndex.\n+              // This could happen when the PurgeRequest is replayed.\n+              if (isReplay(ozoneManager, omKeyInfo.getUpdateID(),\n+                  transactionLogIndex)) {\n+                purgeKey = false;\n+                break;\n+              }\n+            }\n+            if (purgeKey) {\n+              keysToBePurgedList.add(deletedKey);\n+            }\n+          }\n+        }\n+      } catch (IOException ex) {\n+        success = false;\n+        exception = ex;\n+        break;\n+      } finally {\n+        if (acquiredLock) {\n+          omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+              bucketName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwODEzOTE5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0MDo1MFrOFkACIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0MTo1MFrOFkAC6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzYwMQ==", "bodyText": "Minor: We can use the Java8 String method String.join(\", list)", "url": "https://github.com/apache/ozone/pull/450#discussion_r373293601", "createdAt": "2020-01-31T02:40:50Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -115,18 +126,42 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n               bucketName);\n         }\n       }\n+\n+      if (result == Result.REPLAY) {\n+        LOG.debug(\"Replayed Transaction {}. Request: {}\", trxnLogIndex,\n+            purgeKeysRequest);\n+        if (!keysNotPurged.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d39192f9be7c0cd64e8fa2021e46c81a850de31"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzgwMw==", "bodyText": "And also as discussed offline for debug statements we can use isDebugEnabled, so that parameter conversion will not happen. If you want, we can open a new Jira to address this and above.", "url": "https://github.com/apache/ozone/pull/450#discussion_r373293803", "createdAt": "2020-01-31T02:41:50Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -115,18 +126,42 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n               bucketName);\n         }\n       }\n+\n+      if (result == Result.REPLAY) {\n+        LOG.debug(\"Replayed Transaction {}. Request: {}\", trxnLogIndex,\n+            purgeKeysRequest);\n+        if (!keysNotPurged.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzYwMQ=="}, "originalCommit": {"oid": "4d39192f9be7c0cd64e8fa2021e46c81a850de31"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 127, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}