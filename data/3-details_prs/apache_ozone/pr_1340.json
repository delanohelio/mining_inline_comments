{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzI0NTY4", "number": 1340, "title": "HDDS-3188 Add failover proxy for SCM block location.", "bodyText": "What changes were proposed in this pull request?\n(Please fill in changes proposed in this fix)\nWhat is the link to the Apache JIRA\n(Please create an issue in ASF JIRA before opening a pull request,\nand you need to set the title of the pull request which starts with\nthe corresponding JIRA issue number. (e.g. HDDS-XXXX. Fix a typo in YYY.)\nPlease replace this section with the link to the Apache JIRA)\nHow was this patch tested?\n(Please explain how this patch was tested. Ex: unit tests, manual tests)\n(If this patch involves UI changes, please attach a screen-shot; otherwise, remove this)", "createdAt": "2020-08-20T07:29:11Z", "url": "https://github.com/apache/ozone/pull/1340", "merged": true, "mergeCommit": {"oid": "138d33ec0c6a0385f6a59f42fadaaec079ddb6c0"}, "closed": true, "closedAt": "2020-09-30T16:27:10Z", "author": {"login": "timmylicheng"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAwzXZgBqjM2NzU0NTE1OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdM5W_xAH2gAyNDcwNzI0NTY4OmQxNDNiNzkwMjhkYTJjMzgwZTgwNmQ0ZTQ3ODg0M2ZkZDcyMmM5NGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "76e4ee35c38ac76ef386724216b55d9ad12826e3", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/76e4ee35c38ac76ef386724216b55d9ad12826e3", "committedDate": "2020-08-19T02:45:52Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "5144bc5bf97d6880b4eaf684be742d460e93c78b", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/5144bc5bf97d6880b4eaf684be742d460e93c78b", "committedDate": "2020-08-20T14:08:36Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5144bc5bf97d6880b4eaf684be742d460e93c78b", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/5144bc5bf97d6880b4eaf684be742d460e93c78b", "committedDate": "2020-08-20T14:08:36Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "0883c8110be3f37ecf1e7a09bacd5c0656baa863", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/0883c8110be3f37ecf1e7a09bacd5c0656baa863", "committedDate": "2020-08-21T08:07:32Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0883c8110be3f37ecf1e7a09bacd5c0656baa863", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/0883c8110be3f37ecf1e7a09bacd5c0656baa863", "committedDate": "2020-08-21T08:07:32Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "57c4841ace66e3cbc6751871a509fcddc982883c", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/57c4841ace66e3cbc6751871a509fcddc982883c", "committedDate": "2020-08-21T13:23:42Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57c4841ace66e3cbc6751871a509fcddc982883c", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/57c4841ace66e3cbc6751871a509fcddc982883c", "committedDate": "2020-08-21T13:23:42Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "dbbab11102d050d5590b541f4debdcd442379a07", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/dbbab11102d050d5590b541f4debdcd442379a07", "committedDate": "2020-08-25T04:34:30Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dbbab11102d050d5590b541f4debdcd442379a07", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/dbbab11102d050d5590b541f4debdcd442379a07", "committedDate": "2020-08-25T04:34:30Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "cec791b921501a7a06efaf8bbb0785a0cb21916e", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/cec791b921501a7a06efaf8bbb0785a0cb21916e", "committedDate": "2020-08-25T08:55:25Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cec791b921501a7a06efaf8bbb0785a0cb21916e", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/cec791b921501a7a06efaf8bbb0785a0cb21916e", "committedDate": "2020-08-25T08:55:25Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "bb8b1fb78910a4605cfb12e25848e446ed197fa8", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/bb8b1fb78910a4605cfb12e25848e446ed197fa8", "committedDate": "2020-08-25T09:56:13Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb8b1fb78910a4605cfb12e25848e446ed197fa8", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/bb8b1fb78910a4605cfb12e25848e446ed197fa8", "committedDate": "2020-08-25T09:56:13Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/f811ed461002c3d4817dd9093d419182d4fa37ff", "committedDate": "2020-08-25T10:44:13Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0Mzc4OTkx", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-474378991", "createdAt": "2020-08-25T11:19:24Z", "commit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToxOToyNFrOHGTWVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTozOTowMlrOHGT_8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MDUxNg==", "bodyText": "refer to OM-HA, the rpcProxy should be a result of Proxy.newProxyInstance(.... which relies on FailoverProxyProvider to switch between different ScmBlockLocationProtocolService.\n    OzoneManagerProtocolPB proxy = (OzoneManagerProtocolPB) RetryProxy.create(\n        OzoneManagerProtocolPB.class, failoverProxyProvider, retryPolicy);\n    return proxy;", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476370516", "createdAt": "2020-08-25T11:19:24Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -73,15 +75,19 @@\n   private static final RpcController NULL_RPC_CONTROLLER = null;\n \n   private final ScmBlockLocationProtocolPB rpcProxy;\n+  private SCMBlockLocationFailoverProxyProvider failoverProxyProvider;\n \n   /**\n    * Creates a new StorageContainerLocationProtocolClientSideTranslatorPB.\n    *\n-   * @param rpcProxy {@link StorageContainerLocationProtocolPB} RPC proxy\n+   * @param proxyProvider {@link SCMBlockLocationFailoverProxyProvider}\n+   * failover proxy provider.\n    */\n   public ScmBlockLocationProtocolClientSideTranslatorPB(\n-      ScmBlockLocationProtocolPB rpcProxy) {\n-    this.rpcProxy = rpcProxy;\n+      SCMBlockLocationFailoverProxyProvider proxyProvider) {\n+    Preconditions.checkState(proxyProvider != null);\n+    this.failoverProxyProvider = proxyProvider;\n+    this.rpcProxy = proxyProvider.getCurrentProxy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MTk0Ng==", "bodyText": "We need consider the case that current follower SCM does not know current leader.\ncheck this\n  public OMResponse submitRequest(OMRequest payload) throws IOException {\n    try {\n      OMResponse omResponse =\n          rpcProxy.submitRequest(NULL_RPC_CONTROLLER, payload);\n\n      if (omResponse.hasLeaderOMNodeId() && omFailoverProxyProvider != null) {\n        String leaderOmId = omResponse.getLeaderOMNodeId();\n\n        // Failover to the OM node returned by OMResponse leaderOMNodeId if\n        // current proxy is not pointing to that node.\n        omFailoverProxyProvider.performFailoverIfRequired(leaderOmId);\n      }", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476371946", "createdAt": "2020-08-25T11:22:17Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -105,6 +111,11 @@ private SCMBlockLocationResponse submitRequest(\n     try {\n       SCMBlockLocationResponse response =\n           rpcProxy.send(NULL_RPC_CONTROLLER, req);\n+      if (response.getStatus() ==", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NTIyNQ==", "bodyText": "This is not used.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476375225", "createdAt": "2020-08-25T11:28:59Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NjAzNw==", "bodyText": "I guess this method is not needed.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476376037", "createdAt": "2020-08-25T11:30:29Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTE2OQ==", "bodyText": "Should not call performFailover() in FailoverProxyProvider, it is job of RetryInvocationHandler to call performFailover() in its RetryInvocationHandler.ProxyDescriptor.failover()", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476381169", "createdAt": "2020-08-25T11:39:02Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {\n+    return (ScmBlockLocationProtocolPB) getProxy().proxy;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {\n+    if (!currentProxySCMNodeId.equals(newLeaderNodeId)) {\n+      if (scmProxies.containsKey(newLeaderNodeId)) {\n+        lastAttemptedLeader = currentProxySCMNodeId;\n+        currentProxySCMNodeId = newLeaderNodeId;\n+        currentProxyIndex = scmNodeIDList.indexOf(currentProxySCMNodeId);\n+        return true;\n+      }\n+    } else {\n+      lastAttemptedLeader = currentProxySCMNodeId;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates proxy object if it does not already exist.\n+   */\n+  private void createSCMProxyIfNeeded(ProxyInfo proxyInfo,\n+                                     String nodeId) {\n+    if (proxyInfo.proxy == null) {\n+      InetSocketAddress address = scmProxyInfoMap.get(nodeId).getAddress();\n+      try {\n+        ScmBlockLocationProtocolPB proxy = createSCMProxy(address);\n+        try {\n+          proxyInfo.proxy = proxy;\n+        } catch (IllegalAccessError iae) {\n+          scmProxies.put(nodeId,\n+              new ProxyInfo<>(proxy, proxyInfo.proxyInfo));\n+        }\n+      } catch (IOException ioe) {\n+        LOG.error(\"{} Failed to create RPC proxy to SCM at {}\",\n+            this.getClass().getSimpleName(), address, ioe);\n+        throw new RuntimeException(ioe);\n+      }\n+    }\n+  }\n+\n+  private ScmBlockLocationProtocolPB createSCMProxy(\n+      InetSocketAddress scmAddress) throws IOException {\n+    Configuration hadoopConf =\n+        LegacyHadoopConfigurationSource.asHadoopConfiguration(conf);\n+    RPC.setProtocolEngine(hadoopConf, ScmBlockLocationProtocol.class,\n+        ProtobufRpcEngine.class);\n+    return RPC.getProxy(ScmBlockLocationProtocolPB.class, scmVersion,\n+        scmAddress, UserGroupInformation.getCurrentUser(), hadoopConf,\n+        NetUtils.getDefaultSocketFactory(hadoopConf),\n+        (int)conf.getObject(SCMBlockClientConfig.class).getRpcTimeOut());\n+  }\n+\n+  public RetryPolicy getSCMBlockLocationRetryPolicy(\n+      String suggestedLeader) {\n+    RetryPolicy retryPolicy = new RetryPolicy() {\n+      @Override\n+      public RetryAction shouldRetry(Exception e, int retry,\n+                                     int failover, boolean b) {\n+        if (suggestedLeader == null) {\n+          performFailover(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 269}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Mjc5ODE2", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-475279816", "createdAt": "2020-08-26T08:45:38Z", "commit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0NTozOFrOHHCKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0NTozOFrOHHCKUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzNzQ5MQ==", "bodyText": "miss access modifier, such as public", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477137491", "createdAt": "2020-08-26T08:45:38Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  SCMProxyInfo(String serviceID, String nodeID, InetSocketAddress rpcAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MzQ0NzIx", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-475344721", "createdAt": "2020-08-26T10:09:22Z", "commit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDowOToyMlrOHHFUHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDowOToyMlrOHHFUHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4OTE1MQ==", "bodyText": "may be NPE ?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477189151", "createdAt": "2020-08-26T10:09:22Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1053,6 +1053,22 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    return scmHAManager.getSuggestedLeader().getAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/f811ed461002c3d4817dd9093d419182d4fa37ff", "committedDate": "2020-08-25T10:44:13Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "committedDate": "2020-08-26T10:41:09Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/875c46ddccfc3b9ad4f2d230fed1fc52374f94af", "committedDate": "2020-08-26T10:41:09Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "committedDate": "2020-08-27T03:02:46Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/aa1c4a6541f6e02f50eb4f03d0255ca1286bb085", "committedDate": "2020-08-27T03:02:46Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "committedDate": "2020-08-27T06:17:33Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/aff69a69a1ec0e710909d123ffb1ef7784bdb9a0", "committedDate": "2020-08-27T06:17:33Z", "message": "HDDS-3188 Enable SCM group with failover proxy for SCM block location."}, "afterCommit": {"oid": "684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "committedDate": "2020-08-27T06:22:15Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/684f8ff6e5b49d89a0ab3847c36d19d9ea733357", "committedDate": "2020-08-27T06:22:15Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}, "afterCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/046872462842863a56eafb28bfafbf5c130672bc", "committedDate": "2020-08-27T07:42:35Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTQ4MzY1", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-476548365", "createdAt": "2020-08-27T09:34:16Z", "commit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNDoxN1rOHIIRCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNDoxN1rOHIIRCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NjA4OA==", "bodyText": "no need to call nextProxyIndex().\nSince the real failover is done by performFailoverToAssignedLeader(), it is called by RetryPolicy.shouldRetry() and submitRequest()", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478286088", "createdAt": "2020-08-27T09:34:17Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        if (scmAddress.contains(\":\")) {\n+          resultList.add(NetUtils.createSocketAddr(scmAddress));\n+        } else {\n+          final int port = getPortNumberFromConfigKeys(conf,\n+              ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+              .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+          resultList.add(NetUtils.createSocketAddr(scmAddress + \":\" + port));\n+        }\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTQ5NjU5", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-476549659", "createdAt": "2020-08-27T09:36:01Z", "commit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNjowMlrOHIIVDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNjowMlrOHIIVDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NzExOA==", "bodyText": "I guess it will be a NPE ?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478287118", "createdAt": "2020-08-27T09:36:02Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1027,6 +1027,25 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    if (scmHAManager.getSuggestedLeader() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "committedDate": "2020-08-27T09:39:30Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/046872462842863a56eafb28bfafbf5c130672bc", "committedDate": "2020-08-27T07:42:35Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}, "afterCommit": {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "committedDate": "2020-08-27T09:39:30Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3cc7c6b70cf0ddd0e7d87b413632aab95186894a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/3cc7c6b70cf0ddd0e7d87b413632aab95186894a", "committedDate": "2020-08-31T06:06:42Z", "message": "Add close to scm client."}, "afterCommit": {"oid": "7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "committedDate": "2020-08-31T08:52:13Z", "message": "Add close to scm client."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "358362f377edf91ea941c5e3d88c87e3b6999671", "author": {"user": {"login": "GlenGeng", "name": "Glen Geng"}}, "url": "https://github.com/apache/ozone/commit/358362f377edf91ea941c5e3d88c87e3b6999671", "committedDate": "2020-08-31T09:29:35Z", "message": "HDDS-3188: Fix CI"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/7d4c2bdffa6ecbd05e06d99135d69bf6c92fdb28", "committedDate": "2020-08-31T08:52:13Z", "message": "Add close to scm client."}, "afterCommit": {"oid": "311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/311ac066cc5e6bbc899fa8d03f48aea9bd23455a", "committedDate": "2020-08-27T09:39:30Z", "message": "HDDS-3188 Add failover proxy for SCMBlockLocation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/0966949fb860e722d52f13518862736aed8f53e8", "committedDate": "2020-08-31T10:42:57Z", "message": "Merge pull request #7 from GlenGeng/HDDS-3188\n\nHDDS-3188: Fix CI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5Mzc4MTE3", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-479378117", "createdAt": "2020-09-01T03:37:49Z", "commit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzozNzo0OVrOHKcYgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzozNzo0OVrOHKcYgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcxMjgzNA==", "bodyText": "nit: might be useful to print which class current impl is.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480712834", "createdAt": "2020-09-01T03:37:49Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,33 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5Mzc5NTU4", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-479379558", "createdAt": "2020-09-01T03:43:25Z", "commit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzo0MzoyNlrOHKc10g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzo0MzoyNlrOHKc10g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcyMDMzOA==", "bodyText": "The default implementation of getTrimmedStringCollection seems does not validate the format of ip address in string: https://github.com/apache/hadoop-ozone/blob/34ee8311b0d0a37878fe1fd2e5d8c1b91aa8cc8f/hadoop-hdds/config/src/main/java/org/apache/hadoop/hdds/conf/ConfigurationSource.java#L99\nIs the format is already validated somewhere else? if not this implementation will be fragile.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480720338", "createdAt": "2020-09-01T03:43:26Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        int indexOfComma = scmAddress.lastIndexOf(\":\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/362e6f5446fd50f6521007ad9efd5b0ae44a234a", "committedDate": "2020-09-02T07:02:07Z", "message": "Add scm ip address validation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "630a245bd4a98a98c5e156d85f09340c14c8164c", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/630a245bd4a98a98c5e156d85f09340c14c8164c", "committedDate": "2020-09-02T03:01:56Z", "message": "Add scm ip address validation."}, "afterCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/362e6f5446fd50f6521007ad9efd5b0ae44a234a", "committedDate": "2020-09-02T07:02:07Z", "message": "Add scm ip address validation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzgyOTMy", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-484382932", "createdAt": "2020-09-08T18:14:08Z", "commit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODoxNDowOFrOHOopng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODozMjo1OFrOHOpQqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwODEyNg==", "bodyText": "conf#getObject is a heavy call, we can avoid calling it twice.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485108126", "createdAt": "2020-09-08T18:14:08Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDU1NQ==", "bodyText": "Can we avoid putting null proxy?\nWhile reading, instead of checking if proxyInfo.proxy == null, we can do proxyInfo#contains.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485114555", "createdAt": "2020-09-08T18:26:06Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjMzMA==", "bodyText": "What is the reason for not doing anything here?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485116330", "createdAt": "2020-09-08T18:29:31Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODEyMA==", "bodyText": "This can be made private.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485118120", "createdAt": "2020-09-08T18:32:58Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 219}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c064a09df200dea9753a84d5dbb80d0719713e6", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/5c064a09df200dea9753a84d5dbb80d0719713e6", "committedDate": "2020-09-11T02:26:47Z", "message": "Remove suggestedLeader."}, "afterCommit": {"oid": "402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "committedDate": "2020-09-11T03:35:00Z", "message": "Remove suggestedLeader."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "committedDate": "2020-09-14T07:30:05Z", "message": "Remove suggestedLeader."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/402f00f95b24f0b8ac53ee882cc4dbdbe5ccc1c9", "committedDate": "2020-09-11T03:35:00Z", "message": "Remove suggestedLeader."}, "afterCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/277efde99dc3f324ee7b760a99b8d608f0eb1a3f", "committedDate": "2020-09-14T07:30:05Z", "message": "Remove suggestedLeader."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE0MTIy", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492914122", "createdAt": "2020-09-21T19:25:16Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNToxN1rOHVfRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNToxN1rOHVfRIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDQzNA==", "bodyText": "should this configuration group prefix with hdds.scmclient to match with the package name?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294434", "createdAt": "2020-09-21T19:25:17Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE0NDY0", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492914464", "createdAt": "2020-09-21T19:25:46Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNTo0NlrOHVfSKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNTo0NlrOHVfSKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDY5Ng==", "bodyText": "OzoneManager=>StorageContainerManger", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294696", "createdAt": "2020-09-21T19:25:46Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE1Mjc2", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492915276", "createdAt": "2020-09-21T19:26:59Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNjo1OVrOHVfUjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNjo1OVrOHVfUjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ==", "bodyText": "OzoneManager=>StorageContainerManger", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492295311", "createdAt": "2020-09-21T19:26:59Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +\n+          \"If ipc.client.ping is set to true and this rpc-timeout \" +\n+          \"is greater than the value of ipc.ping.interval, the effective \" +\n+          \"value of the rpc-timeout is rounded up to multiple of \" +\n+          \"ipc.ping.interval.\"\n+  )\n+  private long rpcTimeOut = 15 * 60 * 1000;\n+\n+  @Config(key = SCM_CLIENT_FAILOVER_MAX_RETRY,\n+      defaultValue = \"15\",\n+      type = ConfigType.INT,\n+      tags = {OZONE, SCM, CLIENT},\n+      description = \"Max retry count for SCM Client when failover happens.\"\n+  )\n+  private int retryCount = 15;\n+\n+  @Config(key = SCM_CLIENT_RETRY_INTERVAL,\n+      defaultValue = \"2s\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE2OTM2", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492916936", "createdAt": "2020-09-21T19:29:26Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOToyNlrOHVfZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOToyNlrOHVfZhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjU4MQ==", "bodyText": "missing getter for nodeid and serviceid?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492296581", "createdAt": "2020-09-21T19:29:26Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  public SCMProxyInfo(String serviceID, String nodeID,\n+                      InetSocketAddress rpcAddress) {\n+    Preconditions.checkNotNull(rpcAddress);\n+    this.serviceId = serviceID;\n+    this.nodeId = nodeID;\n+    this.rpcAddrStr = rpcAddress.toString();\n+    this.rpcAddr = rpcAddress;\n+    if (rpcAddr.isUnresolved()) {\n+      LOG.warn(\"SCM address {} for serviceID {} remains unresolved \" +\n+              \"for node ID {} Check your ozone-site.xml file to ensure scm \" +\n+              \"addresses are configured properly.\",\n+          rpcAddress, serviceId, nodeId);\n+    }\n+  }\n+\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(\"nodeId=\")\n+        .append(nodeId)\n+        .append(\",nodeAddress=\")\n+        .append(rpcAddrStr).toString();\n+  }\n+\n+  public InetSocketAddress getAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE4ODk4", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492918898", "createdAt": "2020-09-21T19:32:26Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMjoyNlrOHVffpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMjoyNlrOHVffpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODE0OA==", "bodyText": "Should we send back the leader known by this SCM follower instead of null to avoid unnecessary client retry?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492298148", "createdAt": "2020-09-21T19:32:26Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,26 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");\n+    } else {\n+      return ((SCMBlockProtocolServer) impl).getScm().checkLeader();\n+    }\n+  }\n+\n   @Override\n   public SCMBlockLocationResponse send(RpcController controller,\n       SCMBlockLocationRequest request) throws ServiceException {\n+    if (!isLeader()) {\n+      SCMBlockLocationResponse.Builder response = createSCMBlockResponse(\n+          request.getCmdType(),\n+          request.getTraceID());\n+      response.setSuccess(false);\n+      response.setStatus(Status.SCM_NOT_LEADER);\n+      response.setLeaderSCMNodeId(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTE5NzIz", "url": "https://github.com/apache/ozone/pull/1340#pullrequestreview-492919723", "createdAt": "2020-09-21T19:33:45Z", "commit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d143b79028da2c380e806d4e478843fdd722c94a", "author": {"user": {"login": "timmylicheng", "name": "Li Cheng"}}, "url": "https://github.com/apache/ozone/commit/d143b79028da2c380e806d4e478843fdd722c94a", "committedDate": "2020-09-27T06:54:02Z", "message": "Address commnets."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2753, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}