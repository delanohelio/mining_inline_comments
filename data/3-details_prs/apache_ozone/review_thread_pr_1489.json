{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyMDY5NjQ2", "number": 1489, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNDo0MDoxNVrOEyYwPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowOTo0MFrOE8gA9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjY5ODIwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNDo0MDoxNVrOHo_xfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyNjo1N1rOHpjYuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA==", "bodyText": "I don't prefer to add new methods here, this makes current PR not clear to understand.\n@captainzmc , can you make the minor adjustment for getVolumeInfo as I suggested in JIRA HDDS-4308. After this, we can make few lines change I think.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r512749950", "createdAt": "2020-10-27T14:40:15Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MDYyOA==", "bodyText": "Thanks for @linyiqun's review.\nModifying getVolumeInfo to synchronized and get copyObject would not suffice. There is only one instance of volumeArgs in memory, and we need to update volumeArgs atomic after getVolumeInfo. Then get the value of the copyObject.\nSo, I made a modification based on your suggestion, added update volumeArgs's usedBytes to the getVolumeInfo method.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513140628", "createdAt": "2020-10-28T02:22:42Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2OTIyOQ==", "bodyText": "I have not understood one part, how without volume lock this will help here.\nBecause other threads can be updating volumeArgs when this update is happening/ other threads read omVolumeArgs.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513169229", "createdAt": "2020-10-28T04:10:34Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2OTc5Mw==", "bodyText": "Do we need LongAdder still?", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513169793", "createdAt": "2020-10-28T04:12:36Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxNjU4NQ==", "bodyText": "I have not understood one part, how without volume lock this will help here.\nBecause other threads can be updating volumeArgs when this update is happening/ other threads read omVolumeArgs.\n\nThank for @bharatviswa504's  feedback. This is a possible case. Can lead to update usageBytes inaccurate.\nSuppose that ThreadA update VolumeArgs using OMVolumeSetOwnerRequest, it gets VolumeArgs from DB if usageBytes is 1000 at this point. When ThreadB writes the new key using OMKeyCreateRequest, he changes usageBytes to 1100.\nThere is no Volume lock at this point, so ThreadB may finish executing first and ThreadA last. The Final usageBytes for VolumeArgs would be 1000. This should be a problem.\nMaybe we still can't avoid using Volume lock. hi @linyiqun Any suggestions here?", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513216585", "createdAt": "2020-10-28T06:58:32Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxOTM1OA==", "bodyText": "Do we need LongAdder still?\n\nLongAdder will no longer be necessary if there are no concurrent updates to usedBytes.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513219358", "createdAt": "2020-10-28T07:05:59Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMzQzNQ==", "bodyText": "Thank for @bharatviswa504's feedback. This is a possible case. Can lead to update usageBytes inaccurate.\nSuppose that ThreadA update VolumeArgs using OMVolumeSetOwnerRequest, it gets VolumeArgs from DB if usageBytes is 1000 at this point. When ThreadB writes the new key using OMKeyCreateRequest, he changes usageBytes to 1100.\n\nGood catch, @captainzmc . Seems we still need to use volume lock to help us do the volume quota update control. We should acquire volume lock before get volume info (copy volume info) and release volume lock after add the OMClientResponse into double buffer cache.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513333435", "createdAt": "2020-10-28T10:26:57Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, "originalCommit": {"oid": "2614eeb893dc9c406764824aba73faafd56d4ded"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzcxMjU3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDozMTo0NFrOHrRq9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDozMTo0NFrOHrRq9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MDM0MQ==", "bodyText": "Method name setUsedBytes seems confused, can we rename to incrUsedBytes(long bytes)", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515140341", "createdAt": "2020-10-30T14:31:44Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java", "diffHunk": "@@ -177,10 +176,14 @@ public OmOzoneAclMap getAclMap() {\n     return aclMap;\n   }\n \n-  public LongAdder getUsedBytes() {\n+  public long getUsedBytes() {\n     return usedBytes;\n   }\n \n+  public void setUsedBytes(long usedBytes) {\n+    this.usedBytes = this.usedBytes + usedBytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc8e50f63315ce8e915e1861309ab6766fe8004"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzczMzQ3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDozNjo1MlrOHrR31g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDozNjo1MlrOHrR31g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MzYzOA==", "bodyText": "We should not release volume lock until add omClientResponse into double buffer. So that we can make sure stale OmVolumeArgs in other OM request won't be earlier processed than this request. Here we should ensure that the OmVolumeArgs is updated in order.\nI prefer to add volume lock for the whole method. The same comment for other OM Request classes.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515143638", "createdAt": "2020-10-30T14:36:52Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -300,8 +302,26 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           trxnLogIndex);\n \n       // update usedBytes atomically.\n-      omVolumeArgs.getUsedBytes().add(preAllocatedSpace);\n       omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }\n+\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n+      omVolumeArgs.setUsedBytes(preAllocatedSpace);\n+      OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n+      if (acquireVolumeLock) {\n+        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n+        acquireVolumeLock = false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc8e50f63315ce8e915e1861309ab6766fe8004"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzc4Mjc1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo0ODo0MFrOHrSW2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo0ODo0MFrOHrSW2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1MTU3OA==", "bodyText": "The similar concurrent update issue for bucket usedBytes will happens if we release bucket lock here and then try to acquire bucket lock again.\nAs mentioned above, we should both lock the volume and bucket lock for the whole method.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515151578", "createdAt": "2020-10-30T14:48:40Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -300,8 +302,26 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           trxnLogIndex);\n \n       // update usedBytes atomically.\n-      omVolumeArgs.getUsedBytes().add(preAllocatedSpace);\n       omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc8e50f63315ce8e915e1861309ab6766fe8004"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzgxODY0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo1Mzo1N1rOHrSu6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDo1Mzo1N1rOHrSu6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1NzczOQ==", "bodyText": "We should also update below lines to use copyVolumeArgs,  copyBucketInfo.\n    } catch (IOException ex) {\n      result = Result.FAILURE;\n      exception = ex;\n      omClientResponse = new S3MultipartUploadCommitPartResponse(\n          createErrorOMResponse(omResponse, exception), multipartKey, openKey,\n          multipartKeyInfo, oldPartKeyInfo, omKeyInfo,\n          ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n    } finally {\n    ...\n    }", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515157739", "createdAt": "2020-10-30T14:53:57Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java", "diffHunk": "@@ -222,16 +218,34 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // be subtracted.\n       long correctedSpace = omKeyInfo.getDataSize() * factor -\n           keyArgs.getKeyLocationsList().size() * scmBlockSize * factor;\n-      omVolumeArgs.getUsedBytes().add(correctedSpace);\n       omBucketInfo.getUsedBytes().add(correctedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }\n+\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n+      omVolumeArgs.setUsedBytes(correctedSpace);\n+      OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n+      if (acquireVolumeLock) {\n+        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n+        acquireVolumeLock = false;\n+      }\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n \n       omResponse.setCommitMultiPartUploadResponse(\n           MultipartCommitUploadPartResponse.newBuilder()\n               .setPartName(partName));\n       omClientResponse = new S3MultipartUploadCommitPartResponse(\n           omResponse.build(), multipartKey, openKey,\n           multipartKeyInfo, oldPartKeyInfo, omKeyInfo,\n-          ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n+          ozoneManager.isRatisEnabled(), copyVolumeArgs, copyBucketInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc8e50f63315ce8e915e1861309ab6766fe8004"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMzM2Mzg5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMjozMDoyOFrOHsCZPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMzozNzoyNVrOHsEp_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODYyMA==", "bodyText": "The similar concurrent update issue for bucket usedBytes will happens if we release bucket lock here and then try to acquire bucket lock again.\nAs mentioned above, we should both lock the volume and bucket lock for the whole method.\n\n@captainzmc , can you address above comment, bucket lock is also needed since we also do the bucket used bytes update. Can you update this in all below places?\nOther change looks good to me.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515938620", "createdAt": "2020-11-02T12:30:28Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,8 +206,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3c5ba2e990603f66d3c737dcead759e8d5952a8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk3NTY3OQ==", "bodyText": "Thanks  for @linyiqun's feedback. A new commit has been committed to fix this.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515975679", "createdAt": "2020-11-02T13:37:25Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,8 +206,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODYyMA=="}, "originalCommit": {"oid": "a3c5ba2e990603f66d3c737dcead759e8d5952a8"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDI3OTE2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoxMDo1OVrOHsLJhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoxNToyNlrOHshT3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MjA1Mg==", "bodyText": "Nit: Can we rename all variable name of acquiredLock to acquireBucketLock in current PR change?", "url": "https://github.com/apache/ozone/pull/1489#discussion_r516082052", "createdAt": "2020-11-02T16:10:59Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,6 +208,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "325930137c02a41064a5d1f561477a8aa0052017"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTE1MQ==", "bodyText": "Thanks @linyiqun.  Changed this with new commit.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r516445151", "createdAt": "2020-11-03T06:15:26Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,6 +208,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MjA1Mg=="}, "originalCommit": {"oid": "325930137c02a41064a5d1f561477a8aa0052017"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODczMjYzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowMjozOVrOH4qAIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowMjozOVrOH4qAIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MDQ2NQ==", "bodyText": "we do not need this comment any more.", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529170465", "createdAt": "2020-11-24T03:02:39Z", "author": {"login": "runzhiwang"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -171,15 +171,15 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n         quotaReleased += sumBlockLengths(omKeyInfo);\n       }\n       // update usedBytes atomically.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4428bfc07d20e351a23b936d48042201f1ea31c"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODczNTY0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowNDoyOVrOH4qCRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowNDoyOVrOH4qCRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MTAxNA==", "bodyText": "this.usedBytes += bytes;", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529171014", "createdAt": "2020-11-24T03:04:29Z", "author": {"login": "runzhiwang"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java", "diffHunk": "@@ -241,9 +240,14 @@ public String getSourceBucket() {\n   }\n \n \n-  public LongAdder getUsedBytes() {\n+  public long getUsedBytes() {\n     return usedBytes;\n   }\n+\n+  public void incrUsedBytes(long bytes) {\n+    this.usedBytes = this.usedBytes + bytes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4428bfc07d20e351a23b936d48042201f1ea31c"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODc0MzQ1OnYy", "diffSide": "LEFT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyCommitRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowODo0M1rOH4qHSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowODo0M1rOH4qHSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MjI5Nw==", "bodyText": "revert this line", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529172297", "createdAt": "2020-11-24T03:08:43Z", "author": {"login": "runzhiwang"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyCommitRequest.java", "diffHunk": "@@ -167,7 +167,6 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n         }\n       }\n \n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4428bfc07d20e351a23b936d48042201f1ea31c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODc0NTQ4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowOTo0MFrOH4qIjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowOTo0MFrOH4qIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MjYyMA==", "bodyText": "copyBucketInfo -> omBucketInfo.copyObject()", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529172620", "createdAt": "2020-11-24T03:09:40Z", "author": {"login": "runzhiwang"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -158,7 +158,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n \n       omClientResponse = new OMKeyDeleteResponse(omResponse\n           .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n-          omKeyInfo, ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n+          omKeyInfo, ozoneManager.isRatisEnabled(), omVolumeArgs,\n+          copyBucketInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4428bfc07d20e351a23b936d48042201f1ea31c"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4777, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}