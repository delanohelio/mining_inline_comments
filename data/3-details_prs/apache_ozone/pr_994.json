{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MjAwNDc4", "number": 994, "title": "HDDS-3082. Refactor recon missing containers task to detect under, over and mis-replicated containers.", "bodyText": "What changes were proposed in this pull request?\nThe current Recon \"Missing Containers Task\" only highlights missing containers in the cluster.\nIt is desired for it to also detect under, over and mis-replicated containers.\nIn order to do that, the existing database table MISSING_CONTAINERS has been renamed to UNHEALTHY_CONTAINERS, with the definition:\ncontainer_id bigint NOT NULL,\ncontainer_state varchar(16) NOT NULL,\nin_state_since bigint not null,\nexpected_replica_count integer,\nactual_replica_count integer,\nreplica_delta integer not null,\nreason varchar(500)\n\nThe container state can be MISSING, UNDER_REPLICATED, OVER_REPLICATED or MIS_REPLICATED.\nA design decision was made so that if a container is MISSING, then it is not in any of the other states.\nHowever, it can be both under and mis-replicated or in theory over and mis-replicated at the same time and this would result in two rows in the database for a single container.\nEach time the \"Container Health task\" runs, it scans all the existing records, updates any counts and removes any records that are no longer valid.\nThen it processes all other containers without any records in the unhealthy_containters table.\nThe reason the job is split into two parts, is to avoid the need to query the database for every single container on each run.\nThis change only adjusts the job and the backend storage. An additional change is needed to change the rest endpoints to expose the new container states to the users and UI.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-3082\nHow was this patch tested?\nNew and existing unit tests", "createdAt": "2020-05-29T16:24:15Z", "url": "https://github.com/apache/ozone/pull/994", "merged": true, "mergeCommit": {"oid": "ac64ab6bd60c81e1f6086c673c9d0e01c3314647"}, "closed": true, "closedAt": "2020-06-04T09:37:12Z", "author": {"login": "sodonnel"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmE2LUAH2gAyNDI1MjAwNDc4OmE0YTI2Njg5NzVhNjNmMGU4YTcxZGJmN2QyNTdlZjUyMjc0ZjczZTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnZOjVgH2gAyNDI1MjAwNDc4OmQ5ZDdlOWU2MjA4YmM1YzVjODQwNzVmOWU2YmQzYzI3Y2JhYWIxMGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a4a2668975a63f0e8a71dbf7d257ef52274f73e8", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/a4a2668975a63f0e8a71dbf7d257ef52274f73e8", "committedDate": "2020-05-29T16:14:00Z", "message": "Implement new ContainerHealthTask"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "committedDate": "2020-05-29T16:32:47Z", "message": "Fix style issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjIxNTI0", "url": "https://github.com/apache/ozone/pull/994#pullrequestreview-421221524", "createdAt": "2020-05-29T19:19:12Z", "commit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOToxOToxMlrOGcpFyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozOTo0M1rOGcprGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjUzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds to\" +", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686537", "createdAt": "2020-05-29T19:19:12Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjczOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds for\" +", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686738", "createdAt": "2020-05-29T19:19:43Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTgxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Container not found while finding missing containers\", e);\n          \n          \n            \n                  LOG.error(\"Container not found while processing container in Container Health task\", e);", "url": "https://github.com/apache/ozone/pull/994#discussion_r432689814", "createdAt": "2020-05-29T19:26:57Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjM0Nw==", "bodyText": "Can you please add JavaDoc for this method?", "url": "https://github.com/apache/ozone/pull/994#discussion_r432692347", "createdAt": "2020-05-29T19:32:48Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzQwMQ==", "bodyText": "Please fix the dangling statement", "url": "https://github.com/apache/ozone/pull/994#discussion_r432693401", "createdAt": "2020-05-29T19:35:19Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.UNDER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.UNDER_REPLICATED, time));\n+      }\n+\n+      if (container.isOverReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.OVER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.OVER_REPLICATED, time));\n+      }\n+\n+      if (container.isMisReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MIS_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.MIS_REPLICATED, time));\n+      }\n+      return records;\n+    }\n+\n+    static private UnhealthyContainers recordForState(\n+        ContainerHealthStatus container, UnHealthyContainerStates state,\n+        long time) {\n+      UnhealthyContainers rec = new UnhealthyContainers();\n+      rec.setContainerId(container.getContainerID());\n+      if (state == UnHealthyContainerStates.MIS_REPLICATED) {\n+        rec.setExpectedReplicaCount(container.expectedPlacementCount());\n+        rec.setActualReplicaCount(container.actualPlacementCount());\n+        rec.setReplicaDelta(container.misReplicatedDelta());\n+        rec.setReason(container.misReplicatedReason());\n+      } else {\n+        rec.setExpectedReplicaCount(container.getReplicationFactor());\n+        rec.setActualReplicaCount(container.getReplicaCount());\n+        rec.setReplicaDelta(container.replicaDelta());\n+      }\n+      rec.setContainerState(state.toString());\n+      rec.setInStateSince(time);\n+      return rec;\n+    }\n+\n+    static private boolean keepOverReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isOverReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepUnderReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isUnderReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepMisReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isMisReplicated()) {\n+        updateExpectedReplicaCount(rec, container.expectedPlacementCount());\n+        updateActualReplicaCount(rec, container.actualPlacementCount());\n+        updateReplicaDelta(rec, container.misReplicatedDelta());\n+        updateReason(rec, container.misReplicatedReason());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * With a Jooq record, if you update any field in the record, the record\n+     * is marked as changed, even if you updated it to the same value as it is\n+     * already set to. We only need to run a DB update statement if the record\n+     * has really changed. The methods below ensure we do not update the Jooq\n+     * record unless the values have changed and hence save a DB execution\n+     * when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTExNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Test to ensure the correct container state is return by a\n          \n          \n            \n             * ContainerHealthyStatus instance.\n          \n          \n            \n             * Test to ensure the correct container state is returned by a\n          \n          \n            \n             * ContainerHealthStatus instance.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432695115", "createdAt": "2020-05-29T19:38:22Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthStatus.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test to ensure the correct container state is return by a\n+ * ContainerHealthyStatus instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NjA5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Class to test single run of Missing Container Task.\n          \n          \n            \n             * Class to test single run of Container Health Task.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432696090", "createdAt": "2020-05-29T19:39:43Z", "author": {"login": "vivekratnavel"}, "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto.State;\n+import org.apache.hadoop.hdds.scm.ContainerPlacementStatus;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconStorageContainerManagerFacade;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition;\n+import org.hadoop.ozone.recon.schema.tables.daos.ContainerHistoryDao;\n+import org.apache.hadoop.ozone.recon.persistence.AbstractReconSqlDBTest;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.daos.UnhealthyContainersDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.ReconTaskStatus;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test single run of Missing Container Task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzQ5OTgx", "url": "https://github.com/apache/ozone/pull/994#pullrequestreview-421349981", "createdAt": "2020-05-29T23:39:56Z", "commit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMzozOTo1NlrOGcvABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMDo0ODoyNFrOGcvoCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzM2NQ==", "bodyText": "Nit. It would be good to add Javadoc for this method since it is doing some complex operations.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432783365", "createdAt": "2020-05-29T23:39:56Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTE3Mw==", "bodyText": "Can add .filter(c -> !processedContainers.contains(c)) here instead of adding a check inside the processContainer method.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785173", "createdAt": "2020-05-29T23:49:40Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTk5OA==", "bodyText": "I am wondering why this check is not written like\nif (currentContainer != null && currentContainer.getContainerID() != rec.getContainerId()) {\nIn Line #145, we can remove the 'currentContainer = null'.", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785998", "createdAt": "2020-05-29T23:53:51Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ==", "bodyText": "Can we add an 'else' after the isMissing() check? A missing container cannot be in any other state right?", "url": "https://github.com/apache/ozone/pull/994#discussion_r432793609", "createdAt": "2020-05-30T00:48:24Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1473d03d7d47e40a6189e980cbdc937bc1a08d90", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/1473d03d7d47e40a6189e980cbdc937bc1a08d90", "committedDate": "2020-06-01T12:06:47Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20bffd9330dadc8824c6402ea08ab7d712c2e4f0", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/20bffd9330dadc8824c6402ea08ab7d712c2e4f0", "committedDate": "2020-06-01T13:26:01Z", "message": "Trigger CI checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c52fd149762852aa54513330c3c9742e6658c4f", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/1c52fd149762852aa54513330c3c9742e6658c4f", "committedDate": "2020-06-01T15:11:41Z", "message": "Trigger CI checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9d7e9e6208bc5c5c84075f9e6bd3c27cbaab10a", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/d9d7e9e6208bc5c5c84075f9e6bd3c27cbaab10a", "committedDate": "2020-06-02T18:32:39Z", "message": "Refactor code to avoid passing null containers"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3115, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}