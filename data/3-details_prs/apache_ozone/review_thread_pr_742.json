{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NTU5MzM3", "number": 742, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzoxNDo0N1rOD6B34g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTo1OToyOFrOD6b6fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTc0NjkwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzoxNDo0N1rOGRosvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxODoxMDoyMlrOGSKW5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NTc5MA==", "bodyText": "updateDeleteTransactionId() updates the deleteTransactionId only if it more than the current deleteTransactionId. This check is not done before updating the DB. This could lead to different states in DB and in memory, right? I am not sure when it could be possible that new deleteTransactionId is less than the current one.\nWe could probably combine containerData.updateDeleteTransactionId and containerData.incrPendingDeletionBlocks with the batch put operation by making these functions return the updated values.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421145790", "createdAt": "2020-05-06T23:14:47Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "diffHunk": "@@ -251,12 +253,23 @@ private void deleteKeyValueContainerBlocks(\n         }\n       }\n \n-      containerDB.getStore()\n-          .put(DFSUtil.string2Bytes(OzoneConsts.DELETE_TRANSACTION_KEY_PREFIX),\n-              Longs.toByteArray(delTX.getTxID()));\n-      containerData\n-          .updateDeleteTransactionId(delTX.getTxID());\n-      // update pending deletion blocks count in in-memory container status\n+      // Finally commit the DB counters.\n+      BatchOperation batchOperation = new BatchOperation();\n+\n+      // Update in DB pending delete key count and delete transaction ID.\n+      batchOperation.put(DB_CONTAINER_DELETE_TRANSACTION_KEY,\n+          Longs.toByteArray(delTX.getTxID()));\n+\n+      batchOperation.put(DB_PENDING_DELETE_BLOCK_COUNT_KEY, Longs.toByteArray(\n+          containerData.getNumPendingDeletionBlocks() + newDeletionBlocks));\n+\n+      containerDB.getStore().writeBatch(batchOperation);\n+\n+\n+      // update pending deletion blocks count and delete transaction ID in\n+      // in-memory container status\n+      containerData.updateDeleteTransactionId(delTX.getTxID());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5NzI1NA==", "bodyText": "Good catch. Added code to update DB only when delete TxID > current Tx ID", "url": "https://github.com/apache/ozone/pull/742#discussion_r421697254", "createdAt": "2020-05-07T18:10:22Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "diffHunk": "@@ -251,12 +253,23 @@ private void deleteKeyValueContainerBlocks(\n         }\n       }\n \n-      containerDB.getStore()\n-          .put(DFSUtil.string2Bytes(OzoneConsts.DELETE_TRANSACTION_KEY_PREFIX),\n-              Longs.toByteArray(delTX.getTxID()));\n-      containerData\n-          .updateDeleteTransactionId(delTX.getTxID());\n-      // update pending deletion blocks count in in-memory container status\n+      // Finally commit the DB counters.\n+      BatchOperation batchOperation = new BatchOperation();\n+\n+      // Update in DB pending delete key count and delete transaction ID.\n+      batchOperation.put(DB_CONTAINER_DELETE_TRANSACTION_KEY,\n+          Longs.toByteArray(delTX.getTxID()));\n+\n+      batchOperation.put(DB_PENDING_DELETE_BLOCK_COUNT_KEY, Longs.toByteArray(\n+          containerData.getNumPendingDeletionBlocks() + newDeletionBlocks));\n+\n+      containerDB.getStore().writeBatch(batchOperation);\n+\n+\n+      // update pending deletion blocks count and delete transaction ID in\n+      // in-memory container status\n+      containerData.updateDeleteTransactionId(delTX.getTxID());\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE0NTc5MA=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTc5Nzg0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzozODoxN1rOGRpKQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNzo1OToxNVrOGSJ8lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzM0NQ==", "bodyText": "Just a NIT - We can optimize the code by using blockIter.hasNext() as the while condition check instead of instantiating another variable.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421153345", "createdAt": "2020-05-06T23:38:17Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5MDUxOQ==", "bodyText": "This is done like this because hasNext will return StorageContainerException when unable to parse block data. So, that we will not bail out and still continue the iteration.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421690519", "createdAt": "2020-05-07T17:59:15Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzM0NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTgxMjAyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzo0NDo1OVrOGRpSkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzoxOToyMlrOGSTj_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ==", "bodyText": "If there was an error in parsing the block data, we might end up updating incorrect values for usedBytes and blockCount. Previously, we would fail to parse that container and not add it to containerSet. With this change, we would add wrongly parsed containers also to containerSet.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421155475", "createdAt": "2020-05-06T23:44:59Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5MzMxMQ==", "bodyText": "Previously also we used to do this. Slightly modified the code. And I think for one block corruption, if we don't add it to container set, then BackGround Container Scanner will never know about this container, and it will never be fixed. So, I think adding to container set is right thing to do here. Let me know your thoughts?\n     bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n        BlockData blockData;\n        try {\n          blockData = BlockUtils.getBlockData(e.getValue());\n          return blockData.getSize();\n        } catch (IOException ex) {\n          return 0L;\n        }\n      }).sum();", "url": "https://github.com/apache/ozone/pull/742#discussion_r421693311", "createdAt": "2020-05-07T18:03:51Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzY3Mg==", "bodyText": "I see that previously initializeUsedBytes() was done only for OPEN containers. And for others, we would just get the BlockData and update usedBytes.\nWhat I mean to say is that the behavior has changed with this patch. I might have missed some background here. Can you please explain why the change.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421837672", "createdAt": "2020-05-07T22:47:58Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MDU0Mw==", "bodyText": "Previously we used to compute twice, one using the  logic above and for open containers using different logic which is initializeUsedBytes. Now we are doing only once by using initializeUsedBytesAndBlockCount logic.\nSo, previously if a container is open, we used to compute bytesUsed twice and now with this only once, and for all containers computing using initializeUsedBytesAndBlockCount. And reason for not using the above logic is we get all blockData to in-memory at once and compute it. Now with current logic using iterators and computing size block by block.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421840543", "createdAt": "2020-05-07T22:56:34Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MjQ5Mw==", "bodyText": "And also at the end, even new logic which is using iterator finally uses BlockUtils.getBlockData to getNext Block. I feel the current way (PR proposed) of iterating and computing the size is cleaner way, instead of getting all blocks into in-memory at once.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421842493", "createdAt": "2020-05-07T23:02:26Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0ODA2MA==", "bodyText": "Thanks for the explanation Bharat. Makes sense.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421848060", "createdAt": "2020-05-07T23:19:22Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/helpers/KeyValueContainerUtil.java", "diffHunk": "@@ -150,29 +160,109 @@ public static void parseKVContainerData(KeyValueContainerData kvContainerData,\n     }\n     kvContainerData.setDbFile(dbFile);\n \n-    try(ReferenceCountedDB metadata =\n-            BlockUtils.getDB(kvContainerData, config)) {\n-      long bytesUsed = 0;\n-      List<Map.Entry<byte[], byte[]>> liveKeys = metadata.getStore()\n-          .getRangeKVs(null, Integer.MAX_VALUE,\n-              MetadataKeyFilters.getNormalKeyFilter());\n \n-      bytesUsed = liveKeys.parallelStream().mapToLong(e-> {\n-        BlockData blockData;\n+    boolean isBlockMetadataSet = false;\n+\n+    try(ReferenceCountedDB containerDB = BlockUtils.getDB(kvContainerData,\n+        config)) {\n+\n+      // Set pending deleted block count.\n+      byte[] pendingDeleteBlockCount =\n+          containerDB.getStore().get(DB_PENDING_DELETE_BLOCK_COUNT_KEY);\n+      if (pendingDeleteBlockCount != null) {\n+        kvContainerData.incrPendingDeletionBlocks(\n+            Ints.fromByteArray(pendingDeleteBlockCount));\n+      } else {\n+        // Set pending deleted block count.\n+        MetadataKeyFilters.KeyPrefixFilter filter =\n+            new MetadataKeyFilters.KeyPrefixFilter()\n+                .addFilter(OzoneConsts.DELETING_KEY_PREFIX);\n+        int numPendingDeletionBlocks =\n+            containerDB.getStore().getSequentialRangeKVs(null,\n+                Integer.MAX_VALUE, filter)\n+                .size();\n+        kvContainerData.incrPendingDeletionBlocks(numPendingDeletionBlocks);\n+      }\n+\n+      // Set delete transaction id.\n+      byte[] delTxnId =\n+          containerDB.getStore().get(DB_CONTAINER_DELETE_TRANSACTION_KEY);\n+      if (delTxnId != null) {\n+        kvContainerData\n+            .updateDeleteTransactionId(Longs.fromByteArray(delTxnId));\n+      }\n+\n+      // Set BlockCommitSequenceId.\n+      byte[] bcsId = containerDB.getStore().get(\n+          DB_BLOCK_COMMIT_SEQUENCE_ID_KEY);\n+      if (bcsId != null) {\n+        kvContainerData\n+            .updateBlockCommitSequenceId(Longs.fromByteArray(bcsId));\n+      }\n+\n+      // Set bytes used.\n+      // commitSpace for Open Containers relies on usedBytes\n+      byte[] bytesUsed =\n+          containerDB.getStore().get(DB_CONTAINER_BYTES_USED_KEY);\n+      if (bytesUsed != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setBytesUsed(Longs.fromByteArray(bytesUsed));\n+      }\n+\n+      // Set block count.\n+      byte[] blockCount = containerDB.getStore().get(DB_BLOCK_COUNT_KEY);\n+      if (blockCount != null) {\n+        isBlockMetadataSet = true;\n+        kvContainerData.setKeyCount(Longs.fromByteArray(blockCount));\n+      }\n+    }\n+\n+    if (!isBlockMetadataSet) {\n+      initializeUsedBytesAndBlockCount(kvContainerData);\n+    }\n+  }\n+\n+\n+  /**\n+   * Initialize bytes used and block count.\n+   * @param kvContainerData\n+   * @throws IOException\n+   */\n+  private static void initializeUsedBytesAndBlockCount(\n+      KeyValueContainerData kvContainerData) throws IOException {\n+\n+    long blockCount = 0;\n+    try (KeyValueBlockIterator blockIter = new KeyValueBlockIterator(\n+        kvContainerData.getContainerID(),\n+        new File(kvContainerData.getContainerPath()))) {\n+      long usedBytes = 0;\n+\n+\n+      boolean success = true;\n+      while (success) {\n         try {\n-          blockData = BlockUtils.getBlockData(e.getValue());\n-          return blockData.getSize();\n+          if (blockIter.hasNext()) {\n+            BlockData block = blockIter.nextBlock();\n+            long blockLen = 0;\n+\n+            List< ContainerProtos.ChunkInfo > chunkInfoList = block.getChunks();\n+            for (ContainerProtos.ChunkInfo chunk : chunkInfoList) {\n+              ChunkInfo info = ChunkInfo.getFromProtoBuf(chunk);\n+              blockLen += info.getLen();\n+            }\n+\n+            usedBytes += blockLen;\n+            blockCount++;\n+          } else {\n+            success = false;\n+          }\n         } catch (IOException ex) {\n-          return 0L;\n+          LOG.error(\"Failed to parse block data for Container {}\",\n+              kvContainerData.getContainerID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1NTQ3NQ=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMTgzOTIyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/impl/BlockManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMzo1ODowMVrOGRpibQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxODowODo0M1rOGSKSmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1OTUzMw==", "bodyText": "There are two places where blocks are deleted - BlockManagerImpl#deleteBlock and BlockDeletingService.\nI am trying to understand when which is used.\nWhen is BlockManagerImpl#deleteBlock called? Is it always called after the chunk is deleted? Otherwise there would not be any change in bytesUsed.", "url": "https://github.com/apache/ozone/pull/742#discussion_r421159533", "createdAt": "2020-05-06T23:58:01Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/impl/BlockManagerImpl.java", "diffHunk": "@@ -224,11 +239,20 @@ public void deleteBlock(Container container, BlockID blockID) throws\n       // are not atomic. Leaving it here since the impact is refusing\n       // to delete a Block which might have just gotten inserted after\n       // the get check.\n-      byte[] kKey = Longs.toByteArray(blockID.getLocalID());\n+      byte[] blockKey = Longs.toByteArray(blockID.getLocalID());\n \n       getBlockByID(db, blockID);\n-      db.getStore().delete(kKey);\n-      // Decrement blockcount here\n+\n+      // Update DB to delete block and set block count and bytes used.\n+      BatchOperation batch = new BatchOperation();\n+      batch.delete(blockKey);\n+      batch.put(DB_CONTAINER_BYTES_USED_KEY,\n+          Longs.toByteArray(container.getContainerData().getBytesUsed()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5NjE1NQ==", "bodyText": "Right now deleteBlock in BlockManagerImpl is not used, BlockDeletingService delete Chunks and then delete the blocks which are marked for deleted from container DB.\nAnd also updating bytes used is not correct here, so only updated block count here. As anyway bytes used is taken care during delete chunk.\n\n        // Once files are deleted... replace deleting entries with deleted\n        // entries\n        BatchOperation batch = new BatchOperation();\n        succeedBlocks.forEach(entry -> {\n          String blockId =\n              entry.substring(OzoneConsts.DELETING_KEY_PREFIX.length());\n          String deletedEntry = OzoneConsts.DELETED_KEY_PREFIX + blockId;\n          batch.put(DFSUtil.string2Bytes(deletedEntry),\n              DFSUtil.string2Bytes(blockId));\n          batch.delete(DFSUtil.string2Bytes(entry));\n        });", "url": "https://github.com/apache/ozone/pull/742#discussion_r421696155", "createdAt": "2020-05-07T18:08:43Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/keyvalue/impl/BlockManagerImpl.java", "diffHunk": "@@ -224,11 +239,20 @@ public void deleteBlock(Container container, BlockID blockID) throws\n       // are not atomic. Leaving it here since the impact is refusing\n       // to delete a Block which might have just gotten inserted after\n       // the get check.\n-      byte[] kKey = Longs.toByteArray(blockID.getLocalID());\n+      byte[] blockKey = Longs.toByteArray(blockID.getLocalID());\n \n       getBlockByID(db, blockID);\n-      db.getStore().delete(kKey);\n-      // Decrement blockcount here\n+\n+      // Update DB to delete block and set block count and bytes used.\n+      BatchOperation batch = new BatchOperation();\n+      batch.delete(blockKey);\n+      batch.put(DB_CONTAINER_BYTES_USED_KEY,\n+          Longs.toByteArray(container.getContainerData().getBytesUsed()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1OTUzMw=="}, "originalCommit": {"oid": "7e69e9b230a8911902e8e9d171e0fbcafe51d707"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjAxMzQyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTo1OToyOFrOGSR0gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjozMDoyOFrOGSSjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxOTUyMw==", "bodyText": "Should be if (delTx.getTxID > containerData.getDeleteTransactionId())", "url": "https://github.com/apache/ozone/pull/742#discussion_r421819523", "createdAt": "2020-05-07T21:59:28Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "diffHunk": "@@ -256,9 +256,14 @@ private void deleteKeyValueContainerBlocks(\n       // Finally commit the DB counters.\n       BatchOperation batchOperation = new BatchOperation();\n \n-      // Update in DB pending delete key count and delete transaction ID.\n-      batchOperation.put(DB_CONTAINER_DELETE_TRANSACTION_KEY,\n-          Longs.toByteArray(delTX.getTxID()));\n+\n+      // In memory is updated only when existing delete transactionID is\n+      // greater.\n+      if (containerData.getDeleteTransactionId() > delTX.getTxID()) {\n+        // Update in DB pending delete key count and delete transaction ID.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c2807cb3b9a1df829fa3eac5e6f4db3c248c374"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTU4NA==", "bodyText": "Done", "url": "https://github.com/apache/ozone/pull/742#discussion_r421831584", "createdAt": "2020-05-07T22:30:28Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/DeleteBlocksCommandHandler.java", "diffHunk": "@@ -256,9 +256,14 @@ private void deleteKeyValueContainerBlocks(\n       // Finally commit the DB counters.\n       BatchOperation batchOperation = new BatchOperation();\n \n-      // Update in DB pending delete key count and delete transaction ID.\n-      batchOperation.put(DB_CONTAINER_DELETE_TRANSACTION_KEY,\n-          Longs.toByteArray(delTX.getTxID()));\n+\n+      // In memory is updated only when existing delete transactionID is\n+      // greater.\n+      if (containerData.getDeleteTransactionId() > delTX.getTxID()) {\n+        // Update in DB pending delete key count and delete transaction ID.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxOTUyMw=="}, "originalCommit": {"oid": "6c2807cb3b9a1df829fa3eac5e6f4db3c248c374"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4893, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}