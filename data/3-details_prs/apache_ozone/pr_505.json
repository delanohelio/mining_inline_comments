{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4ODQxNTQx", "number": 505, "title": "HDDS-2956. Handle Replay of AllocateBlock request", "bodyText": "What changes were proposed in this pull request?\nTo ensure that allocate block operations are idempotent, compare the transactionID with the objectID and updateID to make sure that the transaction is not a replay. If the transactionID <= updateID, then it implies that the transaction is a replay and hence it should be skipped.\nOMAllocateBlockRequest is made idempotent in this Jira.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-2956\nHow was this patch tested?\nUnit test added.", "createdAt": "2020-01-30T01:07:32Z", "url": "https://github.com/apache/ozone/pull/505", "merged": true, "mergeCommit": {"oid": "15cf3c8f05541724e97c7cb0314509b2ef0e9893"}, "closed": true, "closedAt": "2020-01-31T23:04:20Z", "author": {"login": "hanishakoneru"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_P8dHAH2gAyMzY4ODQxNTQxOjJkZGZhMDMxN2E5ZmM0NGU0NDBiODdjOTE3MmMxNGNiNDYzMTczNTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_3Y9eAFqTM1MTgyNjUxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2ddfa0317a9fc44e440b87c9172c14cb46317352", "author": {"user": {"login": "hanishakoneru", "name": "Hanisha Koneru"}}, "url": "https://github.com/apache/ozone/commit/2ddfa0317a9fc44e440b87c9172c14cb46317352", "committedDate": "2020-01-30T01:06:46Z", "message": "HDDS-2956. Handle Replay of AllocateBlock request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3", "author": {"user": {"login": "hanishakoneru", "name": "Hanisha Koneru"}}, "url": "https://github.com/apache/ozone/commit/8ebe8b1127895feca1416a27f41795c068b8fdf3", "committedDate": "2020-01-30T17:19:12Z", "message": "CI fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjY3NDg3", "url": "https://github.com/apache/ozone/pull/505#pullrequestreview-351267487", "createdAt": "2020-01-31T02:46:14Z", "commit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0NjoxNFrOFkAGNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0NjoxNFrOFkAGNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDY0NA==", "bodyText": "I think, this check will help only when Key is created and Committed. But it will not help in the scenario:\nT1 - Key Create\nT2 - allocate block\nT3 - Key Commit\nT4- Key Delete\nWhen replay, we will still throw an error, as it will not be in the openKeyTable. So, I think it is okay not to get from key table and do a check. As we cannot 100% find replay transactions.", "url": "https://github.com/apache/ozone/pull/505#discussion_r373294644", "createdAt": "2020-01-31T02:46:14Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -160,71 +160,98 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n     auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));\n \n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    String openKeyName = omMetadataManager.getOpenKey(volumeName, bucketName,\n+        keyName, clientID);\n+\n     OMResponse.Builder omResponse = OMResponse.newBuilder().setCmdType(\n         OzoneManagerProtocolProtos.Type.AllocateBlock).setStatus(\n         OzoneManagerProtocolProtos.Status.OK).setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n \n+    OmKeyInfo openKeyInfo = null;\n     IOException exception = null;\n-    OmKeyInfo omKeyInfo = null;\n+\n     try {\n       // check Acl\n       checkKeyAclsInOpenKeyTable(ozoneManager, volumeName, bucketName, keyName,\n           IAccessAuthorizer.ACLType.WRITE, allocateBlockRequest.getClientID());\n \n-      OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n       validateBucketAndVolume(omMetadataManager, volumeName,\n           bucketName);\n \n-      String openKey = omMetadataManager.getOpenKey(\n-          volumeName, bucketName, keyName, clientID);\n-\n       // Here we don't acquire bucket/volume lock because for a single client\n       // allocateBlock is called in serial fashion.\n \n-      omKeyInfo = omMetadataManager.getOpenKeyTable().get(openKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Open Key not found \" + openKey, KEY_NOT_FOUND);\n+      openKeyInfo = omMetadataManager.getOpenKeyTable().get(openKeyName);\n+      if (openKeyInfo == null) {\n+        // Check if this transaction is a replay of ratis logs.\n+        // If the Key was already committed and this transaction is being\n+        // replayed, we should ignore this transaction.\n+        String ozoneKey = omMetadataManager.getOzoneKey(volumeName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjY3ODEw", "url": "https://github.com/apache/ozone/pull/505#pullrequestreview-351267810", "createdAt": "2020-01-31T02:47:34Z", "commit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0NzozNVrOFkAHUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo0NzozNVrOFkAHUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDkzMA==", "bodyText": "Just one minor comment, can we eliminate renaming variable changes, as this is increasing jira scope and code line changes. As with focussed change, it will be simple.", "url": "https://github.com/apache/ozone/pull/505#discussion_r373294930", "createdAt": "2020-01-31T02:47:35Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -134,8 +135,7 @@ public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n \n   @Override\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n-      long transactionLogIndex,\n-      OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjY4MzU5", "url": "https://github.com/apache/ozone/pull/505#pullrequestreview-351268359", "createdAt": "2020-01-31T02:49:42Z", "commit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjY4Njgx", "url": "https://github.com/apache/ozone/pull/505#pullrequestreview-351268681", "createdAt": "2020-01-31T02:51:10Z", "commit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo1MToxMFrOFkAKTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMjo1MToxMFrOFkAKTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTY5NA==", "bodyText": "We want to do auditLog when it is not a replay(best try), like how we did in other key patches.", "url": "https://github.com/apache/ozone/pull/505#discussion_r373295694", "createdAt": "2020-01-31T02:51:10Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -160,71 +160,98 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n     auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));\n \n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    String openKeyName = omMetadataManager.getOpenKey(volumeName, bucketName,\n+        keyName, clientID);\n+\n     OMResponse.Builder omResponse = OMResponse.newBuilder().setCmdType(\n         OzoneManagerProtocolProtos.Type.AllocateBlock).setStatus(\n         OzoneManagerProtocolProtos.Status.OK).setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n \n+    OmKeyInfo openKeyInfo = null;\n     IOException exception = null;\n-    OmKeyInfo omKeyInfo = null;\n+\n     try {\n       // check Acl\n       checkKeyAclsInOpenKeyTable(ozoneManager, volumeName, bucketName, keyName,\n           IAccessAuthorizer.ACLType.WRITE, allocateBlockRequest.getClientID());\n \n-      OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n       validateBucketAndVolume(omMetadataManager, volumeName,\n           bucketName);\n \n-      String openKey = omMetadataManager.getOpenKey(\n-          volumeName, bucketName, keyName, clientID);\n-\n       // Here we don't acquire bucket/volume lock because for a single client\n       // allocateBlock is called in serial fashion.\n \n-      omKeyInfo = omMetadataManager.getOpenKeyTable().get(openKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Open Key not found \" + openKey, KEY_NOT_FOUND);\n+      openKeyInfo = omMetadataManager.getOpenKeyTable().get(openKeyName);\n+      if (openKeyInfo == null) {\n+        // Check if this transaction is a replay of ratis logs.\n+        // If the Key was already committed and this transaction is being\n+        // replayed, we should ignore this transaction.\n+        String ozoneKey = omMetadataManager.getOzoneKey(volumeName,\n+            bucketName, keyName);\n+        OmKeyInfo dbKeyInfo = omMetadataManager.getKeyTable().get(ozoneKey);\n+        if (dbKeyInfo != null) {\n+          if (isReplay(ozoneManager, dbKeyInfo.getUpdateID(), trxnLogIndex)) {\n+            // This transaction is a replay. Send replay response.\n+            throw new OMReplayException();\n+          }\n+        }\n+        throw new OMException(\"Open Key not found \" + openKeyName,\n+            KEY_NOT_FOUND);\n+      }\n+\n+      // Check if this transaction is a replay of ratis logs.\n+      // Check the updateID of the openKey to verify that it is not greater\n+      // than the current transactionLogIndex\n+      if (isReplay(ozoneManager, openKeyInfo.getUpdateID(), trxnLogIndex)) {\n+        // This transaction is a replay. Send replay response.\n+        throw new OMReplayException();\n       }\n \n       // Append new block\n-      omKeyInfo.appendNewBlocks(Collections.singletonList(\n+      openKeyInfo.appendNewBlocks(Collections.singletonList(\n           OmKeyLocationInfo.getFromProtobuf(blockLocation)), false);\n \n       // Set modification time.\n-      omKeyInfo.setModificationTime(keyArgs.getModificationTime());\n+      openKeyInfo.setModificationTime(keyArgs.getModificationTime());\n \n       // Set the UpdateID to current transactionLogIndex\n-      omKeyInfo.setUpdateID(transactionLogIndex);\n+      openKeyInfo.setUpdateID(trxnLogIndex);\n \n       // Add to cache.\n       omMetadataManager.getOpenKeyTable().addCacheEntry(\n-          new CacheKey<>(openKey), new CacheValue<>(Optional.of(omKeyInfo),\n-              transactionLogIndex));\n+          new CacheKey<>(openKeyName),\n+          new CacheValue<>(Optional.of(openKeyInfo), trxnLogIndex));\n \n+      omResponse.setAllocateBlockResponse(AllocateBlockResponse.newBuilder()\n+          .setKeyLocation(blockLocation).build());\n+      omClientResponse = new OMAllocateBlockResponse(omResponse.build(),\n+          openKeyInfo, clientID);\n+      LOG.debug(\"Allocated block for Volume:{}, Bucket:{}, OpenKey:{}\",\n+          volumeName, bucketName, openKeyName);\n     } catch (IOException ex) {\n-      exception = ex;\n+      if (ex instanceof OMReplayException) {\n+        omClientResponse = new OMAllocateBlockResponse(createReplayOMResponse(\n+            omResponse));\n+        LOG.debug(\"Replayed Transaction {} ignored. Request: {}\", trxnLogIndex,\n+            allocateBlockRequest);\n+      } else {\n+        omMetrics.incNumBlockAllocateCallFails();\n+        exception = ex;\n+        omClientResponse = new OMAllocateBlockResponse(createErrorOMResponse(\n+            omResponse, exception));\n+        LOG.error(\"Allocate Block failed. Volume:{}, Bucket:{}, OpenKey:{}. \" +\n+            \"Exception:{}\", volumeName, bucketName, openKeyName, exception);\n+      }\n     }\n \n     auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_BLOCK, auditMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c20546f8c2927e94921b4c132c9d7afc5e4b647f", "author": {"user": {"login": "hanishakoneru", "name": "Hanisha Koneru"}}, "url": "https://github.com/apache/ozone/commit/c20546f8c2927e94921b4c132c9d7afc5e4b647f", "committedDate": "2020-01-31T17:54:59Z", "message": "review comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODI2NTE4", "url": "https://github.com/apache/ozone/pull/505#pullrequestreview-351826518", "createdAt": "2020-01-31T23:04:12Z", "commit": {"oid": "c20546f8c2927e94921b4c132c9d7afc5e4b647f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3789, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}