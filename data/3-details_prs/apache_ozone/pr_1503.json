{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0OTYzMDQ3", "number": 1503, "title": "HDDS-4332: ListFileStatus - do lookup in directory and file tables", "bodyText": "What changes were proposed in this pull request?\nhttps://issues.apache.org/jira/browse/HDDS-4332\nWhat is the link to the Apache JIRA\nThis task is to perform look up of the user given key path in the directory, file and openFile tables.\nOzoneFileSystem APIs:\n\nGetFileStatus\nlistStatus\n\nHow was this patch tested?\nAdded UTs - TestHadoopDirTreeGeneratorV1, TestOzoneFileInterfacesV1, TestOzoneFileSystemV1...", "createdAt": "2020-10-16T16:30:57Z", "url": "https://github.com/apache/ozone/pull/1503", "merged": true, "mergeCommit": {"oid": "d74b856c15b2ef6369d6df9ea24f0fe155c0ef21"}, "closed": true, "closedAt": "2020-10-31T01:02:24Z", "author": {"login": "rakeshadr"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTI3ATgH2gAyNTA0OTYzMDQ3OjQwODQ3OWRjZDg4MzIyM2Q3ODFhMGU3MzM5NDk3NTQ5ODZlYzliODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXws_sgFqTUyMTA5ODk5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "408479dcd883223d781a0e733949754986ec9b87", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/408479dcd883223d781a0e733949754986ec9b87", "committedDate": "2020-10-16T16:21:07Z", "message": "HDDS-4332: ListFileStatus - do lookup in directory and file tables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODc0ODQw", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-510874840", "createdAt": "2020-10-17T04:07:39Z", "commit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDowNzozOVrOHjUEIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNzoxOToxN1rOHjXknw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDk0Ng==", "bodyText": "Nit: this comment seems not accurate here.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506790946", "createdAt": "2020-10-17T04:07:39Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -1831,6 +1838,62 @@ private OzoneFileStatus getOzoneFileStatus(String volumeName,\n             FILE_NOT_FOUND);\n   }\n \n+\n+  private OzoneFileStatus getOzoneFileStatusV1(String volumeName,\n+                                             String bucketName,\n+                                             String keyName,\n+                                             boolean sortDatanodes,\n+                                             String clientAddress)\n+          throws IOException {\n+    OzoneFileStatus fileStatus = null;\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        validateBucket(volumeName, bucketName);\n+        return new OzoneFileStatus();\n+      }\n+\n+      fileStatus = OMFileRequest.getOMKeyInfoIfExists(metadataManager,\n+              volumeName, bucketName, keyName, scmBlockSize);\n+\n+      // Check if the key is a directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjAwNg==", "bodyText": "Can we use default replication type/factor:\n\nOzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT\nOzoneConfigKeys.OZONE_REPLICATION_DEFAULT", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506792006", "createdAt": "2020-10-17T04:21:52Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(\n+      OMMetadataManager omMetadataMgr, String volumeName, String bucketName,\n+      String keyName, long scmBlockSize) throws IOException {\n+\n+    Path keyPath = Paths.get(keyName);\n+    Iterator<Path> elements = keyPath.iterator();\n+    String bucketKey = omMetadataMgr.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataMgr.getBucketTable().get(bucketKey);\n+\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo omDirInfo = null;\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/file1.txt\n+      // 1. Do lookup path component on directoryTable starting from bucket\n+      // 'buck1' to the leaf node component, which is 'file1.txt'.\n+      // 2. If there is no dir exists for the leaf node component 'file1.txt'\n+      // then do look it on fileTable.\n+      String dbNodeName = omMetadataMgr.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      omDirInfo = omMetadataMgr.getDirectoryTable().get(dbNodeName);\n+\n+      if (omDirInfo != null) {\n+        lastKnownParentId = omDirInfo.getObjectID();\n+      } else if (!elements.hasNext()) {\n+        // reached last path component. Check file exists for the given path.\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfoFromFileTable(false,\n+                omMetadataMgr, dbNodeName, keyName);\n+        if (omKeyInfo != null) {\n+          return new OzoneFileStatus(omKeyInfo, scmBlockSize, false);\n+        }\n+      } else {\n+        // Missing intermediate directory and just return null;\n+        // key not found in DB\n+        return null;\n+      }\n+    }\n+\n+    if (omDirInfo != null) {\n+      OmKeyInfo omKeyInfo = getOmKeyInfo(volumeName, bucketName, omDirInfo,\n+              keyName);\n+      return new OzoneFileStatus(omKeyInfo, scmBlockSize, true);\n+    }\n+\n+    // key not found in DB\n+    return null;\n+  }\n+\n+  /**\n+   * Prepare OmKeyInfo from OmDirectoryInfo.\n+   *\n+   * @param volumeName volume name\n+   * @param bucketName bucket name\n+   * @param dirInfo    directory info\n+   * @param keyName    usewr given key name\n+   * @return OmKeyInfo object\n+   */\n+  @NotNull\n+  public static OmKeyInfo getOmKeyInfo(String volumeName, String bucketName,\n+      OmDirectoryInfo dirInfo, String keyName) {\n+\n+    OmKeyInfo.Builder builder = new OmKeyInfo.Builder();\n+    builder.setParentObjectID(dirInfo.getParentObjectID());\n+    builder.setKeyName(keyName);\n+    builder.setAcls(dirInfo.getAcls());\n+    builder.addAllMetadata(dirInfo.getMetadata());\n+    builder.setVolumeName(volumeName);\n+    builder.setBucketName(bucketName);\n+    builder.setCreationTime(dirInfo.getCreationTime());\n+    builder.setModificationTime(dirInfo.getModificationTime());\n+    builder.setObjectID(dirInfo.getObjectID());\n+    builder.setUpdateID(dirInfo.getUpdateID());\n+    builder.setFileName(dirInfo.getName());\n+    builder.setReplicationType(HddsProtos.ReplicationType.RATIS);\n+    builder.setReplicationFactor(HddsProtos.ReplicationFactor.ONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg0ODQxNQ==", "bodyText": "We also don't need args.getRefreshPipeline() here due to HDDS-3658 change.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506848415", "createdAt": "2020-10-17T07:19:17Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;\n+          countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+                  prefixPath, countEntries, numEntries, prefixKeyInDB);\n+        } else {\n+          String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, dirName);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          countEntries++;\n+        }\n+        // move to next entry in the table\n+        iterator.next();\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    int countEntries = 0;\n+    // Convert results in cacheKeyMap to List\n+    for (Map.Entry<String, OzoneFileStatus> entry : cacheKeyMap.entrySet()) {\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getRefreshPipeline()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwOTU4NDI5", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-510958429", "createdAt": "2020-10-17T07:28:49Z", "commit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNzoyODo0OVrOHjXv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwODozMzozNFrOHjZ9ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1MTMxMA==", "bodyText": "Can we reuse an existed method OzoneFSUtils#addTrailingSlashIfNeeded(keyName) instead of?", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506851310", "createdAt": "2020-10-17T07:28:49Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NDU0OA==", "bodyText": "If we cannot find the first OzoneFileStatus based on given startKey. It means that there is no other  OzoneFileStatus matched. And we should return the empty list.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506854548", "createdAt": "2020-10-17T07:35:16Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg1NzAyMw==", "bodyText": "startKey can be a non-existed key here. We cannot just reuse getOzoneFileStatusV1 to find the OzoneFileStatus. getOzoneFileStatusV1 needs the key existed then it has the result.\nExample,\nkey list:\n/a/a\n/a/c\n/a/d\nIf given startkey: /a/b, here should return /a/c", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506857023", "createdAt": "2020-10-17T07:42:51Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MDQ3OA==", "bodyText": "We need to pass scmBlockSize as well:\nOzoneFileStatus(keyInfo, 0, false) -> OzoneFileStatus(keyInfo, scmBlockSize, false)", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506860478", "createdAt": "2020-10-17T07:54:43Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;\n+          countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+                  prefixPath, countEntries, numEntries, prefixKeyInDB);\n+        } else {\n+          String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, dirName);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          countEntries++;\n+        }\n+        // move to next entry in the table\n+        iterator.next();\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    int countEntries = 0;\n+    // Convert results in cacheKeyMap to List\n+    for (Map.Entry<String, OzoneFileStatus> entry : cacheKeyMap.entrySet()) {\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getRefreshPipeline()) {\n+        refreshPipeline(entry.getValue().getKeyInfo());\n+      }\n+      fileStatusList.add(entry.getValue());\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(entry.getValue().getKeyInfo(), clientAddress);\n+      }\n+      countEntries++;\n+      if (countEntries >= numEntries) {\n+        break;\n+      }\n+    }\n+    // Clean up temp map and set\n+    cacheKeyMap.clear();\n+\n+    return fileStatusList;\n+  }\n+\n+  private int getFilesFromDirectory(Map<String, OzoneFileStatus> cacheKeyMap,\n+      String seekKeyInDB, String prefixKeyPath, int countEntries,\n+      long numEntries, long prefixKeyInDB) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+            iterator = keyTable.iterator();\n+    iterator.seek(seekKeyInDB);\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      String entryInDb = iterator.key();\n+      OmKeyInfo keyInfo = iterator.value().getValue();\n+\n+      if (!isImmediateChild(keyInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      keyInfo.setFileName(keyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              keyInfo.getKeyName());\n+      keyInfo.setKeyName(fullKeyPath);\n+      cacheKeyMap.put(entryInDb, new OzoneFileStatus(keyInfo, 0, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg2MTY0NA==", "bodyText": "Can we remove this unused line.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506861644", "createdAt": "2020-10-17T07:58:00Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java", "diffHunk": "@@ -249,12 +273,10 @@ public void tearDown() {\n     }\n   }\n \n-  private void setupOzoneFileSystem()\n+  protected void setupOzoneFileSystem()\n       throws IOException, TimeoutException, InterruptedException {\n-    OzoneConfiguration conf = new OzoneConfiguration();\n-    conf.setInt(FS_TRASH_INTERVAL_KEY, 1);\n-    conf.setBoolean(OMConfigKeys.OZONE_OM_ENABLE_FILESYSTEM_PATHS,\n-        enabledFileSystemPaths);\n+    OzoneConfiguration conf = getOzoneConfig();\n+    //conf.set(OMConfigKeys.OZONE_OM_LAYOUT_VERSION, \"V1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg3NDc2Ng==", "bodyText": "prefixKeyInDB should also updated to new dir objectID dirInfo.getObjectID()", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506874766", "createdAt": "2020-10-17T08:14:21Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;\n+      // Seek the given key in key table.\n+      countEntries = getFilesFromDirectory(cacheKeyMap, seekKeyInDB,\n+              prefixPath, countEntries, numEntries, prefixKeyInDB);\n+      // Seek the given key in dir table.\n+      Table dirTable = metadataManager.getDirectoryTable();\n+      TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+              iterator = dirTable.iterator();\n+\n+      iterator.seek(seekKeyInDB);\n+\n+      while (iterator.hasNext() && numEntries - countEntries > 0) {\n+        String entryInDb = iterator.key();\n+        OmDirectoryInfo dirInfo = iterator.value().getValue();\n+        if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+          break;\n+        }\n+\n+        if (recursive) {\n+          // for recursive list all the entries\n+          prefixPath = OMFileRequest.getAbsolutePath(prefixPath,\n+                  dirInfo.getName());\n+          OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                  bucketName, dirInfo, prefixPath);\n+          cacheKeyMap.put(entryInDb,\n+                  new OzoneFileStatus(omKeyInfo, 0, true));\n+          ++countEntries;\n+          // files from this directory\n+          seekKeyInDB = dirInfo.getObjectID() + OZONE_URI_DELIMITER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4MDA0NQ==", "bodyText": "Typo: usewr -> user", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506880045", "createdAt": "2020-10-17T08:18:30Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(\n+      OMMetadataManager omMetadataMgr, String volumeName, String bucketName,\n+      String keyName, long scmBlockSize) throws IOException {\n+\n+    Path keyPath = Paths.get(keyName);\n+    Iterator<Path> elements = keyPath.iterator();\n+    String bucketKey = omMetadataMgr.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataMgr.getBucketTable().get(bucketKey);\n+\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo omDirInfo = null;\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/file1.txt\n+      // 1. Do lookup path component on directoryTable starting from bucket\n+      // 'buck1' to the leaf node component, which is 'file1.txt'.\n+      // 2. If there is no dir exists for the leaf node component 'file1.txt'\n+      // then do look it on fileTable.\n+      String dbNodeName = omMetadataMgr.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      omDirInfo = omMetadataMgr.getDirectoryTable().get(dbNodeName);\n+\n+      if (omDirInfo != null) {\n+        lastKnownParentId = omDirInfo.getObjectID();\n+      } else if (!elements.hasNext()) {\n+        // reached last path component. Check file exists for the given path.\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfoFromFileTable(false,\n+                omMetadataMgr, dbNodeName, keyName);\n+        if (omKeyInfo != null) {\n+          return new OzoneFileStatus(omKeyInfo, scmBlockSize, false);\n+        }\n+      } else {\n+        // Missing intermediate directory and just return null;\n+        // key not found in DB\n+        return null;\n+      }\n+    }\n+\n+    if (omDirInfo != null) {\n+      OmKeyInfo omKeyInfo = getOmKeyInfo(volumeName, bucketName, omDirInfo,\n+              keyName);\n+      return new OzoneFileStatus(omKeyInfo, scmBlockSize, true);\n+    }\n+\n+    // key not found in DB\n+    return null;\n+  }\n+\n+  /**\n+   * Prepare OmKeyInfo from OmDirectoryInfo.\n+   *\n+   * @param volumeName volume name\n+   * @param bucketName bucket name\n+   * @param dirInfo    directory info\n+   * @param keyName    usewr given key name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzM3Mg==", "bodyText": "We should reset prefixPath after we find the first ozone file info to list.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506887372", "createdAt": "2020-10-17T08:32:45Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjg4NzYxMA==", "bodyText": "Should reset prefixPath to bucketKey I think.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506887610", "createdAt": "2020-10-17T08:33:34Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwOTk0MDMx", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-510994031", "createdAt": "2020-10-17T15:36:29Z", "commit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QxNTozNjoyOVrOHjeD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QxNTozNjoyOVrOHjeD8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk1NDczNg==", "bodyText": "Additionally, startKey needs to be normalized when FileSystemPaths enabled, related JIRA: HDDS-4117", "url": "https://github.com/apache/ozone/pull/1503#discussion_r506954736", "createdAt": "2020-10-17T15:36:29Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTIwNTE1", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-511120515", "createdAt": "2020-10-18T08:18:24Z", "commit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwODoxODoyNFrOHjjMGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwODoxODoyNFrOHjjMGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAzODc0Ng==", "bodyText": "Currently, CreateFile/CreateDir of V1 version also add entry into double buffer cache first, then flush to db. So seems we still need to combine the result from table cache and db.\nFor the further DeleteFile/DeleteDir API implement, we may still follow this table cache way. Not fully understand why here we say ' deleted keys are marked directly in directory table'. Current write type request always operate the cache first, then flush to db I think.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r507038746", "createdAt": "2020-10-18T08:18:24Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2272,167 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    List<OzoneFileStatus> fileStatusList = new ArrayList<>();\n+    if (numEntries <= 0) {\n+      return fileStatusList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    // A map sorted by OmKey to combine results from TableCache and DB.\n+    TreeMap<String, OzoneFileStatus> cacheKeyMap = new TreeMap<>();\n+    String seekKeyInDB = \"\";\n+    long prefixKeyInDB = Long.MIN_VALUE;\n+    String prefixPath = keyName;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // keyName is a directory\n+        if (fileStatus.getKeyInfo() != null) {\n+          seekKeyInDB = fileStatus.getKeyInfo().getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          seekKeyInDB = omBucketInfo.getObjectID()\n+                  + OZONE_URI_DELIMITER;\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+      } else {\n+        // startKey will be used in iterator seek and sets the beginning point\n+        // for key traversal.\n+        // key name will be used as parent ID where the user has requested to\n+        // list the keys from.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null);\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          seekKeyInDB = prefixKeyInDB + OZONE_URI_DELIMITER\n+                  + fileStatusInfo.getKeyInfo().getFileName();\n+        }\n+      }\n+\n+      // Not required to search in TableCache because all the deleted keys\n+      // are marked directly in directory table or in key table by breaking\n+      // the pointer to its sub-dirs. So, there is no issue of inconsistency.\n+      int countEntries = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408479dcd883223d781a0e733949754986ec9b87"}, "originalPosition": 166}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3e9035b7e0b0a28102c481d1d887b6b56abc656", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/d3e9035b7e0b0a28102c481d1d887b6b56abc656", "committedDate": "2020-10-21T18:06:36Z", "message": "Fixed review comments - startKey, tableCache functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e70dbabd7bacc7b0b21771e0a5013114b9072a09", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/e70dbabd7bacc7b0b21771e0a5013114b9072a09", "committedDate": "2020-10-22T03:04:48Z", "message": "Fixed checkstyle warnings."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/57d92c33bb7b5cd47b281eecadcc0fa464205267", "committedDate": "2020-10-22T03:33:07Z", "message": "Fixed UT failure - skipFileNotFoundError"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTM1MDc3", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-514535077", "createdAt": "2020-10-22T09:31:34Z", "commit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTozMTozNFrOHmZAyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwOTozMTozNFrOHmZAyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNzczNw==", "bodyText": "For this branch, we use startKey to get the key info and it's a file in key table. So we will not have the same key string as startKey in dir table. Here I think we should just return one  single file\nCollections.singletonList(fileStatusInfo);", "url": "https://github.com/apache/ozone/pull/1503#discussion_r510017737", "createdAt": "2020-10-22T09:31:34Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MTg0MTQ3", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-518184147", "createdAt": "2020-10-27T22:00:56Z", "commit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjowMDo1NlrOHpSo0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMzo0MToyOVrOHqBbDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1OTAyNA==", "bodyText": "Question: This should be done under bucket lock right?", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513059024", "createdAt": "2020-10-27T22:00:56Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -583,4 +588,112 @@ public static OmKeyInfo getOmKeyInfoFromFileTable(boolean openFileTable,\n     return dbOmKeyInfo;\n   }\n \n+  /**\n+   * Gets OmKeyInfo if exists for the given key name in the DB.\n+   *\n+   * @param omMetadataMgr metadata manager\n+   * @param volumeName    volume name\n+   * @param bucketName    bucket name\n+   * @param keyName       key name\n+   * @param scmBlockSize  scm block size\n+   * @return OzoneFileStatus\n+   * @throws IOException DB failure\n+   */\n+  @Nullable\n+  public static OzoneFileStatus getOMKeyInfoIfExists(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0Njk4OA==", "bodyText": "We need to consider count from this during total count when iterating from cache.\nWe are using that countEntries but listStatusFindFilesInTableCache is not returning that.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513746988", "createdAt": "2020-10-28T20:42:16Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,\n+            seekDirInDB, prefixPath, startKey, volumeName, bucketName,\n+            countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+            iterator = dirTable.iterator();\n+\n+    iterator.seek(seekDirInDB);\n+\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmDirectoryInfo dirInfo = iterator.value().getValue();\n+      if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      // TODO: recursive list will be handled in HDDS-4360 jira.\n+      if (!recursive) {\n+        String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                dirInfo.getName());\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                bucketName, dirInfo, dirName);\n+        fileStatusList.add(new OzoneFileStatus(omKeyInfo, scmBlockSize,\n+                true));\n+        countEntries++;\n+      }\n+      // move to next entry in the DirTable\n+      iterator.next();\n+    }\n+\n+    return countEntries;\n+  }\n+\n+  private int getFilesFromDirectory(Set<OzoneFileStatus> fileStatusList,\n+      String seekKeyInDB, String prefixKeyPath, long prefixKeyInDB,\n+      String startKey, int countEntries, long numEntries) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    listStatusFindFilesInTableCache(fileStatusList, keyTable, prefixKeyInDB,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5OTE2Ng==", "bodyText": "We need to consider count from this during total count when iterating from cache.\nWe are using that countEntries but listStatusFindDirsInTableCache is not returning that", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513799166", "createdAt": "2020-10-28T22:27:26Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNjA5Mg==", "bodyText": "Question: Do we need this second check when startKey is blank?", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513806092", "createdAt": "2020-10-28T22:45:35Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);\n+    return fileStatusFinalList;\n+  }\n+\n+  @SuppressWarnings(\"parameternumber\")\n+  protected int getDirectories(boolean recursive, String startKey,\n+      long numEntries, Set<OzoneFileStatus> fileStatusList,\n+      String volumeName, String bucketName, String seekDirInDB,\n+      long prefixKeyInDB, String prefixPath,\n+      int countEntries) throws IOException {\n+\n+    Table dirTable = metadataManager.getDirectoryTable();\n+    listStatusFindDirsInTableCache(fileStatusList, dirTable, prefixKeyInDB,\n+            seekDirInDB, prefixPath, startKey, volumeName, bucketName,\n+            countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmDirectoryInfo>>\n+            iterator = dirTable.iterator();\n+\n+    iterator.seek(seekDirInDB);\n+\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmDirectoryInfo dirInfo = iterator.value().getValue();\n+      if (!isImmediateChild(dirInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      // TODO: recursive list will be handled in HDDS-4360 jira.\n+      if (!recursive) {\n+        String dirName = OMFileRequest.getAbsolutePath(prefixPath,\n+                dirInfo.getName());\n+        OmKeyInfo omKeyInfo = OMFileRequest.getOmKeyInfo(volumeName,\n+                bucketName, dirInfo, dirName);\n+        fileStatusList.add(new OzoneFileStatus(omKeyInfo, scmBlockSize,\n+                true));\n+        countEntries++;\n+      }\n+      // move to next entry in the DirTable\n+      iterator.next();\n+    }\n+\n+    return countEntries;\n+  }\n+\n+  private int getFilesFromDirectory(Set<OzoneFileStatus> fileStatusList,\n+      String seekKeyInDB, String prefixKeyPath, long prefixKeyInDB,\n+      String startKey, int countEntries, long numEntries) throws IOException {\n+\n+    Table<String, OmKeyInfo> keyTable = metadataManager.getKeyTable();\n+    listStatusFindFilesInTableCache(fileStatusList, keyTable, prefixKeyInDB,\n+            seekKeyInDB, prefixKeyPath, startKey, countEntries, numEntries);\n+    TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+            iterator = keyTable.iterator();\n+    iterator.seek(seekKeyInDB);\n+    while (iterator.hasNext() && numEntries - countEntries > 0) {\n+      OmKeyInfo keyInfo = iterator.value().getValue();\n+\n+      if (!isImmediateChild(keyInfo.getParentObjectID(), prefixKeyInDB)) {\n+        break;\n+      }\n+\n+      keyInfo.setFileName(keyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              keyInfo.getKeyName());\n+      keyInfo.setKeyName(fullKeyPath);\n+      fileStatusList.add(new OzoneFileStatus(keyInfo, scmBlockSize, false));\n+      countEntries++;\n+      iterator.next(); // move to next entry in the table\n+    }\n+    return countEntries;\n+  }\n+\n+  private boolean isImmediateChild(long parentId, long ancestorId) {\n+    return parentId == ancestorId;\n+  }\n+\n+  /**\n+   * Helper function for listStatus to find key in FileTableCache.\n+   */\n+  @SuppressWarnings(\"parameternumber\")\n+  private void listStatusFindFilesInTableCache(\n+          Set<OzoneFileStatus> fileStatusList, Table<String,\n+          OmKeyInfo> keyTable, long prefixKeyInDB, String seekKeyInDB,\n+          String prefixKeyPath, String startKey, int countEntries,\n+          long numEntries) {\n+\n+    Iterator<Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>>>\n+            cacheIter = keyTable.cacheIterator();\n+    // seekKeyInDB will have two type of values.\n+    // 1. \"1024/\"   -> startKey is null or empty\n+    // 2. \"1024/b\"  -> startKey exists\n+    // TODO: recursive list will be handled in HDDS-4360 jira.\n+    while (cacheIter.hasNext() && numEntries - countEntries > 0) {\n+      Map.Entry<CacheKey<String>, CacheValue<OmKeyInfo>> entry =\n+              cacheIter.next();\n+      String cacheKey = entry.getKey().getCacheKey();\n+      OmKeyInfo cacheOmKeyInfo = entry.getValue().getCacheValue();\n+      if(cacheOmKeyInfo == null){\n+        continue;\n+      }\n+\n+      cacheOmKeyInfo.setFileName(cacheOmKeyInfo.getKeyName());\n+      String fullKeyPath = OMFileRequest.getAbsolutePath(prefixKeyPath,\n+              cacheOmKeyInfo.getKeyName());\n+      cacheOmKeyInfo.setKeyName(fullKeyPath);\n+\n+      if (StringUtils.isBlank(startKey)) {\n+        // cacheOmKeyInfo is null if an entry is deleted in cache\n+        if (cacheKey.startsWith(seekKeyInDB) &&\n+                cacheKey.compareTo(seekKeyInDB) >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNTk2OQ==", "bodyText": "Minor NIT: Can we maintain similar order for parameters for getFilesFromDirectories and getDirectories it will be easy to follow while reading code, as it has many parameters.", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513815969", "createdAt": "2020-10-28T23:13:14Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNjc4MA==", "bodyText": "Can we avoid the call to refreshPipeline for directories and also for sortDatanodeInPipeline.\nif (fileStatus.isFile()) {\nrefreshPipeline(fileStatus.getKeyInfo());\nif (args.getSortDatanodes()) {\n        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n      }\n    }\n}", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513816780", "createdAt": "2020-10-28T23:15:25Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNTU1MA==", "bodyText": "When startKey is passed, we seek to that and to construct keyName we used keyArgs keyName as keyName and construct the paths.\nBut let's say\nKeyArgs keyName /a/b\nstartkey is /f/d\nThen we have used parentObjectID and seek and then return all keys in directory /f, but we construct keyNames with prefix as \"/a/b\".\nDo you think we need to have a check when startKey is passed is the parentObjectID is same when recursive is false. To avoid this kind of corner case scenarios?", "url": "https://github.com/apache/ozone/pull/1503#discussion_r513825550", "createdAt": "2020-10-28T23:41:29Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/KeyManagerImpl.java", "diffHunk": "@@ -2205,6 +2276,318 @@ private void listStatusFindKeyInTableCache(\n     return fileStatusList;\n   }\n \n+  public List<OzoneFileStatus> listStatusV1(OmKeyArgs args, boolean recursive,\n+      String startKey, long numEntries, String clientAddress)\n+          throws IOException {\n+    Preconditions.checkNotNull(args, \"Key args can not be null\");\n+\n+    // unsorted OMKeyInfo list contains combine results from TableCache and DB.\n+    List<OzoneFileStatus> fileStatusFinalList = new ArrayList<>();\n+    LinkedHashSet<OzoneFileStatus> fileStatusList = new LinkedHashSet<>();\n+    if (numEntries <= 0) {\n+      return fileStatusFinalList;\n+    }\n+\n+    String volumeName = args.getVolumeName();\n+    String bucketName = args.getBucketName();\n+    String keyName = args.getKeyName();\n+    String seekFileInDB;\n+    String seekDirInDB;\n+    long prefixKeyInDB;\n+    String prefixPath = keyName;\n+\n+    int countEntries = 0;\n+\n+    metadataManager.getLock().acquireReadLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+    try {\n+      if (Strings.isNullOrEmpty(startKey)) {\n+        OzoneFileStatus fileStatus = getFileStatus(args, clientAddress);\n+        if (fileStatus.isFile()) {\n+          return Collections.singletonList(fileStatus);\n+        }\n+\n+        // Not required to search in DeletedTable because all the deleted\n+        // keys will be marked directly in dirTable or in keyTable by\n+        // breaking the pointer to its sub-dirs. So, there is no issue of\n+        // inconsistency.\n+\n+        /*\n+         * keyName is a directory.\n+         * Say, \"/a\" is the dir name and its objectID is 1024, then seek\n+         * will be doing with \"1024/\" to get all immediate descendants.\n+         */\n+        if (fileStatus.getKeyInfo() != null) {\n+          prefixKeyInDB = fileStatus.getKeyInfo().getObjectID();\n+        } else {\n+          // list root directory.\n+          String bucketKey = metadataManager.getBucketKey(volumeName,\n+                  bucketName);\n+          OmBucketInfo omBucketInfo =\n+                  metadataManager.getBucketTable().get(bucketKey);\n+          prefixKeyInDB = omBucketInfo.getObjectID();\n+        }\n+        seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+        seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        // Order of seek -> (1)Seek dirs in dirTable (2)Seek files in fileTable\n+        // 1. Seek the given key in key table.\n+        countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                prefixPath, prefixKeyInDB, startKey, countEntries, numEntries);\n+        // 2. Seek the given key in dir table.\n+        getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                volumeName, bucketName, seekDirInDB, prefixKeyInDB,\n+                prefixPath, countEntries);\n+      } else {\n+        /*\n+         * startKey will be used in iterator seek and sets the beginning point\n+         * for key traversal.\n+         *\n+         * key name will be used as parentID where the user has requested to\n+         * list the keys from.\n+         *\n+         * When recursive flag=false, parentID won't change between two pages.\n+         * For example: OM has a namespace like,\n+         *    /a/1...1M files and /a/b/1...1M files.\n+         *    /a/1...1M directories and /a/b/1...1M directories.\n+         * Listing \"/a\", will always have the parentID as \"a\" irrespective of\n+         * the startKey value.\n+         */\n+        // TODO: recursive flag=true will be handled in HDDS-4360 jira.\n+        OzoneFileStatus fileStatusInfo = getOzoneFileStatusV1(volumeName,\n+                bucketName, startKey, false, null, true);\n+\n+        if (fileStatusInfo != null) {\n+          prefixKeyInDB = fileStatusInfo.getKeyInfo().getParentObjectID();\n+          if(fileStatusInfo.isDirectory()){\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+\n+            // Order of seek -> (1) Seek dirs in dirTable. In OM, always the\n+            // order of search is, first seek into fileTable and then dirTable.\n+            // So, its not required to search again into the fileTable.\n+\n+            // Seek the given key in dirTable.\n+            getDirectories(recursive, startKey, numEntries,\n+                    fileStatusList, volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+\n+          } else {\n+            seekFileInDB = metadataManager.getOzonePathKey(prefixKeyInDB,\n+                    fileStatusInfo.getKeyInfo().getFileName());\n+            // begins from the first sub-dir under the parent dir\n+            seekDirInDB = metadataManager.getOzonePathKey(prefixKeyInDB, \"\");\n+\n+            // Seek the given key in key table.\n+            countEntries = getFilesFromDirectory(fileStatusList, seekFileInDB,\n+                    prefixPath, prefixKeyInDB, startKey, countEntries,\n+                    numEntries);\n+            // Seek the given key in dir table.\n+            getDirectories(recursive, startKey, numEntries, fileStatusList,\n+                    volumeName, bucketName, seekDirInDB,\n+                    prefixKeyInDB, prefixPath, countEntries);\n+          }\n+        } else {\n+          // No key exists for the given startKey.\n+          // TODO: HDDS-4364: startKey can be a non-existed key\n+          return Collections.emptyList();\n+        }\n+      }\n+    } finally {\n+      metadataManager.getLock().releaseReadLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+    }\n+\n+    // Convert results in cacheKeyMap to List\n+    for (OzoneFileStatus fileStatus : fileStatusList) {\n+      // refreshPipeline flag check has been removed as part of\n+      // https://issues.apache.org/jira/browse/HDDS-3658.\n+      // Please refer this jira for more details.\n+      refreshPipeline(fileStatus.getKeyInfo());\n+\n+      // No need to check if a key is deleted or not here, this is handled\n+      // when adding entries to cacheKeyMap from DB.\n+      if (args.getSortDatanodes()) {\n+        sortDatanodeInPipeline(fileStatus.getKeyInfo(), clientAddress);\n+      }\n+    }\n+    fileStatusFinalList.addAll(fileStatusList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57d92c33bb7b5cd47b281eecadcc0fa464205267"}, "originalPosition": 254}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ba48b6affe0738d31765df42322bccb376b809d", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/2ba48b6affe0738d31765df42322bccb376b809d", "committedDate": "2020-10-29T14:00:21Z", "message": "Fixed review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea07683a0838e9bd6fd4ed06d1e82e91f29d5f13", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/ea07683a0838e9bd6fd4ed06d1e82e91f29d5f13", "committedDate": "2020-10-30T07:41:53Z", "message": "Fixed Review comments - added isImmediateChild check for startKey, updated seekInDB comparison"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff36080affed8955b737ac92c604688c279db219", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/ff36080affed8955b737ac92c604688c279db219", "committedDate": "2020-10-30T14:50:24Z", "message": "Fixed checkstyle warnings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwODE5Mjk1", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-520819295", "createdAt": "2020-10-30T16:09:40Z", "commit": {"oid": "ff36080affed8955b737ac92c604688c279db219"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDk4NDU1", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-521098455", "createdAt": "2020-10-31T00:57:10Z", "commit": {"oid": "ff36080affed8955b737ac92c604688c279db219"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwMDo1NzoxMFrOHrjuvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwMDo1NzoxMFrOHrjuvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjIyMA==", "bodyText": "Minor: Is this needed here?", "url": "https://github.com/apache/ozone/pull/1503#discussion_r515436220", "createdAt": "2020-10-31T00:57:10Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileInterfaces.java", "diffHunk": "@@ -162,6 +164,14 @@ public void init() throws Exception {\n     omMetrics = cluster.getOzoneManager().getMetrics();\n   }\n \n+  @NotNull", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff36080affed8955b737ac92c604688c279db219"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDk4OTky", "url": "https://github.com/apache/ozone/pull/1503#pullrequestreview-521098992", "createdAt": "2020-10-31T01:02:05Z", "commit": {"oid": "ff36080affed8955b737ac92c604688c279db219"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2393, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}