{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5Nzk4NjA3", "number": 941, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo0ODowOVrOD-AqoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODoxNDo1NVrOD-Vc9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzQ5MjE3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo0ODowOVrOGX2euQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0MTozNlrOGYbKcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MzAzMw==", "bodyText": "Minor NIT: Should we set authority in the initOFSPath??\nAs there we have checked for auth.", "url": "https://github.com/apache/ozone/pull/941#discussion_r427663033", "createdAt": "2020-05-19T23:48:09Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -66,7 +70,13 @@\n   static final String OFS_MOUNT_TMP_VOLUMENAME = \"tmp\";\n \n   OFSPath(Path path) {\n-    String pathStr = path.toUri().getPath();\n+    URI uri = path.toUri();\n+    // scheme is case-insensitive\n+    if (!uri.getScheme().toLowerCase().equals(OZONE_OFS_URI_SCHEME)) {\n+      throw new ParseException(\"Can't parse schemes other than ofs://.\");\n+    }\n+    authority = uri.getAuthority();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDA0OQ==", "bodyText": "initOFSPath was designed to take a path without scheme or authority though. I didn't intend to change the parsing logic too much but I might do a refactoring to make it more consistent overall since you mentioned.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428264049", "createdAt": "2020-05-20T19:41:36Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -66,7 +70,13 @@\n   static final String OFS_MOUNT_TMP_VOLUMENAME = \"tmp\";\n \n   OFSPath(Path path) {\n-    String pathStr = path.toUri().getPath();\n+    URI uri = path.toUri();\n+    // scheme is case-insensitive\n+    if (!uri.getScheme().toLowerCase().equals(OZONE_OFS_URI_SCHEME)) {\n+      throw new ParseException(\"Can't parse schemes other than ofs://.\");\n+    }\n+    authority = uri.getAuthority();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MzAzMw=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzUwNzE2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo1NTo0MVrOGX2nqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo1NTo0MVrOGX2nqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NTMyMA==", "bodyText": "Thinking more, do we need this, from above uri, we can get authority and check if it is empty or nulll and then throw error. So, in this way, we don't need to convert path to URI again.", "url": "https://github.com/apache/ozone/pull/941#discussion_r427665320", "createdAt": "2020-05-19T23:55:41Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -78,8 +88,8 @@ private void initOFSPath(String pathStr) {\n     // pathStr should not have authority\n     try {\n       URI uri = new URI(pathStr);\n-      String authority = uri.getAuthority();\n-      if (authority != null && !authority.isEmpty()) {\n+      String auth = uri.getAuthority();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NjcwOTIzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzoyMjozMFrOGYWJDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NzoyNlrOGcr1iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg==", "bodyText": "Should it be first username and then .Trash ? like ofs:///vol1/bucket1/username/.Trash  ?\nThis is default iml at FileSystem.java\n\n /**\n   * Get the root directory of Trash for current user when the path specified\n   * is deleted.\n   *\n   * @param path the trash root of the path to be determined.\n   * @return the default implementation returns {@code /user/$USER/.Trash}\n   */\n  public Path getTrashRoot(Path path) {\n    return this.makeQualified(new Path(getHomeDirectory().toUri().getPath(),\n        TRASH_PREFIX));\n  }\n\nCC: @mukul1987 @sadanand48 @arp7 : I think this should be checked with Sadanand implementation as well to be in sync?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428181772", "createdAt": "2020-05-20T17:22:30Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwODk0Mg==", "bodyText": "Given we don't have a home directory per bucket, I think this PR took an approach similar to encryption zone where the .Trash is created per bucket, i.e., ofs://vol1/bucket1/.Trash/username, which have a common trash root per bucket.\nIf we take ofs:///vol1/bucket1/username/.Trash, we won't have a common trash root. As a result, the trash clean up will be expensive as we don't have a common root per bucket to check the expired trash checkpoints.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428208942", "createdAt": "2020-05-20T18:08:13Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MzU1Ng==", "bodyText": "Thanks @xiaoyuyao for explanation. I agree on flipping folders here.\nMy point is: after looking at Trash impl demo today, in o3fs we seems to be getting /.Trash\nMy point is, this o3fs and ofs trash directories should be in sync. so that emptier will not omit the  trash dirs created by o3fs?\nAlso inside OM Server, we get trashRoots from the fs configured as OM. That should default fs. When we configure ofs, it should also consider trash dirs created by o3fs? I think yes, so that they both should be in sync.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428253556", "createdAt": "2020-05-20T19:21:04Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2OTg0NQ==", "bodyText": "I agree o3fs and ofs trash locations should be the same. We should refactor the common parts to some new shared classes later.\nI didn't get the \"OM Server\" part though. IMO getTrashRoot is purely a client-side method?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428269845", "createdAt": "2020-05-20T19:52:52Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4NjU1OQ==", "bodyText": "Yes its client side logic. TrashEmptier uses fs to get the directories and this TrashEmptier runs inside NN, so here it will be in OM server.\nIf we wanted to reuse the logic, all dirs should be in sync and TrashEmptier will get the trashRoots and cleanup.\nFor your ref below is the TrashEmptier code:\ntry {\n         now = Time.now();\n         if (now >= end) {\n           Collection<FileStatus> trashRoots;\n           trashRoots = fs.getTrashRoots(true);      // list all trash dirs\n\n           for (FileStatus trashRoot : trashRoots) {   // dump each trash\n             if (!trashRoot.isDirectory())\n               continue;\n             try {\n               TrashPolicyDefault trash = new TrashPolicyDefault(fs, conf);\n               trash.deleteCheckpoint(trashRoot.getPath(), false);\n               trash.createCheckpoint(trashRoot.getPath(), new Date(now));\n             } catch (IOException e) {\n               LOG.warn(\"Trash caught: \"+e+\". Skipping \" +\n                   trashRoot.getPath() + \".\");\n             } \n           }\n         }\n       } catch (Exception e) {\n         LOG.warn(\"RuntimeException during Trash.Emptier.run(): \", e); \n       }", "url": "https://github.com/apache/ozone/pull/941#discussion_r428286559", "createdAt": "2020-05-20T20:24:59Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5ODE2OQ==", "bodyText": "I am in favor of maintaining trash roots for ofs and o3fs the same (We should override getTrashRoot for o3fs similar to this Jira), as @umamaheswararao said in the first phase, we can reuse the code of hdfs logic and run the same in OM with OFS filesystem object and also for this we need to implement fs.getTrashRoots return path for all buckets in the system(Which can be done in a separate Jira).", "url": "https://github.com/apache/ozone/pull/941#discussion_r428298169", "createdAt": "2020-05-20T20:47:53Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NzYyOA==", "bodyText": "@umamaheswararao I think we are on the same page. Both o3fs and ofs have Trash per bucket. And code should be reused.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428377628", "createdAt": "2020-05-21T00:14:51Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTUyOA==", "bodyText": "I agree we should reuse some code when we implement trash for o3fs.", "url": "https://github.com/apache/ozone/pull/941#discussion_r432731528", "createdAt": "2020-05-29T20:57:26Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njg0OTY5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODowMDo0N1rOGYXizg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1MzoxOFrOGYbiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNDc1MA==", "bodyText": "should we change initOFSPath to take URI as parameter so that all the URI check can be done inside initOFSPath?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428204750", "createdAt": "2020-05-20T18:00:47Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -78,8 +88,8 @@ private void initOFSPath(String pathStr) {\n     // pathStr should not have authority", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MDA5Nw==", "bodyText": "@bharatviswa504  also mentioned this. Will do.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428270097", "createdAt": "2020-05-20T19:53:18Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -78,8 +88,8 @@ private void initOFSPath(String pathStr) {\n     // pathStr should not have authority", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNDc1MA=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njg3ODEyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODowOToxMlrOGYX1Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOTozNDowMFrOGZh4Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg==", "bodyText": "NIT: we can use Path API to create the path safely instead of string concat.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428209482", "createdAt": "2020-05-20T18:09:12Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority).setPath(OZONE_URI_DELIMITER + volumeName +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MTIyNw==", "bodyText": "Do you mean using constructor new Path(prevPath, \"child\") and building the path step by step?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428271227", "createdAt": "2020-05-20T19:55:25Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority).setPath(OZONE_URI_DELIMITER + volumeName +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMjYwMg==", "bodyText": "Attempted in 53c19f1.\nI also explored Paths.get() but it returns java.nio.file.Paths.", "url": "https://github.com/apache/ozone/pull/941#discussion_r429422602", "createdAt": "2020-05-22T19:34:00Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority).setPath(OZONE_URI_DELIMITER + volumeName +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njg4MzYyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODoxMDoyNFrOGYX4jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDowNTowOVrOGcqgcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDMxNg==", "bodyText": "Can you also verify the key1 is moved to the proper Trash location?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428210316", "createdAt": "2020-05-20T18:10:24Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwOTc0NA==", "bodyText": "done in 31969f9", "url": "https://github.com/apache/ozone/pull/941#discussion_r432709744", "createdAt": "2020-05-29T20:05:09Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDMxNg=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njg4NTExOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODoxMDo1MVrOGYX5fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NjowMFrOGcrzQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDU1Ng==", "bodyText": "Can you add a test with skipTrash and make sure it is not moved to the Trash location?", "url": "https://github.com/apache/ozone/pull/941#discussion_r428210556", "createdAt": "2020-05-20T18:10:51Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMDk0Nw==", "bodyText": "done in 241361e.", "url": "https://github.com/apache/ozone/pull/941#discussion_r432730947", "createdAt": "2020-05-29T20:56:00Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDU1Ng=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Njg5NzgxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODoxNDo1NVrOGYYCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDo1NToyMVrOGd1ngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ==", "bodyText": "You also need to Override getTrashRoots() which returns all trash locations under the root across multiple buckets. This should be very similar to how Trash under encryption zone is handled in DistributedFileSystem#getTrashRoots().", "url": "https://github.com/apache/ozone/pull/941#discussion_r428212741", "createdAt": "2020-05-20T18:14:55Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -658,6 +658,19 @@ public String getUsername() {\n     return userName;\n   }\n \n+  /**\n+   * Get the root directory of Trash for a path in OFS.\n+   * Returns /<volumename>/<bucketname>/.Trash/<username>\n+   * Caller appends either Current or checkpoint timestamp for trash destination\n+   * @param path the trash root of the path to be determined.\n+   * @return trash root\n+   */\n+  @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5MjU0Nw==", "bodyText": "Good catch. It also seems Emptier in TrashPolicyDefault utilizes getTrashRoots(), which @umamaheswararao believes might make trash clean up easier in Ozone.", "url": "https://github.com/apache/ozone/pull/941#discussion_r428292547", "createdAt": "2020-05-20T20:36:40Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -658,6 +658,19 @@ public String getUsername() {\n     return userName;\n   }\n \n+  /**\n+   * Get the root directory of Trash for a path in OFS.\n+   * Returns /<volumename>/<bucketname>/.Trash/<username>\n+   * Caller appends either Current or checkpoint timestamp for trash destination\n+   * @param path the trash root of the path to be determined.\n+   * @return trash root\n+   */\n+  @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MDM1NQ==", "bodyText": "Created HDDS-3705 to track getTrashRoots impl.", "url": "https://github.com/apache/ozone/pull/941#discussion_r433940355", "createdAt": "2020-06-02T14:55:21Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -658,6 +658,19 @@ public String getUsername() {\n     return userName;\n   }\n \n+  /**\n+   * Get the root directory of Trash for a path in OFS.\n+   * Returns /<volumename>/<bucketname>/.Trash/<username>\n+   * Caller appends either Current or checkpoint timestamp for trash destination\n+   * @param path the trash root of the path to be determined.\n+   * @return trash root\n+   */\n+  @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ=="}, "originalCommit": {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4319, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}