{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTA1Mjcy", "number": 1628, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0OTo1OVrOFCp5Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDozNjoyOVrOFtBCfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI3ODM0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AuthorizationV4QueryParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0OTo1OVrOIB7pig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo0OTo1OVrOIB7pig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5Njc3OA==", "bodyText": "https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\nThis has X-Amz-Expires, we are not considering this param", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538896778", "createdAt": "2020-12-08T23:49:59Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AuthorizationV4QueryParser.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.SignatureInfo.Version;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parser for getting auth info from query parameters.\n+ * <p>\n+ * See: https://docs.aws.amazon\n+ * .com/AmazonS3/latest/API/sigv4-query-string-auth.html\n+ */\n+public class AuthorizationV4QueryParser implements SignatureParser {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AuthorizationV4QueryParser.class);\n+\n+  private final MultivaluedMap<String, String> queryParameters;\n+\n+  public AuthorizationV4QueryParser(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    this.queryParameters = queryParameters;\n+  }\n+\n+  @Override\n+  public SignatureInfo parseSignature() throws OS3Exception {\n+\n+    if (!queryParameters.containsKey(\"X-Amz-Signature\")) {\n+      return null;\n+    }\n+\n+    Credential credential =\n+        new Credential(queryParameters.getFirst(\"X-Amz-Credential\"));\n+\n+    return new SignatureInfo(\n+        Version.V4,\n+        queryParameters.getFirst(\"X-Amz-Date\"),\n+        credential.getAccessKeyID(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzI4OTYxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AuthorizationV4HeaderParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1NDowMlrOIB7vxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMzo1NDozNVrOIB7wtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODM3Mg==", "bodyText": "AuthorizationV4HeaderParser.IDENTIFIER=AWS4", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538898372", "createdAt": "2020-12-08T23:54:02Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AuthorizationV4HeaderParser.java", "diffHunk": "@@ -1,86 +1,78 @@\n /**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership.  The ASF\n- * licenses this file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n  * <p>\n  * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n+package org.apache.hadoop.ozone.s3.signature;\n \n-package org.apache.hadoop.ozone.s3.header;\n-\n+import java.time.LocalDate;\n+import java.util.Collection;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Preconditions;\n-import org.apache.commons.codec.DecoderException;\n-import org.apache.commons.codec.binary.Hex;\n import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n import org.apache.hadoop.ozone.s3.exception.S3ErrorTable;\n+import org.apache.hadoop.ozone.s3.signature.SignatureInfo.Version;\n import org.apache.hadoop.util.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.time.LocalDate;\n-import java.util.Collection;\n \n+import com.google.common.annotations.VisibleForTesting;\n import static java.time.temporal.ChronoUnit.DAYS;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.binary.Hex;\n import static org.apache.commons.lang3.StringUtils.isEmpty;\n import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.MALFORMED_HEADER;\n-import static org.apache.hadoop.ozone.s3.AWSSignatureProcessor.AWS4_SIGNING_ALGORITHM;\n-import static org.apache.hadoop.ozone.s3.AWSSignatureProcessor.DATE_FORMATTER;\n+import static org.apache.hadoop.ozone.s3.signature.SignatureProcessor.AWS4_SIGNING_ALGORITHM;\n+import static org.apache.hadoop.ozone.s3.signature.SignatureProcessor.DATE_FORMATTER;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * S3 Authorization header.\n- * Ref: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using\n- * -authorization-header.html\n+ * Class to parse v4 auth information from header.\n  */\n-public class AuthorizationHeaderV4 {\n+public class AuthorizationV4HeaderParser implements SignatureParser {\n \n-  private final static Logger LOG = LoggerFactory.getLogger(\n-      AuthorizationHeaderV4.class);\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AuthorizationV4HeaderParser.class);\n \n   private final static String CREDENTIAL = \"Credential=\";\n   private final static String SIGNEDHEADERS = \"SignedHeaders=\";\n   private final static String SIGNATURE = \"Signature=\";\n \n   private String authHeader;\n-  private String algorithm;\n-  private String credential;\n-  private String signedHeadersStr;\n-  private String signature;\n-  private Credential credentialObj;\n-  private Collection<String> signedHeaders;\n \n-  /**\n-   * Construct AuthorizationHeader object.\n-   * @param header\n-   */\n-  public AuthorizationHeaderV4(String header) throws OS3Exception {\n-    Preconditions.checkNotNull(header);\n-    this.authHeader = header;\n-    parseAuthHeader();\n+  public AuthorizationV4HeaderParser(String authHeader) {\n+    this.authHeader = authHeader;\n   }\n \n   /**\n    * This method parses authorization header.\n+   * <p>\n+   * Authorization Header sample:\n+   * AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1/s3\n+   * /aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date,\n+   * Signature\n+   * =db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\n    *\n-   *  Authorization Header sample:\n-   *  AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1/s3\n-   *  /aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date,\n-   * Signature=db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\n    * @throws OS3Exception\n    */\n   @SuppressWarnings(\"StringSplitter\")\n-  public void parseAuthHeader() throws OS3Exception {\n+  @Override\n+  public SignatureInfo parseSignature() throws OS3Exception {\n+    if (authHeader == null || authHeader\n+        .startsWith(AuthorizationV2HeaderParser.IDENTIFIER + \" \")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODYxMw==", "bodyText": "V2 starts with AWS, V4 Starts with AWS4", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538898613", "createdAt": "2020-12-08T23:54:35Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AuthorizationV4HeaderParser.java", "diffHunk": "@@ -1,86 +1,78 @@\n /**\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership.  The ASF\n- * licenses this file to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n  * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n  * <p>\n  * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations under\n- * the License.\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n+package org.apache.hadoop.ozone.s3.signature;\n \n-package org.apache.hadoop.ozone.s3.header;\n-\n+import java.time.LocalDate;\n+import java.util.Collection;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Preconditions;\n-import org.apache.commons.codec.DecoderException;\n-import org.apache.commons.codec.binary.Hex;\n import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n import org.apache.hadoop.ozone.s3.exception.S3ErrorTable;\n+import org.apache.hadoop.ozone.s3.signature.SignatureInfo.Version;\n import org.apache.hadoop.util.StringUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.time.LocalDate;\n-import java.util.Collection;\n \n+import com.google.common.annotations.VisibleForTesting;\n import static java.time.temporal.ChronoUnit.DAYS;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.binary.Hex;\n import static org.apache.commons.lang3.StringUtils.isEmpty;\n import static org.apache.commons.lang3.StringUtils.isNotEmpty;\n import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.MALFORMED_HEADER;\n-import static org.apache.hadoop.ozone.s3.AWSSignatureProcessor.AWS4_SIGNING_ALGORITHM;\n-import static org.apache.hadoop.ozone.s3.AWSSignatureProcessor.DATE_FORMATTER;\n+import static org.apache.hadoop.ozone.s3.signature.SignatureProcessor.AWS4_SIGNING_ALGORITHM;\n+import static org.apache.hadoop.ozone.s3.signature.SignatureProcessor.DATE_FORMATTER;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * S3 Authorization header.\n- * Ref: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using\n- * -authorization-header.html\n+ * Class to parse v4 auth information from header.\n  */\n-public class AuthorizationHeaderV4 {\n+public class AuthorizationV4HeaderParser implements SignatureParser {\n \n-  private final static Logger LOG = LoggerFactory.getLogger(\n-      AuthorizationHeaderV4.class);\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AuthorizationV4HeaderParser.class);\n \n   private final static String CREDENTIAL = \"Credential=\";\n   private final static String SIGNEDHEADERS = \"SignedHeaders=\";\n   private final static String SIGNATURE = \"Signature=\";\n \n   private String authHeader;\n-  private String algorithm;\n-  private String credential;\n-  private String signedHeadersStr;\n-  private String signature;\n-  private Credential credentialObj;\n-  private Collection<String> signedHeaders;\n \n-  /**\n-   * Construct AuthorizationHeader object.\n-   * @param header\n-   */\n-  public AuthorizationHeaderV4(String header) throws OS3Exception {\n-    Preconditions.checkNotNull(header);\n-    this.authHeader = header;\n-    parseAuthHeader();\n+  public AuthorizationV4HeaderParser(String authHeader) {\n+    this.authHeader = authHeader;\n   }\n \n   /**\n    * This method parses authorization header.\n+   * <p>\n+   * Authorization Header sample:\n+   * AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1/s3\n+   * /aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date,\n+   * Signature\n+   * =db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\n    *\n-   *  Authorization Header sample:\n-   *  AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1/s3\n-   *  /aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date,\n-   * Signature=db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\n    * @throws OS3Exception\n    */\n   @SuppressWarnings(\"StringSplitter\")\n-  public void parseAuthHeader() throws OS3Exception {\n+  @Override\n+  public SignatureInfo parseSignature() throws OS3Exception {\n+    if (authHeader == null || authHeader\n+        .startsWith(AuthorizationV2HeaderParser.IDENTIFIER + \" \")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODM3Mg=="}, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzM1NzE0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDoxODoyMlrOIB8U_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowODozMFrOICMl1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwNzkwMg==", "bodyText": "Can we combine this method and below.\nAnd also can we call this method like createStringToSign, it is confusing as it says createSignatureBase IMO.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538907902", "createdAt": "2020-12-09T00:18:22Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  private static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NDM1OA==", "bodyText": "Sure, we can. But I kept them separated to make them more testable with separating the logic to extract information from the logic to create the sign.\nI added the @VisibleForTesting annotation and simplified the test (mocks are removed) to show this concept, but I am open to merge it if you don't like it.\n(See 48676ea0b)", "url": "https://github.com/apache/ozone/pull/1628#discussion_r539174358", "createdAt": "2020-12-09T10:08:30Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  private static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkwNzkwMg=="}, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzQxMTEyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDozODo0NFrOIB8ydw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoxMjozOVrOICMxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNTQ0Nw==", "bodyText": "Here the debug is removed, do we want to add the same when OS3Exception also?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538915447", "createdAt": "2020-12-09T00:38:44Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "diffHunk": "@@ -130,14 +139,29 @@ private OzoneClient getClient(OzoneConfiguration config)\n     } catch (Throwable t) {\n       // For any other critical errors during object creation throw Internal\n       // error.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Error during Client Creation: \", t);\n-      }\n+      //      if (LOG.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NzI0OQ==", "bodyText": "Good, question. I am thinking what supposed to be the right error handling.\nAFAIK all of these exceptions are related to the user / input errors. They are not really application errors. User errors are not required to be logged, IMHO a permission denied is part of the normal business.\nI would restore the LOG.isDebugEnabled() here, if you agree...  (8fe1202)", "url": "https://github.com/apache/ozone/pull/1628#discussion_r539177249", "createdAt": "2020-12-09T10:12:39Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "diffHunk": "@@ -130,14 +139,29 @@ private OzoneClient getClient(OzoneConfiguration config)\n     } catch (Throwable t) {\n       // For any other critical errors during object creation throw Internal\n       // error.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Error during Client Creation: \", t);\n-      }\n+      //      if (LOG.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNTQ0Nw=="}, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzQ0NzIwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDo1MTo0NFrOIB9GEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMDo1MTo0NFrOIB9GEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMDQ2Ng==", "bodyText": "Minor: Move this also inside isDebugEnabled, here it is string, I believe we don't require LOG.isDebugEnabled() right?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r538920466", "createdAt": "2020-12-09T00:51:44Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  private static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        context.getUriInfo().getQueryParameters());\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      Map<String, String> headers,\n+      MultivaluedMap<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope, canonicalRequest;\n+    credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(headers.get(X_AMAZ_DATE) + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams);\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+    }\n+\n+    LOG.debug(\"StringToSign:[{}]\", strToSign);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b230dfae488ac8f592398fe9fa6fe82b461331"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4NzQ5OTIzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMDo0ODozOFrOI7sFlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQwODo0NDozN1rOI_7NhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ1OTIyMQ==", "bodyText": "Minor: Unused method.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r599459221", "createdAt": "2021-03-23T10:48:38Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "diffHunk": "@@ -138,6 +146,21 @@ private OzoneClient getClient(OzoneConfiguration config)\n     return ozoneClient;\n   }\n \n+  @NotNull\n+  @VisibleForTesting\n+  OzoneClient createOzoneClient() throws IOException {\n+    if (omServiceID == null) {\n+      return OzoneClientFactory.getRpcClient(ozoneConfiguration);\n+    } else {\n+      // As in HA case, we need to pass om service ID.\n+      return OzoneClientFactory.getRpcClient(omServiceID,\n+          ozoneConfiguration);\n+    }\n+  }\n+\n+  private void getSignatureInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzkwMTMxNw==", "bodyText": "Thanks, removed.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603901317", "createdAt": "2021-03-30T08:44:37Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/OzoneClientProducer.java", "diffHunk": "@@ -138,6 +146,21 @@ private OzoneClient getClient(OzoneConfiguration config)\n     return ozoneClient;\n   }\n \n+  @NotNull\n+  @VisibleForTesting\n+  OzoneClient createOzoneClient() throws IOException {\n+    if (omServiceID == null) {\n+      return OzoneClientFactory.getRpcClient(ozoneConfiguration);\n+    } else {\n+      // As in HA case, we need to pass om service ID.\n+      return OzoneClientFactory.getRpcClient(omServiceID,\n+          ozoneConfiguration);\n+    }\n+  }\n+\n+  private void getSignatureInfo() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ1OTIyMQ=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4NzUwNjg5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/endpoint/BucketEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMDo1MDoyMFrOI7sKFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQwODo0NDozMVrOI_7NPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ2MDM3NQ==", "bodyText": "Minor: Unnecessary change", "url": "https://github.com/apache/ozone/pull/1628#discussion_r599460375", "createdAt": "2021-03-23T10:50:20Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/endpoint/BucketEndpoint.java", "diffHunk": "@@ -57,6 +57,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzkwMTI0NA==", "bodyText": "Thanks. reverted.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603901244", "createdAt": "2021-03-30T08:44:31Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/endpoint/BucketEndpoint.java", "diffHunk": "@@ -57,6 +57,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ2MDM3NQ=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4NzU4ODIxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AWSSignatureProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMTowOTo1M1rOI7s8Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQwODozNjowMVrOI_61Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ3MzIyNg==", "bodyText": "Question: why do we convert header keys to lowercase?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r599473226", "createdAt": "2021-03-23T11:09:53Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AWSSignatureProcessor.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.hadoop.ozone.s3.HeaderPreprocessor;\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.SignatureInfo.Version;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parser to process AWS V2 & V4 auth request. Creates string to sign and auth\n+ * header. For more details refer to AWS documentation https://docs.aws\n+ * .amazon.com/general/latest/gr/sigv4-create-canonical-request.html.\n+ **/\n+@RequestScoped\n+public class AWSSignatureProcessor implements SignatureProcessor {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AWSSignatureProcessor.class);\n+\n+  @Context\n+  private ContainerRequestContext context;\n+\n+  public SignatureInfo parseSignature() throws OS3Exception {\n+\n+    LowerCaseKeyStringMap headers =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzg5NTA0Ng==", "bodyText": "Good question, but I am not sure. As far as I see it's added in #1098 I think I just kept the same logic what we used before...", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603895046", "createdAt": "2021-03-30T08:36:01Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/AWSSignatureProcessor.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.hadoop.ozone.s3.HeaderPreprocessor;\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.SignatureInfo.Version;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Parser to process AWS V2 & V4 auth request. Creates string to sign and auth\n+ * header. For more details refer to AWS documentation https://docs.aws\n+ * .amazon.com/general/latest/gr/sigv4-create-canonical-request.html.\n+ **/\n+@RequestScoped\n+public class AWSSignatureProcessor implements SignatureProcessor {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AWSSignatureProcessor.class);\n+\n+  @Context\n+  private ContainerRequestContext context;\n+\n+  public SignatureInfo parseSignature() throws OS3Exception {\n+\n+    LowerCaseKeyStringMap headers =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ3MzIyNg=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxMjE2Mzk0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxMDo1Njo0MFrOI_QT7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMFQwODo0NDoyMVrOI_7Mtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE5ODQ0Ng==", "bodyText": "Can we do Log here?\nI see it is already logged when debug enabled. do we want to remove this?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603198446", "createdAt": "2021-03-29T10:56:40Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -125,7 +127,7 @@ public static String createSignatureBase(\n         headers,\n         queryParams,\n         !signatureInfo.isSignPayload());\n-\n+    System.out.println(canonicalRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae957803458a1c8f59cd77979e869e9136e6bbe8"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzkwMTExMQ==", "bodyText": "Yup, thanks. Removed.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603901111", "createdAt": "2021-03-30T08:44:21Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -125,7 +127,7 @@ public static String createSignatureBase(\n         headers,\n         queryParams,\n         !signatureInfo.isSignPayload());\n-\n+    System.out.println(canonicalRequest);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzE5ODQ0Ng=="}, "originalCommit": {"oid": "ae957803458a1c8f59cd77979e869e9136e6bbe8"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxMjE5NDQ1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxMTowNToxNFrOI_QmMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDozODoxNlrOJBgD6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMzEyMg==", "bodyText": "Why are we doing this?\nhttps://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html\nHere there is an example urlEncode method is given, don't see such replace here?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603203122", "createdAt": "2021-03-29T11:05:14Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  public static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        fromMultiValueToSingleValueMap(\n+            context.getUriInfo().getQueryParameters()));\n+  }\n+\n+  @VisibleForTesting\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      LowerCaseKeyStringMap headers,\n+      Map<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(signatureInfo.getDateTime() + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    String canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams,\n+        !signatureInfo.isSignPayload());\n+    System.out.println(canonicalRequest);\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+      LOG.debug(\"StringToSign:[{}]\", strToSign);\n+    }\n+\n+    return strToSign.toString();\n+  }\n+\n+  public static Map<String, String> fromMultiValueToSingleValueMap(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    Map<String, String> result = new HashMap<>();\n+    for (String key : queryParameters.keySet()) {\n+      result.put(key, queryParameters.getFirst(key));\n+    }\n+    return result;\n+  }\n+\n+  public static String hash(String payload) throws NoSuchAlgorithmException {\n+    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+    md.update(payload.getBytes(UTF_8));\n+    return Hex.encode(md.digest()).toLowerCase();\n+  }\n+\n+  @VisibleForTesting\n+  public static String buildCanonicalRequest(\n+      String schema,\n+      String method,\n+      String uri,\n+      String signedHeaders,\n+      Map<String, String> headers,\n+      Map<String, String> queryParams,\n+      boolean unsignedPayload\n+  ) throws OS3Exception {\n+\n+    Iterable<String> parts = split(\"/\", uri);\n+    List<String> encParts = new ArrayList<>();\n+    for (String p : parts) {\n+      encParts.add(urlEncode(p));\n+    }\n+    String canonicalUri = join(\"/\", encParts);\n+\n+    String canonicalQueryStr = getQueryParamString(queryParams);\n+\n+    StringBuilder canonicalHeaders = new StringBuilder();\n+\n+    for (String header : StringUtils.getStringCollection(signedHeaders, \";\")) {\n+      canonicalHeaders.append(header.toLowerCase());\n+      canonicalHeaders.append(\":\");\n+      if (headers.containsKey(header)) {\n+        String headerValue = headers.get(header);\n+        canonicalHeaders.append(headerValue);\n+        canonicalHeaders.append(NEWLINE);\n+\n+        // Set for testing purpose only to skip date and host validation.\n+        validateSignedHeader(schema, header, headerValue);\n+\n+      } else {\n+        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n+            \"request but requested to be signed.\");\n+      }\n+    }\n+\n+    String payloadHash;\n+    if (UNSIGNED_PAYLOAD.equals(\n+        headers.get(X_AMZ_CONTENT_SHA256)) || unsignedPayload) {\n+      payloadHash = UNSIGNED_PAYLOAD;\n+    } else {\n+      payloadHash = headers.get(X_AMZ_CONTENT_SHA256);\n+    }\n+    String canonicalRequest = method + NEWLINE\n+        + canonicalUri + NEWLINE\n+        + canonicalQueryStr + NEWLINE\n+        + canonicalHeaders + NEWLINE\n+        + signedHeaders + NEWLINE\n+        + payloadHash;\n+    return canonicalRequest;\n+  }\n+\n+  /**\n+   * String join that also works with empty strings.\n+   *\n+   * @return joined string\n+   */\n+  private static String join(String glue, List<String> parts) {\n+    StringBuilder result = new StringBuilder();\n+    boolean addSeparator = false;\n+    for (String p : parts) {\n+      if (addSeparator) {\n+        result.append(glue);\n+      }\n+      result.append(p);\n+      addSeparator = true;\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns matching strings.\n+   *\n+   * @param regex Regular expression to split by\n+   * @param whole The string to split\n+   * @return pieces\n+   */\n+  private static Iterable<String> split(String regex, String whole) {\n+    Pattern p = Pattern.compile(regex);\n+    Matcher m = p.matcher(whole);\n+    List<String> result = new ArrayList<>();\n+    int pos = 0;\n+    while (m.find()) {\n+      result.add(whole.substring(pos, m.start()));\n+      pos = m.end();\n+    }\n+    result.add(whole.substring(pos));\n+    return result;\n+  }\n+\n+  private static String urlEncode(String str) {\n+    try {\n+\n+      return URLEncoder.encode(str, UTF_8.name())\n+          .replaceAll(\"\\\\+\", \"%20\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzkwMDQ3Mg==", "bodyText": "Again, it's a good question, but I don't know exactly. I didn't modify the logic in this patch.\nIt was added by Ajay in apache/hadoop#561. I tried to re-organize the URLEncoder, but tests started to fail so I decided to keep all the existing logic as is.\nWe can try to clean up it, but I would prefer to do it outside of this patch (just to make clear what is related to the simple reorganization and what is related to a logic change...)", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603900472", "createdAt": "2021-03-30T08:43:30Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  public static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        fromMultiValueToSingleValueMap(\n+            context.getUriInfo().getQueryParameters()));\n+  }\n+\n+  @VisibleForTesting\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      LowerCaseKeyStringMap headers,\n+      Map<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(signatureInfo.getDateTime() + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    String canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams,\n+        !signatureInfo.isSignPayload());\n+    System.out.println(canonicalRequest);\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+      LOG.debug(\"StringToSign:[{}]\", strToSign);\n+    }\n+\n+    return strToSign.toString();\n+  }\n+\n+  public static Map<String, String> fromMultiValueToSingleValueMap(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    Map<String, String> result = new HashMap<>();\n+    for (String key : queryParameters.keySet()) {\n+      result.put(key, queryParameters.getFirst(key));\n+    }\n+    return result;\n+  }\n+\n+  public static String hash(String payload) throws NoSuchAlgorithmException {\n+    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+    md.update(payload.getBytes(UTF_8));\n+    return Hex.encode(md.digest()).toLowerCase();\n+  }\n+\n+  @VisibleForTesting\n+  public static String buildCanonicalRequest(\n+      String schema,\n+      String method,\n+      String uri,\n+      String signedHeaders,\n+      Map<String, String> headers,\n+      Map<String, String> queryParams,\n+      boolean unsignedPayload\n+  ) throws OS3Exception {\n+\n+    Iterable<String> parts = split(\"/\", uri);\n+    List<String> encParts = new ArrayList<>();\n+    for (String p : parts) {\n+      encParts.add(urlEncode(p));\n+    }\n+    String canonicalUri = join(\"/\", encParts);\n+\n+    String canonicalQueryStr = getQueryParamString(queryParams);\n+\n+    StringBuilder canonicalHeaders = new StringBuilder();\n+\n+    for (String header : StringUtils.getStringCollection(signedHeaders, \";\")) {\n+      canonicalHeaders.append(header.toLowerCase());\n+      canonicalHeaders.append(\":\");\n+      if (headers.containsKey(header)) {\n+        String headerValue = headers.get(header);\n+        canonicalHeaders.append(headerValue);\n+        canonicalHeaders.append(NEWLINE);\n+\n+        // Set for testing purpose only to skip date and host validation.\n+        validateSignedHeader(schema, header, headerValue);\n+\n+      } else {\n+        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n+            \"request but requested to be signed.\");\n+      }\n+    }\n+\n+    String payloadHash;\n+    if (UNSIGNED_PAYLOAD.equals(\n+        headers.get(X_AMZ_CONTENT_SHA256)) || unsignedPayload) {\n+      payloadHash = UNSIGNED_PAYLOAD;\n+    } else {\n+      payloadHash = headers.get(X_AMZ_CONTENT_SHA256);\n+    }\n+    String canonicalRequest = method + NEWLINE\n+        + canonicalUri + NEWLINE\n+        + canonicalQueryStr + NEWLINE\n+        + canonicalHeaders + NEWLINE\n+        + signedHeaders + NEWLINE\n+        + payloadHash;\n+    return canonicalRequest;\n+  }\n+\n+  /**\n+   * String join that also works with empty strings.\n+   *\n+   * @return joined string\n+   */\n+  private static String join(String glue, List<String> parts) {\n+    StringBuilder result = new StringBuilder();\n+    boolean addSeparator = false;\n+    for (String p : parts) {\n+      if (addSeparator) {\n+        result.append(glue);\n+      }\n+      result.append(p);\n+      addSeparator = true;\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns matching strings.\n+   *\n+   * @param regex Regular expression to split by\n+   * @param whole The string to split\n+   * @return pieces\n+   */\n+  private static Iterable<String> split(String regex, String whole) {\n+    Pattern p = Pattern.compile(regex);\n+    Matcher m = p.matcher(whole);\n+    List<String> result = new ArrayList<>();\n+    int pos = 0;\n+    while (m.find()) {\n+      result.add(whole.substring(pos, m.start()));\n+      pos = m.end();\n+    }\n+    result.add(whole.substring(pos));\n+    return result;\n+  }\n+\n+  private static String urlEncode(String str) {\n+    try {\n+\n+      return URLEncoder.encode(str, UTF_8.name())\n+          .replaceAll(\"\\\\+\", \"%20\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMzEyMg=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU1MzY0Mw==", "bodyText": "Yes, this is completely old code. I just see one new change.\n\nWe can try to clean up it, but I would prefer to do it outside of this patch (just to make clear what is related to the >simple reorganization and what is related to a logic change...)\n\nAgreed, already this is a big change, no need of further refactor.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r605553643", "createdAt": "2021-04-01T10:38:16Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  public static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        fromMultiValueToSingleValueMap(\n+            context.getUriInfo().getQueryParameters()));\n+  }\n+\n+  @VisibleForTesting\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      LowerCaseKeyStringMap headers,\n+      Map<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(signatureInfo.getDateTime() + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    String canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams,\n+        !signatureInfo.isSignPayload());\n+    System.out.println(canonicalRequest);\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+      LOG.debug(\"StringToSign:[{}]\", strToSign);\n+    }\n+\n+    return strToSign.toString();\n+  }\n+\n+  public static Map<String, String> fromMultiValueToSingleValueMap(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    Map<String, String> result = new HashMap<>();\n+    for (String key : queryParameters.keySet()) {\n+      result.put(key, queryParameters.getFirst(key));\n+    }\n+    return result;\n+  }\n+\n+  public static String hash(String payload) throws NoSuchAlgorithmException {\n+    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+    md.update(payload.getBytes(UTF_8));\n+    return Hex.encode(md.digest()).toLowerCase();\n+  }\n+\n+  @VisibleForTesting\n+  public static String buildCanonicalRequest(\n+      String schema,\n+      String method,\n+      String uri,\n+      String signedHeaders,\n+      Map<String, String> headers,\n+      Map<String, String> queryParams,\n+      boolean unsignedPayload\n+  ) throws OS3Exception {\n+\n+    Iterable<String> parts = split(\"/\", uri);\n+    List<String> encParts = new ArrayList<>();\n+    for (String p : parts) {\n+      encParts.add(urlEncode(p));\n+    }\n+    String canonicalUri = join(\"/\", encParts);\n+\n+    String canonicalQueryStr = getQueryParamString(queryParams);\n+\n+    StringBuilder canonicalHeaders = new StringBuilder();\n+\n+    for (String header : StringUtils.getStringCollection(signedHeaders, \";\")) {\n+      canonicalHeaders.append(header.toLowerCase());\n+      canonicalHeaders.append(\":\");\n+      if (headers.containsKey(header)) {\n+        String headerValue = headers.get(header);\n+        canonicalHeaders.append(headerValue);\n+        canonicalHeaders.append(NEWLINE);\n+\n+        // Set for testing purpose only to skip date and host validation.\n+        validateSignedHeader(schema, header, headerValue);\n+\n+      } else {\n+        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n+            \"request but requested to be signed.\");\n+      }\n+    }\n+\n+    String payloadHash;\n+    if (UNSIGNED_PAYLOAD.equals(\n+        headers.get(X_AMZ_CONTENT_SHA256)) || unsignedPayload) {\n+      payloadHash = UNSIGNED_PAYLOAD;\n+    } else {\n+      payloadHash = headers.get(X_AMZ_CONTENT_SHA256);\n+    }\n+    String canonicalRequest = method + NEWLINE\n+        + canonicalUri + NEWLINE\n+        + canonicalQueryStr + NEWLINE\n+        + canonicalHeaders + NEWLINE\n+        + signedHeaders + NEWLINE\n+        + payloadHash;\n+    return canonicalRequest;\n+  }\n+\n+  /**\n+   * String join that also works with empty strings.\n+   *\n+   * @return joined string\n+   */\n+  private static String join(String glue, List<String> parts) {\n+    StringBuilder result = new StringBuilder();\n+    boolean addSeparator = false;\n+    for (String p : parts) {\n+      if (addSeparator) {\n+        result.append(glue);\n+      }\n+      result.append(p);\n+      addSeparator = true;\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns matching strings.\n+   *\n+   * @param regex Regular expression to split by\n+   * @param whole The string to split\n+   * @return pieces\n+   */\n+  private static Iterable<String> split(String regex, String whole) {\n+    Pattern p = Pattern.compile(regex);\n+    Matcher m = p.matcher(whole);\n+    List<String> result = new ArrayList<>();\n+    int pos = 0;\n+    while (m.find()) {\n+      result.add(whole.substring(pos, m.start()));\n+      pos = m.end();\n+    }\n+    result.add(whole.substring(pos));\n+    return result;\n+  }\n+\n+  private static String urlEncode(String str) {\n+    try {\n+\n+      return URLEncoder.encode(str, UTF_8.name())\n+          .replaceAll(\"\\\\+\", \"%20\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwMzEyMg=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgxMjIyMTAyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/test/java/org/apache/hadoop/ozone/s3/signature/TestStringToSignProducer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yOVQxMToxMjoyNVrOI_Q1lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDozOTo0N1rOJBgHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNzA2Mg==", "bodyText": "Not understood here message is String to sign is invalid\nBut signatureBase is matching with signature.\nCould you explain how/what is being tested here and how the value is generated", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603207062", "createdAt": "2021-03-29T11:12:25Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/test/java/org/apache/hadoop/ozone/s3/signature/TestStringToSignProducer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hadoop.ozone.s3.HeaderPreprocessor;\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test string2sign creation.\n+ */\n+public class TestStringToSignProducer {\n+\n+  @Test\n+  public void test() throws Exception {\n+\n+    LowerCaseKeyStringMap headers = new LowerCaseKeyStringMap();\n+    headers.put(\"Content-Length\", \"123\");\n+    headers.put(\"Host\", \"0.0.0.0:9878\");\n+    headers.put(\"X-AMZ-Content-Sha256\", \"Content-SHA\");\n+    headers.put(\"X-AMZ-Date\", \"123\");\n+    headers.put(\"Content-Type\", \"ozone/mpu\");\n+    headers.put(HeaderPreprocessor.ORIGINAL_CONTENT_TYPE, \"streaming\");\n+\n+    String authHeader =\n+        \"AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1\"\n+            + \"/s3/aws4_request, \"\n+            + \"SignedHeaders=host;x-amz-content-sha256;x-amz-date;\"\n+            + \"content-type, \"\n+            + \"Signature\"\n+            +\n+            \"=db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\";\n+\n+    headers.put(\"Authorization\",\n+        authHeader);\n+\n+    Map<String, String> queryParameters = new HashMap<>();\n+\n+    final SignatureInfo signatureInfo =\n+        new AuthorizationV4HeaderParser(authHeader, \"123\") {\n+          @Override\n+          public void validateDateRange(Credential credentialObj)\n+              throws OS3Exception {\n+            //NOOP\n+          }\n+        }.parseSignature();\n+\n+    headers.fixContentType();\n+\n+    final String signatureBase =\n+        StringToSignProducer.createSignatureBase(\n+            signatureInfo,\n+            \"http\",\n+            \"GET\",\n+            \"/buckets\",\n+            headers,\n+            queryParameters);\n+\n+    Assert.assertEquals(\n+        \"String to sign is invalid\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzg5NjkyMQ==", "bodyText": "I may misunderstand the question, but the message is printed out when the two values are not equal:\nFrom JUnit javadoc:\n\nAsserts that two objects are equal. If they are not, an {@link AssertionError} is thrown with the given message.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r603896921", "createdAt": "2021-03-30T08:38:35Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/test/java/org/apache/hadoop/ozone/s3/signature/TestStringToSignProducer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hadoop.ozone.s3.HeaderPreprocessor;\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test string2sign creation.\n+ */\n+public class TestStringToSignProducer {\n+\n+  @Test\n+  public void test() throws Exception {\n+\n+    LowerCaseKeyStringMap headers = new LowerCaseKeyStringMap();\n+    headers.put(\"Content-Length\", \"123\");\n+    headers.put(\"Host\", \"0.0.0.0:9878\");\n+    headers.put(\"X-AMZ-Content-Sha256\", \"Content-SHA\");\n+    headers.put(\"X-AMZ-Date\", \"123\");\n+    headers.put(\"Content-Type\", \"ozone/mpu\");\n+    headers.put(HeaderPreprocessor.ORIGINAL_CONTENT_TYPE, \"streaming\");\n+\n+    String authHeader =\n+        \"AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1\"\n+            + \"/s3/aws4_request, \"\n+            + \"SignedHeaders=host;x-amz-content-sha256;x-amz-date;\"\n+            + \"content-type, \"\n+            + \"Signature\"\n+            +\n+            \"=db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\";\n+\n+    headers.put(\"Authorization\",\n+        authHeader);\n+\n+    Map<String, String> queryParameters = new HashMap<>();\n+\n+    final SignatureInfo signatureInfo =\n+        new AuthorizationV4HeaderParser(authHeader, \"123\") {\n+          @Override\n+          public void validateDateRange(Credential credentialObj)\n+              throws OS3Exception {\n+            //NOOP\n+          }\n+        }.parseSignature();\n+\n+    headers.fixContentType();\n+\n+    final String signatureBase =\n+        StringToSignProducer.createSignatureBase(\n+            signatureInfo,\n+            \"http\",\n+            \"GET\",\n+            \"/buckets\",\n+            headers,\n+            queryParameters);\n+\n+    Assert.assertEquals(\n+        \"String to sign is invalid\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNzA2Mg=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU1NDQ3MA==", "bodyText": "Sorry for not being clear, my question is how you have got the siggnatureBase computed. I see in other test it is mentioned it is from AWS documentation, is this also from there?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r605554470", "createdAt": "2021-04-01T10:39:47Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/test/java/org/apache/hadoop/ozone/s3/signature/TestStringToSignProducer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.hadoop.ozone.s3.HeaderPreprocessor;\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test string2sign creation.\n+ */\n+public class TestStringToSignProducer {\n+\n+  @Test\n+  public void test() throws Exception {\n+\n+    LowerCaseKeyStringMap headers = new LowerCaseKeyStringMap();\n+    headers.put(\"Content-Length\", \"123\");\n+    headers.put(\"Host\", \"0.0.0.0:9878\");\n+    headers.put(\"X-AMZ-Content-Sha256\", \"Content-SHA\");\n+    headers.put(\"X-AMZ-Date\", \"123\");\n+    headers.put(\"Content-Type\", \"ozone/mpu\");\n+    headers.put(HeaderPreprocessor.ORIGINAL_CONTENT_TYPE, \"streaming\");\n+\n+    String authHeader =\n+        \"AWS4-HMAC-SHA256 Credential=AKIAJWFJK62WUTKNFJJA/20181009/us-east-1\"\n+            + \"/s3/aws4_request, \"\n+            + \"SignedHeaders=host;x-amz-content-sha256;x-amz-date;\"\n+            + \"content-type, \"\n+            + \"Signature\"\n+            +\n+            \"=db81b057718d7c1b3b8dffa29933099551c51d787b3b13b9e0f9ebed45982bf2\";\n+\n+    headers.put(\"Authorization\",\n+        authHeader);\n+\n+    Map<String, String> queryParameters = new HashMap<>();\n+\n+    final SignatureInfo signatureInfo =\n+        new AuthorizationV4HeaderParser(authHeader, \"123\") {\n+          @Override\n+          public void validateDateRange(Credential credentialObj)\n+              throws OS3Exception {\n+            //NOOP\n+          }\n+        }.parseSignature();\n+\n+    headers.fixContentType();\n+\n+    final String signatureBase =\n+        StringToSignProducer.createSignatureBase(\n+            signatureInfo,\n+            \"http\",\n+            \"GET\",\n+            \"/buckets\",\n+            headers,\n+            queryParameters);\n+\n+    Assert.assertEquals(\n+        \"String to sign is invalid\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzIwNzA2Mg=="}, "originalCommit": {"oid": "56566240b6a01609d3aad977671399b7d7d5038c"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyNzQ3MjYzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDozNjoyOVrOJBgAGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMzozNzozOFrOJBm1Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU1MjY2Ng==", "bodyText": "Question: This check is not there in the old code, newly added. Any reason for this?", "url": "https://github.com/apache/ozone/pull/1628#discussion_r605552666", "createdAt": "2021-04-01T10:36:29Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  public static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        fromMultiValueToSingleValueMap(\n+            context.getUriInfo().getQueryParameters()));\n+  }\n+\n+  @VisibleForTesting\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      LowerCaseKeyStringMap headers,\n+      Map<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(signatureInfo.getDateTime() + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    String canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams,\n+        !signatureInfo.isSignPayload());\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+      LOG.debug(\"StringToSign:[{}]\", strToSign);\n+    }\n+\n+    return strToSign.toString();\n+  }\n+\n+  public static Map<String, String> fromMultiValueToSingleValueMap(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    Map<String, String> result = new HashMap<>();\n+    for (String key : queryParameters.keySet()) {\n+      result.put(key, queryParameters.getFirst(key));\n+    }\n+    return result;\n+  }\n+\n+  public static String hash(String payload) throws NoSuchAlgorithmException {\n+    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+    md.update(payload.getBytes(UTF_8));\n+    return Hex.encode(md.digest()).toLowerCase();\n+  }\n+\n+  @VisibleForTesting\n+  public static String buildCanonicalRequest(\n+      String schema,\n+      String method,\n+      String uri,\n+      String signedHeaders,\n+      Map<String, String> headers,\n+      Map<String, String> queryParams,\n+      boolean unsignedPayload\n+  ) throws OS3Exception {\n+\n+    Iterable<String> parts = split(\"/\", uri);\n+    List<String> encParts = new ArrayList<>();\n+    for (String p : parts) {\n+      encParts.add(urlEncode(p));\n+    }\n+    String canonicalUri = join(\"/\", encParts);\n+\n+    String canonicalQueryStr = getQueryParamString(queryParams);\n+\n+    StringBuilder canonicalHeaders = new StringBuilder();\n+\n+    for (String header : StringUtils.getStringCollection(signedHeaders, \";\")) {\n+      canonicalHeaders.append(header.toLowerCase());\n+      canonicalHeaders.append(\":\");\n+      if (headers.containsKey(header)) {\n+        String headerValue = headers.get(header);\n+        canonicalHeaders.append(headerValue);\n+        canonicalHeaders.append(NEWLINE);\n+\n+        // Set for testing purpose only to skip date and host validation.\n+        validateSignedHeader(schema, header, headerValue);\n+\n+      } else {\n+        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n+            \"request but requested to be signed.\");\n+      }\n+    }\n+\n+    String payloadHash;\n+    if (UNSIGNED_PAYLOAD.equals(\n+        headers.get(X_AMZ_CONTENT_SHA256)) || unsignedPayload) {\n+      payloadHash = UNSIGNED_PAYLOAD;\n+    } else {\n+      payloadHash = headers.get(X_AMZ_CONTENT_SHA256);\n+    }\n+    String canonicalRequest = method + NEWLINE\n+        + canonicalUri + NEWLINE\n+        + canonicalQueryStr + NEWLINE\n+        + canonicalHeaders + NEWLINE\n+        + signedHeaders + NEWLINE\n+        + payloadHash;\n+    return canonicalRequest;\n+  }\n+\n+  /**\n+   * String join that also works with empty strings.\n+   *\n+   * @return joined string\n+   */\n+  private static String join(String glue, List<String> parts) {\n+    StringBuilder result = new StringBuilder();\n+    boolean addSeparator = false;\n+    for (String p : parts) {\n+      if (addSeparator) {\n+        result.append(glue);\n+      }\n+      result.append(p);\n+      addSeparator = true;\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns matching strings.\n+   *\n+   * @param regex Regular expression to split by\n+   * @param whole The string to split\n+   * @return pieces\n+   */\n+  private static Iterable<String> split(String regex, String whole) {\n+    Pattern p = Pattern.compile(regex);\n+    Matcher m = p.matcher(whole);\n+    List<String> result = new ArrayList<>();\n+    int pos = 0;\n+    while (m.find()) {\n+      result.add(whole.substring(pos, m.start()));\n+      pos = m.end();\n+    }\n+    result.add(whole.substring(pos));\n+    return result;\n+  }\n+\n+  private static String urlEncode(String str) {\n+    try {\n+\n+      return URLEncoder.encode(str, UTF_8.name())\n+          .replaceAll(\"\\\\+\", \"%20\")\n+          .replaceAll(\"%7E\", \"~\");\n+    } catch (UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static String getQueryParamString(\n+      Map<String, String> queryMap\n+  ) {\n+    List<String> params = new ArrayList<>(queryMap.keySet());\n+\n+    // Sort by name, then by value\n+    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n+        queryMap.get(o1).compareTo(queryMap.get(o2)) :\n+        o1.compareTo(o2));\n+\n+    StringBuilder result = new StringBuilder();\n+    for (String p : params) {\n+      if (!p.equals(\"X-Amz-Signature\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "261d282e3701d0b840c2d0e34828433bc022b2e4"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTY2NDU1NQ==", "bodyText": "This is the code which creates the canonical string of the query parameters to sign it later.\nIf the signature itself is added as a query parameter, it should be excluded from the string itself (to have a predictable string to sign).\nTLDR: earlier we didn't support X-Amz-Signature query parameter therefore we ignored this exclusion.", "url": "https://github.com/apache/ozone/pull/1628#discussion_r605664555", "createdAt": "2021-04-01T13:37:38Z", "author": {"login": "elek"}, "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/signature/StringToSignProducer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.s3.signature;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.MultivaluedMap;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLEncoder;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.hadoop.ozone.s3.exception.OS3Exception;\n+import org.apache.hadoop.ozone.s3.signature.AWSSignatureProcessor.LowerCaseKeyStringMap;\n+import org.apache.hadoop.util.StringUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.apache.hadoop.ozone.s3.exception.S3ErrorTable.S3_AUTHINFO_CREATION_ERROR;\n+import org.apache.kerby.util.Hex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Stateless utility to create stringToSign, the base of the signature.\n+ */\n+public final class StringToSignProducer {\n+\n+  public static final String X_AMZ_CONTENT_SHA256 = \"X-Amz-Content-SHA256\";\n+  public static final String X_AMAZ_DATE = \"X-Amz-Date\";\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(StringToSignProducer.class);\n+  private static final Charset UTF_8 = StandardCharsets.UTF_8;\n+  private static final String NEWLINE = \"\\n\";\n+  private static final String HOST = \"host\";\n+  private static final String UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\n+  /**\n+   * Seconds in a week, which is the max expiration time Sig-v4 accepts.\n+   */\n+  private static final long PRESIGN_URL_MAX_EXPIRATION_SECONDS =\n+      60 * 60 * 24 * 7;\n+  public static final DateTimeFormatter TIME_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n+          .withZone(ZoneOffset.UTC);\n+\n+  private StringToSignProducer() {\n+  }\n+\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      ContainerRequestContext context\n+  ) throws Exception {\n+    return createSignatureBase(signatureInfo,\n+        context.getUriInfo().getRequestUri().getScheme(),\n+        context.getMethod(),\n+        context.getUriInfo().getRequestUri().getPath(),\n+        LowerCaseKeyStringMap.fromHeaderMap(context.getHeaders()),\n+        fromMultiValueToSingleValueMap(\n+            context.getUriInfo().getQueryParameters()));\n+  }\n+\n+  @VisibleForTesting\n+  public static String createSignatureBase(\n+      SignatureInfo signatureInfo,\n+      String scheme,\n+      String method,\n+      String uri,\n+      LowerCaseKeyStringMap headers,\n+      Map<String, String> queryParams\n+  ) throws Exception {\n+    StringBuilder strToSign = new StringBuilder();\n+    // According to AWS sigv4 documentation, authorization header should be\n+    // in following format.\n+    // Authorization: algorithm Credential=access key ID/credential scope,\n+    // SignedHeaders=SignedHeaders, Signature=signature\n+\n+    // Construct String to sign in below format.\n+    // StringToSign =\n+    //    Algorithm + \\n +\n+    //    RequestDateTime + \\n +\n+    //    CredentialScope + \\n +\n+    //    HashedCanonicalRequest\n+    String credentialScope = signatureInfo.getCredentialScope();\n+\n+    // If the absolute path is empty, use a forward slash (/)\n+    uri = (uri.trim().length() > 0) ? uri : \"/\";\n+    // Encode URI and preserve forward slashes\n+    strToSign.append(signatureInfo.getAlgorithm() + NEWLINE);\n+    strToSign.append(signatureInfo.getDateTime() + NEWLINE);\n+    strToSign.append(credentialScope + NEWLINE);\n+\n+    String canonicalRequest = buildCanonicalRequest(\n+        scheme,\n+        method,\n+        uri,\n+        signatureInfo.getSignedHeaders(),\n+        headers,\n+        queryParams,\n+        !signatureInfo.isSignPayload());\n+    strToSign.append(hash(canonicalRequest));\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"canonicalRequest:[{}]\", canonicalRequest);\n+      LOG.debug(\"StringToSign:[{}]\", strToSign);\n+    }\n+\n+    return strToSign.toString();\n+  }\n+\n+  public static Map<String, String> fromMultiValueToSingleValueMap(\n+      MultivaluedMap<String, String> queryParameters\n+  ) {\n+    Map<String, String> result = new HashMap<>();\n+    for (String key : queryParameters.keySet()) {\n+      result.put(key, queryParameters.getFirst(key));\n+    }\n+    return result;\n+  }\n+\n+  public static String hash(String payload) throws NoSuchAlgorithmException {\n+    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n+    md.update(payload.getBytes(UTF_8));\n+    return Hex.encode(md.digest()).toLowerCase();\n+  }\n+\n+  @VisibleForTesting\n+  public static String buildCanonicalRequest(\n+      String schema,\n+      String method,\n+      String uri,\n+      String signedHeaders,\n+      Map<String, String> headers,\n+      Map<String, String> queryParams,\n+      boolean unsignedPayload\n+  ) throws OS3Exception {\n+\n+    Iterable<String> parts = split(\"/\", uri);\n+    List<String> encParts = new ArrayList<>();\n+    for (String p : parts) {\n+      encParts.add(urlEncode(p));\n+    }\n+    String canonicalUri = join(\"/\", encParts);\n+\n+    String canonicalQueryStr = getQueryParamString(queryParams);\n+\n+    StringBuilder canonicalHeaders = new StringBuilder();\n+\n+    for (String header : StringUtils.getStringCollection(signedHeaders, \";\")) {\n+      canonicalHeaders.append(header.toLowerCase());\n+      canonicalHeaders.append(\":\");\n+      if (headers.containsKey(header)) {\n+        String headerValue = headers.get(header);\n+        canonicalHeaders.append(headerValue);\n+        canonicalHeaders.append(NEWLINE);\n+\n+        // Set for testing purpose only to skip date and host validation.\n+        validateSignedHeader(schema, header, headerValue);\n+\n+      } else {\n+        throw new RuntimeException(\"Header \" + header + \" not present in \" +\n+            \"request but requested to be signed.\");\n+      }\n+    }\n+\n+    String payloadHash;\n+    if (UNSIGNED_PAYLOAD.equals(\n+        headers.get(X_AMZ_CONTENT_SHA256)) || unsignedPayload) {\n+      payloadHash = UNSIGNED_PAYLOAD;\n+    } else {\n+      payloadHash = headers.get(X_AMZ_CONTENT_SHA256);\n+    }\n+    String canonicalRequest = method + NEWLINE\n+        + canonicalUri + NEWLINE\n+        + canonicalQueryStr + NEWLINE\n+        + canonicalHeaders + NEWLINE\n+        + signedHeaders + NEWLINE\n+        + payloadHash;\n+    return canonicalRequest;\n+  }\n+\n+  /**\n+   * String join that also works with empty strings.\n+   *\n+   * @return joined string\n+   */\n+  private static String join(String glue, List<String> parts) {\n+    StringBuilder result = new StringBuilder();\n+    boolean addSeparator = false;\n+    for (String p : parts) {\n+      if (addSeparator) {\n+        result.append(glue);\n+      }\n+      result.append(p);\n+      addSeparator = true;\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n+   * Returns matching strings.\n+   *\n+   * @param regex Regular expression to split by\n+   * @param whole The string to split\n+   * @return pieces\n+   */\n+  private static Iterable<String> split(String regex, String whole) {\n+    Pattern p = Pattern.compile(regex);\n+    Matcher m = p.matcher(whole);\n+    List<String> result = new ArrayList<>();\n+    int pos = 0;\n+    while (m.find()) {\n+      result.add(whole.substring(pos, m.start()));\n+      pos = m.end();\n+    }\n+    result.add(whole.substring(pos));\n+    return result;\n+  }\n+\n+  private static String urlEncode(String str) {\n+    try {\n+\n+      return URLEncoder.encode(str, UTF_8.name())\n+          .replaceAll(\"\\\\+\", \"%20\")\n+          .replaceAll(\"%7E\", \"~\");\n+    } catch (UnsupportedEncodingException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static String getQueryParamString(\n+      Map<String, String> queryMap\n+  ) {\n+    List<String> params = new ArrayList<>(queryMap.keySet());\n+\n+    // Sort by name, then by value\n+    Collections.sort(params, (o1, o2) -> o1.equals(o2) ?\n+        queryMap.get(o1).compareTo(queryMap.get(o2)) :\n+        o1.compareTo(o2));\n+\n+    StringBuilder result = new StringBuilder();\n+    for (String p : params) {\n+      if (!p.equals(\"X-Amz-Signature\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU1MjY2Ng=="}, "originalCommit": {"oid": "261d282e3701d0b840c2d0e34828433bc022b2e4"}, "originalPosition": 271}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4522, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}