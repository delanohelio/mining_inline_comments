{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNjYzMDA1", "number": 1405, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNToyMjozNlrOEhgrKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDoyMDo0NlrOEjTKNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTczODAzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNToyMjozNlrOHO3HKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMTo0MToxM1rOHRtYSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw==", "bodyText": "Instead of a new method, we can use annotation.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r485345067", "createdAt": "2020-09-09T05:22:36Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2OTAxMQ==", "bodyText": "@bharatviswa504 Yes, I pondered about adding annotation for this. Given that we already have annotations for Cleanup tables and BelongsToLayoutVersion, I wanted to hold off on adding more annotations. If it is ok with you, after the first round of changes, we can change this to an annotation.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r485769011", "createdAt": "2020-09-09T16:49:28Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIxMzg2MQ==", "bodyText": "The problem currently with an annotation approach is the fact that we can not use expressions like \"SetAcl.name() + \"-\" + ObjectType.KEY\" in annotations, as that does not qualify as a constant.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r486213861", "createdAt": "2020-09-10T09:55:37Z", "author": {"login": "fapifta"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyMDE2MQ==", "bodyText": "If that is the problem we can define a static variable with direct value and do it.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488220161", "createdAt": "2020-09-14T21:06:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMTMzOA==", "bodyText": "@bharatviswa504 As discussed offline, we can revisit in the next iteration.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488331338", "createdAt": "2020-09-15T01:41:13Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw=="}, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NDQ5NTI0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/LayoutVersionInstanceFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDoyMDo0NlrOHRlLHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDoyMDo0NlrOHRlLHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5Njg5Mg==", "bodyText": "I think we need a \",\" here instead of \"+\".", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488196892", "createdAt": "2020-09-14T20:20:46Z", "author": {"login": "fapifta"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/LayoutVersionInstanceFactory.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.PriorityQueue;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * Generic factory which stores different instances of Type 'T' sharded by\n+ * a key & version. A single key can be associated with different versions\n+ * of 'T'.\n+ *\n+ * Why does this class exist?\n+ * A typical use case during upgrade is to have multiple versions of a class\n+ * / method / object and chose them based  on current layout\n+ * version at runtime. Before finalizing, an older version is typically\n+ * needed, and after finalize, a newer version is needed. This class serves\n+ * this purpose in a generic way.\n+ *\n+ * For example, we can create a Factory to create multiple versions of\n+ * OMRequests sharded by Request Type & Layout Version Supported.\n+ */\n+public class LayoutVersionInstanceFactory<T> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(LayoutVersionInstanceFactory.class);\n+\n+  /**\n+   * The factory will maintain ALL instances > MLV and 1 instance <= MLV in a\n+   * priority queue (ordered by version). By doing that it guarantees O(1)\n+   * lookup at all times, since we always would lookup the first element (top\n+   * of the PQ).\n+   * Multiple entries will be there ONLY during pre-finalized state.\n+   * On finalization, we will be removing the entry one by one until we reach\n+   * a single entry. On a regular component instance (finalized), there will\n+   * be a single request version associated with a request always.\n+   */\n+  private final Map<String, PriorityQueue<VersionedInstance<T>>> instances =\n+      new HashMap<>();\n+\n+  /**\n+   * Register an instance with a given factory key (key + version).\n+   * For safety reasons we dont allow (1) re-registering, (2) registering an\n+   * instance with version > SLV.\n+   *\n+   * @param lvm LayoutVersionManager\n+   * @param key VersionFactoryKey key to associate with instance.\n+   * @param instance instance to register.\n+   */\n+  public boolean register(LayoutVersionManager lvm, VersionFactoryKey key,\n+                       T instance) {\n+    // If version is not passed in, go defensive and set the highest possible\n+    // version (SLV).\n+    int version = key.getVersion() == null ?\n+        lvm.getSoftwareLayoutVersion() : key.getVersion();\n+\n+    checkArgument(lvm.getSoftwareLayoutVersion() >= key.getVersion(),\n+        String.format(\"Cannot register key %s since the version is greater \" +\n+                \"than the Software layout version %d\",\n+        key, lvm.getSoftwareLayoutVersion()));\n+\n+    // If we reach here, we know that the passed in version belongs to\n+    // [0, SLV].\n+    String primaryKey = key.getKey();\n+    instances.computeIfAbsent(primaryKey, s ->\n+        new PriorityQueue<>(Comparator.comparingInt(o -> o.version)));\n+\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    Optional<VersionedInstance<T>> existingInstance =\n+        versionedInstances.parallelStream()\n+        .filter(v -> v.version == key.getVersion()).findAny();\n+\n+    if (existingInstance.isPresent()) {\n+      throw new IllegalArgumentException(String.format(\"Cannot register key \" +\n+          \"%s since there is an existing entry already.\", key));\n+    }\n+\n+    if (!versionedInstances.isEmpty() && isValid(lvm, version)) {\n+      VersionedInstance<T> currentPeek = versionedInstances.peek();\n+      if (currentPeek.version < version) {\n+        // Current peek < passed in version (and <= MLV). Hence, we can\n+        // remove it, since the passed in a better candidate.\n+        versionedInstances.poll();\n+        // Add the passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else if (currentPeek.version > lvm.getMetadataLayoutVersion()) {\n+        // Current peak is > MLV, hence we don't need to remove that. Just\n+        // add passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else {\n+        // Current peek <= MLV and > passed in version, and hence a better\n+        // canidate. Retaining the peek, and ignoring the passed in instance.\n+        return false;\n+      }\n+    } else {\n+      // Passed in instance version > MLV (or the first version to be\n+      // registered), hence can be registered.\n+      versionedInstances.offer(new VersionedInstance<>(version, instance));\n+      return true;\n+    }\n+  }\n+\n+  private boolean isValid(LayoutVersionManager lvm, int version) {\n+    return version <= lvm.getMetadataLayoutVersion();\n+  }\n+\n+  /**\n+   * From the list of versioned instances for a given \"key\", this\n+   * returns the \"floor\" value corresponding to the given version.\n+   * For example, if we have key = \"CreateKey\",  entry -> [(1, CreateKeyV1),\n+   * (3, CreateKeyV2), and if the passed in key = CreateKey & version = 2, we\n+   * return CreateKeyV1.\n+   * Since this is a priority queue based implementation, we use a O(1) peek()\n+   * lookup to get the current valid version.\n+   * @param lvm LayoutVersionManager\n+   * @param key Key and Version.\n+   * @return instance.\n+   */\n+  public T get(LayoutVersionManager lvm, VersionFactoryKey key) {\n+    Integer version = key.getVersion();\n+    // If version is not passed in, go defensive and set the highest allowed\n+    // version (MLV).\n+    if (version == null) {\n+      version = lvm.getMetadataLayoutVersion();\n+    }\n+\n+    checkArgument(lvm.getMetadataLayoutVersion() >= version,\n+        String.format(\"Cannot get key %s since the version is greater \" +\n+                \"than the Metadata layout version %d\",\n+            key, lvm.getMetadataLayoutVersion()));\n+\n+    String primaryKey = key.getKey();\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    if (versionedInstances == null || versionedInstances.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    }\n+\n+    VersionedInstance<T> value = versionedInstances.peek();\n+    if (value == null || value.version > version) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    } else {\n+      return value.instance;\n+    }\n+  }\n+\n+  /**\n+   * To be called on finalization when there is an MLV update.\n+   * @param lvm LayoutVersionManager instance.\n+   */\n+  public void onFinalize(LayoutVersionManager lvm) {\n+    Iterator<Map.Entry<String, PriorityQueue<VersionedInstance<T>>>> iterator =\n+        instances.entrySet().iterator();\n+    while (iterator.hasNext()) {\n+      Map.Entry<String, PriorityQueue<VersionedInstance<T>>> next =\n+          iterator.next();\n+      PriorityQueue<VersionedInstance<T>> vInstances = next.getValue();\n+      VersionedInstance<T> prevInstance = null;\n+      while (!vInstances.isEmpty() &&\n+          vInstances.peek().version < lvm.getMetadataLayoutVersion()) {\n+        prevInstance = vInstances.poll();\n+        LOG.info(\"Unregistering {} from factory. \", prevInstance.instance);\n+      }\n+\n+      if ((vInstances.isEmpty() ||\n+          vInstances.peek().version > lvm.getMetadataLayoutVersion())\n+          && prevInstance != null) {\n+        vInstances.offer(prevInstance);\n+      }\n+\n+      if (vInstances.isEmpty()) {\n+        LOG.info(\"Unregistering '{}' from factory since it has no entries.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5281c2615e479e3a6b6685e1cc776b548d78b4da"}, "originalPosition": 206}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4874, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}