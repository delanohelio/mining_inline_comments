{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5ODUwOTgy", "number": 943, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDo0NToxNlrOD-y2vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1NjozMlrOEJN9Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTcxNTE2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDo0NToxNlrOGZHUcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyMDoxOVrOGmF7Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4NzUwNA==", "bodyText": "What are the difference is the operation is not volume bucket delete? It seems the txIndex are added the same anyway.", "url": "https://github.com/apache/ozone/pull/943#discussion_r428987504", "createdAt": "2020-05-22T00:45:16Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "diffHunk": "@@ -286,30 +301,45 @@ private void flushTransactions() {\n     }\n   }\n \n-  private void cleanupCache(List<Long> lastRatisTransactionIndex) {\n-    // As now only volume and bucket transactions are handled only called\n-    // cleanupCache on bucketTable.\n-    // TODO: After supporting all write operations we need to call\n-    //  cleanupCache on the tables only when buffer has entries for that table.\n-    omMetadataManager.getBucketTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getVolumeTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getUserTable().cleanupCache(lastRatisTransactionIndex);\n-\n-    //TODO: Optimization we can do here is for key transactions we can only\n-    // cleanup cache when it is key commit transaction. In this way all\n-    // intermediate transactions for a key will be read from in-memory cache.\n-    omMetadataManager.getOpenKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getDeletedTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getS3Table().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getMultipartInfoTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getS3SecretTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getDelegationTokenTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getPrefixTable().cleanupCache(lastRatisTransactionIndex);\n+  /**\n+   * Set cleanup epoch for the DoubleBufferEntry.\n+   * @param entry\n+   * @param cleanupEpochs\n+   */\n+  private void setCleanupEpoch(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    // Add epochs depending on operated tables. In this way\n+    // cleanup will be called only when required.\n+\n+    // As bucket and volume table is full cache add cleanup\n+    // epochs only when request is delete to cleanup deleted\n+    // entries.\n+\n+    String opName =\n+        entry.getResponse().getOMResponse().getCmdType().name();\n+\n+    if (opName.toLowerCase().contains(VOLUME) ||\n+        opName.toLowerCase().contains(BUCKET)) {\n+      if (DeleteBucket.name().equals(opName)\n+          || DeleteVolume.name().equals(opName)) {\n+        entry.getResponse().operatedTables().forEach(\n+            table -> cleanupEpochs.get(table)\n+                .add(entry.getTrxLogIndex()));\n+      }\n+    } else {\n+      entry.getResponse().operatedTables().forEach(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50320fb628a1cdd9a2f43c912967f55a12379067"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjExMQ==", "bodyText": "When operation is of type volume/bucket entry should be added only when deletevolume/deletebucket.  As volume/bucket is full cache, and cache should be cleaned up only for delete operations.", "url": "https://github.com/apache/ozone/pull/943#discussion_r442596111", "createdAt": "2020-06-19T02:20:19Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "diffHunk": "@@ -286,30 +301,45 @@ private void flushTransactions() {\n     }\n   }\n \n-  private void cleanupCache(List<Long> lastRatisTransactionIndex) {\n-    // As now only volume and bucket transactions are handled only called\n-    // cleanupCache on bucketTable.\n-    // TODO: After supporting all write operations we need to call\n-    //  cleanupCache on the tables only when buffer has entries for that table.\n-    omMetadataManager.getBucketTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getVolumeTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getUserTable().cleanupCache(lastRatisTransactionIndex);\n-\n-    //TODO: Optimization we can do here is for key transactions we can only\n-    // cleanup cache when it is key commit transaction. In this way all\n-    // intermediate transactions for a key will be read from in-memory cache.\n-    omMetadataManager.getOpenKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getDeletedTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getS3Table().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getMultipartInfoTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getS3SecretTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getDelegationTokenTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getPrefixTable().cleanupCache(lastRatisTransactionIndex);\n+  /**\n+   * Set cleanup epoch for the DoubleBufferEntry.\n+   * @param entry\n+   * @param cleanupEpochs\n+   */\n+  private void setCleanupEpoch(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    // Add epochs depending on operated tables. In this way\n+    // cleanup will be called only when required.\n+\n+    // As bucket and volume table is full cache add cleanup\n+    // epochs only when request is delete to cleanup deleted\n+    // entries.\n+\n+    String opName =\n+        entry.getResponse().getOMResponse().getCmdType().name();\n+\n+    if (opName.toLowerCase().contains(VOLUME) ||\n+        opName.toLowerCase().contains(BUCKET)) {\n+      if (DeleteBucket.name().equals(opName)\n+          || DeleteVolume.name().equals(opName)) {\n+        entry.getResponse().operatedTables().forEach(\n+            table -> cleanupEpochs.get(table)\n+                .add(entry.getTrxLogIndex()));\n+      }\n+    } else {\n+      entry.getResponse().operatedTables().forEach(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4NzUwNA=="}, "originalCommit": {"oid": "50320fb628a1cdd9a2f43c912967f55a12379067"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTcxODE3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketCreateResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDo0NzowOVrOGZHWRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjozMjo0MlrOGmGGow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4Nzk3Mg==", "bodyText": "As an alternative, you might achieve the same by adding a class annotation with table name string.", "url": "https://github.com/apache/ozone/pull/943#discussion_r428987972", "createdAt": "2020-05-22T00:47:09Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketCreateResponse.java", "diffHunk": "@@ -30,11 +32,16 @@\n import javax.annotation.Nullable;\n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for CreateBucket request.\n  */\n public final class OMBucketCreateResponse extends OMClientResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50320fb628a1cdd9a2f43c912967f55a12379067"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTA3NQ==", "bodyText": "Done.", "url": "https://github.com/apache/ozone/pull/943#discussion_r442599075", "createdAt": "2020-06-19T02:32:42Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketCreateResponse.java", "diffHunk": "@@ -30,11 +32,16 @@\n import javax.annotation.Nullable;\n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for CreateBucket request.\n  */\n public final class OMBucketCreateResponse extends OMClientResponse {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4Nzk3Mg=="}, "originalCommit": {"oid": "50320fb628a1cdd9a2f43c912967f55a12379067"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDk5NjUxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketDeleteResponse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1MDo1M1rOGppoxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1ODoyMlrOGpp2lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNjk4Mw==", "bodyText": "Should this be removed after we add the annotation?", "url": "https://github.com/apache/ozone/pull/943#discussion_r446326983", "createdAt": "2020-06-26T17:50:53Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketDeleteResponse.java", "diffHunk": "@@ -19,20 +19,29 @@\n package org.apache.hadoop.ozone.om.response.bucket;\n \n import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n import org.apache.hadoop.ozone.om.response.OMClientResponse;\n import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n     .OMResponse;\n import org.apache.hadoop.hdds.utils.db.BatchOperation;\n \n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for DeleteBucket request.\n  */\n+@CleanupTableInfo(cleanupTables = {BUCKET_TABLE})\n public final class OMBucketDeleteResponse extends OMClientResponse {\n \n+  private static final List<String> OPERATED_TABLES =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzMDUxOA==", "bodyText": "Done", "url": "https://github.com/apache/ozone/pull/943#discussion_r446330518", "createdAt": "2020-06-26T17:58:22Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketDeleteResponse.java", "diffHunk": "@@ -19,20 +19,29 @@\n package org.apache.hadoop.ozone.om.response.bucket;\n \n import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n import org.apache.hadoop.ozone.om.response.OMClientResponse;\n import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n     .OMResponse;\n import org.apache.hadoop.hdds.utils.db.BatchOperation;\n \n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for DeleteBucket request.\n  */\n+@CleanupTableInfo(cleanupTables = {BUCKET_TABLE})\n public final class OMBucketDeleteResponse extends OMClientResponse {\n \n+  private static final List<String> OPERATED_TABLES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNjk4Mw=="}, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDk5NzQ4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketSetPropertyResponse.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1MToxNFrOGpppYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1ODoyNlrOGpp2tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzEzOQ==", "bodyText": "Same as above.", "url": "https://github.com/apache/ozone/pull/943#discussion_r446327139", "createdAt": "2020-06-26T17:51:14Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketSetPropertyResponse.java", "diffHunk": "@@ -18,22 +18,31 @@\n package org.apache.hadoop.ozone.om.response.bucket;\n \n import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.apache.hadoop.ozone.om.OMMetadataManager;\n import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n import org.apache.hadoop.ozone.om.response.OMClientResponse;\n import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n     .OMResponse;\n import org.apache.hadoop.hdds.utils.db.BatchOperation;\n \n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for SetBucketProperty request.\n  */\n+@CleanupTableInfo(cleanupTables = {BUCKET_TABLE})\n public class OMBucketSetPropertyResponse extends OMClientResponse {\n   private OmBucketInfo omBucketInfo;\n \n+  private static final List<String> OPERATED_TABLES =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzMDU0OA==", "bodyText": "Done", "url": "https://github.com/apache/ozone/pull/943#discussion_r446330548", "createdAt": "2020-06-26T17:58:26Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/bucket/OMBucketSetPropertyResponse.java", "diffHunk": "@@ -18,22 +18,31 @@\n package org.apache.hadoop.ozone.om.response.bucket;\n \n import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.apache.hadoop.ozone.om.OMMetadataManager;\n import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n import org.apache.hadoop.ozone.om.response.OMClientResponse;\n import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n     .OMResponse;\n import org.apache.hadoop.hdds.utils.db.BatchOperation;\n \n import javax.annotation.Nonnull;\n \n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.BUCKET_TABLE;\n+\n /**\n  * Response for SetBucketProperty request.\n  */\n+@CleanupTableInfo(cleanupTables = {BUCKET_TABLE})\n public class OMBucketSetPropertyResponse extends OMClientResponse {\n   private OmBucketInfo omBucketInfo;\n \n+  private static final List<String> OPERATED_TABLES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyNzEzOQ=="}, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTAxMjkxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1NjozMlrOGppzPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNzo1ODoxOFrOGpp2dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyOTY2MQ==", "bodyText": "Can we add a unit test on response class that misses annotation?", "url": "https://github.com/apache/ozone/pull/943#discussion_r446329661", "createdAt": "2020-06-26T17:56:32Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "diffHunk": "@@ -353,29 +368,62 @@ private void flushTransactions() {\n     }\n   }\n \n-  private void cleanupCache(List<Long> lastRatisTransactionIndex) {\n-    // As now only volume and bucket transactions are handled only called\n-    // cleanupCache on bucketTable.\n-    // TODO: After supporting all write operations we need to call\n-    //  cleanupCache on the tables only when buffer has entries for that table.\n-    omMetadataManager.getBucketTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getVolumeTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getUserTable().cleanupCache(lastRatisTransactionIndex);\n-\n-    //TODO: Optimization we can do here is for key transactions we can only\n-    // cleanup cache when it is key commit transaction. In this way all\n-    // intermediate transactions for a key will be read from in-memory cache.\n-    omMetadataManager.getOpenKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getDeletedTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getMultipartInfoTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getS3SecretTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getDelegationTokenTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getPrefixTable().cleanupCache(lastRatisTransactionIndex);\n+  /**\n+   * Set cleanup epoch for the DoubleBufferEntry.\n+   * @param entry\n+   * @param cleanupEpochs\n+   */\n+  private void setCleanupEpoch(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    // Add epochs depending on operated tables. In this way\n+    // cleanup will be called only when required.\n+\n+    // As bucket and volume table is full cache add cleanup\n+    // epochs only when request is delete to cleanup deleted\n+    // entries.\n+\n+    String opName =\n+        entry.getResponse().getOMResponse().getCmdType().name();\n+\n+    if (opName.toLowerCase().contains(VOLUME) ||\n+        opName.toLowerCase().contains(BUCKET)) {\n+      if (DeleteBucket.name().equals(opName)\n+          || DeleteVolume.name().equals(opName)) {\n+        addCleanupEntry(entry, cleanupEpochs);\n+      }\n+    } else {\n+      addCleanupEntry(entry, cleanupEpochs);\n+    }\n+  }\n+\n+\n+  private void addCleanupEntry(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    Class<? extends OMClientResponse> responseClass =\n+        entry.getResponse().getClass();\n+    CleanupTableInfo cleanupTableInfo =\n+        responseClass.getAnnotation(CleanupTableInfo.class);\n+    if (cleanupTableInfo != null) {\n+      String[] cleanupTables = cleanupTableInfo.cleanupTables();\n+      for (String table : cleanupTables) {\n+        cleanupEpochs.computeIfAbsent(table, list -> new ArrayList<>())\n+            .add(entry.getTrxLogIndex());\n+      }\n+    } else {\n+      // This is to catch early errors, when an new response class missed to\n+      // add CleanupTableInfo annotation.\n+      throw new RuntimeException(\"CleanupTableInfo Annotation is missing \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMzMDQ4NA==", "bodyText": "TestCleanupTableInfo test is added for this purpose.", "url": "https://github.com/apache/ozone/pull/943#discussion_r446330484", "createdAt": "2020-06-26T17:58:18Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerDoubleBuffer.java", "diffHunk": "@@ -353,29 +368,62 @@ private void flushTransactions() {\n     }\n   }\n \n-  private void cleanupCache(List<Long> lastRatisTransactionIndex) {\n-    // As now only volume and bucket transactions are handled only called\n-    // cleanupCache on bucketTable.\n-    // TODO: After supporting all write operations we need to call\n-    //  cleanupCache on the tables only when buffer has entries for that table.\n-    omMetadataManager.getBucketTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getVolumeTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getUserTable().cleanupCache(lastRatisTransactionIndex);\n-\n-    //TODO: Optimization we can do here is for key transactions we can only\n-    // cleanup cache when it is key commit transaction. In this way all\n-    // intermediate transactions for a key will be read from in-memory cache.\n-    omMetadataManager.getOpenKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getKeyTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getDeletedTable().cleanupCache(lastRatisTransactionIndex);\n-    omMetadataManager.getMultipartInfoTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getS3SecretTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getDelegationTokenTable().cleanupCache(\n-        lastRatisTransactionIndex);\n-    omMetadataManager.getPrefixTable().cleanupCache(lastRatisTransactionIndex);\n+  /**\n+   * Set cleanup epoch for the DoubleBufferEntry.\n+   * @param entry\n+   * @param cleanupEpochs\n+   */\n+  private void setCleanupEpoch(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    // Add epochs depending on operated tables. In this way\n+    // cleanup will be called only when required.\n+\n+    // As bucket and volume table is full cache add cleanup\n+    // epochs only when request is delete to cleanup deleted\n+    // entries.\n+\n+    String opName =\n+        entry.getResponse().getOMResponse().getCmdType().name();\n+\n+    if (opName.toLowerCase().contains(VOLUME) ||\n+        opName.toLowerCase().contains(BUCKET)) {\n+      if (DeleteBucket.name().equals(opName)\n+          || DeleteVolume.name().equals(opName)) {\n+        addCleanupEntry(entry, cleanupEpochs);\n+      }\n+    } else {\n+      addCleanupEntry(entry, cleanupEpochs);\n+    }\n+  }\n+\n+\n+  private void addCleanupEntry(DoubleBufferEntry entry, Map<String,\n+      List<Long>> cleanupEpochs) {\n+    Class<? extends OMClientResponse> responseClass =\n+        entry.getResponse().getClass();\n+    CleanupTableInfo cleanupTableInfo =\n+        responseClass.getAnnotation(CleanupTableInfo.class);\n+    if (cleanupTableInfo != null) {\n+      String[] cleanupTables = cleanupTableInfo.cleanupTables();\n+      for (String table : cleanupTables) {\n+        cleanupEpochs.computeIfAbsent(table, list -> new ArrayList<>())\n+            .add(entry.getTrxLogIndex());\n+      }\n+    } else {\n+      // This is to catch early errors, when an new response class missed to\n+      // add CleanupTableInfo annotation.\n+      throw new RuntimeException(\"CleanupTableInfo Annotation is missing \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyOTY2MQ=="}, "originalCommit": {"oid": "ac2b771177401a46ecba4e27e6bf53b179d9f1b1"}, "originalPosition": 133}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4325, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}