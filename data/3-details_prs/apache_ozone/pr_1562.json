{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NjkxNzQw", "number": 1562, "title": "HDDS-4440. [PROPOSAL] Use per-request authentication and persistent connections between S3g and OM", "bodyText": "This is a design doc. Please see the content.", "createdAt": "2020-11-09T11:24:27Z", "url": "https://github.com/apache/ozone/pull/1562", "merged": true, "mergeCommit": {"oid": "3859f9f9440aa3eca059c38161e66a175a385f72"}, "closed": true, "closedAt": "2021-03-08T09:20:47Z", "author": {"login": "elek"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABday-6NAH2gAyNTE3NjkxNzQwOmVkMjQyOWI4ZWYzNDFiZGExZjcyODdlZmZkYTM3ZDU4YjI5MTAxMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd-_AZ2AFqTYwMTE5NDU3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100", "author": {"user": {"login": "elek", "name": "Elek, M\u00e1rton"}}, "url": "https://github.com/apache/ozone/commit/ed2429b8ef341bda1f7287effda37d58b2910100", "committedDate": "2020-11-09T11:23:14Z", "message": "HDDS-4440. Use per-request authentication and persistent connections between S3g and OM"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTI0MDM1", "url": "https://github.com/apache/ozone/pull/1562#pullrequestreview-531924035", "createdAt": "2020-11-17T00:14:08Z", "commit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMDoxNDowOFrOH0e3tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMDozNToxNVrOH0fvMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5Mzc4Mw==", "bodyText": "OzoneClientProduced -> OzoneClientProducer", "url": "https://github.com/apache/ozone/pull/1562#discussion_r524793783", "createdAt": "2020-11-17T00:14:08Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNTg5MA==", "bodyText": "Just to clarify my understanding, we don't have invalidate token method for s3G right?\nAs this token is generated from Client auth header fields. Means token is generated per request.\nWe are sending the required info to validate the auth header with the secret which OM has.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r524805890", "createdAt": "2020-11-17T00:28:50Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjg5Mw==", "bodyText": "Does that mean with this approach we need one ozone Client instantiated, as token is part of OMRequest.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r524806893", "createdAt": "2020-11-17T00:31:42Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.\n+\n+```\n+public class UserGroupInformation {\n+  \n+  ...\n+  \n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    } else {\n+      return subject == ((UserGroupInformation) o).subject;\n+    }\n+  }\n+}\n+```\n+\n+ But the UGI initialization of Ozone always creates a new `Subject` instance for each request (even if the subject name is the same). In `OzoneClientProducer`:\n+\n+```\n+  UserGroupInformation remoteUser =\n+          UserGroupInformation.createRemoteUser(awsAccessId); // <-- new Subject is created\n+      \n+      if (OzoneSecurityUtil.isSecurityEnabled(config)) {\n+        try {\n+          OzoneTokenIdentifier identifier = new OzoneTokenIdentifier();\n+          //setup identifier\n+          \n+          Token<OzoneTokenIdentifier> token = new Token(identifier.getBytes(),\n+              identifier.getSignature().getBytes(UTF_8),\n+              identifier.getKind(),\n+              omService);\n+          remoteUser.addToken(token);\n+          ....\n+```\n+\n+**As a result Hadoop RPC caching doesn't apply to Ozone S3g**. It's a good news because it's secure, but bad news as the performance is bad.\n+\n+# Proposed change\n+\n+We need an RPC mechanism between the Ozone S3g service and Ozone Manager service which can support per-request authentication and accepts\n+\n+The  Ozone Manager client already has a pluggable transport interface: `OmTransport` is a simple interface which can deliver `OMRequest` messages:\n+\n+```\n+public interface OmTransport {\n+\n+  /**\n+   * The main method to send out the request on the defined transport.\n+   */\n+  OMResponse submitRequest(OMRequest payload) throws IOException;\n+  ...\n+```\n+\n+ The proposal is to create a new **additional** transport, based on GRPC, which can do the per-request authentication. **Existing Hadoop clients will use the well-known Hadoop RPC client**, but S3g can start to use this specific transport to achieve better performance.\n+\n+As this is nothing more, just a transport: exactly the same messages (`OmRequest`) will be used, it's not a new RPC interface.\n+\n+Only one modification is required in the RPC interface: a new per-request`token` field should be introduced in `OMRequest` which is optional.\n+\n+A new GRPC service should be started in Ozone Manager, which receives `OMRequest` and for each request, the Hadoop `UserGroupInformation` is set based on the new token field (after authentication).\n+\n+`OzoneToken` identifier can be simplified (after deprecation period) with removing the S3 specific part, as it won't be required any more.\n+\n+With this approach the `OzoneClient` instances can be cached on S3g side (with persistent GRPC connections) as the authentication information is not part of the OzoneClient any more (added by the `OmTransport` implementation per request (in case of GRPC) or per connection (in case of HadoopRPC)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNzk4NA==", "bodyText": "Few questions:\nThis means S3G does not use hadoop Rpc Client, it will be use GrpcClient\nSo how OM HA will be handled retry handling logic, so all that logic need to be implemented in this new GrpcClient?\nAnd once the token is validated, will it go with the normal flow of execution in OzoneManager?\nFew minor questions, as I don't have much expertise on Grpc Implementation.\n\nDoes GrpcServer also will have RPC handler threads where requests can be handled parallel on OM.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r524807984", "createdAt": "2020-11-17T00:35:15Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.\n+\n+```\n+public class UserGroupInformation {\n+  \n+  ...\n+  \n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    } else {\n+      return subject == ((UserGroupInformation) o).subject;\n+    }\n+  }\n+}\n+```\n+\n+ But the UGI initialization of Ozone always creates a new `Subject` instance for each request (even if the subject name is the same). In `OzoneClientProducer`:\n+\n+```\n+  UserGroupInformation remoteUser =\n+          UserGroupInformation.createRemoteUser(awsAccessId); // <-- new Subject is created\n+      \n+      if (OzoneSecurityUtil.isSecurityEnabled(config)) {\n+        try {\n+          OzoneTokenIdentifier identifier = new OzoneTokenIdentifier();\n+          //setup identifier\n+          \n+          Token<OzoneTokenIdentifier> token = new Token(identifier.getBytes(),\n+              identifier.getSignature().getBytes(UTF_8),\n+              identifier.getKind(),\n+              omService);\n+          remoteUser.addToken(token);\n+          ....\n+```\n+\n+**As a result Hadoop RPC caching doesn't apply to Ozone S3g**. It's a good news because it's secure, but bad news as the performance is bad.\n+\n+# Proposed change\n+\n+We need an RPC mechanism between the Ozone S3g service and Ozone Manager service which can support per-request authentication and accepts\n+\n+The  Ozone Manager client already has a pluggable transport interface: `OmTransport` is a simple interface which can deliver `OMRequest` messages:\n+\n+```\n+public interface OmTransport {\n+\n+  /**\n+   * The main method to send out the request on the defined transport.\n+   */\n+  OMResponse submitRequest(OMRequest payload) throws IOException;\n+  ...\n+```\n+\n+ The proposal is to create a new **additional** transport, based on GRPC, which can do the per-request authentication. **Existing Hadoop clients will use the well-known Hadoop RPC client**, but S3g can start to use this specific transport to achieve better performance.\n+\n+As this is nothing more, just a transport: exactly the same messages (`OmRequest`) will be used, it's not a new RPC interface.\n+\n+Only one modification is required in the RPC interface: a new per-request`token` field should be introduced in `OMRequest` which is optional.\n+\n+A new GRPC service should be started in Ozone Manager, which receives `OMRequest` and for each request, the Hadoop `UserGroupInformation` is set based on the new token field (after authentication).\n+\n+`OzoneToken` identifier can be simplified (after deprecation period) with removing the S3 specific part, as it won't be required any more.\n+\n+With this approach the `OzoneClient` instances can be cached on S3g side (with persistent GRPC connections) as the authentication information is not part of the OzoneClient any more (added by the `OmTransport` implementation per request (in case of GRPC) or per connection (in case of HadoopRPC)).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjg5Mw=="}, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 197}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTM2NDQ4", "url": "https://github.com/apache/ozone/pull/1562#pullrequestreview-531936448", "createdAt": "2020-11-17T00:41:00Z", "commit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMDo0MTowMFrOH0f2Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMDo0MTowMFrOH0f2Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwOTgyMg==", "bodyText": "Not understood this point, what is meant by service discovery call is not required and also not using ozone client may have own challenge.\nSo, can we use one single client even with Hadoop RPC? More information on this point will help what is meant by this alternative.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r524809822", "createdAt": "2020-11-17T00:41:00Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.\n+\n+```\n+public class UserGroupInformation {\n+  \n+  ...\n+  \n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    } else {\n+      return subject == ((UserGroupInformation) o).subject;\n+    }\n+  }\n+}\n+```\n+\n+ But the UGI initialization of Ozone always creates a new `Subject` instance for each request (even if the subject name is the same). In `OzoneClientProducer`:\n+\n+```\n+  UserGroupInformation remoteUser =\n+          UserGroupInformation.createRemoteUser(awsAccessId); // <-- new Subject is created\n+      \n+      if (OzoneSecurityUtil.isSecurityEnabled(config)) {\n+        try {\n+          OzoneTokenIdentifier identifier = new OzoneTokenIdentifier();\n+          //setup identifier\n+          \n+          Token<OzoneTokenIdentifier> token = new Token(identifier.getBytes(),\n+              identifier.getSignature().getBytes(UTF_8),\n+              identifier.getKind(),\n+              omService);\n+          remoteUser.addToken(token);\n+          ....\n+```\n+\n+**As a result Hadoop RPC caching doesn't apply to Ozone S3g**. It's a good news because it's secure, but bad news as the performance is bad.\n+\n+# Proposed change\n+\n+We need an RPC mechanism between the Ozone S3g service and Ozone Manager service which can support per-request authentication and accepts\n+\n+The  Ozone Manager client already has a pluggable transport interface: `OmTransport` is a simple interface which can deliver `OMRequest` messages:\n+\n+```\n+public interface OmTransport {\n+\n+  /**\n+   * The main method to send out the request on the defined transport.\n+   */\n+  OMResponse submitRequest(OMRequest payload) throws IOException;\n+  ...\n+```\n+\n+ The proposal is to create a new **additional** transport, based on GRPC, which can do the per-request authentication. **Existing Hadoop clients will use the well-known Hadoop RPC client**, but S3g can start to use this specific transport to achieve better performance.\n+\n+As this is nothing more, just a transport: exactly the same messages (`OmRequest`) will be used, it's not a new RPC interface.\n+\n+Only one modification is required in the RPC interface: a new per-request`token` field should be introduced in `OMRequest` which is optional.\n+\n+A new GRPC service should be started in Ozone Manager, which receives `OMRequest` and for each request, the Hadoop `UserGroupInformation` is set based on the new token field (after authentication).\n+\n+`OzoneToken` identifier can be simplified (after deprecation period) with removing the S3 specific part, as it won't be required any more.\n+\n+With this approach the `OzoneClient` instances can be cached on S3g side (with persistent GRPC connections) as the authentication information is not part of the OzoneClient any more (added by the `OmTransport` implementation per request (in case of GRPC) or per connection (in case of HadoopRPC)).\n+\n+# Possible alternatives\n+\n+* It's possible to use pure Hadoop RPC client instead of Ozone Client which would make the client connection slightly cheaper (service discovery call is not required) but it's still require to create new connections for each requests (and downloading data without OzoneClient may have own challenges).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODY3NzU5", "url": "https://github.com/apache/ozone/pull/1562#pullrequestreview-532867759", "createdAt": "2020-11-17T22:31:52Z", "commit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjozMTo1MlrOH1OLVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjo0MjozOFrOH1Ofrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2ODg1Mg==", "bodyText": "To protect the token from being stolen, TLS must be enabled for GRPC.\nTo set up TLS for GRPC, the client must get the CA cert via service discovery.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r525568852", "createdAt": "2020-11-17T22:31:52Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.\n+\n+```\n+public class UserGroupInformation {\n+  \n+  ...\n+  \n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    } else {\n+      return subject == ((UserGroupInformation) o).subject;\n+    }\n+  }\n+}\n+```\n+\n+ But the UGI initialization of Ozone always creates a new `Subject` instance for each request (even if the subject name is the same). In `OzoneClientProducer`:\n+\n+```\n+  UserGroupInformation remoteUser =\n+          UserGroupInformation.createRemoteUser(awsAccessId); // <-- new Subject is created\n+      \n+      if (OzoneSecurityUtil.isSecurityEnabled(config)) {\n+        try {\n+          OzoneTokenIdentifier identifier = new OzoneTokenIdentifier();\n+          //setup identifier\n+          \n+          Token<OzoneTokenIdentifier> token = new Token(identifier.getBytes(),\n+              identifier.getSignature().getBytes(UTF_8),\n+              identifier.getKind(),\n+              omService);\n+          remoteUser.addToken(token);\n+          ....\n+```\n+\n+**As a result Hadoop RPC caching doesn't apply to Ozone S3g**. It's a good news because it's secure, but bad news as the performance is bad.\n+\n+# Proposed change\n+\n+We need an RPC mechanism between the Ozone S3g service and Ozone Manager service which can support per-request authentication and accepts\n+\n+The  Ozone Manager client already has a pluggable transport interface: `OmTransport` is a simple interface which can deliver `OMRequest` messages:\n+\n+```\n+public interface OmTransport {\n+\n+  /**\n+   * The main method to send out the request on the defined transport.\n+   */\n+  OMResponse submitRequest(OMRequest payload) throws IOException;\n+  ...\n+```\n+\n+ The proposal is to create a new **additional** transport, based on GRPC, which can do the per-request authentication. **Existing Hadoop clients will use the well-known Hadoop RPC client**, but S3g can start to use this specific transport to achieve better performance.\n+\n+As this is nothing more, just a transport: exactly the same messages (`OmRequest`) will be used, it's not a new RPC interface.\n+\n+Only one modification is required in the RPC interface: a new per-request`token` field should be introduced in `OMRequest` which is optional.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDA2Mw==", "bodyText": "I still feel we can reuse the Hadoop Rpc connection here.\nDon't remember exactly why we have to use a token user and do the token validation at OM. But another solution I would like to propose is to use Proxy user at S3g:\nInstead of wrap the token to create a new Hadoop RPC connection per call. S3g can validate OM token similar to the way DN validate OM block token. After validation succeeds, S3g can create a proxy user to connect to OM. If it is the same client, the proxy user can be reused.", "url": "https://github.com/apache/ozone/pull/1562#discussion_r525574063", "createdAt": "2020-11-17T22:42:38Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM\n+date: 2020-11-09\n+jira: HDDS-4440\n+status: accepted\n+author: M\u00e1rton Elek\n+---\n+<!--\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+   http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License. See accompanying LICENSE file.\n+-->\n+\n+# Overview\n+\n+* Hadoop RPC authenticate the calls at the beginning of the connections. All the subsequent messages on the same call will use existing, initialized authentication.\n+* S3 gateway sends the authentication as Hadoop RPC delegation token for **each requests**.\n+* To authenticate each of the S3 REST requests Ozone creates a new `OzoneClient` for eac HTTP requests, which introduces problems with performance and error handling.\n+* This proposal suggests to create a new transport (**in addition** to the existing Hadoop RPC) for the OMClientProtocol where the requests can be authenticated per-request.\n+\n+# Authentication with S3 gateway\n+\n+AWS S3 request authentication based on [signing the REST messages](https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html). Each of the HTTP requests must include and authentication header which contains the used the *access key id* and a signatures created with the help of the *secret key*.\n+\n+```\n+Authorization: AWS AWSAccessKeyId:Signature\n+```\n+\n+Ozone S3g is a REST gateway for Ozone which receives AWS compatible HTTP calls and forwards the requests to the Ozone Manager and Datanode services. Ozone S3g is **stateless**, it couldn't check any authentication information which are stored on the Ozone Manager side. It can check only the format of the signature.\n+\n+For the authentication S3g parses the HTTP header and sends all the relevant (and required) information to Ozone Manager which can check the signature with the help of stored *secret key*.\n+\n+This is implemented with the help of the delegation token mechanism of Hadoop RPC. Hadoop RPC supports Kerberos and token based authentication where tokens can be customized. The Ozone specific implementation `OzoneTokenIdentifier` contains a `type` field which can `DELEGATION_TOKEN` or `S3AUTHINFO`. The later one is used to authenticate the request based on S3 REST header (signature + required information).\n+\n+Both token and Kerberos based authentication are checked by Hadoop RPC during the connection initialization phase using the SASL standard. SASL defines the initial handshake of the creation where server can check the authentication information with a challenge-response mechanism.\n+\n+As a result Ozone S3g requires to create a new Hadoop RPC client for each of the HTTP requests as each requests may have different AWS authentication   information / signature. Ozone S3g creates a new `OzoneClient` for each of the requests which includes the creation of Hadoop RPC client.\n+\n+There are two problems with this approach:\n+\n+1.  **performance**: Creating a new `OzoneClient` requires to create new connection, to perform the SASL handshake and to send the initial discovery call to the OzoneManager to get the list of available services. It makes S3 performance very slow.\n+2. **error handling:** Creating new `OzoneClient` for each requests makes the propagation of error code harder with CDI.\n+\n+[CDI](http://cdi-spec.org/) is the specification of *Contexts and  Dependency Injection* for Java. Can be used for both JavaEE and JavaSE and it's integrated with most web frameworks. Ozone S3g uses this specification to inject different services to to REST handlers using `@Inject` annotation.\n+\n+`OzoneClient` is created by the `OzoneClientProduced`:\n+\n+```\n+@RequestScoped\n+public class OzoneClientProducer {\n+\n+  private OzoneClient client;\n+\n+  @Inject\n+  private SignatureProcessor signatureParser;\n+\n+  @Inject\n+  private OzoneConfiguration ozoneConfiguration;\n+\n+  @Inject\n+  private Text omService;\n+\n+  @Inject\n+  private String omServiceID;\n+\n+\n+  @Produces\n+  public OzoneClient createClient() throws OS3Exception, IOException {\n+    client = getClient(ozoneConfiguration);\n+    return client;\n+  }\n+...\n+}\n+```\n+\n+As we can see here, the producer is *request* scoped (see the annotation on the class), which means that the `OzoneClient` bean will be created for each request. If the client couldn't be created a specific exception will be thrown by the CDI framework (!) as one bean couldn't be injected with CDI. This error is different from the regular business exceptions therefore the normal exception handler (`OS3ExceptionMapper` implements `javax.ws.rs.ext.ExceptionMapper`) -- which can transform exceptions to HTTP error code -- doesn't apply. It can cause strange 500 error instead of some authentication error.\n+\n+## Caching\n+\n+Hadoop RPC has a very specific caching layer which is **not used** by Ozone S3g. This section describe the caching of the Hadoop RPC, but safe to skip (It explain how is the caching ignored).\n+\n+As creating new Hadoop RPC connection is an expensive operation Hadoop RPC has an internal caching mechanism to cache client and connections (!). This caching is hard-coded and based on static fields (couldn't be adjusted easily).\n+\n+Hadoop RPC client is usually created by `RPC.getProcolProxy`. For example:\n+\n+```\n+HelloWorldServicePB proxy = RPC.getProtocolProxy(\n+            HelloWorldServicePB.class,\n+            scmVersion,\n+            new InetSocketAddress(1234),\n+            UserGroupInformation.getCurrentUser(),\n+            configuration,\n+            new StandardSocketFactory(),\n+            Client.getRpcTimeout(configuration),\n+            retryPolicy).getProxy();\n+```\n+\n+This code fragment creates a new client which can be used from the code, and it uses multiple caches for client creation.\n+\n+1. Protocol engines are cached by `RPC.PROTOCOL_ENGINES` static field, but it's safe to assume that the `ProtobufRpcEngine` is used for most of the current applications.\n+\n+2. `ProtobufRpcEngine` has a static `ClientCache` field which caches the client instances with the `socketFactory` and `protocol` as the key.\n+\n+3. Finally the `Client.getConnection` method uses a cache to cache the connections:\n+\n+   ```\n+   connection = connections.computeIfAbsent(remoteId,\n+       id -> new Connection(id, serviceClass, removeMethod));\n+   ```\n+\n+   The key for the cache is the `remoteId` which includes all the configuration, connection parameters (like destination host) and `UserGroupInformation` (UGI).\n+\n+The caching of the connections can cause very interesting cases. As an example, let's assume that delegation token is invalidated with an RPC call. The workflow can be something like this:\n+\n+1. create protocol proxy (with token authentication)\n+2. invalidate token (rpc call)\n+3. close protocol proxy (connection may not be closed. depends from the cache)\n+4. create a new protocol proxy\n+5. If connection is cached (same UGI) services can be used even if the token is invalidated earlier (as the token is checked during the initialization of the tokens).\n+\n+Fortunately this behavior doesn't cause any problem in case of Ozone and S3g. UGI (which is part of the cache key of the connection cache) equals if (and only if) the underlying `Subject` is the same.\n+\n+```\n+public class UserGroupInformation {\n+  \n+  ...\n+  \n+  @Override\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    } else {\n+      return subject == ((UserGroupInformation) o).subject;\n+    }\n+  }\n+}\n+```\n+\n+ But the UGI initialization of Ozone always creates a new `Subject` instance for each request (even if the subject name is the same). In `OzoneClientProducer`:\n+\n+```\n+  UserGroupInformation remoteUser =\n+          UserGroupInformation.createRemoteUser(awsAccessId); // <-- new Subject is created\n+      \n+      if (OzoneSecurityUtil.isSecurityEnabled(config)) {\n+        try {\n+          OzoneTokenIdentifier identifier = new OzoneTokenIdentifier();\n+          //setup identifier\n+          \n+          Token<OzoneTokenIdentifier> token = new Token(identifier.getBytes(),\n+              identifier.getSignature().getBytes(UTF_8),\n+              identifier.getKind(),\n+              omService);\n+          remoteUser.addToken(token);\n+          ....\n+```\n+\n+**As a result Hadoop RPC caching doesn't apply to Ozone S3g**. It's a good news because it's secure, but bad news as the performance is bad.\n+\n+# Proposed change\n+\n+We need an RPC mechanism between the Ozone S3g service and Ozone Manager service which can support per-request authentication and accepts\n+\n+The  Ozone Manager client already has a pluggable transport interface: `OmTransport` is a simple interface which can deliver `OMRequest` messages:\n+\n+```\n+public interface OmTransport {\n+\n+  /**\n+   * The main method to send out the request on the defined transport.\n+   */\n+  OMResponse submitRequest(OMRequest payload) throws IOException;\n+  ...\n+```\n+\n+ The proposal is to create a new **additional** transport, based on GRPC, which can do the per-request authentication. **Existing Hadoop clients will use the well-known Hadoop RPC client**, but S3g can start to use this specific transport to achieve better performance.\n+\n+As this is nothing more, just a transport: exactly the same messages (`OmRequest`) will be used, it's not a new RPC interface.\n+\n+Only one modification is required in the RPC interface: a new per-request`token` field should be introduced in `OMRequest` which is optional.\n+\n+A new GRPC service should be started in Ozone Manager, which receives `OMRequest` and for each request, the Hadoop `UserGroupInformation` is set based on the new token field (after authentication).\n+\n+`OzoneToken` identifier can be simplified (after deprecation period) with removing the S3 specific part, as it won't be required any more.\n+\n+With this approach the `OzoneClient` instances can be cached on S3g side (with persistent GRPC connections) as the authentication information is not part of the OzoneClient any more (added by the `OmTransport` implementation per request (in case of GRPC) or per connection (in case of HadoopRPC)).\n+\n+# Possible alternatives\n+\n+* It's possible to use pure Hadoop RPC client instead of Ozone Client which would make the client connection slightly cheaper (service discovery call is not required) but it's still require to create new connections for each requests (and downloading data without OzoneClient may have own challenges).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2429b8ef341bda1f7287effda37d58b2910100"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0bf60dbf01add562556574358f0cfdaa5814065", "author": {"user": {"login": "elek", "name": "Elek, M\u00e1rton"}}, "url": "https://github.com/apache/ozone/commit/b0bf60dbf01add562556574358f0cfdaa5814065", "committedDate": "2020-11-23T08:36:23Z", "message": "fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af946408c560e1ccbb5a1e6711775eb7e140113b", "author": {"user": {"login": "elek", "name": "Elek, M\u00e1rton"}}, "url": "https://github.com/apache/ozone/commit/af946408c560e1ccbb5a1e6711775eb7e140113b", "committedDate": "2020-12-07T15:01:28Z", "message": "diagram about the old a new approach"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxMDQ1MDky", "url": "https://github.com/apache/ozone/pull/1562#pullrequestreview-601045092", "createdAt": "2021-03-01T18:33:59Z", "commit": {"oid": "b0bf60dbf01add562556574358f0cfdaa5814065"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxODozMzo1OVrOIt2zvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQxODozMzo1OVrOIt2zvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDk1NDgxMg==", "bodyText": "Can we add the word proposal here in the title/summary?", "url": "https://github.com/apache/ozone/pull/1562#discussion_r584954812", "createdAt": "2021-03-01T18:33:59Z", "author": {"login": "arp7"}, "path": "hadoop-hdds/docs/content/design/s3-performance.md", "diffHunk": "@@ -0,0 +1,205 @@\n+---\n+title: Persistent OM connection for S3 gateway\n+summary: Use per-request authentication and persistent connections between S3g and OM", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0bf60dbf01add562556574358f0cfdaa5814065"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c6ce9158a9425ca331fea72fbf7153891047ea1", "author": {"user": {"login": "elek", "name": "Elek, M\u00e1rton"}}, "url": "https://github.com/apache/ozone/commit/9c6ce9158a9425ca331fea72fbf7153891047ea1", "committedDate": "2021-03-01T19:18:05Z", "message": "adding proposal word to the title and summary"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxMTk0NTc0", "url": "https://github.com/apache/ozone/pull/1562#pullrequestreview-601194574", "createdAt": "2021-03-01T21:45:00Z", "commit": {"oid": "9c6ce9158a9425ca331fea72fbf7153891047ea1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2257, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}