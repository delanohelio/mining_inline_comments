{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNTU4ODc4", "number": 1404, "title": "HDDS-2949: mkdir : store directory entries in a separate table", "bodyText": "What changes were proposed in this pull request?\nAll the directories from the path components should be created on 'DirectoryTable'. Here, it uses new classes and retained existing logic. This is required during rolling upgrade. So, created V1 classes for the implementation. Later, during rolling upgrade will rebase this feature branch accordingly.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-2949\nHow was this patch tested?\nVerified using TestOMDirectoryCreateResponseV1.java and TestOzoneDirectory.java unit test cases.\nNote: As this is an incremental change, it is expected to have failures related to file, key ops test cases. Will fix this later through subsequent sub-tasks.", "createdAt": "2020-09-07T17:15:29Z", "url": "https://github.com/apache/ozone/pull/1404", "merged": true, "mergeCommit": {"oid": "5519cc095785e7a501f6f7a873e9087049219e50"}, "closed": true, "closedAt": "2020-10-01T19:15:20Z", "author": {"login": "rakeshadr"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG6CJOgFqTQ4NDI4OTgzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOWWiNAFqTUwMDY0NDU4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Mjg5ODM1", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-484289835", "createdAt": "2020-09-08T16:05:47Z", "commit": {"oid": "af21eda4b80d02c0643bafc84ab84bc0a63aa04e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjowNTo0OFrOHOkM3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjowOTozM1rOHOkV2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNTIyOA==", "bodyText": "Wrong log instance name, TestOzoneFileSystem -> TestOzoneDirectory", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485035228", "createdAt": "2020-09-08T16:05:48Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneDirectory.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.\u2002\u2002See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.\u2002\u2002The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.\u2002\u2002You may obtain a copy of the License at\n+ *\n+ * \u2002\u2002\u2002\u2002 http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.util.StringUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_KEY;\n+import static org.apache.hadoop.ozone.OzoneConfigKeys.OZONE_FS_ITERATE_BATCH_SIZE;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test verifies the entries and operations in directory table.\n+ */\n+public class TestOzoneDirectory {\n+\n+  @Rule\n+  public Timeout timeout = new Timeout(300000);\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(TestOzoneFileSystem.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af21eda4b80d02c0643bafc84ab84bc0a63aa04e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNzUyOA==", "bodyText": "Just a comment: will we introduced DIR_LOCK for dir table update in the future?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485037528", "createdAt": "2020-09-08T16:09:33Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af21eda4b80d02c0643bafc84ab84bc0a63aa04e"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDgyMzk1", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-485082395", "createdAt": "2020-09-09T14:41:21Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzM1NzQw", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-488335740", "createdAt": "2020-09-15T05:30:30Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMDozMFrOHRxQoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMDozMFrOHRxQoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NDkxMg==", "bodyText": "Minor:\nHere this should be like this.ozoneAcls.add(ozoneacls)", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488394912", "createdAt": "2020-09-15T05:30:30Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzM2MDA2", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-488336006", "createdAt": "2020-09-15T05:31:14Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMToxNVrOHRxRgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMToxNVrOHRxRgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTEzOA==", "bodyText": "Minor:\nHere this should be like this.metadata.putAll(newMetadata)", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488395138", "createdAt": "2020-09-15T05:31:15Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzM2Njg3", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-488336687", "createdAt": "2020-09-15T05:33:10Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMzoxMFrOHRxT2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozMzoxMFrOHRxT2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTczNg==", "bodyText": "Do we need to atleast print getObjectID() + name here?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488395736", "createdAt": "2020-09-15T05:33:10Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzM3ODkz", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-488337893", "createdAt": "2020-09-15T05:36:21Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozNjoyMVrOHRxYDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxMjoxMlrOHSUuVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjgxMw==", "bodyText": "Minor: New line missing at end of file.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488396813", "createdAt": "2020-09-15T05:36:21Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \"\";\n+  }\n+\n+  public long getParentObjectID() {\n+    return parentObjectID;\n+  }\n+\n+  public String getPath() {\n+    return getParentObjectID() + OzoneConsts.OM_KEY_PREFIX + getName();\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public long getCreationTime() {\n+    return creationTime;\n+  }\n+\n+  public long getModificationTime() {\n+    return modificationTime;\n+  }\n+\n+  public List<OzoneAcl> getAcls() {\n+    return acls;\n+  }\n+\n+  /**\n+   * Creates DirectoryInfo protobuf from OmDirectoryInfo.\n+   */\n+  public OzoneManagerProtocolProtos.DirectoryInfo getProtobuf() {\n+    OzoneManagerProtocolProtos.DirectoryInfo.Builder pib =\n+            OzoneManagerProtocolProtos.DirectoryInfo.newBuilder().setName(name)\n+                    .setCreationTime(creationTime)\n+                    .setModificationTime(modificationTime)\n+                    .addAllMetadata(KeyValueUtil.toProtobuf(metadata))\n+                    .setObjectID(objectID)\n+                    .setUpdateID(updateID)\n+                    .setParentID(parentObjectID);\n+    if (acls != null) {\n+      pib.addAllAcls(OzoneAclUtil.toProtobuf(acls));\n+    }\n+    return pib.build();\n+  }\n+\n+  /**\n+   * Parses DirectoryInfo protobuf and creates OmPrefixInfo.\n+   * @param dirInfo\n+   * @return instance of OmDirectoryInfo\n+   */\n+  public static OmDirectoryInfo getFromProtobuf(\n+          OzoneManagerProtocolProtos.DirectoryInfo dirInfo) {\n+    OmDirectoryInfo.Builder opib = OmDirectoryInfo.newBuilder()\n+            .setName(dirInfo.getName())\n+            .setCreationTime(dirInfo.getCreationTime())\n+            .setModificationTime(dirInfo.getModificationTime())\n+            .setAcls(OzoneAclUtil.fromProtobuf(dirInfo.getAclsList()));\n+    if (dirInfo.getMetadataList() != null) {\n+      opib.addAllMetadata(KeyValueUtil\n+              .getFromProtobuf(dirInfo.getMetadataList()));\n+    }\n+    if (dirInfo.hasObjectID()) {\n+      opib.setObjectID(dirInfo.getObjectID());\n+    }\n+    if (dirInfo.hasParentID()) {\n+      opib.setParentObjectID(dirInfo.getParentID());\n+    }\n+    if (dirInfo.hasUpdateID()) {\n+      opib.setUpdateID(dirInfo.getUpdateID());\n+    }\n+    return opib.build();\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    OmDirectoryInfo omDirInfo = (OmDirectoryInfo) o;\n+    return creationTime == omDirInfo.creationTime &&\n+            modificationTime == omDirInfo.modificationTime &&\n+            name.equals(omDirInfo.name) &&\n+            Objects.equals(metadata, omDirInfo.metadata) &&\n+            Objects.equals(acls, omDirInfo.acls) &&\n+            objectID == omDirInfo.objectID &&\n+            updateID == omDirInfo.updateID &&\n+            parentObjectID == omDirInfo.parentObjectID;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(objectID, parentObjectID, name);\n+  }\n+\n+  /**\n+   * Return a new copy of the object.\n+   */\n+  public OmDirectoryInfo copyObject() {\n+    OmDirectoryInfo.Builder builder = new Builder()\n+            .setName(name)\n+            .setCreationTime(creationTime)\n+            .setModificationTime(modificationTime)\n+            .setParentObjectID(parentObjectID)\n+            .setObjectID(objectID)\n+            .setUpdateID(updateID);\n+\n+    acls.forEach(acl -> builder.addAcl(new OzoneAcl(acl.getType(),\n+            acl.getName(), (BitSet) acl.getAclBitSet().clone(),\n+            acl.getAclScope())));\n+\n+    if (metadata != null) {\n+      metadata.forEach((k, v) -> builder.addMetadata(k, v));\n+    }\n+\n+    return builder.build();\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Nzc0Ng==", "bodyText": "Minor: Newline missing at end of the file.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488397746", "createdAt": "2020-09-15T05:39:21Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/codec/OmDirectoryInfoCodec.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.codec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hadoop.hdds.utils.db.Codec;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.DirectoryInfo;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Codec to encode OmDirectoryInfo as byte array.\n+ */\n+public class OmDirectoryInfoCodec implements Codec<OmDirectoryInfo> {\n+\n+  @Override\n+  public byte[] toPersistedFormat(OmDirectoryInfo object) throws IOException {\n+    Preconditions\n+            .checkNotNull(object, \"Null object can't be converted \" +\n+                    \"to byte array.\");\n+    return object.getProtobuf().toByteArray();\n+  }\n+\n+  @Override\n+  public OmDirectoryInfo fromPersistedFormat(byte[] rawData)\n+          throws IOException {\n+    Preconditions\n+            .checkNotNull(rawData,\n+                    \"Null byte array can't converted to real object.\");\n+    try {\n+      return OmDirectoryInfo.getFromProtobuf(DirectoryInfo.parseFrom(rawData));\n+    } catch (InvalidProtocolBufferException e) {\n+      throw new IllegalArgumentException(\n+              \"Can't encode the the raw data from the byte array\", e);\n+    }\n+  }\n+\n+  @Override\n+  public OmDirectoryInfo copyObject(OmDirectoryInfo object) {\n+    return object.copyObject();\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTQ3OA==", "bodyText": "once we change setMetadata with the same code, we can remove this API.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488399478", "createdAt": "2020-09-15T05:44:31Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNTIxOQ==", "bodyText": "Can we add a unit test similar to TestOMDirectoryCreateRequest.java", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488915219", "createdAt": "2020-09-15T19:26:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneDirectory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.\u2002\u2002See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.\u2002\u2002The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.\u2002\u2002You may obtain a copy of the License at\n+ *\n+ * \u2002\u2002\u2002\u2002 http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.util.StringUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_KEY;\n+import static org.apache.hadoop.ozone.OzoneConfigKeys.OZONE_FS_ITERATE_BATCH_SIZE;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test verifies the entries and operations in directory table.\n+ */\n+public class TestOzoneDirectory {\n+\n+  @Rule\n+  public Timeout timeout = new Timeout(300000);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNzc5OQ==", "bodyText": "Minor: omPrefixInfo -> omDirectoryInfo", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488917799", "createdAt": "2020-09-15T19:29:54Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMzMzNw==", "bodyText": "Minor: parentPrefixInfo -> parentDirectoryInfo", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488923337", "createdAt": "2020-09-15T19:36:13Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0MDE3NQ==", "bodyText": "With current logic Key and directory in bucket root will pass, as we have not checked bucket/key in keyTable in first iteration.\nExample scenario:\nFSDataOutputStream ozoneOutputStream = fs.create(new Path(\"/a1\"));\n    ozoneOutputStream.close();\n\n    fs.mkdirs(new Path(\"/a1\"));", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488940175", "createdAt": "2020-09-15T20:02:40Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omPrefixInfo != null) {\n+        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          lastKnownParentId = omPrefixInfo.getObjectID();\n+          parentPrefixInfo = omPrefixInfo;\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        if (parentPrefixInfo != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTM2Mg==", "bodyText": "result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n\nShould this line of code be here, as here we found a directory exists in given path? But with this approach, I see there is no real use of it.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488949362", "createdAt": "2020-09-15T20:20:36Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omPrefixInfo != null) {\n+        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Mjg1Mw==", "bodyText": "Modified logic below, looks like few cases are missed.\nHave a look into it, and reuse it as needed.\n  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n          @Nonnull OMMetadataManager omMetadataManager,\n          @Nonnull String volumeName,\n          @Nonnull String bucketName, @Nonnull String keyName,\n          @Nonnull Path keyPath) throws IOException {\n\n    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n    List<String> missing = new ArrayList<>();\n    List<OzoneAcl> inheritAcls = new ArrayList<>();\n    OMDirectoryResult result = OMDirectoryResult.NONE;\n\n    Iterator<Path> elements = keyPath.iterator();\n    // TODO: volume id and bucket id generation logic.\n    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n    long lastKnownParentId = omMetadataManager.getBucketTable().get(bucketKey)\n        .getObjectID();\n    String dbDirName = \"\"; // absolute path for trace logs\n    while (elements.hasNext()) {\n      String fileName = elements.next().toString();\n      if (missing.size() > 0) {\n        // Add all the sub-dirs to the missing list except the leaf element.\n        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n        if(elements.hasNext()){\n          // skips leaf node.\n          missing.add(fileName);\n        }\n        continue;\n      }\n\n      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n      // 1. Do lookup on directoryTable. If not exists goto next step.\n      // 2. Do look on keyTable. If not exists goto next step.\n      // 3. Add 'sub-dir' to missing parents list\n      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n              lastKnownParentId, fileName);\n      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n              get(dbNodeName);\n      if (omPrefixInfo != null) {\n        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n        if (elements.hasNext()) {\n          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n          lastKnownParentId = omPrefixInfo.getObjectID();\n          inheritAcls = omPrefixInfo.getAcls();\n          continue;\n        } else {\n          // Checked all the sub-dirs till the leaf node.\n          // Found a directory in the given path.\n          result = OMDirectoryResult.DIRECTORY_EXISTS;\n          break;\n        }\n      } else {\n        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n          if (elements.hasNext()) {\n            // Found a file in the given key name.\n            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n          } else {\n            // Checked all the sub-dirs till the leaf file.\n            // Found a file with the given key name.\n            result = OMDirectoryResult.FILE_EXISTS;\n          }\n          break; // Skip directory traversal as it hits key.\n        }\n      }\n\n      // Add to missing list, there is no such key/directory with given name\n      if (elements.hasNext()) {\n        missing.add(fileName);\n      }\n    }\n\n    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {\n      String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n          bucketName, dbDirName);\n      LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n          + inheritAcls);\n    }\n\n    if (result != OMDirectoryResult.NONE) {\n      LOG.trace(\"verifyFiles in Path : \" + \"/\" + volumeName\n              + \"/\" + bucketName + \"/\" + keyName + \":\" + result);\n      return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing, result,\n              inheritAcls, dbDirName);\n    }\n\n    if (inheritAcls.isEmpty()) {\n      inheritAcls = omMetadataManager.getBucketTable().get(bucketKey)\n              .getAcls();\n      LOG.trace(\"Acls inherited from bucket \" + bucketName + \" are : \"\n              + inheritAcls);\n    }\n\n    LOG.trace(\"verifyFiles in Path : \" + volumeName + \"/\" + bucketName + \"/\"\n            + keyName + \":\" + result);\n\n    // Found no files/ directories in the given path.\n    return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing,\n            OMDirectoryResult.NONE, inheritAcls, null);\n  }", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488972853", "createdAt": "2020-09-15T21:05:49Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NDY3NQ==", "bodyText": "Here this should be in new format right?\nlike parentObjectID/name, as we use the format of parentObjectID/name when writing to DB in Response class.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488974675", "createdAt": "2020-09-15T21:09:34Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -254,4 +440,34 @@ public static void addKeyTableCacheEntries(\n           new CacheValue<>(keyInfo, index));\n     }\n   }\n+\n+  /**\n+   * Adding directory info to the Table cache.\n+   *\n+   * @param omMetadataManager  OM Metdata Manager\n+   * @param dirInfo            directory info\n+   * @param missingParentInfos list of the parents to be added to DB\n+   * @param trxnLogIndex       transaction log index\n+   */\n+  public static void addDirectoryTableCacheEntries(\n+          OMMetadataManager omMetadataManager,\n+          Optional<OmDirectoryInfo> dirInfo,\n+          Optional<List<OmDirectoryInfo>> missingParentInfos,\n+          long trxnLogIndex) {\n+    for (OmDirectoryInfo parentInfo : missingParentInfos.get()) {\n+      omMetadataManager.getDirectoryTable().addCacheEntry(\n+              new CacheKey<>(omMetadataManager.getOzoneLeafNodeKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTQ1Mw==", "bodyText": "Not understand what this TODO means here.\nCan you explain what is missing here?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488975453", "createdAt": "2020-09-15T21:11:11Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" +keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to KeyTable\", missingKey);\n+      // what about keyArgs for parent directories? TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTk1Nw==", "bodyText": "Here should we increment Keys based on the number of directories being created?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488975957", "createdAt": "2020-09-15T21:12:12Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" +keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTE3Njk5", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-489117699", "createdAt": "2020-09-15T21:31:19Z", "commit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTozMToyMFrOHSVQtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTozMToyMFrOHSVQtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NDc1OQ==", "bodyText": "Here we can add exisitingKeyPath also it will help in debugging failure scenario for like mkdir fails with FILE_EXISTS or FILE_EXISTS_IN_GIVEN_PATH or other error", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488984759", "createdAt": "2020-09-15T21:31:20Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -156,6 +277,71 @@ public static long getObjIDFromTxId(long id) {\n     return new ImmutablePair<>(baseId, maxAvailableId);\n   }\n \n+\n+  /**\n+   * Class to return the results from verifyDirectoryKeysInPath.\n+   * Includes the list of missing intermediate directories and\n+   * the directory search result code.\n+   */\n+  public static class OMPathInfoV1 {\n+    private OMDirectoryResult directoryResult;\n+    private String leafNodeName;\n+    private long lastKnownParentId;\n+    private long leafNodeObjectId;\n+    private List<String> missingParents;\n+    private List<OzoneAcl> acls;\n+\n+    public OMPathInfoV1(String leafNodeName, long lastKnownParentId,\n+                        List missingParents, OMDirectoryResult result,\n+                        List<OzoneAcl> aclList) {\n+      this.leafNodeName = leafNodeName;\n+      this.lastKnownParentId = lastKnownParentId;\n+      this.missingParents = missingParents;\n+      this.directoryResult = result;\n+      this.acls = aclList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 169}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fd60f6688f3f9df14749fb6ea4af4332c00d907", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/1fd60f6688f3f9df14749fb6ea4af4332c00d907", "committedDate": "2020-09-25T19:43:56Z", "message": "HDDS-2949: mkdir : store directory entries in a separate table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f2560eeb2c26aaef2e9c619ba2f93b08177a754", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/0f2560eeb2c26aaef2e9c619ba2f93b08177a754", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed checkstyle warnings and changed layout version defaulting to V0 to run existing UTs happily"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6023e771bdb88af811c907509e558dbcfcbb602a", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/6023e771bdb88af811c907509e558dbcfcbb602a", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed checkstyle, findbug warnings, review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8dc0607f00efa9c1fd53c26f117ef2c4d558202", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/e8dc0607f00efa9c1fd53c26f117ef2c4d558202", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "786b2972981a2ff624136a0a2cc75f21d431951f", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/786b2972981a2ff624136a0a2cc75f21d431951f", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed checkstyle warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "892214ba54ff5de62355470818ab47de8b94d2ec", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/892214ba54ff5de62355470818ab47de8b94d2ec", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed typos and renamed method name"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d63a0000b0fa9cdff8bccad6a1f5fd9ff63a06f2", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/d63a0000b0fa9cdff8bccad6a1f5fd9ff63a06f2", "committedDate": "2020-09-24T11:42:58Z", "message": "Fixed typos and renamed method name"}, "afterCommit": {"oid": "892214ba54ff5de62355470818ab47de8b94d2ec", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/892214ba54ff5de62355470818ab47de8b94d2ec", "committedDate": "2020-09-25T19:43:56Z", "message": "Fixed typos and renamed method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/c94d909974f2df086bbceb0e5b6b0f87dc977c53", "committedDate": "2020-09-25T19:55:30Z", "message": "Fixed rebase compilation failures and renamed variable name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzgxNDE4", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-497781418", "createdAt": "2020-09-28T18:15:01Z", "commit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxNTowMVrOHZKMKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMTozMDoyN1rOHZQUyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzQwMA==", "bodyText": "We dont need this check.\nAs default inheritAcls is bucketAcls only.\nLet's say, we create /a/b/c, now for all of them we have acls with bucketAcls.\nSo, next time when we create /a/b/c/d, then it will have Acls.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496143400", "createdAt": "2020-09-28T18:15:01Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+                + inheritAcls);\n+      }\n+    }\n+\n+    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {\n+      String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+              bucketName, dbDirName);\n+      LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+              + inheritAcls);\n+    }\n+\n+    if (result != OMDirectoryResult.NONE) {\n+      LOG.trace(\"verifyFiles in Path : \" + \"/\" + volumeName\n+              + \"/\" + bucketName + \"/\" + keyName + \":\" + result);\n+      return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing, result,\n+              inheritAcls, fullKeyPath.toString());\n+    }\n+\n+    if (inheritAcls.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA==", "bodyText": "Now we don't really need this, as now logic checks from parent to leaf, as previous logic checks from leaf to parent DIRECTORY_EXISTS_IN_GIVENPATH makes sense, so we don't really need this special handling.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496145730", "createdAt": "2020-09-28T18:19:33Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+                + inheritAcls);\n+      }\n+    }\n+\n+    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjMzMw==", "bodyText": "We need only full path in case of errors where we can return fullKeyPath.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496146333", "createdAt": "2020-09-28T18:20:34Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+                + inheritAcls);\n+      }\n+    }\n+\n+    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA=="}, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjgxMA==", "bodyText": "Here still addallMetadata is there and setMetadata is removed.\nI think that should be fine, but if we can name it as setMetadata it will be uniform with setAcls", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496146810", "createdAt": "2020-09-28T18:21:29Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTQ3OA=="}, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MjcyNw==", "bodyText": "Cache KeyName also should be same as parentObjectID/dirname\nAs this is what we used to search for the entry in the directory table.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496152727", "createdAt": "2020-09-28T18:32:12Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFullKeyPathName() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      for (int indx = 0; indx < numKeys; indx++) {\n+        omMetrics.incNumKeys();\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to DirectoryTable\",\n+              missingKey);\n+      // what about keyArgs for parent directories? TODO\n+      OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(missingKey,\n+              keyArgs, nextObjId, lastKnownParentId, trxnLogIndex, inheritAcls);\n+      objectCount++;\n+\n+      missingParentInfos.add(dirInfo);\n+\n+      // add entry to directory table\n+      omMetadataManager.getDirectoryTable().addCacheEntry(\n+              new CacheKey<>(omMetadataManager.getOzoneKey(volumeName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1NjA4NQ==", "bodyText": "Can we have a new API in Metrics class to take a value for increment, instead of calling in for loop?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496156085", "createdAt": "2020-09-28T18:38:34Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFullKeyPathName() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      for (int indx = 0; indx < numKeys; indx++) {\n+        omMetrics.incNumKeys();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4MzE5NA==", "bodyText": "And also here entries are set with only leaf name, it should be full path.\nExample:\n/v/b/a/b1/c\nRight now with this logic, missing directory Info's created in cache are which is wrong\n/v/b/a\n/v/b/b1 --> /v/b/a/b1\n/v/b/c --> /v/b/a/b1/c\nI see that we do in OMDirectoryCreateRequestV1.java, So we can remove adding to the cache here, which will solve this issue.\nRight now because of the above logic we have both.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496183194", "createdAt": "2020-09-28T19:29:52Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFullKeyPathName() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      for (int indx = 0; indx < numKeys; indx++) {\n+        omMetrics.incNumKeys();\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to DirectoryTable\",\n+              missingKey);\n+      // what about keyArgs for parent directories? TODO\n+      OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(missingKey,\n+              keyArgs, nextObjId, lastKnownParentId, trxnLogIndex, inheritAcls);\n+      objectCount++;\n+\n+      missingParentInfos.add(dirInfo);\n+\n+      // add entry to directory table\n+      omMetadataManager.getDirectoryTable().addCacheEntry(\n+              new CacheKey<>(omMetadataManager.getOzoneKey(volumeName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MjcyNw=="}, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MDk5MQ==", "bodyText": "We can remove trace here in loop, we can log outside the for loop.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496190991", "createdAt": "2020-09-28T19:44:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NDAxMQ==", "bodyText": "Here only validateAndUpdateCache is done, so it will only be in cache.\nAs Table get checks both in cache and DB first check should be enough here.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496194011", "createdAt": "2020-09-28T19:50:51Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.*;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.*;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNTU0MQ==", "bodyText": "Can we use Key separator(/) here?", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496235541", "createdAt": "2020-09-28T21:12:32Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> listOfAcls) {\n+      if (listOfAcls != null) {\n+        this.acls.addAll(listOfAcls);\n+      }\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \":\" + getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzODU4Mg==", "bodyText": "One more test can be added here file exists in a given path.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496238582", "createdAt": "2020-09-28T21:18:53Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.*;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.*;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithFilesInPath() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    long objID = 100;\n+    long txnID = 5000;\n+    // for index=0, parentID is bucketID\n+    OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+            dirs.get(0), objID++, parentID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+            txnID, omMetadataManager);\n+    parentID = omDirInfo.getObjectID();\n+\n+    // Add a key in second level.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,\n+            HddsProtos.ReplicationFactor.THREE, objID++);\n+    String ozoneKey = parentID + \"/\" + dirs.get(1);\n+    omMetadataManager.getKeyTable().addCacheEntry(new CacheKey<>(ozoneKey),\n+            new CacheValue<>(Optional.of(omKeyInfo), ++txnID));\n+    omMetadataManager.getKeyTable().put(ozoneKey, omKeyInfo);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.FILE_ALREADY_EXISTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0MzQwOA==", "bodyText": "This can be removed, already volume/buckets use new id generation logic.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496243408", "createdAt": "2020-09-28T21:29:23Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0MzkxMw==", "bodyText": "DIRECTORY_EXISTS_IN_GIVENPATH is used when we check from leaf to parent, but now this logic is opposite.\nI am fine with leaving, but not really required in this case.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496243913", "createdAt": "2020-09-28T21:30:27Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omPrefixInfo != null) {\n+        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTM2Mg=="}, "originalCommit": {"oid": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4347ff0ccf452a92b5e62ba332a0400140f177ff", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/4347ff0ccf452a92b5e62ba332a0400140f177ff", "committedDate": "2020-09-29T17:19:36Z", "message": "Fixed review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/72172429fb9580ac63f35427ca91d34d5fe4eaca", "committedDate": "2020-09-29T18:33:48Z", "message": "Fixed cheeckstyle warnings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODYwNzM2", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-499860736", "createdAt": "2020-09-30T22:39:49Z", "commit": {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMjozOTo0OVrOHaxwqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMzowMTo1M1rOHayNHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDI5OQ==", "bodyText": "We are adding them 2 times once here, and next immediately in addDirectoryTableCacheEntries.\nNo correctness issue, but can be removed from one place.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497840299", "createdAt": "2020-09-30T22:39:49Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFileExistsInPath() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys(numKeys);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to DirectoryTable\",\n+              missingKey);\n+      OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(missingKey,\n+              keyArgs, nextObjId, lastKnownParentId, trxnLogIndex, inheritAcls);\n+      objectCount++;\n+\n+      missingParentInfos.add(dirInfo);\n+\n+      // add entry to directory table\n+      String dirKey = omMetadataManager.getOzonePathKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0Mjg2OQ==", "bodyText": "Minor:\nkeyName should be bucketKey+\"/\"+dirs.get(0)+\"/\"+dirs.get(1), as this is the key put in to keyTable.\nNo correctness issue BTW.", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497842869", "createdAt": "2020-09-30T22:47:25Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmMetadataManagerImpl;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(false, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    Assert.assertEquals(\"Wrong OM numKeys metrics\",\n+            0, ozoneManager.getMetrics().getNumKeys());\n+\n+    // Key should exist in DB and doesn't added to cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesNotInCache(dirs, bucketID);\n+  }\n+\n+  /**\n+   * Case: File exists with the same name as the requested directory.\n+   * Say, requested to createDir '/a/b/c' and there is a file exists with\n+   * same name.\n+   */\n+  @Test\n+  public void testValidateAndUpdateCacheWithFilesInPath() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    // add all the parent directories into DirectoryTable. This won't create\n+    // the leaf node and this will be used in CreateDirectoryReq.\n+    for (int indx = 0; indx < dirs.size() - 1; indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(false, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    long objID = parentID + 100;\n+    long txnID = 50000;\n+\n+    // Add a file into the FileTable, this is to simulate \"file exists\" check.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,\n+            HddsProtos.ReplicationFactor.THREE, objID++);\n+    String ozoneFileName = parentID + \"/\" + dirs.get(dirs.size() - 1);\n+    omMetadataManager.getKeyTable().addCacheEntry(new CacheKey<>(ozoneFileName),\n+            new CacheValue<>(Optional.of(omKeyInfo), ++txnID));\n+    omMetadataManager.getKeyTable().put(ozoneFileName, omKeyInfo);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.FILE_ALREADY_EXISTS);\n+\n+    Assert.assertEquals(\"Wrong OM numKeys metrics\",\n+            0, ozoneManager.getMetrics().getNumKeys());\n+\n+    // Key should not exist in DB\n+    Assert.assertNotNull(omMetadataManager.getKeyTable().get(ozoneFileName));\n+    // Key should not exist in DB\n+    Assert.assertEquals(\"Wrong directories count!\", 3,\n+            omMetadataManager.getDirectoryTable().getEstimatedKeyCount());\n+  }\n+\n+\n+  /**\n+   * Case: File exists in the given path.\n+   * Say, requested to createDir '/a/b/c/d' and there is a file '/a/b' exists\n+   * in the given path.\n+   */\n+  @Test\n+  public void testValidateAndUpdateCacheWithFileExistsInGivenPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    long objID = parentID + 100;\n+    long txnID = 5000;\n+\n+    // for index=0, parentID is bucketID\n+    OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+            dirs.get(0), objID++, parentID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+            txnID, omMetadataManager);\n+    parentID = omDirInfo.getObjectID();\n+\n+    // Add a key in second level.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0NzU4Mg==", "bodyText": "For leaf, we have used baseObjID + objCount. But here it is mentioned we use baseObjID is used for leaf, assuming that it has started for missing directories from baseObjID +1.\n pathInfo.setLeafNodeObjectId(baseObjId + objectCount);\nIf we want to keep them sorted, we can start with ObjCount as 0. (Not sure, in future if this will help in the listing)\nWith this, there is a chance to exceed maxObjectID", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497847582", "createdAt": "2020-09-30T23:01:53Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFileExistsInPath() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys(numKeys);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96a750b7ba25c980416654f8e0ca226c8f2a1bb3", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/96a750b7ba25c980416654f8e0ca226c8f2a1bb3", "committedDate": "2020-10-01T03:26:25Z", "message": "Fixed review comments - added UTs and removed duplicated calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c6e3f9cae97050939e8165bb85509af4d401d9a", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/9c6e3f9cae97050939e8165bb85509af4d401d9a", "committedDate": "2020-10-01T04:11:46Z", "message": "Fixed checkstyle warning - unused imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjQ0NTg5", "url": "https://github.com/apache/ozone/pull/1404#pullrequestreview-500644589", "createdAt": "2020-10-01T19:14:42Z", "commit": {"oid": "9c6e3f9cae97050939e8165bb85509af4d401d9a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2477, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}