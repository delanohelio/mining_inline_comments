{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMTE3MDMx", "number": 415, "reviewThreads": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMTo1MjoyNFrODYXb8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODozNDowOFrODcBGEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODc2NDAxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMTo1MjoyNFrOFeL5cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjozNDo0MlrOFeMbIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NjUzMA==", "bodyText": "Can we rename this method to setVolumeAndBucket as we are setting the values here.", "url": "https://github.com/apache/ozone/pull/415#discussion_r367196530", "createdAt": "2020-01-16T01:52:24Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ObjectStore objectStore;\n+  private OzoneVolume volume;\n+  private OzoneBucket bucket;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public void setVolume(String volumeString) throws IOException {\n+    this.volume = objectStore.getVolume(volumeString);\n+  }\n+\n+  public void setBucket(String bucketString) throws IOException {\n+    this.bucket = volume.getBucket(bucketString);\n+  }\n+\n+  private void getVolumeAndBucket(OFSPath ofsPath,\n+      boolean createIfNotExist) throws IOException {\n+    getVolumeAndBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Apply volumeStr and bucketStr stored in the object instance before\n+   * executing a FileSystem operation.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException\n+   */\n+  private void getVolumeAndBucket(String volumeStr, String bucketStr,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0c879ccd447ade27dbd0a2d0673d8d09d34d33"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNTE1Mg==", "bodyText": "done", "url": "https://github.com/apache/ozone/pull/415#discussion_r367205152", "createdAt": "2020-01-16T02:34:42Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,602 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ObjectStore objectStore;\n+  private OzoneVolume volume;\n+  private OzoneBucket bucket;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public void setVolume(String volumeString) throws IOException {\n+    this.volume = objectStore.getVolume(volumeString);\n+  }\n+\n+  public void setBucket(String bucketString) throws IOException {\n+    this.bucket = volume.getBucket(bucketString);\n+  }\n+\n+  private void getVolumeAndBucket(OFSPath ofsPath,\n+      boolean createIfNotExist) throws IOException {\n+    getVolumeAndBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Apply volumeStr and bucketStr stored in the object instance before\n+   * executing a FileSystem operation.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException\n+   */\n+  private void getVolumeAndBucket(String volumeStr, String bucketStr,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NjUzMA=="}, "originalCommit": {"oid": "2c0c879ccd447ade27dbd0a2d0673d8d09d34d33"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjQ0MTkxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzoyNzo0N1rOFgMOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzoyNzo0N1rOFgMOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5OTAwMA==", "bodyText": "OFileSystem -> RootedOzoneFileSystem", "url": "https://github.com/apache/ozone/pull/415#discussion_r369299000", "createdAt": "2020-01-21T23:27:47Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjQ0NzkwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzozMDo1NVrOFgMR2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMDowMDo1MFrOFhQfeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5OTkyOQ==", "bodyText": "If this is going to change, can we please add a TODO here to keep track.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369299929", "createdAt": "2020-01-21T23:30:55Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxNzUyOA==", "bodyText": "I forgot to clean up this line of comment. the rootPath below should be good.", "url": "https://github.com/apache/ozone/pull/415#discussion_r370417528", "createdAt": "2020-01-24T00:00:50Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5OTkyOQ=="}, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjQ2NzIzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzo0MToyOVrOFgMdhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwMDoxODoyMVrOFhQxOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMjkxOQ==", "bodyText": "rootBucket is used globally in this Test suit. Can we make it a global variable?\nAlso, rootBucket gives the impression that it's the bucket at the root of the FS. Could we rename it to testBucket or volumeAndBucketPath or something else?", "url": "https://github.com/apache/ozone/pull/415#discussion_r369302919", "createdAt": "2020-01-21T23:41:29Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // TODO: FileSystem#loadFileSystems is not loading ofs:// class by default\n+    //  hence this workaround. Might need to add some config in hadoop source.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // TODO: Address this properly.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME,\n+            conf), RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQyMjA3NQ==", "bodyText": "Yep this looks duplicated for those existing test cases modified from O3FS tests.\nThe point is there will definitely be more OFS-specific test cases (like testMkdirOnNonExistentVolumeBucket()) introduced into the this test class which won't use rootBucket.\nI would make this class global and rename it.\nDone in 7a3de51.", "url": "https://github.com/apache/ozone/pull/415#discussion_r370422075", "createdAt": "2020-01-24T00:18:21Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // TODO: FileSystem#loadFileSystems is not loading ofs:// class by default\n+    //  hence this workaround. Might need to add some config in hadoop source.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // TODO: Address this properly.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME,\n+            conf), RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMjkxOQ=="}, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjQ3NDg0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzo0NTozM1rOFgMiHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMzo0NTozM1rOFgMiHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDA5NQ==", "bodyText": "We can add one more check later that listStatus(rootBucket) returns 1 fileStatus object - parent.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369304095", "createdAt": "2020-01-21T23:45:33Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // TODO: FileSystem#loadFileSystems is not loading ofs:// class by default\n+    //  hence this workaround. Might need to add some config in hadoop source.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // TODO: Address this properly.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME,\n+            conf), RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKeyInBucket(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket, \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKeyInBucket(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path parent = new Path(rootBucket, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(rootBucket);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a01d19f0cfa2cdce5e252be2dd33fcb0d4fb6a"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjUwNDEwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMDo1NVrOFgMzjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMDo1NVrOFgMzjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwODU1Ng==", "bodyText": "Let's test \"rename to different bucket\" in a separate method.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369308556", "createdAt": "2020-01-22T00:00:55Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME, conf),\n+        RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKeyInBucket(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket, \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKeyInBucket(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path parent = new Path(rootBucket, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(rootBucket);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);\n+\n+    ContractTestUtils.touch(fs, file1);\n+    ContractTestUtils.touch(fs, file2);\n+\n+    // ListStatus on a directory should return all subdirs along with\n+    // files, even if there exists a file and sub-dir with the same name.\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        2, fileStatuses.length);\n+\n+    // ListStatus should return only the immediate children of a directory.\n+    Path file3 = new Path(parent, \"dir1/key3\");\n+    Path file4 = new Path(parent, \"dir1/key4\");\n+    ContractTestUtils.touch(fs, file3);\n+    ContractTestUtils.touch(fs, file4);\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        3, fileStatuses.length);\n+  }\n+\n+  private String getRandomNonExistVolumeName() throws Exception {\n+    final int numDigit = 5;\n+    long retriesLeft = Math.round(Math.pow(10, 5));\n+    String name = null;\n+    while (name == null && retriesLeft-- > 0) {\n+      name = \"volume-\" + RandomStringUtils.randomNumeric(numDigit);\n+      // Check volume existence.\n+      Iterator<? extends OzoneVolume> iter =\n+          objectStore.listVolumesByUser(null, name, null);\n+      if (iter.hasNext()) {\n+        // If there is a match, try again.\n+        // Note that volume name prefix match doesn't equal volume existence\n+        //  but the check is sufficient for this test.\n+        name = null;\n+      }\n+    }\n+    if (retriesLeft <= 0) {\n+      throw new Exception(\n+          \"Failed to generate random volume name that doesn't exist already.\");\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * Tests Mkdir operation on a volume that doesn't exist.\n+   * Expect Mkdir to create the volume and bucket.\n+   */\n+  @Test\n+  public void testMkdirOnNonExistentVolumeBucket() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path root = new Path(\"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // Check volume and bucket existence, they should both be created.\n+    OzoneVolume ozoneVolume = objectStore.getVolume(volumeNameLocal);\n+    OzoneBucket ozoneBucket = ozoneVolume.getBucket(bucketNameLocal);\n+    OFSPath ofsPathDir1 = new OFSPath(dir12);\n+    String key = ofsPathDir1.getKeyName() + \"/\";\n+    OzoneKeyDetails ozoneKeyDetails = ozoneBucket.getKey(key);\n+    assertEquals(key, ozoneKeyDetails.getName());\n+\n+    // Verify that directories are created.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir1.toString());\n+    assertEquals(fileStatuses[1].getPath().toUri().getPath(), dir2.toString());\n+\n+    fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir12.toString());\n+    fileStatuses = ofs.listStatus(dir12);\n+    assertEquals(fileStatuses.length, 0);\n+    fileStatuses = ofs.listStatus(dir2);\n+    assertEquals(fileStatuses.length, 0);\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnRoot() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // ListStatus on root should return dir1 (even though /dir1 key does not\n+    // exist) and dir2 only. dir12 is not an immediate child of root and\n+    // hence should not be listed.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that dir12 is not included in the result of the listStatus on root\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertFalse(fileStatus1.equals(dir12.toString()));\n+    assertFalse(fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnLargeDirectory() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Set<String> paths = new TreeSet<>();\n+    int numDirs = 5111;\n+    for(int i = 0; i < numDirs; i++) {\n+      Path p = new Path(root, String.valueOf(i));\n+      fs.mkdirs(p);\n+      paths.add(p.getName());\n+    }\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\n+        \"Total directories listed do not match the existing directories\",\n+        numDirs, fileStatuses.length);\n+\n+    for (int i=0; i < numDirs; i++) {\n+      assertTrue(paths.contains(fileStatuses[i].getPath().getName()));\n+    }\n+  }\n+\n+  /**\n+   * Tests listStatus on a path with subdirs.\n+   */\n+  @Test\n+  public void testListStatusOnSubDirs() throws Exception {\n+    // Create the following key structure\n+    //      /dir1/dir11/dir111\n+    //      /dir1/dir12\n+    //      /dir1/dir12/file121\n+    //      /dir2\n+    // ListStatus on /dir1 should return all its immediated subdirs only\n+    // which are /dir1/dir11 and /dir1/dir12. Super child files/dirs\n+    // (/dir1/dir12/file121 and /dir1/dir11/dir111) should not be returned by\n+    // listStatus.\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(rootBucket, \"dir1\");\n+    Path dir11 = new Path(dir1, \"dir11\");\n+    Path dir111 = new Path(dir11, \"dir111\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path file121 = new Path(dir12, \"file121\");\n+    Path dir2 = new Path(rootBucket, \"dir2\");\n+    fs.mkdirs(dir111);\n+    fs.mkdirs(dir12);\n+    ContractTestUtils.touch(fs, file121);\n+    fs.mkdirs(dir2);\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that the two children of /dir1 returned by listStatus operation\n+    // are /dir1/dir11 and /dir1/dir12.\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertTrue(fileStatus1.equals(dir11.toString()) ||\n+        fileStatus1.equals(dir12.toString()));\n+    assertTrue(fileStatus2.equals(dir11.toString()) ||\n+        fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  @Test\n+  public void testNonExplicitlyCreatedPathExistsAfterItsLeafsWereRemoved()\n+      throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path source = new Path(rootBucket, \"source\");\n+    Path interimPath = new Path(source, \"interimPath\");\n+    Path leafInsideInterimPath = new Path(interimPath, \"leaf\");\n+    Path target = new Path(rootBucket, \"target\");\n+    Path leafInTarget = new Path(target, \"leaf\");\n+\n+    fs.mkdirs(source);\n+    fs.mkdirs(target);\n+    fs.mkdirs(leafInsideInterimPath);\n+\n+    // Attempt to rename the key to a different bucket\n+    Path bucket2 = new Path(\"/\" + volumeName + \"/\" + bucketName + \"test\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjUwNTk2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMTo1MVrOFgM0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMTo1MVrOFgM0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwODgzMA==", "bodyText": "I think we can avoid printing this here. Just a comment would suffice.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369308830", "createdAt": "2020-01-22T00:01:51Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME, conf),\n+        RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKeyInBucket(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket, \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKeyInBucket(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path parent = new Path(rootBucket, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(rootBucket);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);\n+\n+    ContractTestUtils.touch(fs, file1);\n+    ContractTestUtils.touch(fs, file2);\n+\n+    // ListStatus on a directory should return all subdirs along with\n+    // files, even if there exists a file and sub-dir with the same name.\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        2, fileStatuses.length);\n+\n+    // ListStatus should return only the immediate children of a directory.\n+    Path file3 = new Path(parent, \"dir1/key3\");\n+    Path file4 = new Path(parent, \"dir1/key4\");\n+    ContractTestUtils.touch(fs, file3);\n+    ContractTestUtils.touch(fs, file4);\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        3, fileStatuses.length);\n+  }\n+\n+  private String getRandomNonExistVolumeName() throws Exception {\n+    final int numDigit = 5;\n+    long retriesLeft = Math.round(Math.pow(10, 5));\n+    String name = null;\n+    while (name == null && retriesLeft-- > 0) {\n+      name = \"volume-\" + RandomStringUtils.randomNumeric(numDigit);\n+      // Check volume existence.\n+      Iterator<? extends OzoneVolume> iter =\n+          objectStore.listVolumesByUser(null, name, null);\n+      if (iter.hasNext()) {\n+        // If there is a match, try again.\n+        // Note that volume name prefix match doesn't equal volume existence\n+        //  but the check is sufficient for this test.\n+        name = null;\n+      }\n+    }\n+    if (retriesLeft <= 0) {\n+      throw new Exception(\n+          \"Failed to generate random volume name that doesn't exist already.\");\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * Tests Mkdir operation on a volume that doesn't exist.\n+   * Expect Mkdir to create the volume and bucket.\n+   */\n+  @Test\n+  public void testMkdirOnNonExistentVolumeBucket() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path root = new Path(\"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // Check volume and bucket existence, they should both be created.\n+    OzoneVolume ozoneVolume = objectStore.getVolume(volumeNameLocal);\n+    OzoneBucket ozoneBucket = ozoneVolume.getBucket(bucketNameLocal);\n+    OFSPath ofsPathDir1 = new OFSPath(dir12);\n+    String key = ofsPathDir1.getKeyName() + \"/\";\n+    OzoneKeyDetails ozoneKeyDetails = ozoneBucket.getKey(key);\n+    assertEquals(key, ozoneKeyDetails.getName());\n+\n+    // Verify that directories are created.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir1.toString());\n+    assertEquals(fileStatuses[1].getPath().toUri().getPath(), dir2.toString());\n+\n+    fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir12.toString());\n+    fileStatuses = ofs.listStatus(dir12);\n+    assertEquals(fileStatuses.length, 0);\n+    fileStatuses = ofs.listStatus(dir2);\n+    assertEquals(fileStatuses.length, 0);\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnRoot() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // ListStatus on root should return dir1 (even though /dir1 key does not\n+    // exist) and dir2 only. dir12 is not an immediate child of root and\n+    // hence should not be listed.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that dir12 is not included in the result of the listStatus on root\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertFalse(fileStatus1.equals(dir12.toString()));\n+    assertFalse(fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnLargeDirectory() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Set<String> paths = new TreeSet<>();\n+    int numDirs = 5111;\n+    for(int i = 0; i < numDirs; i++) {\n+      Path p = new Path(root, String.valueOf(i));\n+      fs.mkdirs(p);\n+      paths.add(p.getName());\n+    }\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\n+        \"Total directories listed do not match the existing directories\",\n+        numDirs, fileStatuses.length);\n+\n+    for (int i=0; i < numDirs; i++) {\n+      assertTrue(paths.contains(fileStatuses[i].getPath().getName()));\n+    }\n+  }\n+\n+  /**\n+   * Tests listStatus on a path with subdirs.\n+   */\n+  @Test\n+  public void testListStatusOnSubDirs() throws Exception {\n+    // Create the following key structure\n+    //      /dir1/dir11/dir111\n+    //      /dir1/dir12\n+    //      /dir1/dir12/file121\n+    //      /dir2\n+    // ListStatus on /dir1 should return all its immediated subdirs only\n+    // which are /dir1/dir11 and /dir1/dir12. Super child files/dirs\n+    // (/dir1/dir12/file121 and /dir1/dir11/dir111) should not be returned by\n+    // listStatus.\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(rootBucket, \"dir1\");\n+    Path dir11 = new Path(dir1, \"dir11\");\n+    Path dir111 = new Path(dir11, \"dir111\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path file121 = new Path(dir12, \"file121\");\n+    Path dir2 = new Path(rootBucket, \"dir2\");\n+    fs.mkdirs(dir111);\n+    fs.mkdirs(dir12);\n+    ContractTestUtils.touch(fs, file121);\n+    fs.mkdirs(dir2);\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that the two children of /dir1 returned by listStatus operation\n+    // are /dir1/dir11 and /dir1/dir12.\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertTrue(fileStatus1.equals(dir11.toString()) ||\n+        fileStatus1.equals(dir12.toString()));\n+    assertTrue(fileStatus2.equals(dir11.toString()) ||\n+        fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  @Test\n+  public void testNonExplicitlyCreatedPathExistsAfterItsLeafsWereRemoved()\n+      throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path source = new Path(rootBucket, \"source\");\n+    Path interimPath = new Path(source, \"interimPath\");\n+    Path leafInsideInterimPath = new Path(interimPath, \"leaf\");\n+    Path target = new Path(rootBucket, \"target\");\n+    Path leafInTarget = new Path(target, \"leaf\");\n+\n+    fs.mkdirs(source);\n+    fs.mkdirs(target);\n+    fs.mkdirs(leafInsideInterimPath);\n+\n+    // Attempt to rename the key to a different bucket\n+    Path bucket2 = new Path(\"/\" + volumeName + \"/\" + bucketName + \"test\");\n+    Path leafInTargetInAnotherBucket = new Path(bucket2, \"leaf\");\n+    try {\n+      fs.rename(leafInsideInterimPath, leafInTargetInAnotherBucket);\n+      fail(\"Should have thrown exception when renaming to a different bucket\");\n+    } catch (IOException ex) {\n+      System.out.println(\"Exception thrown as expected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjUwODA3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMzowOVrOFgM19Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMDowMzowOVrOFgM19Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTE3Mw==", "bodyText": "getKeyInBucket looks like we are getting key from a specific bucket and not the global bucket. Can we rename this back to getKey?", "url": "https://github.com/apache/ozone/pull/415#discussion_r369309173", "createdAt": "2020-01-22T00:03:09Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,408 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by OFileSystem\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+\n+    // For now:\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() throws IOException {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME, conf),\n+        RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKeyInBucket(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path grandparent = new Path(rootBucket, \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKeyInBucket(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKeyInBucket(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path parent = new Path(rootBucket, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(rootBucket);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);\n+\n+    ContractTestUtils.touch(fs, file1);\n+    ContractTestUtils.touch(fs, file2);\n+\n+    // ListStatus on a directory should return all subdirs along with\n+    // files, even if there exists a file and sub-dir with the same name.\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        2, fileStatuses.length);\n+\n+    // ListStatus should return only the immediate children of a directory.\n+    Path file3 = new Path(parent, \"dir1/key3\");\n+    Path file4 = new Path(parent, \"dir1/key4\");\n+    ContractTestUtils.touch(fs, file3);\n+    ContractTestUtils.touch(fs, file4);\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        3, fileStatuses.length);\n+  }\n+\n+  private String getRandomNonExistVolumeName() throws Exception {\n+    final int numDigit = 5;\n+    long retriesLeft = Math.round(Math.pow(10, 5));\n+    String name = null;\n+    while (name == null && retriesLeft-- > 0) {\n+      name = \"volume-\" + RandomStringUtils.randomNumeric(numDigit);\n+      // Check volume existence.\n+      Iterator<? extends OzoneVolume> iter =\n+          objectStore.listVolumesByUser(null, name, null);\n+      if (iter.hasNext()) {\n+        // If there is a match, try again.\n+        // Note that volume name prefix match doesn't equal volume existence\n+        //  but the check is sufficient for this test.\n+        name = null;\n+      }\n+    }\n+    if (retriesLeft <= 0) {\n+      throw new Exception(\n+          \"Failed to generate random volume name that doesn't exist already.\");\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * Tests Mkdir operation on a volume that doesn't exist.\n+   * Expect Mkdir to create the volume and bucket.\n+   */\n+  @Test\n+  public void testMkdirOnNonExistentVolumeBucket() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path root = new Path(\"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // Check volume and bucket existence, they should both be created.\n+    OzoneVolume ozoneVolume = objectStore.getVolume(volumeNameLocal);\n+    OzoneBucket ozoneBucket = ozoneVolume.getBucket(bucketNameLocal);\n+    OFSPath ofsPathDir1 = new OFSPath(dir12);\n+    String key = ofsPathDir1.getKeyName() + \"/\";\n+    OzoneKeyDetails ozoneKeyDetails = ozoneBucket.getKey(key);\n+    assertEquals(key, ozoneKeyDetails.getName());\n+\n+    // Verify that directories are created.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir1.toString());\n+    assertEquals(fileStatuses[1].getPath().toUri().getPath(), dir2.toString());\n+\n+    fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir12.toString());\n+    fileStatuses = ofs.listStatus(dir12);\n+    assertEquals(fileStatuses.length, 0);\n+    fileStatuses = ofs.listStatus(dir2);\n+    assertEquals(fileStatuses.length, 0);\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnRoot() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // ListStatus on root should return dir1 (even though /dir1 key does not\n+    // exist) and dir2 only. dir12 is not an immediate child of root and\n+    // hence should not be listed.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that dir12 is not included in the result of the listStatus on root\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertFalse(fileStatus1.equals(dir12.toString()));\n+    assertFalse(fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnLargeDirectory() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Set<String> paths = new TreeSet<>();\n+    int numDirs = 5111;\n+    for(int i = 0; i < numDirs; i++) {\n+      Path p = new Path(root, String.valueOf(i));\n+      fs.mkdirs(p);\n+      paths.add(p.getName());\n+    }\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\n+        \"Total directories listed do not match the existing directories\",\n+        numDirs, fileStatuses.length);\n+\n+    for (int i=0; i < numDirs; i++) {\n+      assertTrue(paths.contains(fileStatuses[i].getPath().getName()));\n+    }\n+  }\n+\n+  /**\n+   * Tests listStatus on a path with subdirs.\n+   */\n+  @Test\n+  public void testListStatusOnSubDirs() throws Exception {\n+    // Create the following key structure\n+    //      /dir1/dir11/dir111\n+    //      /dir1/dir12\n+    //      /dir1/dir12/file121\n+    //      /dir2\n+    // ListStatus on /dir1 should return all its immediated subdirs only\n+    // which are /dir1/dir11 and /dir1/dir12. Super child files/dirs\n+    // (/dir1/dir12/file121 and /dir1/dir11/dir111) should not be returned by\n+    // listStatus.\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(rootBucket, \"dir1\");\n+    Path dir11 = new Path(dir1, \"dir11\");\n+    Path dir111 = new Path(dir11, \"dir111\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path file121 = new Path(dir12, \"file121\");\n+    Path dir2 = new Path(rootBucket, \"dir2\");\n+    fs.mkdirs(dir111);\n+    fs.mkdirs(dir12);\n+    ContractTestUtils.touch(fs, file121);\n+    fs.mkdirs(dir2);\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that the two children of /dir1 returned by listStatus operation\n+    // are /dir1/dir11 and /dir1/dir12.\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertTrue(fileStatus1.equals(dir11.toString()) ||\n+        fileStatus1.equals(dir12.toString()));\n+    assertTrue(fileStatus2.equals(dir11.toString()) ||\n+        fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  @Test\n+  public void testNonExplicitlyCreatedPathExistsAfterItsLeafsWereRemoved()\n+      throws Exception {\n+    Path rootBucket = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path source = new Path(rootBucket, \"source\");\n+    Path interimPath = new Path(source, \"interimPath\");\n+    Path leafInsideInterimPath = new Path(interimPath, \"leaf\");\n+    Path target = new Path(rootBucket, \"target\");\n+    Path leafInTarget = new Path(target, \"leaf\");\n+\n+    fs.mkdirs(source);\n+    fs.mkdirs(target);\n+    fs.mkdirs(leafInsideInterimPath);\n+\n+    // Attempt to rename the key to a different bucket\n+    Path bucket2 = new Path(\"/\" + volumeName + \"/\" + bucketName + \"test\");\n+    Path leafInTargetInAnotherBucket = new Path(bucket2, \"leaf\");\n+    try {\n+      fs.rename(leafInsideInterimPath, leafInTargetInAnotherBucket);\n+      fail(\"Should have thrown exception when renaming to a different bucket\");\n+    } catch (IOException ex) {\n+      System.out.println(\"Exception thrown as expected\");\n+    }\n+\n+    assertTrue(fs.rename(leafInsideInterimPath, leafInTarget));\n+\n+    // after rename listStatus for interimPath should succeed and\n+    // interimPath should have no children\n+    FileStatus[] statuses = fs.listStatus(interimPath);\n+    assertNotNull(\"liststatus returns a null array\", statuses);\n+    assertEquals(\"Statuses array is not empty\", 0, statuses.length);\n+    FileStatus fileStatus = fs.getFileStatus(interimPath);\n+    assertEquals(\"FileStatus does not point to interimPath\",\n+        interimPath.getName(), fileStatus.getPath().getName());\n+  }\n+\n+  private OzoneKeyDetails getKeyInBucket(Path keyPath, boolean isDirectory)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjYxNDg4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMTowNjoyNVrOFgN1rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMTo0Nzo0MFrOFiABqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTQ4NA==", "bodyText": "Do we want to convert startPath also to ofsPath here? Most likely, the startPath would only have the keyName prefix as the full path with volume and bucket is already given in pathStr.\nI am ok either way but we should add JavaDocs to explain this. Otherwise, user may assume it to be keyName prefix but we take it as volume/bucket/key or vice versa.\nIt would be good to add JavaDoc to all the methods. Atleast all the methods in OzoneClientAdapter should have a JavaDoc as they are client facing.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369325484", "createdAt": "2020-01-22T01:06:25Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,604 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  private OzoneBucket getBucket(OFSPath ofsPath,\n+      boolean createIfNotExist) throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException volEx) {\n+            if (volEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              objectStore.createVolume(volumeStr);\n+            } else {\n+              throw volEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          volume.createBucket(bucketStr);\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      bucket.createDirectory(keyStr);\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  public FileStatusAdapter getFileStatus(String path, URI uri,\n+      Path qualifiedPath, String userName)\n+      throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_QUERY);\n+      OzoneFileStatus status = bucket.getFileStatus(key);\n+      // Note: qualifiedPath passed in is good from\n+      //  BasicRootedOzoneFileSystem#getFileStatus. No need to prepend here.\n+      makeQualified(status, uri, qualifiedPath, userName);\n+      return toFileStatusAdapter(status);\n+\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_NOT_FOUND) {\n+        throw new\n+            FileNotFoundException(key + \": No such file or directory!\");\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public void makeQualified(FileStatus status, URI uri, Path path,\n+      String username) {\n+    if (status instanceof OzoneFileStatus) {\n+      ((OzoneFileStatus) status)\n+          .makeQualified(uri, path,\n+              username, username);\n+    }\n+  }\n+\n+  @Override\n+  public Iterator<BasicKeyInfo> listKeys(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_LIST);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    return new IteratorAdapter(bucket.listKeys(key));\n+  }\n+\n+  public List<FileStatusAdapter> listStatus(String pathStr, boolean recursive,\n+      String startPath, long numEntries, URI uri,\n+      Path workingDir, String username) throws IOException {\n+\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyName = ofsPath.getKeyName();\n+    OFSPath ofsStartPath = new OFSPath(startPath);\n+    String startKey = ofsStartPath.getKeyName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5MTQ0MQ==", "bodyText": "Since I made all the input path params (pathStr) for BasicRootedOzoneClientAdapterImpl methods full path (volume+bucket+key), I believe it's best to keep startPath consistent. - That's why I intentionally renamed the parameter name in API definition from startKey to startPath.\nTotally agree that doc is required. This should've been done in o3fs BasicOzoneClientAdapterImpl as well.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371191441", "createdAt": "2020-01-27T11:35:37Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,604 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  private OzoneBucket getBucket(OFSPath ofsPath,\n+      boolean createIfNotExist) throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException volEx) {\n+            if (volEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              objectStore.createVolume(volumeStr);\n+            } else {\n+              throw volEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          volume.createBucket(bucketStr);\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      bucket.createDirectory(keyStr);\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  public FileStatusAdapter getFileStatus(String path, URI uri,\n+      Path qualifiedPath, String userName)\n+      throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_QUERY);\n+      OzoneFileStatus status = bucket.getFileStatus(key);\n+      // Note: qualifiedPath passed in is good from\n+      //  BasicRootedOzoneFileSystem#getFileStatus. No need to prepend here.\n+      makeQualified(status, uri, qualifiedPath, userName);\n+      return toFileStatusAdapter(status);\n+\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_NOT_FOUND) {\n+        throw new\n+            FileNotFoundException(key + \": No such file or directory!\");\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public void makeQualified(FileStatus status, URI uri, Path path,\n+      String username) {\n+    if (status instanceof OzoneFileStatus) {\n+      ((OzoneFileStatus) status)\n+          .makeQualified(uri, path,\n+              username, username);\n+    }\n+  }\n+\n+  @Override\n+  public Iterator<BasicKeyInfo> listKeys(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_LIST);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    return new IteratorAdapter(bucket.listKeys(key));\n+  }\n+\n+  public List<FileStatusAdapter> listStatus(String pathStr, boolean recursive,\n+      String startPath, long numEntries, URI uri,\n+      Path workingDir, String username) throws IOException {\n+\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyName = ofsPath.getKeyName();\n+    OFSPath ofsStartPath = new OFSPath(startPath);\n+    String startKey = ofsStartPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTQ4NA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjMyOA==", "bodyText": "Done in b21005e.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371196328", "createdAt": "2020-01-27T11:47:40Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,604 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  private OzoneBucket getBucket(OFSPath ofsPath,\n+      boolean createIfNotExist) throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException volEx) {\n+            if (volEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              objectStore.createVolume(volumeStr);\n+            } else {\n+              throw volEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          volume.createBucket(bucketStr);\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      bucket.createDirectory(keyStr);\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  public FileStatusAdapter getFileStatus(String path, URI uri,\n+      Path qualifiedPath, String userName)\n+      throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_QUERY);\n+      OzoneFileStatus status = bucket.getFileStatus(key);\n+      // Note: qualifiedPath passed in is good from\n+      //  BasicRootedOzoneFileSystem#getFileStatus. No need to prepend here.\n+      makeQualified(status, uri, qualifiedPath, userName);\n+      return toFileStatusAdapter(status);\n+\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_NOT_FOUND) {\n+        throw new\n+            FileNotFoundException(key + \": No such file or directory!\");\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  public void makeQualified(FileStatus status, URI uri, Path path,\n+      String username) {\n+    if (status instanceof OzoneFileStatus) {\n+      ((OzoneFileStatus) status)\n+          .makeQualified(uri, path,\n+              username, username);\n+    }\n+  }\n+\n+  @Override\n+  public Iterator<BasicKeyInfo> listKeys(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_LIST);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    return new IteratorAdapter(bucket.listKeys(key));\n+  }\n+\n+  public List<FileStatusAdapter> listStatus(String pathStr, boolean recursive,\n+      String startPath, long numEntries, URI uri,\n+      Path workingDir, String username) throws IOException {\n+\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String keyName = ofsPath.getKeyName();\n+    OFSPath ofsStartPath = new OFSPath(startPath);\n+    String startKey = ofsStartPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTQ4NA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjYzMjI3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToxNzo0OFrOFgOAQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToxNzo0OFrOFgOAQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODE5NA==", "bodyText": "Commented variables", "url": "https://github.com/apache/ozone/pull/415#discussion_r369328194", "createdAt": "2020-01-22T01:17:48Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjYzMjkzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToxODoxOFrOFgOAtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToxODoxOFrOFgOAtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODMxMA==", "bodyText": "OFileSystem -> RootedOzoneFileSystem", "url": "https://github.com/apache/ozone/pull/415#discussion_r369328310", "createdAt": "2020-01-22T01:18:18Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjYzNTUyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToyMDowNVrOFgOCYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMTo0Nzo0M1rOFiABug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODczNw==", "bodyText": "The URL can also have the path, right?", "url": "https://github.com/apache/ozone/pull/415#discussion_r369328737", "createdAt": "2020-01-22T01:20:05Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjM0Ng==", "bodyText": "Yep. Done: da12d48", "url": "https://github.com/apache/ozone/pull/415#discussion_r371196346", "createdAt": "2020-01-27T11:47:43Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODczNw=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjY0NDM2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMToyNjozMlrOFgOIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMTo1MDozMlrOFiAGTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzMDIwMQ==", "bodyText": "We are assigning serviceID also to omHost variable. Can we either change the variable name to reflect this or add a comment explaining this.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369330201", "createdAt": "2020-01-22T01:26:32Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NzUxNw==", "bodyText": "Done, omHost -> omHostOrServiceId: 8e34c5f\nBTW this should be applied to o3fs as well.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371197517", "createdAt": "2020-01-27T11:50:32Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzMDIwMQ=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTU5MzI1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDo1MDoyOVrOFgqhPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMjoxMDo0MFrOFiAl2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5NTM5MA==", "bodyText": "I am confused about pathToKey() functionality. If the input path is not an absolute path, it prepends the working dir (/user/username/) to the path. Please correct me if my understanding is wrong.\nFor o3fs, if the input key is lets say \"dir1/dir2/key1\", then pathToKey would be /user/username/dir1/dir2/key1. The volume and bucket would have been set already while creating the FS object.\nThe same example with ofs would result in volume being set as \"user\" and bucket as \"username\" and key as \"dir1/dir2/key1\". Here, we are making an assumption of the volume and bucket. Would it not be better to not allow non-absolute paths in ofs?", "url": "https://github.com/apache/ozone/pull/415#discussion_r369795390", "createdAt": "2020-01-22T20:50:29Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 639}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1NzI5NA==", "bodyText": "This is a design decision which we can leave out in this Jira and probably add a TODO to keep track, if you agree.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369857294", "createdAt": "2020-01-22T23:14:38Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5NTM5MA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 639}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwNTU5Mw==", "bodyText": "This pathToKey is added in HDDS-177 by Anu. Honestly what I did here was fixing the typo.\nYour understanding is right. It should convert a relative path into an absolute one (if not). Then remove leading /.\nBut I think defaulting volume to user and bucket name to <USERNAME> in this case is exactly the way we intend it to be? So when user run ozone fs -put textfile.txt doc/ should automatically put the file under doc/ in user's home directory. (workingDir should be renamed to homeDir IMO) CMIIW.\nYes we are assuming that admin would create a volume named user and created a bucket for each user beforehand. That is indeed the implication. Let's discuss it.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371205593", "createdAt": "2020-01-27T12:10:40Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5NTM5MA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 639}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTYzMjUyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMTowMzoyNVrOFgq5Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0MjozNlrOFiDAtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwMTUwNw==", "bodyText": "When renaming a directory, we iterate through all the keys in that directory. For each key, we are going to call adapter.renamePath(). This function would in turn get BucketInfo from OM each time. We should optimize this to avoid the extra getBucketInfo calls.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369801507", "createdAt": "2020-01-22T21:03:25Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NTIzNg==", "bodyText": "Yep this is a problem.\nI attempted to address it in commit dfc50cc8b0f9d35aa5d9dfcea3e4beedb4930341.\nI do realize my solution still have 2 minor issues:\n\ncode duplication, e.g. overloaded renamePath/deleteObject shares mostly the same code;\nusing key in processKeyPath would be more efficient -- but this would break my intention of using ONLY full path outside of AdapterImpl.\n\nThose two issues above could be solved with some degree of refactoring. I'm doing it this way just to show one of the ways to solve the RPC call problem. Comments?", "url": "https://github.com/apache/ozone/pull/415#discussion_r371245236", "createdAt": "2020-01-27T13:42:36Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwMTUwNw=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTc1ODg1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMTo0Nzo0MFrOFgsIbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0MjozMlrOFiDAjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgyMTgwNA==", "bodyText": "When deleting a directory, we iterate through all the keys in that directory. For each key, we are going to call adapter.deleteObject(). This function would in turn get BucketInfo from OM each time. We should optimize this to avoid the extra getBucketInfo calls.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369821804", "createdAt": "2020-01-22T21:47:40Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NTE5Nw==", "bodyText": "Attempted to address it in commit dfc50cc8b0f9d35aa5d9dfcea3e4beedb4930341. See my comment above.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371245197", "createdAt": "2020-01-27T13:42:32Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgyMTgwNA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTc5NjUzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjowMToxNFrOFgsgUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0OTozNFrOFiDOaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgyNzkyMw==", "bodyText": "Do we need to convert pathKey to ofsPath here? We make this conversion when corresponding function (rename/delete) is called in processKeyPath anyway.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369827923", "createdAt": "2020-01-22T22:01:14Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");\n+    if (!path.isAbsolute()) {\n+      path = new Path(workingDir, path);\n+    }\n+    // removing leading '/' char\n+    String key = path.toUri().getPath().substring(1);\n+    LOG.trace(\"path for key: {} is: {}\", key, path);\n+    return key;\n+  }\n+\n+  /**\n+   * Add trailing delimiter to path if it is already not present.\n+   *\n+   * @param key the ozone Key which needs to be appended\n+   * @return delimiter appended key\n+   */\n+  private String addTrailingSlashIfNeeded(String key) {\n+    if (!isEmpty(key) && !key.endsWith(OZONE_URI_DELIMITER)) {\n+      return key + OZONE_URI_DELIMITER;\n+    } else {\n+      return key;\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RootedOzoneFileSystem{URI=\" + uri + \", \"\n+        + \"workingDir=\" + workingDir + \", \"\n+        + \"userName=\" + userName + \", \"\n+        + \"statistics=\" + statistics\n+        + \"}\";\n+  }\n+\n+  /**\n+   * This class provides an interface to iterate through all the keys in the\n+   * bucket prefixed with the input path key and process them.\n+   * <p>\n+   * Each implementing class should define how the keys should be processed\n+   * through the processKeyPath() function.\n+   */\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private Iterator<BasicKeyInfo> keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+        throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = adapter.listKeys(pathKey);\n+    }\n+\n+    /**\n+     * The output of processKey determines if further iteration through the\n+     * keys should be done or not.\n+     *\n+     * @return true if we should continue iteration of keys, false otherwise.\n+     * @throws IOException\n+     */\n+    abstract boolean processKeyPath(String keyPath) throws IOException;\n+\n+    /**\n+     * Iterates through all the keys prefixed with the input path's key and\n+     * processes the key though processKey().\n+     * If for any key, the processKey() returns false, then the iteration is\n+     * stopped and returned with false indicating that all the keys could not\n+     * be processed successfully.\n+     *\n+     * @return true if all keys are processed successfully, false otherwise.\n+     * @throws IOException\n+     */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 719}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0ODc0Nw==", "bodyText": "Yes since I intend to convert key to full path before feeding it to processKeyPath(). I could change it back but again, my idea of \"using only full path outside of AdapterImpl\" will be broken. <- this could probably be solved with refactoring but I don't think that is a priority at the moment.\nAdded comment and TODO in 10fe834.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371248747", "createdAt": "2020-01-27T13:49:34Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");\n+    if (!path.isAbsolute()) {\n+      path = new Path(workingDir, path);\n+    }\n+    // removing leading '/' char\n+    String key = path.toUri().getPath().substring(1);\n+    LOG.trace(\"path for key: {} is: {}\", key, path);\n+    return key;\n+  }\n+\n+  /**\n+   * Add trailing delimiter to path if it is already not present.\n+   *\n+   * @param key the ozone Key which needs to be appended\n+   * @return delimiter appended key\n+   */\n+  private String addTrailingSlashIfNeeded(String key) {\n+    if (!isEmpty(key) && !key.endsWith(OZONE_URI_DELIMITER)) {\n+      return key + OZONE_URI_DELIMITER;\n+    } else {\n+      return key;\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RootedOzoneFileSystem{URI=\" + uri + \", \"\n+        + \"workingDir=\" + workingDir + \", \"\n+        + \"userName=\" + userName + \", \"\n+        + \"statistics=\" + statistics\n+        + \"}\";\n+  }\n+\n+  /**\n+   * This class provides an interface to iterate through all the keys in the\n+   * bucket prefixed with the input path key and process them.\n+   * <p>\n+   * Each implementing class should define how the keys should be processed\n+   * through the processKeyPath() function.\n+   */\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private Iterator<BasicKeyInfo> keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+        throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = adapter.listKeys(pathKey);\n+    }\n+\n+    /**\n+     * The output of processKey determines if further iteration through the\n+     * keys should be done or not.\n+     *\n+     * @return true if we should continue iteration of keys, false otherwise.\n+     * @throws IOException\n+     */\n+    abstract boolean processKeyPath(String keyPath) throws IOException;\n+\n+    /**\n+     * Iterates through all the keys prefixed with the input path's key and\n+     * processes the key though processKey().\n+     * If for any key, the processKey() returns false, then the iteration is\n+     * stopped and returned with false indicating that all the keys could not\n+     * be processed successfully.\n+     *\n+     * @return true if all keys are processed successfully, false otherwise.\n+     * @throws IOException\n+     */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgyNzkyMw=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 719}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTgxMzE0OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjowNzoyN1rOFgsqxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1Nzo1NVrOFiDfiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzMDU5OA==", "bodyText": "I did not understand what we are doing here. Could you please give an example.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369830598", "createdAt": "2020-01-22T22:07:27Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");\n+    if (!path.isAbsolute()) {\n+      path = new Path(workingDir, path);\n+    }\n+    // removing leading '/' char\n+    String key = path.toUri().getPath().substring(1);\n+    LOG.trace(\"path for key: {} is: {}\", key, path);\n+    return key;\n+  }\n+\n+  /**\n+   * Add trailing delimiter to path if it is already not present.\n+   *\n+   * @param key the ozone Key which needs to be appended\n+   * @return delimiter appended key\n+   */\n+  private String addTrailingSlashIfNeeded(String key) {\n+    if (!isEmpty(key) && !key.endsWith(OZONE_URI_DELIMITER)) {\n+      return key + OZONE_URI_DELIMITER;\n+    } else {\n+      return key;\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RootedOzoneFileSystem{URI=\" + uri + \", \"\n+        + \"workingDir=\" + workingDir + \", \"\n+        + \"userName=\" + userName + \", \"\n+        + \"statistics=\" + statistics\n+        + \"}\";\n+  }\n+\n+  /**\n+   * This class provides an interface to iterate through all the keys in the\n+   * bucket prefixed with the input path key and process them.\n+   * <p>\n+   * Each implementing class should define how the keys should be processed\n+   * through the processKeyPath() function.\n+   */\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private Iterator<BasicKeyInfo> keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+        throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = adapter.listKeys(pathKey);\n+    }\n+\n+    /**\n+     * The output of processKey determines if further iteration through the\n+     * keys should be done or not.\n+     *\n+     * @return true if we should continue iteration of keys, false otherwise.\n+     * @throws IOException\n+     */\n+    abstract boolean processKeyPath(String keyPath) throws IOException;\n+\n+    /**\n+     * Iterates through all the keys prefixed with the input path's key and\n+     * processes the key though processKey().\n+     * If for any key, the processKey() returns false, then the iteration is\n+     * stopped and returned with false indicating that all the keys could not\n+     * be processed successfully.\n+     *\n+     * @return true if all keys are processed successfully, false otherwise.\n+     * @throws IOException\n+     */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        while (keyIterator.hasNext()) {\n+          BasicKeyInfo key = keyIterator.next();\n+          String keyPath = ofsPath.getNonKeyPathNoPrefixDelim() +\n+              OZONE_URI_DELIMITER + key.getName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!processKeyPath(keyPath)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        return processKeyPath(pathKey);\n+      }\n+    }\n+\n+    String getPathKey() {\n+      return pathKey;\n+    }\n+\n+    boolean pathIsDirectory() {\n+      return status.isDirectory();\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  public RootedOzoneClientAdapter getAdapter() {\n+    return adapter;\n+  }\n+\n+  public boolean isEmpty(CharSequence cs) {\n+    return cs == null || cs.length() == 0;\n+  }\n+\n+  public boolean isNumber(String number) {\n+    try {\n+      Integer.parseInt(number);\n+    } catch (NumberFormatException ex) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private FileStatus convertFileStatus(FileStatusAdapter fileStatusAdapter) {\n+    Path symLink = null;\n+    try {\n+      fileStatusAdapter.getSymlink();\n+    } catch (Exception ex) {\n+      //NOOP: If not symlink symlink remains null.\n+    }\n+\n+    // Process path.\n+    URI newUri = fileStatusAdapter.getPath().toUri();\n+    try {\n+      newUri = new URIBuilder().setScheme(newUri.getScheme())\n+          .setHost(newUri.getAuthority())\n+          .setPath(newUri.getPath())\n+          .build();\n+    } catch (URISyntaxException e) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 782}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzEyOA==", "bodyText": "This chunk of code is useless now. It was previously added for stitching the listStatus result. Just removed it.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371253128", "createdAt": "2020-01-27T13:57:55Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.CreateFlag;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.LocatedFileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.util.Progressable;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.fs.ozone.Constants.LISTING_PAGE_SIZE;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_DEFAULT_USER;\n+import static org.apache.hadoop.fs.ozone.Constants.OZONE_USER_DIR;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_OFS_URI_SCHEME;\n+\n+/**\n+ * The minimal Ozone Filesystem implementation.\n+ * <p>\n+ * This is a basic version which doesn't extend\n+ * KeyProviderTokenIssuer and doesn't include statistics. It can be used\n+ * from older hadoop version. For newer hadoop version use the full featured\n+ * OFileSystem.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class BasicRootedOzoneFileSystem extends FileSystem {\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneFileSystem.class);\n+\n+  /**\n+   * The Ozone client for connecting to Ozone server.\n+   */\n+\n+  private URI uri;\n+  private String userName;\n+  private Path workingDir;\n+//  private String gOmHost;\n+//  private int gOmPort;\n+//  private Configuration gConf;\n+//  private boolean gIsolatedClassloader;\n+\n+  private RootedOzoneClientAdapter adapter;\n+//  private String adapterPath;\n+\n+  private static final String URI_EXCEPTION_TEXT =\n+      \"URL should be one of the following formats: \" +\n+      \"ofs://om-service-id/  OR \" +\n+      \"ofs://om-host.example.com/  OR \" +\n+      \"ofs://om-host.example.com:5678/\";\n+\n+  @Override\n+  public void initialize(URI name, Configuration conf) throws IOException {\n+    super.initialize(name, conf);\n+    setConf(conf);\n+    Objects.requireNonNull(name.getScheme(), \"No scheme provided in \" + name);\n+    Preconditions.checkArgument(getScheme().equals(name.getScheme()),\n+        \"Invalid scheme provided in \" + name);\n+\n+    String authority = name.getAuthority();\n+    if (authority == null) {\n+      // authority is null when fs.defaultFS is not a qualified ofs URI and\n+      // ofs:/// is passed to the client. matcher will NPE if authority is null\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+\n+    String omHost;\n+    int omPort = -1;\n+    // Parse hostname and port\n+    String[] parts = authority.split(\":\");\n+    if (parts.length > 2) {\n+      throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+    }\n+    omHost = parts[0];\n+    if (parts.length == 2) {\n+      try {\n+        omPort = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(URI_EXCEPTION_TEXT);\n+      }\n+    }\n+\n+    try {\n+      uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority)\n+          .build();\n+      LOG.trace(\"Ozone URI for OFS initialization is \" + uri);\n+\n+      //isolated is the default for ozonefs-lib-legacy which includes the\n+      // /ozonefs.txt, otherwise the default is false. It could be overridden.\n+      boolean defaultValue =\n+          BasicRootedOzoneFileSystem.class.getClassLoader()\n+              .getResource(\"ozonefs.txt\") != null;\n+\n+      //Use string here instead of the constant as constant may not be available\n+      //on the classpath of a hadoop 2.7\n+      boolean isolatedClassloader =\n+          conf.getBoolean(\"ozone.fs.isolated-classloader\", defaultValue);\n+\n+      // adapter should be initialized in operations.\n+      this.adapter = createAdapter(conf, omHost, omPort, isolatedClassloader);\n+\n+      try {\n+        this.userName =\n+            UserGroupInformation.getCurrentUser().getShortUserName();\n+      } catch (IOException e) {\n+        this.userName = OZONE_DEFAULT_USER;\n+      }\n+      this.workingDir = new Path(OZONE_USER_DIR, this.userName)\n+          .makeQualified(this.uri, this.workingDir);\n+    } catch (URISyntaxException ue) {\n+      final String msg = \"Invalid Ozone endpoint \" + name;\n+      LOG.error(msg, ue);\n+      throw new IOException(msg, ue);\n+    }\n+  }\n+\n+  protected RootedOzoneClientAdapter createAdapter(Configuration conf,\n+      String omHost, int omPort, boolean isolatedClassloader)\n+      throws IOException {\n+\n+    if (isolatedClassloader) {\n+      // TODO: Check how this code path need to be changed, for legacy Hadoop?\n+      return RootedOzoneClientAdapterFactory.createAdapter();\n+    } else {\n+      return new BasicRootedOzoneClientAdapterImpl(omHost, omPort, conf);\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      adapter.close();\n+    } finally {\n+      super.close();\n+    }\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return uri;\n+  }\n+\n+  @Override\n+  public String getScheme() {\n+    return OZONE_OFS_URI_SCHEME;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int bufferSize) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_OPEN);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"open() path: {}\", path);\n+    final String key = pathToKey(path);\n+    return new FSDataInputStream(\n+        new OzoneFSInputStream(adapter.readFile(key), statistics));\n+  }\n+\n+  protected void incrementCounter(Statistic statistic) {\n+    //don't do anything in this default implementation.\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize,\n+      short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+    LOG.trace(\"create() path:{}\", f);\n+    incrementCounter(Statistic.INVOCATION_CREATE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(f);\n+    return createOutputStream(key, overwrite, true);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream createNonRecursive(Path path,\n+      FsPermission permission,\n+      EnumSet<CreateFlag> flags,\n+      int bufferSize,\n+      short replication,\n+      long blockSize,\n+      Progressable progress) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_CREATE_NON_RECURSIVE);\n+    statistics.incrementWriteOps(1);\n+    final String key = pathToKey(path);\n+    return createOutputStream(key, flags.contains(CreateFlag.OVERWRITE), false);\n+  }\n+\n+  private FSDataOutputStream createOutputStream(String key, boolean overwrite,\n+      boolean recursive) throws IOException {\n+    return new FSDataOutputStream(adapter.createFile(key, overwrite, recursive),\n+        statistics);\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path f, int bufferSize,\n+      Progressable progress) throws IOException {\n+    throw new UnsupportedOperationException(\"append() Not implemented by the \"\n+        + getClass().getSimpleName() + \" FileSystem implementation\");\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+      adapter.renamePath(keyPath, newPath);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Check whether the source and destination path are valid and then perform\n+   * rename from source path to destination path.\n+   * <p>\n+   * The rename operation is performed by renaming the keys with src as prefix.\n+   * For such keys the prefix is changed from src to dst.\n+   *\n+   * @param src source path for rename\n+   * @param dst destination path for rename\n+   * @return true if rename operation succeeded or\n+   * if the src and dst have the same path and are of the same type\n+   * @throws IOException on I/O errors or if the src/dst paths are invalid.\n+   */\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_RENAME);\n+    statistics.incrementWriteOps(1);\n+    if (src.equals(dst)) {\n+      return true;\n+    }\n+\n+    LOG.trace(\"rename() from: {} to: {}\", src, dst);\n+    if (src.isRoot()) {\n+      // Cannot rename root of file system\n+      LOG.trace(\"Cannot rename the root of a filesystem\");\n+      return false;\n+    }\n+\n+    // src and dst should be in the same bucket\n+    OFSPath ofsSrc = new OFSPath(src);\n+    OFSPath ofsDst = new OFSPath(dst);\n+    if (!ofsSrc.isInSameBucketAs(ofsDst)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    // Cannot rename a directory to its own subdirectory\n+    Path dstParent = dst.getParent();\n+    while (dstParent != null && !src.equals(dstParent)) {\n+      dstParent = dstParent.getParent();\n+    }\n+    Preconditions.checkArgument(dstParent == null,\n+        \"Cannot rename a directory to its own subdirectory\");\n+    // Check if the source exists\n+    FileStatus srcStatus;\n+    try {\n+      srcStatus = getFileStatus(src);\n+    } catch (FileNotFoundException fnfe) {\n+      // source doesn't exist, return\n+      return false;\n+    }\n+\n+    // Check if the destination exists\n+    FileStatus dstStatus;\n+    try {\n+      dstStatus = getFileStatus(dst);\n+    } catch (FileNotFoundException fnde) {\n+      dstStatus = null;\n+    }\n+\n+    if (dstStatus == null) {\n+      // If dst doesn't exist, check whether dst parent dir exists or not\n+      // if the parent exists, the source can still be renamed to dst path\n+      dstStatus = getFileStatus(dst.getParent());\n+      if (!dstStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Failed to rename %s to %s, %s is a file\", src, dst,\n+            dst.getParent()));\n+      }\n+    } else {\n+      // if dst exists and source and destination are same,\n+      // check both the src and dst are of same type\n+      if (srcStatus.getPath().equals(dstStatus.getPath())) {\n+        return !srcStatus.isDirectory();\n+      } else if (dstStatus.isDirectory()) {\n+        // If dst is a directory, rename source as subpath of it.\n+        // for example rename /source to /dst will lead to /dst/source\n+        dst = new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses = listStatus(dst);\n+        } catch (FileNotFoundException fnde) {\n+          statuses = null;\n+        }\n+\n+        if (statuses != null && statuses.length > 0) {\n+          // If dst exists and not a directory not empty\n+          throw new FileAlreadyExistsException(String.format(\n+              \"Failed to rename %s to %s, file already exists or not empty!\",\n+              src, dst));\n+        }\n+      } else {\n+        // If dst is not a directory\n+        throw new FileAlreadyExistsException(String.format(\n+            \"Failed to rename %s to %s, file already exists!\", src, dst));\n+      }\n+    }\n+\n+    if (srcStatus.isDirectory()) {\n+      if (dst.toString().startsWith(src.toString() + OZONE_URI_DELIMITER)) {\n+        LOG.trace(\"Cannot rename a directory to a subdirectory of self\");\n+        return false;\n+      }\n+    }\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    boolean result = iterator.iterate();\n+    if (result) {\n+      createFakeParentDirectory(src);\n+    }\n+    return result;\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    private boolean recursive;\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(String keyPath) throws IOException {\n+      if (keyPath.equals(\"\")) {\n+        LOG.trace(\"Skipping deleting root directory\");\n+        return true;\n+      } else {\n+        LOG.trace(\"deleting key path:\" + keyPath);\n+        boolean succeed = adapter.deleteObject(keyPath);\n+        // if recursive delete is requested ignore the return value of\n+        // deleteObject and issue deletes for other keys.\n+        return recursive || succeed;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Deletes the children of the input dir path by iterating though the\n+   * DeleteIterator.\n+   *\n+   * @param f directory path to be deleted\n+   * @return true if successfully deletes all required keys, false otherwise\n+   * @throws IOException\n+   */\n+  private boolean innerDelete(Path f, boolean recursive) throws IOException {\n+    LOG.trace(\"delete() path:{} recursive:{}\", f, recursive);\n+    try {\n+      DeleteIterator iterator = new DeleteIterator(f, recursive);\n+      return iterator.iterate();\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Couldn't delete {} - does not exist\", f);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_DELETE);\n+    statistics.incrementWriteOps(1);\n+    LOG.debug(\"Delete path {} - recursive {}\", f, recursive);\n+    FileStatus status;\n+    try {\n+      status = getFileStatus(f);\n+    } catch (FileNotFoundException ex) {\n+      LOG.warn(\"delete: Path does not exist: {}\", f);\n+      return false;\n+    }\n+\n+    String key = pathToKey(f);\n+    boolean result;\n+\n+    if (status.isDirectory()) {\n+      LOG.debug(\"delete: Path is a directory: {}\", f);\n+      key = addTrailingSlashIfNeeded(key);\n+\n+      if (key.equals(\"/\")) {\n+        LOG.warn(\"Cannot delete root directory.\");\n+        return false;\n+      }\n+\n+      result = innerDelete(f, recursive);\n+    } else {\n+      LOG.debug(\"delete: Path is a file: {}\", f);\n+      result = adapter.deleteObject(key);\n+    }\n+\n+    if (result) {\n+      // If this delete operation removes all files/directories from the\n+      // parent direcotry, then an empty parent directory must be created.\n+      createFakeParentDirectory(f);\n+    }\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Create a fake parent directory key if it does not already exist and no\n+   * other child of this parent directory exists.\n+   *\n+   * @param f path to the fake parent directory\n+   * @throws IOException\n+   */\n+  private void createFakeParentDirectory(Path f) throws IOException {\n+    Path parent = f.getParent();\n+    if (parent != null && !parent.isRoot()) {\n+      createFakeDirectoryIfNecessary(parent);\n+    }\n+  }\n+\n+  /**\n+   * Create a fake directory key if it does not already exist.\n+   *\n+   * @param f path to the fake directory\n+   * @throws IOException\n+   */\n+  private void createFakeDirectoryIfNecessary(Path f) throws IOException {\n+    String key = pathToKey(f);\n+    if (!key.isEmpty() && !o3Exists(f)) {\n+      LOG.debug(\"Creating new fake directory at {}\", f);\n+      String dirKey = addTrailingSlashIfNeeded(key);\n+      adapter.createDirectory(dirKey);\n+    }\n+  }\n+\n+  /**\n+   * Check if a file or directory exists corresponding to given path.\n+   *\n+   * @param f path to file/directory.\n+   * @return true if it exists, false otherwise.\n+   * @throws IOException\n+   */\n+  private boolean o3Exists(final Path f) throws IOException {\n+    Path path = makeQualified(f);\n+    try {\n+      getFileStatus(path);\n+      return true;\n+    } catch (FileNotFoundException ex) {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_LIST_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"listStatus() path:{}\", f);\n+    int numEntries = LISTING_PAGE_SIZE;\n+    LinkedList<FileStatus> statuses = new LinkedList<>();\n+    List<FileStatus> tmpStatusList;\n+    String startPath = \"\";\n+\n+    do {\n+      tmpStatusList =\n+          adapter.listStatus(pathToKey(f), false, startPath,\n+              numEntries, uri, workingDir, getUsername())\n+              .stream()\n+              .map(this::convertFileStatus)\n+              .collect(Collectors.toList());\n+\n+      if (!tmpStatusList.isEmpty()) {\n+        if (startPath.isEmpty()) {\n+          statuses.addAll(tmpStatusList);\n+        } else {\n+          statuses.addAll(tmpStatusList.subList(1, tmpStatusList.size()));\n+        }\n+        startPath = pathToKey(statuses.getLast().getPath());\n+      }\n+      // listStatus returns entries numEntries in size if available.\n+      // Any lesser number of entries indicate that the required entries have\n+      // exhausted.\n+    } while (tmpStatusList.size() == numEntries);\n+\n+    return statuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path newDir) {\n+    workingDir = newDir;\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return workingDir;\n+  }\n+\n+  @Override\n+  public Token<?> getDelegationToken(String renewer) throws IOException {\n+    return adapter.getDelegationToken(renewer);\n+  }\n+\n+  /**\n+   * Get a canonical service name for this file system. If the URI is logical,\n+   * the hostname part of the URI will be returned.\n+   *\n+   * @return a service string that uniquely identifies this file system.\n+   */\n+  @Override\n+  public String getCanonicalServiceName() {\n+    return adapter.getCanonicalServiceName();\n+  }\n+\n+  /**\n+   * Get the username of the FS.\n+   *\n+   * @return the short name of the user who instantiated the FS\n+   */\n+  public String getUsername() {\n+    return userName;\n+  }\n+\n+  /**\n+   * Creates a directory. Directory is represented using a key with no value.\n+   *\n+   * @param path directory path to be created\n+   * @return true if directory exists or created successfully.\n+   * @throws IOException\n+   */\n+  private boolean mkdir(Path path) throws IOException {\n+    return adapter.createDirectory(pathToKey(path));\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.trace(\"mkdir() path:{} \", f);\n+    String key = pathToKey(f);\n+    if (isEmpty(key)) {\n+      return false;\n+    }\n+    return mkdir(f);\n+  }\n+\n+  @Override\n+  public FileStatus getFileStatus(Path f) throws IOException {\n+    incrementCounter(Statistic.INVOCATION_GET_FILE_STATUS);\n+    statistics.incrementReadOps(1);\n+    LOG.trace(\"getFileStatus() path:{}\", f);\n+    Path qualifiedPath = f.makeQualified(uri, workingDir);\n+    String key = pathToKey(qualifiedPath);\n+    FileStatus fileStatus = null;\n+    try {\n+      fileStatus = convertFileStatus(\n+          adapter.getFileStatus(key, uri, qualifiedPath, getUsername()));\n+    } catch (OMException ex) {\n+      if (ex.getResult().equals(OMException.ResultCodes.KEY_NOT_FOUND)) {\n+        throw new FileNotFoundException(\"File not found. path:\" + f);\n+      }\n+    }\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public BlockLocation[] getFileBlockLocations(FileStatus fileStatus,\n+      long start, long len)\n+      throws IOException {\n+    if (fileStatus instanceof LocatedFileStatus) {\n+      return ((LocatedFileStatus) fileStatus).getBlockLocations();\n+    } else {\n+      return super.getFileBlockLocations(fileStatus, start, len);\n+    }\n+  }\n+\n+  /**\n+   * Turn a path (relative or otherwise) into an Ozone key.\n+   *\n+   * @param path the path of the file.\n+   * @return the key of the object that represents the file.\n+   */\n+  public String pathToKey(Path path) {\n+    Objects.requireNonNull(path, \"Path can't be null!\");\n+    if (!path.isAbsolute()) {\n+      path = new Path(workingDir, path);\n+    }\n+    // removing leading '/' char\n+    String key = path.toUri().getPath().substring(1);\n+    LOG.trace(\"path for key: {} is: {}\", key, path);\n+    return key;\n+  }\n+\n+  /**\n+   * Add trailing delimiter to path if it is already not present.\n+   *\n+   * @param key the ozone Key which needs to be appended\n+   * @return delimiter appended key\n+   */\n+  private String addTrailingSlashIfNeeded(String key) {\n+    if (!isEmpty(key) && !key.endsWith(OZONE_URI_DELIMITER)) {\n+      return key + OZONE_URI_DELIMITER;\n+    } else {\n+      return key;\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RootedOzoneFileSystem{URI=\" + uri + \", \"\n+        + \"workingDir=\" + workingDir + \", \"\n+        + \"userName=\" + userName + \", \"\n+        + \"statistics=\" + statistics\n+        + \"}\";\n+  }\n+\n+  /**\n+   * This class provides an interface to iterate through all the keys in the\n+   * bucket prefixed with the input path key and process them.\n+   * <p>\n+   * Each implementing class should define how the keys should be processed\n+   * through the processKeyPath() function.\n+   */\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private Iterator<BasicKeyInfo> keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+        throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = adapter.listKeys(pathKey);\n+    }\n+\n+    /**\n+     * The output of processKey determines if further iteration through the\n+     * keys should be done or not.\n+     *\n+     * @return true if we should continue iteration of keys, false otherwise.\n+     * @throws IOException\n+     */\n+    abstract boolean processKeyPath(String keyPath) throws IOException;\n+\n+    /**\n+     * Iterates through all the keys prefixed with the input path's key and\n+     * processes the key though processKey().\n+     * If for any key, the processKey() returns false, then the iteration is\n+     * stopped and returned with false indicating that all the keys could not\n+     * be processed successfully.\n+     *\n+     * @return true if all keys are processed successfully, false otherwise.\n+     * @throws IOException\n+     */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        while (keyIterator.hasNext()) {\n+          BasicKeyInfo key = keyIterator.next();\n+          String keyPath = ofsPath.getNonKeyPathNoPrefixDelim() +\n+              OZONE_URI_DELIMITER + key.getName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!processKeyPath(keyPath)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        return processKeyPath(pathKey);\n+      }\n+    }\n+\n+    String getPathKey() {\n+      return pathKey;\n+    }\n+\n+    boolean pathIsDirectory() {\n+      return status.isDirectory();\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  public RootedOzoneClientAdapter getAdapter() {\n+    return adapter;\n+  }\n+\n+  public boolean isEmpty(CharSequence cs) {\n+    return cs == null || cs.length() == 0;\n+  }\n+\n+  public boolean isNumber(String number) {\n+    try {\n+      Integer.parseInt(number);\n+    } catch (NumberFormatException ex) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private FileStatus convertFileStatus(FileStatusAdapter fileStatusAdapter) {\n+    Path symLink = null;\n+    try {\n+      fileStatusAdapter.getSymlink();\n+    } catch (Exception ex) {\n+      //NOOP: If not symlink symlink remains null.\n+    }\n+\n+    // Process path.\n+    URI newUri = fileStatusAdapter.getPath().toUri();\n+    try {\n+      newUri = new URIBuilder().setScheme(newUri.getScheme())\n+          .setHost(newUri.getAuthority())\n+          .setPath(newUri.getPath())\n+          .build();\n+    } catch (URISyntaxException e) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzMDU5OA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 782}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTgyNDM3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjoxMToxNlrOFgsxkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDoxNTo0OFrOFiEEwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzMjMzNg==", "bodyText": "Can you please add comments explaining how vol, bucket and mounts are used.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369832336", "createdAt": "2020-01-22T22:11:16Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.yetus.audience.InterfaceStability;\n+import java.util.StringTokenizer;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+\n+/**\n+ * Utility class for Rooted Ozone Filesystem (OFS) path processing.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class OFSPath {\n+  private String volumeName;\n+  private String bucketName;\n+  private String mountName;\n+  private String keyName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MjY1Ng==", "bodyText": "I added a table for illustration: 4bb7ed1\nNote the table might change in the future. This just shows what it does at the moment.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371262656", "createdAt": "2020-01-27T14:15:48Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.yetus.audience.InterfaceStability;\n+import java.util.StringTokenizer;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+\n+/**\n+ * Utility class for Rooted Ozone Filesystem (OFS) path processing.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class OFSPath {\n+  private String volumeName;\n+  private String bucketName;\n+  private String mountName;\n+  private String keyName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzMjMzNg=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NTg2MzY4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystemWithMocks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMjoyNDozMVrOFgtI1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDozNjozNFrOFiE1ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzODI5NA==", "bodyText": "testFSUriHostVersionDefault() and testFSUriWithHostPortUnspecified() need to be modified to test ofs.", "url": "https://github.com/apache/ozone/pull/415#discussion_r369838294", "createdAt": "2020-01-22T22:24:31Z", "author": {"login": "hanishakoneru"}, "path": "hadoop-ozone/ozonefs/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystemWithMocks.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.net.URI;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Ozone File system tests that are light weight and use mocks.\n+ */\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({ OzoneClientFactory.class, UserGroupInformation.class })\n+@PowerMockIgnore(\"javax.management.*\")\n+public class TestRootedOzoneFileSystemWithMocks {\n+\n+  @Test\n+  public void testFSUriWithHostPortOverrides() throws Exception {\n+    Configuration conf = new OzoneConfiguration();\n+    OzoneClient ozoneClient = mock(OzoneClient.class);\n+    ObjectStore objectStore = mock(ObjectStore.class);\n+    OzoneVolume volume = mock(OzoneVolume.class);\n+    OzoneBucket bucket = mock(OzoneBucket.class);\n+\n+    when(ozoneClient.getObjectStore()).thenReturn(objectStore);\n+    when(objectStore.getVolume(eq(\"volume1\"))).thenReturn(volume);\n+    when(volume.getBucket(\"bucket1\")).thenReturn(bucket);\n+\n+    PowerMockito.mockStatic(OzoneClientFactory.class);\n+    PowerMockito.when(OzoneClientFactory.getRpcClient(eq(\"local.host\"),\n+        eq(5899), eq(conf))).thenReturn(ozoneClient);\n+\n+    UserGroupInformation ugi = mock(UserGroupInformation.class);\n+    PowerMockito.mockStatic(UserGroupInformation.class);\n+    PowerMockito.when(UserGroupInformation.getCurrentUser()).thenReturn(ugi);\n+    when(ugi.getShortUserName()).thenReturn(\"user1\");\n+\n+    // Note: FileSystem#loadFileSystems doesn't load OFS class because\n+    //  META-INF still points to org.apache.hadoop.fs.ozone.OzoneFileSystem\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    URI uri = new URI(\"ofs://local.host:5899/volume1/bucket1\");\n+\n+    FileSystem fileSystem = FileSystem.get(uri, conf);\n+    RootedOzoneFileSystem ofs = (RootedOzoneFileSystem) fileSystem;\n+\n+    assertEquals(ofs.getUri().getAuthority(), \"local.host:5899\");\n+    PowerMockito.verifyStatic();\n+    OzoneClientFactory.getRpcClient(\"local.host\", 5899, conf);\n+  }\n+\n+  @Test\n+  public void testFSUriWithHostPortUnspecified() throws Exception {\n+    Configuration conf = new OzoneConfiguration();\n+    final int omPort = OmUtils.getOmRpcPort(conf);\n+\n+    OzoneClient ozoneClient = mock(OzoneClient.class);\n+    ObjectStore objectStore = mock(ObjectStore.class);\n+    OzoneVolume volume = mock(OzoneVolume.class);\n+    OzoneBucket bucket = mock(OzoneBucket.class);\n+\n+    when(ozoneClient.getObjectStore()).thenReturn(objectStore);\n+    when(objectStore.getVolume(eq(\"volume1\"))).thenReturn(volume);\n+    when(volume.getBucket(\"bucket1\")).thenReturn(bucket);\n+\n+    PowerMockito.mockStatic(OzoneClientFactory.class);\n+    PowerMockito.when(OzoneClientFactory.getRpcClient(eq(\"local.host\"),\n+        eq(omPort), eq(conf))).thenReturn(ozoneClient);\n+\n+    UserGroupInformation ugi = mock(UserGroupInformation.class);\n+    PowerMockito.mockStatic(UserGroupInformation.class);\n+    PowerMockito.when(UserGroupInformation.getCurrentUser()).thenReturn(ugi);\n+    when(ugi.getShortUserName()).thenReturn(\"user1\");\n+\n+    URI uri = new URI(\"o3fs://bucket1.volume1.local.host\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NTE2Ng==", "bodyText": "Done in 5a20f9d.", "url": "https://github.com/apache/ozone/pull/415#discussion_r371275166", "createdAt": "2020-01-27T14:36:34Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystemWithMocks.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.net.URI;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Ozone File system tests that are light weight and use mocks.\n+ */\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({ OzoneClientFactory.class, UserGroupInformation.class })\n+@PowerMockIgnore(\"javax.management.*\")\n+public class TestRootedOzoneFileSystemWithMocks {\n+\n+  @Test\n+  public void testFSUriWithHostPortOverrides() throws Exception {\n+    Configuration conf = new OzoneConfiguration();\n+    OzoneClient ozoneClient = mock(OzoneClient.class);\n+    ObjectStore objectStore = mock(ObjectStore.class);\n+    OzoneVolume volume = mock(OzoneVolume.class);\n+    OzoneBucket bucket = mock(OzoneBucket.class);\n+\n+    when(ozoneClient.getObjectStore()).thenReturn(objectStore);\n+    when(objectStore.getVolume(eq(\"volume1\"))).thenReturn(volume);\n+    when(volume.getBucket(\"bucket1\")).thenReturn(bucket);\n+\n+    PowerMockito.mockStatic(OzoneClientFactory.class);\n+    PowerMockito.when(OzoneClientFactory.getRpcClient(eq(\"local.host\"),\n+        eq(5899), eq(conf))).thenReturn(ozoneClient);\n+\n+    UserGroupInformation ugi = mock(UserGroupInformation.class);\n+    PowerMockito.mockStatic(UserGroupInformation.class);\n+    PowerMockito.when(UserGroupInformation.getCurrentUser()).thenReturn(ugi);\n+    when(ugi.getShortUserName()).thenReturn(\"user1\");\n+\n+    // Note: FileSystem#loadFileSystems doesn't load OFS class because\n+    //  META-INF still points to org.apache.hadoop.fs.ozone.OzoneFileSystem\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    URI uri = new URI(\"ofs://local.host:5899/volume1/bucket1\");\n+\n+    FileSystem fileSystem = FileSystem.get(uri, conf);\n+    RootedOzoneFileSystem ofs = (RootedOzoneFileSystem) fileSystem;\n+\n+    assertEquals(ofs.getUri().getAuthority(), \"local.host:5899\");\n+    PowerMockito.verifyStatic();\n+    OzoneClientFactory.getRpcClient(\"local.host\", 5899, conf);\n+  }\n+\n+  @Test\n+  public void testFSUriWithHostPortUnspecified() throws Exception {\n+    Configuration conf = new OzoneConfiguration();\n+    final int omPort = OmUtils.getOmRpcPort(conf);\n+\n+    OzoneClient ozoneClient = mock(OzoneClient.class);\n+    ObjectStore objectStore = mock(ObjectStore.class);\n+    OzoneVolume volume = mock(OzoneVolume.class);\n+    OzoneBucket bucket = mock(OzoneBucket.class);\n+\n+    when(ozoneClient.getObjectStore()).thenReturn(objectStore);\n+    when(objectStore.getVolume(eq(\"volume1\"))).thenReturn(volume);\n+    when(volume.getBucket(\"bucket1\")).thenReturn(bucket);\n+\n+    PowerMockito.mockStatic(OzoneClientFactory.class);\n+    PowerMockito.when(OzoneClientFactory.getRpcClient(eq(\"local.host\"),\n+        eq(omPort), eq(conf))).thenReturn(ozoneClient);\n+\n+    UserGroupInformation ugi = mock(UserGroupInformation.class);\n+    PowerMockito.mockStatic(UserGroupInformation.class);\n+    PowerMockito.when(UserGroupInformation.getCurrentUser()).thenReturn(ugi);\n+    when(ugi.getShortUserName()).thenReturn(\"user1\");\n+\n+    URI uri = new URI(\"o3fs://bucket1.volume1.local.host\");\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzODI5NA=="}, "originalCommit": {"oid": "bdffa6ab5c1f59cedc968bf36c2ccd286cc6288f"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTkzOTAyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToxMjo0MlrOFixLKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODowNTo0OFrOFjSQYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMTU3OA==", "bodyText": "The test cases are very similar to TestOzoneFileSystem, most of the difference are in setup.\nCan we refactor to have a base class that contains all the common test methods and leave only the setup in the subclass for different file system? (This is the approach taken in the contract test to avoid duplicate code)", "url": "https://github.com/apache/ozone/pull/415#discussion_r372001578", "createdAt": "2020-01-28T19:12:42Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5NTM2OQ==", "bodyText": "Indeed most code are the same, but not just in the setup. In quite a few existing test cases I changed some subtle variable to make it run on o3fs, meaning we likely would need to change o3fs's unit test a bit as well (potentially more conflicts when merging this branch with trunk). I would suggest adding a TODO for this class and do the refactoring at a later point. What do you say?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372095369", "createdAt": "2020-01-28T22:30:19Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMTU3OA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0MzU4Nw==", "bodyText": "Added TODO.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372543587", "createdAt": "2020-01-29T18:05:48Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ */\n+public class TestRootedOzoneFileSystem {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMTU3OA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDAyNDYyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0MDoxMlrOFiyBpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToxODoxOFrOFi06xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTUyNw==", "bodyText": "should we do getVolumeDetails/create first and if that fails, there is no need to create bucket.\nAs createVolume is an admin only operation, I would expect most of the client driven operation will fail here.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372015527", "createdAt": "2020-01-28T19:40:12Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MjkxOA==", "bodyText": "@xiaoyuyao Actually this part was coded previously that it checks if the volume exists first. Then @bharatviswa504 argued that this way we would always have at least two round trips for each getBucket() (first getVolumeDetails, then getBucketDetails) regardless of whether the bucket already exists. This change is made in d2a01d1#diff-1982358804d0a7b88f575ecd1e3b3013R202", "url": "https://github.com/apache/ozone/pull/415#discussion_r372062918", "createdAt": "2020-01-28T21:18:18Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTUyNw=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDAzNDgyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0MzoyMFrOFiyH5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoxMzoyNFrOFjSesg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNzEyNw==", "bodyText": "Even the volume creation succeed, the bucket creation might fail if the ACLs are not set properly when security and acls are enabled. With o3fs, this is OK because the volume/bucket are provisioned and acls setup before it is mounted. With ofs, this may not work without ACL changes.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372017127", "createdAt": "2020-01-28T19:43:20Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NzI1MA==", "bodyText": "As we discussed, currently in Ozone createVolume will set owner to current user when volArg owner is null: https://github.com/smengcl/hadoop-ozone/blob/046a06f02783da516179ee8d8d1bed862d22f78d/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java#L268\nCan we resolve this one?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372547250", "createdAt": "2020-01-29T18:13:24Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNzEyNw=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDAzODYzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0NDoyOVrOFiyKOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0NDoyOVrOFiyKOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNzcyMQ==", "bodyText": "what is permission denied, do we recover the environment by delete the volume?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372017721", "createdAt": "2020-01-28T19:44:29Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDA5NDQ5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowMjozOVrOFiytyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoxODoxN1rOFjSn8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNjgyNw==", "bodyText": "In the /tmp case, the bucketName length is also 0? do we want to create a /tmp volume here?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372026827", "createdAt": "2020-01-28T20:02:39Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0OTYxNg==", "bodyText": "Done in e16a52e.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372549616", "createdAt": "2020-01-29T18:18:17Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNjgyNw=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 360}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDA5NjA5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowMzoxMFrOFiyuxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoyNDozNFrOFjS02Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzA3OQ==", "bodyText": "what if keyStr is empty(length 0) should we check that before getBucket?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372027079", "createdAt": "2020-01-28T20:03:10Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1MjE3Ng==", "bodyText": "Actually here we need to put the keyStr.length() check after getBucket, since getBucket need to create volume and bucket if they don't exist. If we check it before try clause it wouldn't create the volume and bucket then.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372552176", "createdAt": "2020-01-29T18:23:07Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzA3OQ=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1MjkyMQ==", "bodyText": "Comment updated in c0e2ed7.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372552921", "createdAt": "2020-01-29T18:24:34Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNzA3OQ=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDEwMzEzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowNTo0OVrOFiyzXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOTowODozN1rOFj2jBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA==", "bodyText": "check keyName is empty?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372028254", "createdAt": "2020-01-28T20:05:49Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODU5OA==", "bodyText": "Do we support delete volume/bucket via OFS?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372028598", "createdAt": "2020-01-28T20:06:35Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1NTM3NQ==", "bodyText": "keyName check done in ac0cd77.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372555375", "createdAt": "2020-01-29T18:29:21Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1NjAxOQ==", "bodyText": "On supporting delete volume/bucket though, this is a good question. I'd argue it is weird to support delete volume/bucket via rm interface but from a flat filesystem point of view it should be a feature. What's you opinion? @arp7", "url": "https://github.com/apache/ozone/pull/415#discussion_r372556019", "createdAt": "2020-01-29T18:30:40Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc1Mjk4Mg==", "bodyText": "Let's follow up that on separate JIRA.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372752982", "createdAt": "2020-01-30T04:19:07Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzODE4MQ==", "bodyText": "Agree", "url": "https://github.com/apache/ozone/pull/415#discussion_r373138181", "createdAt": "2020-01-30T19:08:37Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODI1NA=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 392}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDExMDc1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMDowODo0MlrOFiy4Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozMToxMlrOFjTCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyOTQ4Mw==", "bodyText": "should we move the counter incr before getBucket so that we can accurately count the ops even though getBucket may fail?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372029483", "createdAt": "2020-01-28T20:08:42Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Path to delete.\n+   * @return true if operation succeeded, false upon IOException.\n+   */\n+  boolean deleteObject(OzoneBucket bucket, String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  public FileStatusAdapter getFileStatus(String path, URI uri,\n+      Path qualifiedPath, String userName)\n+      throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_QUERY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1NjMwMg==", "bodyText": "Done in a9ef567", "url": "https://github.com/apache/ozone/pull/415#discussion_r372556302", "createdAt": "2020-01-29T18:31:12Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+\n+    // Check path and newPathName are in the same volume and same bucket.\n+    // This should have been checked in BasicRootedOzoneFileSystem#rename\n+    // already via regular call path unless bypassed.\n+    if (!ofsPath.isInSameBucketAs(ofsNewPath)) {\n+      throw new IOException(\"Cannot rename a key to a different bucket\");\n+    }\n+\n+    OzoneBucket bucket = getBucket(ofsPath, false);\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Existing key path.\n+   * @param newPath New key path.\n+   * @throws IOException IOException from bucket.renameKey().\n+   */\n+  void renamePath(OzoneBucket bucket, String path, String newPath)\n+      throws IOException {\n+    incrementCounter(Statistic.OBJECTS_RENAMED);\n+    OFSPath ofsPath = new OFSPath(path);\n+    OFSPath ofsNewPath = new OFSPath(newPath);\n+    // No same-bucket policy check here since this call path is controlled\n+    String key = ofsPath.getKeyName();\n+    String newKey = ofsNewPath.getKeyName();\n+    bucket.renameKey(key, newKey);\n+  }\n+\n+  /**\n+   * Helper method to create an directory specified by key name in bucket.\n+   *\n+   * @param pathStr path to be created as directory\n+   * @return true if the key is created, false otherwise\n+   */\n+  @Override\n+  public boolean createDirectory(String pathStr) throws IOException {\n+    LOG.trace(\"creating dir for path: {}\", pathStr);\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    // Volume name unspecified, return failure\n+    if (ofsPath.getVolumeName().length() == 0) {\n+      return false;\n+    }\n+    // Handle where only volume is specified in pathStr\n+    if (ofsPath.getBucketName().length() == 0) {\n+      objectStore.createVolume(ofsPath.getVolumeName());\n+      return true;\n+    }\n+    String keyStr = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, true);\n+      // if keyStr is empty, it indicates that only volume or volume+bucket is\n+      // given in pathStr, so getBucket() above should've handled the creation\n+      // of volume/bucket already.\n+      if (keyStr != null && keyStr.length() > 0) {\n+        bucket.createDirectory(keyStr);\n+      }\n+    } catch (OMException e) {\n+      if (e.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS) {\n+        throw new FileAlreadyExistsException(e.getMessage());\n+      }\n+      throw e;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param path path to a key to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Package-private helper function to reduce calls to getBucket().\n+   * @param bucket Bucket to operate in.\n+   * @param path Path to delete.\n+   * @return true if operation succeeded, false upon IOException.\n+   */\n+  boolean deleteObject(OzoneBucket bucket, String path) {\n+    LOG.trace(\"issuing delete for path to key: {}\", path);\n+    OFSPath ofsPath = new OFSPath(path);\n+    String keyName = ofsPath.getKeyName();\n+    try {\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed \" + ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n+  public FileStatusAdapter getFileStatus(String path, URI uri,\n+      Path qualifiedPath, String userName)\n+      throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      incrementCounter(Statistic.OBJECTS_QUERY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyOTQ4Mw=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDM5NTMxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMTo0NDoxMlrOFi1p8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjoyNzo0N1rOFi21hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA3NDk5NQ==", "bodyText": "How is the /tempVol/tempBucket created? Do we provide a CLI to admin?", "url": "https://github.com/apache/ozone/pull/415#discussion_r372074995", "createdAt": "2020-01-28T21:44:12Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.yetus.audience.InterfaceStability;\n+import java.util.StringTokenizer;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+\n+/**\n+ * Utility class for Rooted Ozone Filesystem (OFS) path processing.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class OFSPath {\n+  /**\n+   * Here is a table illustrating what each name variable is given an input path\n+   * Assuming /tmp is mounted to /tempVol/tempBucket", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5NDM0Mg==", "bodyText": "This is undecided. Yes we could give admin a CLI command to do the initialization. But we might want to leave this for jira HDDS-2929.", "url": "https://github.com/apache/ozone/pull/415#discussion_r372094342", "createdAt": "2020-01-28T22:27:47Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.yetus.audience.InterfaceStability;\n+import java.util.StringTokenizer;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+\n+/**\n+ * Utility class for Rooted Ozone Filesystem (OFS) path processing.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class OFSPath {\n+  /**\n+   * Here is a table illustrating what each name variable is given an input path\n+   * Assuming /tmp is mounted to /tempVol/tempBucket", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA3NDk5NQ=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU4MzM5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo1NTozNVrOFi3fgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozNzowM1rOFjTNTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTA5MQ==", "bodyText": "Let's change renamePath to rename", "url": "https://github.com/apache/ozone/pull/415#discussion_r372105091", "createdAt": "2020-01-28T22:55:35Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1OTE4MQ==", "bodyText": "Done in 5c1c081", "url": "https://github.com/apache/ozone/pull/415#discussion_r372559181", "createdAt": "2020-01-29T18:37:03Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneClientAdapterImpl.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.ozone;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.crypto.key.KeyProvider;\n+import org.apache.hadoop.fs.BlockLocation;\n+import org.apache.hadoop.fs.FileAlreadyExistsException;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdds.client.ReplicationFactor;\n+import org.apache.hadoop.hdds.client.ReplicationType;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.security.x509.SecurityConfig;\n+import org.apache.hadoop.io.Text;\n+import org.apache.hadoop.ozone.OmUtils;\n+import org.apache.hadoop.ozone.OzoneConfigKeys;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClient;\n+import org.apache.hadoop.ozone.client.OzoneClientFactory;\n+import org.apache.hadoop.ozone.client.OzoneKey;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.ozone.client.io.OzoneOutputStream;\n+import org.apache.hadoop.ozone.client.protocol.ClientProtocol;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfoGroup;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.security.OzoneTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n+import org.apache.hadoop.security.token.TokenRenewer;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .VOLUME_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes\n+    .BUCKET_NOT_FOUND;\n+\n+/**\n+ * Basic Implementation of the OzoneFileSystem calls.\n+ * <p>\n+ * This is the minimal version which doesn't include any statistics.\n+ * <p>\n+ * For full featured version use OzoneClientAdapterImpl.\n+ */\n+public class BasicRootedOzoneClientAdapterImpl\n+    implements RootedOzoneClientAdapter {\n+\n+  static final Logger LOG =\n+      LoggerFactory.getLogger(BasicRootedOzoneClientAdapterImpl.class);\n+\n+  private OzoneClient ozoneClient;\n+  private ClientProtocol proxy;\n+  private ObjectStore objectStore;\n+  private ReplicationType replicationType;\n+  private ReplicationFactor replicationFactor;\n+  private boolean securityEnabled;\n+  private int configuredDnPort;\n+\n+  /**\n+   * Create new OzoneClientAdapter implementation.\n+   *\n+   * @throws IOException In case of a problem.\n+   */\n+  public BasicRootedOzoneClientAdapterImpl() throws IOException {\n+    this(createConf());\n+  }\n+\n+  private static OzoneConfiguration createConf() {\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+    try {\n+      return new OzoneConfiguration();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(OzoneConfiguration conf)\n+      throws IOException {\n+    this(null, -1, conf);\n+  }\n+\n+  public BasicRootedOzoneClientAdapterImpl(String omHost, int omPort,\n+      Configuration hadoopConf) throws IOException {\n+\n+    ClassLoader contextClassLoader =\n+        Thread.currentThread().getContextClassLoader();\n+    Thread.currentThread().setContextClassLoader(null);\n+\n+    try {\n+      OzoneConfiguration conf = OzoneConfiguration.of(hadoopConf);\n+\n+      if (omHost == null && OmUtils.isServiceIdsDefined(conf)) {\n+        // When the host name or service id isn't given\n+        // but ozone.om.service.ids is defined, declare failure.\n+\n+        // This is a safety precaution that prevents the client from\n+        // accidentally failing over to an unintended OM.\n+        throw new IllegalArgumentException(\"Service ID or host name must not\"\n+            + \" be omitted when ozone.om.service.ids is defined.\");\n+      }\n+\n+      if (omPort != -1) {\n+        // When the port number is specified, perform the following check\n+        if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+          // If omHost is a service id, it shouldn't use a port\n+          throw new IllegalArgumentException(\"Port \" + omPort +\n+              \" specified in URI but host '\" + omHost + \"' is a \"\n+              + \"logical (HA) OzoneManager and does not use port information.\");\n+        }\n+      } else {\n+        // When port number is not specified, read it from config\n+        omPort = OmUtils.getOmRpcPort(conf);\n+      }\n+\n+      SecurityConfig secConfig = new SecurityConfig(conf);\n+\n+      if (secConfig.isSecurityEnabled()) {\n+        this.securityEnabled = true;\n+      }\n+\n+      String replicationTypeConf =\n+          conf.get(OzoneConfigKeys.OZONE_REPLICATION_TYPE,\n+              OzoneConfigKeys.OZONE_REPLICATION_TYPE_DEFAULT);\n+\n+      int replicationCountConf = conf.getInt(OzoneConfigKeys.OZONE_REPLICATION,\n+          OzoneConfigKeys.OZONE_REPLICATION_DEFAULT);\n+\n+      if (OmUtils.isOmHAServiceId(conf, omHost)) {\n+        // omHost is listed as one of the service ids in the config,\n+        // thus we should treat omHost as omServiceId\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, conf);\n+      } else if (StringUtils.isNotEmpty(omHost) && omPort != -1) {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(omHost, omPort, conf);\n+      } else {\n+        this.ozoneClient =\n+            OzoneClientFactory.getRpcClient(conf);\n+      }\n+      objectStore = ozoneClient.getObjectStore();\n+      proxy = objectStore.getClientProxy();\n+      this.replicationType = ReplicationType.valueOf(replicationTypeConf);\n+      this.replicationFactor = ReplicationFactor.valueOf(replicationCountConf);\n+      this.configuredDnPort = conf.getInt(\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT,\n+          OzoneConfigKeys.DFS_CONTAINER_IPC_PORT_DEFAULT);\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(contextClassLoader);\n+    }\n+  }\n+\n+  OzoneBucket getBucket(OFSPath ofsPath, boolean createIfNotExist)\n+      throws IOException {\n+\n+    return getBucket(ofsPath.getVolumeName(), ofsPath.getBucketName(),\n+        createIfNotExist);\n+  }\n+\n+  /**\n+   * Get OzoneBucket object to operate in.\n+   * Optionally create volume and bucket if not found.\n+   *\n+   * @param createIfNotExist Set this to true if the caller is a write operation\n+   *                         in order to create the volume and bucket.\n+   * @throws IOException Exceptions other than OMException with result code\n+   *                     VOLUME_NOT_FOUND or BUCKET_NOT_FOUND.\n+   */\n+  private OzoneBucket getBucket(String volumeStr, String bucketStr,\n+      boolean createIfNotExist) throws IOException {\n+\n+    OzoneBucket bucket;\n+    try {\n+      bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+    } catch (OMException ex) {\n+      if (createIfNotExist) {\n+        // Note: getBucketDetails always throws BUCKET_NOT_FOUND, even if\n+        // the volume doesn't exist.\n+        if (ex.getResult().equals(BUCKET_NOT_FOUND)) {\n+          OzoneVolume volume;\n+          try {\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          } catch (OMException getVolEx) {\n+            if (getVolEx.getResult().equals(VOLUME_NOT_FOUND)) {\n+              // Volume doesn't exist. Create it\n+              try {\n+                objectStore.createVolume(volumeStr);\n+              } catch (OMException newVolEx) {\n+                // Ignore the case where another client created the volume\n+                if (!newVolEx.getResult().equals(VOLUME_ALREADY_EXISTS)) {\n+                  throw newVolEx;\n+                }\n+              }\n+            } else {\n+              throw getVolEx;\n+            }\n+            // Try get volume again\n+            volume = proxy.getVolumeDetails(volumeStr);\n+          }\n+          // Create the bucket\n+          try {\n+            volume.createBucket(bucketStr);\n+          } catch (OMException newBucEx) {\n+            // Ignore the case where another client created the bucket\n+            if (!newBucEx.getResult().equals(BUCKET_ALREADY_EXISTS)) {\n+              throw newBucEx;\n+            }\n+          }\n+        }\n+        // Try get bucket again\n+        bucket = proxy.getBucketDetails(volumeStr, bucketStr);\n+      } else {\n+        throw ex;\n+      }\n+    }\n+\n+    return bucket;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    ozoneClient.close();\n+  }\n+\n+  @Override\n+  public InputStream readFile(String pathStr) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_READ);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      return bucket.readFile(key).getInputStream();\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_NOT_FOUND\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileNotFoundException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  protected void incrementCounter(Statistic objectsRead) {\n+    //noop: Use OzoneClientAdapterImpl which supports statistics.\n+  }\n+\n+  @Override\n+  public OzoneFSOutputStream createFile(String pathStr, boolean overWrite,\n+      boolean recursive) throws IOException {\n+    incrementCounter(Statistic.OBJECTS_CREATED);\n+    OFSPath ofsPath = new OFSPath(pathStr);\n+    String key = ofsPath.getKeyName();\n+    try {\n+      OzoneBucket bucket = getBucket(ofsPath, false);\n+      OzoneOutputStream ozoneOutputStream = bucket.createFile(\n+          key, 0, replicationType, replicationFactor, overWrite, recursive);\n+      return new OzoneFSOutputStream(ozoneOutputStream.getOutputStream());\n+    } catch (OMException ex) {\n+      if (ex.getResult() == OMException.ResultCodes.FILE_ALREADY_EXISTS\n+          || ex.getResult() == OMException.ResultCodes.NOT_A_FILE) {\n+        throw new FileAlreadyExistsException(\n+            ex.getResult().name() + \": \" + ex.getMessage());\n+      } else {\n+        throw ex;\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void renamePath(String path, String newPath) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTA5MQ=="}, "originalCommit": {"oid": "60b4bf8e6008cbd53d95c3e0f249f33227209c1e"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzA0NjU2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxODozNDowOFrOFj1dqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxOToxNDoxMlrOFj2uCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMDQyNg==", "bodyText": "Consider reducing the numDirs as it will unnecessarily slow down the PR.", "url": "https://github.com/apache/ozone/pull/415#discussion_r373120426", "createdAt": "2020-01-30T18:34:08Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ *\n+ * TODO: Refactor this and TestOzoneFileSystem to eliminate most\n+ *  code duplication.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  // Store path commonly used by tests that test functionality within a bucket\n+  private String testBucketStr;\n+  private Path testBucketPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by RootedOzoneFileSystem (OFS)\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+    testBucketStr = \"/\" + volumeName + \"/\" + bucketName;\n+    testBucketPath = new Path(testBucketStr);\n+\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME, conf),\n+        RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path grandparent = new Path(testBucketPath,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKey(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKey(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path grandparent = new Path(testBucketPath,\n+        \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKey(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKey(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path parent = new Path(testBucketPath, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(testBucketPath);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);\n+\n+    ContractTestUtils.touch(fs, file1);\n+    ContractTestUtils.touch(fs, file2);\n+\n+    fileStatuses = ofs.listStatus(testBucketPath);\n+    assertEquals(\"Should have created parent\",\n+        1, fileStatuses.length);\n+    assertEquals(\"Parent path doesn't match\",\n+        fileStatuses[0].getPath().toUri().getPath(), parent.toString());\n+\n+    // ListStatus on a directory should return all subdirs along with\n+    // files, even if there exists a file and sub-dir with the same name.\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        2, fileStatuses.length);\n+\n+    // ListStatus should return only the immediate children of a directory.\n+    Path file3 = new Path(parent, \"dir1/key3\");\n+    Path file4 = new Path(parent, \"dir1/key4\");\n+    ContractTestUtils.touch(fs, file3);\n+    ContractTestUtils.touch(fs, file4);\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        3, fileStatuses.length);\n+  }\n+\n+  /**\n+   * OFS: Helper function for tests. Return a volume name that doesn't exist.\n+   */\n+  private String getRandomNonExistVolumeName() throws Exception {\n+    final int numDigit = 5;\n+    long retriesLeft = Math.round(Math.pow(10, 5));\n+    String name = null;\n+    while (name == null && retriesLeft-- > 0) {\n+      name = \"volume-\" + RandomStringUtils.randomNumeric(numDigit);\n+      // Check volume existence.\n+      Iterator<? extends OzoneVolume> iter =\n+          objectStore.listVolumesByUser(null, name, null);\n+      if (iter.hasNext()) {\n+        // If there is a match, try again.\n+        // Note that volume name prefix match doesn't equal volume existence\n+        //  but the check is sufficient for this test.\n+        name = null;\n+      }\n+    }\n+    if (retriesLeft <= 0) {\n+      throw new Exception(\n+          \"Failed to generate random volume name that doesn't exist already.\");\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * OFS: Test mkdir on volume, bucket and dir that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirOnNonExistentVolumeBucketDir() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path root = new Path(\"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // Check volume and bucket existence, they should both be created.\n+    OzoneVolume ozoneVolume = objectStore.getVolume(volumeNameLocal);\n+    OzoneBucket ozoneBucket = ozoneVolume.getBucket(bucketNameLocal);\n+    OFSPath ofsPathDir1 = new OFSPath(dir12);\n+    String key = ofsPathDir1.getKeyName() + \"/\";\n+    OzoneKeyDetails ozoneKeyDetails = ozoneBucket.getKey(key);\n+    assertEquals(key, ozoneKeyDetails.getName());\n+\n+    // Verify that directories are created.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir1.toString());\n+    assertEquals(fileStatuses[1].getPath().toUri().getPath(), dir2.toString());\n+\n+    fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir12.toString());\n+    fileStatuses = ofs.listStatus(dir12);\n+    assertEquals(fileStatuses.length, 0);\n+    fileStatuses = ofs.listStatus(dir2);\n+    assertEquals(fileStatuses.length, 0);\n+  }\n+\n+  /**\n+   * OFS: Tests mkdir on a volume and bucket that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirNonExistentVolumeBucket() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path newVolBucket = new Path(\n+        \"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    fs.mkdirs(newVolBucket);\n+\n+    // Verify with listVolumes and listBuckets\n+    Iterator<? extends OzoneVolume> iterVol =\n+        objectStore.listVolumesByUser(null, volumeNameLocal, null);\n+    OzoneVolume ozoneVolume = iterVol.next();\n+    assertNotNull(ozoneVolume);\n+    assertEquals(volumeNameLocal, ozoneVolume.getName());\n+\n+    Iterator<? extends OzoneBucket> iterBuc =\n+        ozoneVolume.listBuckets(\"bucket-\");\n+    OzoneBucket ozoneBucket = iterBuc.next();\n+    assertNotNull(ozoneBucket);\n+    assertEquals(bucketNameLocal, ozoneBucket.getName());\n+\n+    // TODO: Use listStatus to check volume and bucket creation in HDDS-2928.\n+  }\n+\n+  /**\n+   * OFS: Tests mkdir on a volume that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirNonExistentVolume() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    Path newVolume = new Path(\"/\" + volumeNameLocal);\n+    fs.mkdirs(newVolume);\n+\n+    // Verify with listVolumes and listBuckets\n+    Iterator<? extends OzoneVolume> iterVol =\n+        objectStore.listVolumesByUser(null, volumeNameLocal, null);\n+    OzoneVolume ozoneVolume = iterVol.next();\n+    assertNotNull(ozoneVolume);\n+    assertEquals(volumeNameLocal, ozoneVolume.getName());\n+\n+    // TODO: Use listStatus to check volume and bucket creation in HDDS-2928.\n+  }\n+\n+  /**\n+   * Tests listStatus operation in a bucket.\n+   */\n+  @Test\n+  public void testListStatusOnRoot() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // ListStatus on root should return dir1 (even though /dir1 key does not\n+    // exist) and dir2 only. dir12 is not an immediate child of root and\n+    // hence should not be listed.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that dir12 is not included in the result of the listStatus on root\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertFalse(fileStatus1.equals(dir12.toString()));\n+    assertFalse(fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnLargeDirectory() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Set<String> paths = new TreeSet<>();\n+    int numDirs = 5111;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "780ebaf5b5279e921a9eed5a43db34027c9b1aa4"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MTAwMQ==", "bodyText": "I'm not sure why o3fs test chose this random number. But basically numDirs only need to be larger than LISTING_PAGE_SIZE so it tests pagination. And BTW I believe integration tests are disabled in PR by default now. (They are not run in PR checks.)\nReduced in 0d71006.", "url": "https://github.com/apache/ozone/pull/415#discussion_r373141001", "createdAt": "2020-01-30T19:14:12Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestRootedOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.contract.ContractTestUtils;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.ObjectStore;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.client.OzoneClientException;\n+import org.apache.hadoop.ozone.client.OzoneKeyDetails;\n+import org.apache.hadoop.ozone.client.OzoneVolume;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import static org.apache.hadoop.ozone.om.OMConfigKeys.OZONE_OM_ADDRESS_KEY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Ozone file system tests that are not covered by contract tests.\n+ *\n+ * TODO: Refactor this and TestOzoneFileSystem to eliminate most\n+ *  code duplication.\n+ */\n+public class TestRootedOzoneFileSystem {\n+\n+  @Rule\n+  public Timeout globalTimeout = new Timeout(300_000);\n+\n+  private static MiniOzoneCluster cluster = null;\n+\n+  private static FileSystem fs;\n+  private static RootedOzoneFileSystem ofs;\n+\n+  private static ObjectStore objectStore;\n+\n+  private String volumeName;\n+  private String bucketName;\n+\n+  private String rootPath;\n+\n+  // Store path commonly used by tests that test functionality within a bucket\n+  private String testBucketStr;\n+  private Path testBucketPath;\n+\n+  @Before\n+  public void init() throws Exception {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    cluster = MiniOzoneCluster.newBuilder(conf)\n+        .setNumDatanodes(3)\n+        .build();\n+    cluster.waitForClusterToBeReady();\n+    objectStore = cluster.getClient().getObjectStore();\n+\n+    // create a volume and a bucket to be used by RootedOzoneFileSystem (OFS)\n+    OzoneBucket bucket = TestDataUtil.createVolumeAndBucket(cluster);\n+    volumeName = bucket.getVolumeName();\n+    bucketName = bucket.getName();\n+    testBucketStr = \"/\" + volumeName + \"/\" + bucketName;\n+    testBucketPath = new Path(testBucketStr);\n+\n+    rootPath = String.format(\"%s://%s/\", OzoneConsts.OZONE_OFS_URI_SCHEME,\n+        conf.get(OZONE_OM_ADDRESS_KEY));\n+\n+    // Set the fs.defaultFS and start the filesystem\n+    conf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, rootPath);\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    fs = FileSystem.get(conf);\n+    ofs = (RootedOzoneFileSystem) fs;\n+  }\n+\n+  @After\n+  public void teardown() {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+    IOUtils.closeQuietly(fs);\n+  }\n+\n+  @Test\n+  public void testOzoneFsServiceLoader() throws IOException {\n+    OzoneConfiguration conf = new OzoneConfiguration();\n+    // Note: FileSystem#loadFileSystems won't load OFS class due to META-INF\n+    //  hence this workaround.\n+    conf.set(\"fs.ofs.impl\", \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    assertEquals(\n+        FileSystem.getFileSystemClass(OzoneConsts.OZONE_OFS_URI_SCHEME, conf),\n+        RootedOzoneFileSystem.class);\n+  }\n+\n+  @Test\n+  public void testCreateDoesNotAddParentDirKeys() throws Exception {\n+    Path grandparent = new Path(testBucketPath,\n+        \"testCreateDoesNotAddParentDirKeys\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    OzoneKeyDetails key = getKey(child, false);\n+    OFSPath childOFSPath = new OFSPath(child);\n+    assertEquals(key.getName(), childOFSPath.getKeyName());\n+\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKey(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // List status on the parent should show the child file\n+    assertEquals(\"List status of parent should include the 1 child file\", 1L,\n+        (long)fs.listStatus(parent).length);\n+    assertTrue(\"Parent directory does not appear to be a directory\",\n+        fs.getFileStatus(parent).isDirectory());\n+  }\n+\n+  @Test\n+  public void testDeleteCreatesFakeParentDir() throws Exception {\n+    Path grandparent = new Path(testBucketPath,\n+        \"testDeleteCreatesFakeParentDir\");\n+    Path parent = new Path(grandparent, \"parent\");\n+    Path child = new Path(parent, \"child\");\n+    ContractTestUtils.touch(fs, child);\n+\n+    // Verify that parent dir key does not exist\n+    // Creating a child should not add parent keys to the bucket\n+    try {\n+      getKey(parent, true);\n+    } catch (IOException ex) {\n+      assertKeyNotFoundException(ex);\n+    }\n+\n+    // Delete the child key\n+    assertTrue(fs.delete(child, false));\n+\n+    // Deleting the only child should create the parent dir key if it does\n+    // not exist\n+    OFSPath parentOFSPath = new OFSPath(parent);\n+    String parentKey = parentOFSPath.getKeyName() + \"/\";\n+    OzoneKeyDetails parentKeyInfo = getKey(parent, true);\n+    assertEquals(parentKey, parentKeyInfo.getName());\n+\n+    // Recursive delete with DeleteIterator\n+    assertTrue(fs.delete(grandparent, true));\n+  }\n+\n+  @Test\n+  public void testListStatus() throws Exception {\n+    Path parent = new Path(testBucketPath, \"testListStatus\");\n+    Path file1 = new Path(parent, \"key1\");\n+    Path file2 = new Path(parent, \"key2\");\n+\n+    FileStatus[] fileStatuses = ofs.listStatus(testBucketPath);\n+    assertEquals(\"Should be empty\", 0, fileStatuses.length);\n+\n+    ContractTestUtils.touch(fs, file1);\n+    ContractTestUtils.touch(fs, file2);\n+\n+    fileStatuses = ofs.listStatus(testBucketPath);\n+    assertEquals(\"Should have created parent\",\n+        1, fileStatuses.length);\n+    assertEquals(\"Parent path doesn't match\",\n+        fileStatuses[0].getPath().toUri().getPath(), parent.toString());\n+\n+    // ListStatus on a directory should return all subdirs along with\n+    // files, even if there exists a file and sub-dir with the same name.\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        2, fileStatuses.length);\n+\n+    // ListStatus should return only the immediate children of a directory.\n+    Path file3 = new Path(parent, \"dir1/key3\");\n+    Path file4 = new Path(parent, \"dir1/key4\");\n+    ContractTestUtils.touch(fs, file3);\n+    ContractTestUtils.touch(fs, file4);\n+    fileStatuses = ofs.listStatus(parent);\n+    assertEquals(\"FileStatus did not return all children of the directory\",\n+        3, fileStatuses.length);\n+  }\n+\n+  /**\n+   * OFS: Helper function for tests. Return a volume name that doesn't exist.\n+   */\n+  private String getRandomNonExistVolumeName() throws Exception {\n+    final int numDigit = 5;\n+    long retriesLeft = Math.round(Math.pow(10, 5));\n+    String name = null;\n+    while (name == null && retriesLeft-- > 0) {\n+      name = \"volume-\" + RandomStringUtils.randomNumeric(numDigit);\n+      // Check volume existence.\n+      Iterator<? extends OzoneVolume> iter =\n+          objectStore.listVolumesByUser(null, name, null);\n+      if (iter.hasNext()) {\n+        // If there is a match, try again.\n+        // Note that volume name prefix match doesn't equal volume existence\n+        //  but the check is sufficient for this test.\n+        name = null;\n+      }\n+    }\n+    if (retriesLeft <= 0) {\n+      throw new Exception(\n+          \"Failed to generate random volume name that doesn't exist already.\");\n+    }\n+    return name;\n+  }\n+\n+  /**\n+   * OFS: Test mkdir on volume, bucket and dir that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirOnNonExistentVolumeBucketDir() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path root = new Path(\"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // Check volume and bucket existence, they should both be created.\n+    OzoneVolume ozoneVolume = objectStore.getVolume(volumeNameLocal);\n+    OzoneBucket ozoneBucket = ozoneVolume.getBucket(bucketNameLocal);\n+    OFSPath ofsPathDir1 = new OFSPath(dir12);\n+    String key = ofsPathDir1.getKeyName() + \"/\";\n+    OzoneKeyDetails ozoneKeyDetails = ozoneBucket.getKey(key);\n+    assertEquals(key, ozoneKeyDetails.getName());\n+\n+    // Verify that directories are created.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir1.toString());\n+    assertEquals(fileStatuses[1].getPath().toUri().getPath(), dir2.toString());\n+\n+    fileStatuses = ofs.listStatus(dir1);\n+    assertEquals(fileStatuses[0].getPath().toUri().getPath(), dir12.toString());\n+    fileStatuses = ofs.listStatus(dir12);\n+    assertEquals(fileStatuses.length, 0);\n+    fileStatuses = ofs.listStatus(dir2);\n+    assertEquals(fileStatuses.length, 0);\n+  }\n+\n+  /**\n+   * OFS: Tests mkdir on a volume and bucket that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirNonExistentVolumeBucket() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    String bucketNameLocal = \"bucket-\" + RandomStringUtils.randomNumeric(5);\n+    Path newVolBucket = new Path(\n+        \"/\" + volumeNameLocal + \"/\" + bucketNameLocal);\n+    fs.mkdirs(newVolBucket);\n+\n+    // Verify with listVolumes and listBuckets\n+    Iterator<? extends OzoneVolume> iterVol =\n+        objectStore.listVolumesByUser(null, volumeNameLocal, null);\n+    OzoneVolume ozoneVolume = iterVol.next();\n+    assertNotNull(ozoneVolume);\n+    assertEquals(volumeNameLocal, ozoneVolume.getName());\n+\n+    Iterator<? extends OzoneBucket> iterBuc =\n+        ozoneVolume.listBuckets(\"bucket-\");\n+    OzoneBucket ozoneBucket = iterBuc.next();\n+    assertNotNull(ozoneBucket);\n+    assertEquals(bucketNameLocal, ozoneBucket.getName());\n+\n+    // TODO: Use listStatus to check volume and bucket creation in HDDS-2928.\n+  }\n+\n+  /**\n+   * OFS: Tests mkdir on a volume that doesn't exist.\n+   */\n+  @Test\n+  public void testMkdirNonExistentVolume() throws Exception {\n+    String volumeNameLocal = getRandomNonExistVolumeName();\n+    Path newVolume = new Path(\"/\" + volumeNameLocal);\n+    fs.mkdirs(newVolume);\n+\n+    // Verify with listVolumes and listBuckets\n+    Iterator<? extends OzoneVolume> iterVol =\n+        objectStore.listVolumesByUser(null, volumeNameLocal, null);\n+    OzoneVolume ozoneVolume = iterVol.next();\n+    assertNotNull(ozoneVolume);\n+    assertEquals(volumeNameLocal, ozoneVolume.getName());\n+\n+    // TODO: Use listStatus to check volume and bucket creation in HDDS-2928.\n+  }\n+\n+  /**\n+   * Tests listStatus operation in a bucket.\n+   */\n+  @Test\n+  public void testListStatusOnRoot() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Path dir1 = new Path(root, \"dir1\");\n+    Path dir12 = new Path(dir1, \"dir12\");\n+    Path dir2 = new Path(root, \"dir2\");\n+    fs.mkdirs(dir12);\n+    fs.mkdirs(dir2);\n+\n+    // ListStatus on root should return dir1 (even though /dir1 key does not\n+    // exist) and dir2 only. dir12 is not an immediate child of root and\n+    // hence should not be listed.\n+    FileStatus[] fileStatuses = ofs.listStatus(root);\n+    assertEquals(\"FileStatus should return only the immediate children\", 2,\n+        fileStatuses.length);\n+\n+    // Verify that dir12 is not included in the result of the listStatus on root\n+    String fileStatus1 = fileStatuses[0].getPath().toUri().getPath();\n+    String fileStatus2 = fileStatuses[1].getPath().toUri().getPath();\n+    assertFalse(fileStatus1.equals(dir12.toString()));\n+    assertFalse(fileStatus2.equals(dir12.toString()));\n+  }\n+\n+  /**\n+   * Tests listStatus operation on root directory.\n+   */\n+  @Test\n+  public void testListStatusOnLargeDirectory() throws Exception {\n+    Path root = new Path(\"/\" + volumeName + \"/\" + bucketName);\n+    Set<String> paths = new TreeSet<>();\n+    int numDirs = 5111;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEyMDQyNg=="}, "originalCommit": {"oid": "780ebaf5b5279e921a9eed5a43db34027c9b1aa4"}, "originalPosition": 360}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 83, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}