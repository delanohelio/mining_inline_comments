{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNzkxMzk0", "number": 1705, "title": "HDDS-4569. Add pre append gate and marker file to OM prepare state.", "bodyText": "What changes were proposed in this pull request?\nAdd a gate to the pre append step of OzoneManagerStateMachine and submit request of OzoneManagerRatisServer to block further write requests from coming in when an ozone manager is prepared. Also add a marker file that is written when the OM is prepared so that if it is restarted without a special flag, it automatically enters prepare mode.\nThis pull request updates the Ratis snapshot to the latest version which includes the necessary RATIS-1216 fix, and addresses backwards incompatible changes made as a result of the update. The following 12 files were updated as a result of this Ratis change only; their changes are not related to the prepare gate or marker file:\n\nContainerStateMachine\nXceiverServerRatis\nContainerTestHelper\nTestHelper\nTestHadoopTreeDirGenerator\nTestHadoopNestedTreeDirGenerator\nTestOzoneClientKeyGenerator\nTestOMRatisSnapshots\nOMTransactionInfo\nOMRatisSnapshotInfo\nTestOzonemanagerRatisServer\npom.xml\n\nWhat is the link to the Apache JIRA\nHDDS-4569\nHow was this patch tested?\nUnit and integration tests added.\nNotes\nThere are a few outstanding issues related to prepare, including HDDS-4610 and RATIS-1241 that are causing flakiness in the prepare integration tests. It may not be possible to get a clean CI run on this feature without these fixes.", "createdAt": "2020-12-15T23:53:52Z", "url": "https://github.com/apache/ozone/pull/1705", "merged": true, "mergeCommit": {"oid": "17a126da1775d45f8843b47985bb5deb0ea3e928"}, "closed": true, "closedAt": "2021-01-04T19:22:54Z", "author": {"login": "errose28"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkmdMFgH2gAyNTQwNzkxMzk0OjJmNjk3ODExN2M3MDJmMGJlMjdlMTkyYTE4ZTBlODI2MTc2ZDJkYjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABds7Y0wgFqTU2MTI3ODcwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2f6978117c702f0be27e192a18e0e826176d2db8", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/2f6978117c702f0be27e192a18e0e826176d2db8", "committedDate": "2020-12-09T22:26:47Z", "message": "Add first draft of blocking write transactions in OM prepare mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddb8ccd82bb1152e70b63e7c4d976ed2834c7861", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/ddb8ccd82bb1152e70b63e7c4d976ed2834c7861", "committedDate": "2020-12-09T22:26:47Z", "message": "Move prepare state to external class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28db622cba916f41b331304a6262aa76e53fcf4a", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/28db622cba916f41b331304a6262aa76e53fcf4a", "committedDate": "2020-12-09T22:26:47Z", "message": "Create prepare marker file in prepare request"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38190e08faf906b74cfbb49e6dad8318bf7f2ad9", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/38190e08faf906b74cfbb49e6dad8318bf7f2ad9", "committedDate": "2020-12-09T22:26:47Z", "message": "Move prepare marker file operations to the OzoneManagerPrepareState class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e280b81807a1545716b0d12d115f00919fcc15de", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/e280b81807a1545716b0d12d115f00919fcc15de", "committedDate": "2020-12-10T20:31:43Z", "message": "Add exception handling to turn off leader step down on prepare reject\n\nRequires RATIS-1216"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9723427d65241bc6f0623b7c651f3090f590bcd", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/b9723427d65241bc6f0623b7c651f3090f590bcd", "committedDate": "2020-12-10T20:32:38Z", "message": "Turn off failover for write failure while in prepare and add simple test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "348302683a1dcd5ca3e272d477680290a4af20b3", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/348302683a1dcd5ca3e272d477680290a4af20b3", "committedDate": "2020-12-10T21:57:18Z", "message": "Update ratis to use tip of ratis master + RATIS-1216"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f4156a27db09e08d72f0d0adbdb89ec69301e7c", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/4f4156a27db09e08d72f0d0adbdb89ec69301e7c", "committedDate": "2020-12-11T23:02:28Z", "message": "Updates for initial integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69df22c169d08bd4bab53e82ea8a84c9d2b50320", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/69df22c169d08bd4bab53e82ea8a84c9d2b50320", "committedDate": "2020-12-14T20:51:54Z", "message": "More refactoring of integration tests\n\nThe tests still do not pass consistently. Doing the test with transactions\nsometimes times out, and the test with restarts sometimes segfaults RocksDB."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "558632706afd277106666303241792d68dadb804", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/558632706afd277106666303241792d68dadb804", "committedDate": "2020-12-14T21:26:18Z", "message": "Create marker file in 'current' subdirectory of om metadata dir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6592dde817da8af59ef10edaa1186b5f13956217", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/6592dde817da8af59ef10edaa1186b5f13956217", "committedDate": "2020-12-14T21:54:41Z", "message": "Clean up error responses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "387f7b6eb5222345c9ce04eef4b8536eb52abe27", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/387f7b6eb5222345c9ce04eef4b8536eb52abe27", "committedDate": "2020-12-14T21:56:33Z", "message": "Remoce forUpgrade flag in ozone manager ctor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65cb97b867bfa417b39a480eff9eadd0fd8aed77", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/65cb97b867bfa417b39a480eff9eadd0fd8aed77", "committedDate": "2020-12-14T22:57:43Z", "message": "Fix errors in error status code and marker file creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cebbb36a0d6f2e073f8e54eedea123d3f26b0f2b", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/cebbb36a0d6f2e073f8e54eedea123d3f26b0f2b", "committedDate": "2020-12-15T15:50:20Z", "message": "Remove incorrect raft log index check\n\nThis check is also removed by HDDS-4564, which will probably be merged first."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "658b27a5cf80d44e541b150013bc3d59c82067bb", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/658b27a5cf80d44e541b150013bc3d59c82067bb", "committedDate": "2020-12-15T15:51:08Z", "message": "Add concurrent request test for prepare\n\nSeems to pass consistently."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34c19c60eb01e0d86d0d141b1b094b95af29b1e2", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/34c19c60eb01e0d86d0d141b1b094b95af29b1e2", "committedDate": "2020-12-15T17:07:05Z", "message": "Add unit tests for prepare state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85cace143377284d203b8462ac4e4d54a68ad015", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/85cace143377284d203b8462ac4e4d54a68ad015", "committedDate": "2020-12-15T17:32:05Z", "message": "Rename methods and add docs for prepare state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "827168ecdcff7a1f23c39acc734906e5a0ecb209", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/827168ecdcff7a1f23c39acc734906e5a0ecb209", "committedDate": "2020-12-15T18:11:28Z", "message": "Fix rat and checkstyle failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3e674232a2158629de477dc6a3f7ea9a52d2db9", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/c3e674232a2158629de477dc6a3f7ea9a52d2db9", "committedDate": "2020-12-15T23:28:57Z", "message": "Update waiting conditions in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/e8950fa2137dc57bac8e1d91067642595308d9d2", "committedDate": "2020-12-15T23:48:44Z", "message": "Update Ratis to latest snapshot"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzI3Nzcz", "url": "https://github.com/apache/ozone/pull/1705#pullrequestreview-553727773", "createdAt": "2020-12-16T14:17:50Z", "commit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDoxNzo1MFrOIHHeAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDoyNjo0NFrOIHH5IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzMxMw==", "bodyText": "Can you closed executorService after the test.", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544333313", "createdAt": "2020-12-16T14:17:50Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/om/TestOzoneManagerPrepare.java", "diffHunk": "@@ -138,75 +112,111 @@ public void testPrepareWithTransactions() throws Exception {\n    */\n //  @Test\n   public void testPrepareDownedOM() throws Exception {\n+    setup();\n     // Index of the OM that will be shut down during this test.\n     final int shutdownOMIndex = 2;\n-\n-    MiniOzoneHAClusterImpl cluster = getCluster();\n-    OzoneClient ozClient = OzoneClientFactory.getRpcClient(getConf());\n-\n-    String volumeName = UUID.randomUUID().toString();\n-    String bucketName = UUID.randomUUID().toString();\n-    ObjectStore store = ozClient.getObjectStore();\n+    List<OzoneManager> runningOms = cluster.getOzoneManagersList();\n \n     // Create keys with all 3 OMs up.\n-    store.createVolume(volumeName);\n-    OzoneVolume volume = store.getVolume(volumeName);\n-    volume.createBucket(bucketName);\n-\n-    Set<String> writtenKeys = new HashSet<>();\n-    for (int i = 1; i <= 50; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n-\n-    // Make sure all OMs have logs from writing data, so we can check that\n-    // they are purged after prepare.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      LambdaTestUtils.await(timeoutMillis, 1000,\n-          () -> logFilesPresentInRatisPeer(om));\n-    }\n+    Set<String> writtenKeys = writeKeysAndWaitForLogs(10, runningOms);\n \n     // Shut down one OM.\n     cluster.stopOzoneManager(shutdownOMIndex);\n     OzoneManager downedOM = cluster.getOzoneManager(shutdownOMIndex);\n     Assert.assertFalse(downedOM.isRunning());\n+    Assert.assertEquals(runningOms.remove(shutdownOMIndex), downedOM);\n \n     // Write keys with the remaining OMs up.\n-    for (int i = 51; i <= 100; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n+    writtenKeys.addAll(\n+        writeKeysAndWaitForLogs(10, runningOms));\n \n-    OzoneManagerProtocol ozoneManagerClient =\n-        ozClient.getObjectStore().getClientProxy().getOzoneManagerClient();\n-    long prepareIndex = ozoneManagerClient.prepareOzoneManager(\n-        PREPARE_FLUSH_WAIT_TIMEOUT_SECONDS, PREPARE_FLUSH_INTERVAL_SECONDS);\n+    long prepareIndex = submitPrepareRequest();\n \n     // Check that the two live OMs are prepared.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      if (om != downedOM) {\n-        // Follower may still be applying transactions.\n-        waitAndCheckPrepared(om, prepareIndex);\n-      }\n-    }\n+    assertClusterPrepared(prepareIndex, runningOms);\n \n     // Restart the downed OM and wait for it to catch up.\n     // Since prepare was the last Ratis transaction, it should have all data\n     // it missed once it receives the prepare transaction.\n     cluster.restartOzoneManager(downedOM, true);\n-    LambdaTestUtils.await(timeoutMillis, 2000,\n-        () -> checkPrepared(downedOM, prepareIndex));\n+    runningOms.add(shutdownOMIndex, downedOM);\n \n     // Make sure all OMs are prepared and still have data.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      List<OmKeyInfo> readKeys = om.getMetadataManager().listKeys(volumeName,\n-          bucketName, null, keyPrefix, 100);\n+    assertClusterPrepared(prepareIndex, runningOms);\n+    assertKeysWritten(writtenKeys, runningOms);\n+  }\n+\n+  @Test\n+  public void testPrepareWithRestart() throws Exception {\n+    setup();\n+    writeKeysAndWaitForLogs(10);\n+    long prepareIndex = submitPrepareRequest();\n+    assertClusterPrepared(prepareIndex);\n+\n+    // Restart all ozone managers.\n+    cluster.restartOzoneManager();\n+\n+    // No check for cleared logs, since Ratis meta transactions may slip in\n+    // on restart.\n+    assertClusterPrepared(prepareIndex);\n+  }\n \n-      Assert.assertEquals(writtenKeys.size(), readKeys.size());\n-      for (OmKeyInfo keyInfo: readKeys) {\n-        Assert.assertTrue(writtenKeys.contains(keyInfo.getKeyName()));\n+  /**\n+   * Issues requests on ten different threads, for which one is a prepare and\n+   * the rest are create volume. We cannot be sure of the exact order that\n+   * the requests will execute, so this test checks that the cluster ends in\n+   * a prepared state, and that create volume requests either succeed, or fail\n+   * indicating the cluster was prepared before they were encountered.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testPrepareWithMultipleThreads() throws Exception {\n+    setup();\n+    final int numThreads = 10;\n+    final int prepareTaskIndex = 5;\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n+    // For the prepare task, the future will return a log index.\n+    // For the create volume tasks, 0 (dummy value) will be returned.\n+    List<Future<Long>> tasks = new ArrayList<>();\n+\n+    for (int i = 0; i < numThreads; i++) {\n+      Callable<Long> task;\n+      if (i == prepareTaskIndex) {\n+        task = this::submitPrepareRequest;\n+      } else {\n+        String volumeName = VOLUME + i;\n+        task = () -> {\n+          clientProtocol.createVolume(volumeName);\n+          return 0L;\n+        };\n+      }\n+      tasks.add(executorService.submit(task));\n+    }\n+\n+    // For each task, wait for it to complete and check its result.\n+    for (int i = 0; i < numThreads; i++) {\n+      Future<Long> future = tasks.get(i);\n+\n+      if (i == prepareTaskIndex) {\n+        assertClusterPrepared(future.get());\n+        assertRatisLogsCleared();\n+      } else {\n+        try {\n+          // If this throws an exception, it should be an OMException\n+          // indicating failure because the cluster was already prepared.\n+          // If no exception is thrown, the volume should be created.\n+          future.get();\n+          String volumeName = VOLUME + i;\n+          Assert.assertTrue(clientProtocol.listVolumes(volumeName, \"\", 1)\n+              .stream()\n+              .anyMatch((vol) -> vol.getName().equals(volumeName)));\n+        } catch (ExecutionException ex) {\n+          Throwable cause = ex.getCause();\n+          Assert.assertTrue(cause instanceof OMException);\n+          Assert.assertEquals(OMException.ResultCodes.NOT_SUPPORTED_OPERATION,\n+              ((OMException) cause).getResult());\n+        }\n       }\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNjM1OQ==", "bodyText": "Can we use a better status name for this, like OM_IN_PREPARE_MODE?", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544336359", "createdAt": "2020-12-16T14:21:45Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerRatisServer.java", "diffHunk": "@@ -128,10 +129,25 @@ private static long nextCallId() {\n    * @throws ServiceException\n    */\n   public OMResponse submitRequest(OMRequest omRequest) throws ServiceException {\n-    RaftClientRequest raftClientRequest =\n-        createWriteRaftClientRequest(omRequest);\n-    RaftClientReply raftClientReply = submitRequestToRatis(raftClientRequest);\n-    return processReply(omRequest, raftClientReply);\n+    // In prepare mode, only prepare and cancel requests are allowed to go\n+    // through.\n+    if (OzoneManagerPrepareState.requestAllowed(omRequest.getCmdType())) {\n+      RaftClientRequest raftClientRequest =\n+          createWriteRaftClientRequest(omRequest);\n+      RaftClientReply raftClientReply = submitRequestToRatis(raftClientRequest);\n+\n+      return processReply(omRequest, raftClientReply);\n+    } else {\n+      String message = \"Cannot apply write request \" +\n+          omRequest.getCmdType().name() + \" when OM is in prepare mode.\";\n+      OMResponse.Builder omResponse = OMResponse.newBuilder()\n+          .setMessage(message)\n+          .setStatus(OzoneManagerProtocolProtos.Status.NOT_SUPPORTED_OPERATION)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzODk0Nw==", "bodyText": "Can you add @OverRide here, so we could directly know this is an override method.", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544338947", "createdAt": "2020-12-16T14:25:04Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerStateMachine.java", "diffHunk": "@@ -193,6 +196,32 @@ public TransactionContext startTransaction(\n     return handleStartTransactionRequests(raftClientRequest, omRequest);\n   }\n \n+  public TransactionContext preAppendTransaction(TransactionContext trx)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDI1Nw==", "bodyText": "Not fully get this, why we remove this safe check?", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544340257", "createdAt": "2020-12-16T14:26:44Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/upgrade/OMPrepareRequest.java", "diffHunk": "@@ -184,26 +188,18 @@ private static void waitForLogIndex(long indexToWaitFor,\n \n   /**\n    * Take a snapshot of the state machine at the last index, and purge ALL logs.\n-   * @param impl RaftServerImpl instance\n+   * @param division Raft server division.\n    * @throws IOException on Error.\n    */\n-  public static long takeSnapshotAndPurgeLogs(RaftServerImpl impl)\n+  public static long takeSnapshotAndPurgeLogs(RaftServer.Division division)\n       throws IOException {\n \n-    StateMachine stateMachine = impl.getStateMachine();\n+    StateMachine stateMachine = division.getStateMachine();\n     long snapshotIndex = stateMachine.takeSnapshot();\n-    RaftLog raftLog = impl.getState().getLog();\n-    long raftLogIndex = raftLog.getLastEntryTermIndex().getIndex();\n-\n-    // Ensure that Ratis's in memory snapshot index is the same as the index\n-    // of its last log entry.\n-    if (snapshotIndex != raftLogIndex) {\n-      throw new IOException(\"Snapshot index \" + snapshotIndex + \" does not \" +\n-          \"match last log index \" + raftLogIndex);\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8938f11299ca66bd2800aa83f373225aa559de54", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/8938f11299ca66bd2800aa83f373225aa559de54", "committedDate": "2020-12-21T15:56:24Z", "message": "Merge branch 'HDDS-3698-upgrade' into HDDS-4569\n\n* HDDS-3698-upgrade:\n  HDDS-4564. Prepare client should check every OM individually for the prepared check based on Txn ID. (#1692)\n  HDDS-4178. SCM Finalize client command implementation (#1651)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1623db1559ff6dada1a6ffdb724d194be7a74376", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/1623db1559ff6dada1a6ffdb724d194be7a74376", "committedDate": "2020-12-21T23:35:32Z", "message": "Refactor prepare state to use the not started -> in progress -> completed states"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65e3ba50282d0f817e1092fcfcfca7fa23d123ae", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/65e3ba50282d0f817e1092fcfcfca7fa23d123ae", "committedDate": "2020-12-22T17:17:31Z", "message": "Make prepare state a member of OzoneManager\n\nChanging the prepare state now requires retrieving it from the ozone manager."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86bf7a564dc39ff82a3f179f677c0f37a3016f33", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/86bf7a564dc39ff82a3f179f677c0f37a3016f33", "committedDate": "2020-12-22T17:19:42Z", "message": "Fix checkstyle violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "871fd52a7e87c12fd686d08605eedfbaa05c125c", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/871fd52a7e87c12fd686d08605eedfbaa05c125c", "committedDate": "2020-12-22T17:55:31Z", "message": "Fixes based on review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f046aad1f22c4afb484f9bd552975fdc44d547f6", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/f046aad1f22c4afb484f9bd552975fdc44d547f6", "committedDate": "2020-12-22T18:40:14Z", "message": "Add specific result code for failing a request because OM is prepared"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b3f1f5490b37c1802ed5c6dcc4f0a502ebc0170", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/5b3f1f5490b37c1802ed5c6dcc4f0a502ebc0170", "committedDate": "2020-12-22T19:27:59Z", "message": "Connect prepare status request from HDDS-4564 to this feature\n\nAllow retrieving prepare state as one object for a consistent view.\nFix old test that incorrectly checked for OMException on finish prepare."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b995e38eaac982f47ba6d8e094cbb7e011c5a56", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/5b995e38eaac982f47ba6d8e094cbb7e011c5a56", "committedDate": "2020-12-22T20:46:03Z", "message": "Minor tweaks to ratis fixes to more closely follow HDDS-4617\n\nWill remove merge conflicts where the code was functionally identical.\nHDDS-4617 updates to a newer ratis snapshot, so it contains more changes than\nare present here."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c622b0f9758ddefb0c168bff83671dfd9f03427", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/5c622b0f9758ddefb0c168bff83671dfd9f03427", "committedDate": "2020-12-22T20:59:43Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "committedDate": "2020-12-22T21:56:29Z", "message": "Fix spotbugs violations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3Njc3OTgx", "url": "https://github.com/apache/ozone/pull/1705#pullrequestreview-557677981", "createdAt": "2020-12-23T07:02:39Z", "commit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNzowMjo0MFrOIKW6wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QwNzoyNTo0MVrOIKX_IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczMjE2MQ==", "bodyText": "There is an 'enablePrepareGate()' in finishPrepare. Do we need the one in Line # 180?", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547732161", "createdAt": "2020-12-23T07:02:40Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManagerPrepareState.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.server.ServerUtils;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerStateMachine;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerRatisServer;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.PrepareStatusResponse.PrepareStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+\n+/**\n+ * Controls the prepare state of the {@link OzoneManager} containing the\n+ * instance. When prepared, an ozone manager should have no Ratis logs\n+ * remaining, disallow all write requests except prepare and cancel prepare,\n+ * and have a marker file present on disk that will cause it to remain prepared\n+ * on restart.\n+ */\n+public final class OzoneManagerPrepareState {\n+  public static final long NO_PREPARE_INDEX = -1;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OzoneManagerPrepareState.class);\n+\n+  private boolean prepareGateEnabled;\n+  private long prepareIndex;\n+  private PrepareStatus status;\n+  private final ConfigurationSource conf;\n+\n+  public OzoneManagerPrepareState(ConfigurationSource conf) {\n+    prepareGateEnabled = false;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+    this.conf = conf;\n+  }\n+\n+  /**\n+   * Turns on the prepare gate flag, clears the prepare index, and moves the\n+   * prepare status to {@link PrepareStatus#PREPARE_IN_PROGRESS}.\n+   *\n+   * Turning on the prepare gate flag will enable a gate in the\n+   * {@link OzoneManagerStateMachine#preAppendTransaction} (called on leader\n+   * OM only) and {@link OzoneManagerRatisServer#submitRequest}\n+   * (called on all OMs) that block write requests from reaching the OM and\n+   * fail them with error responses to the client.\n+   */\n+  public synchronized void enablePrepareGate() {\n+    prepareGateEnabled = true;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_IN_PROGRESS;\n+  }\n+\n+  /**\n+   * Removes the prepare marker file, clears the prepare index, turns off\n+   * the prepare gate, and moves the prepare status to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED}.\n+   * This can be called from any state to clear the current prepare state.\n+   *\n+   * @throws IOException If the prepare marker file exists but cannot be\n+   * deleted.\n+   */\n+  public synchronized void cancelPrepare()\n+      throws IOException {\n+    deletePrepareMarkerFile();\n+    prepareIndex = NO_PREPARE_INDEX;\n+    prepareGateEnabled = false;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+  }\n+\n+  /**\n+   * Enables the prepare gate, writes the prepare marker file, sets the in\n+   * memory prepare index, and\n+   * moves the prepare status to {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * This can be called from any state to move the OM into prepare mode.\n+   *\n+   * @param index The log index to prepare the OM on.\n+   * @throws IOException If the marker file cannot be written.\n+   */\n+  public synchronized void finishPrepare(long index) throws IOException {\n+    finishPrepare(index, true);\n+  }\n+\n+  private void finishPrepare(long index, boolean writeFile) throws IOException {\n+    // Enabling the prepare gate is idempotent, and may have already been\n+    // performed if we are the leader.If we are a follower, we must ensure this\n+    // is run now case we become the leader.\n+    enablePrepareGate();\n+\n+    if (writeFile) {\n+      writePrepareMarkerFile(index);\n+    }\n+    prepareIndex = index;\n+    status = PrepareStatus.PREPARE_COMPLETED;\n+  }\n+\n+  /**\n+   * Uses the on disk marker file to determine the OM's prepare state.\n+   * If the marker file exists and contains an index matching {@code\n+   * expectedPrepareIndex}, the necessary steps will be taken to finish\n+   * preparation and the state will be moved to\n+   * {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * Else, the status will be moved to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} and any preparation steps will\n+   * be cancelled.\n+   *\n+   * @return The status the OM is in after this method call.\n+   * @throws IOException If the marker file cannot be read, and it cannot be\n+   * deleted as part of moving to the\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} state.\n+   */\n+  public synchronized PrepareStatus restorePrepare(long expectedPrepareIndex)\n+      throws IOException {\n+    boolean prepareIndexRead = true;\n+    long prepareMarkerIndex = NO_PREPARE_INDEX;\n+\n+    File prepareMarkerFile = getPrepareMarkerFile();\n+    if (prepareMarkerFile.exists()) {\n+      byte[] data = new byte[(int) prepareMarkerFile.length()];\n+      try(FileInputStream stream = new FileInputStream(prepareMarkerFile)) {\n+        stream.read(data);\n+      } catch (IOException e) {\n+        LOG.error(\"Failed to read prepare marker file {} while restoring OM.\",\n+            prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+\n+      try {\n+        prepareMarkerIndex = Long.parseLong(\n+            new String(data, StandardCharsets.UTF_8));\n+      } catch (NumberFormatException e) {\n+        LOG.error(\"Failed to parse log index from prepare marker file {} \" +\n+            \"while restoring OM.\", prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+    } else {\n+      // No marker file found.\n+      prepareIndexRead = false;\n+    }\n+\n+    boolean prepareRestored = false;\n+    if (prepareIndexRead) {\n+      if (prepareMarkerIndex != expectedPrepareIndex) {\n+        LOG.error(\"Failed to restore OM prepare state, because the expected \" +\n+            \"prepare index {} does not match the index {} written to the \" +\n+            \"marker file.\", expectedPrepareIndex, prepareMarkerIndex);\n+      } else {\n+        // Prepare state can only be restored if we read the expected index\n+        // from the marker file.\n+        prepareRestored = true;\n+      }\n+    }\n+\n+    if (prepareRestored) {\n+      enablePrepareGate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNTM4Mw==", "bodyText": "Can we add a unit test for this method since it has a few different execution flows?", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547735383", "createdAt": "2020-12-23T07:06:39Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerStateMachine.java", "diffHunk": "@@ -193,6 +196,32 @@ public TransactionContext startTransaction(\n     return handleStartTransactionRequests(raftClientRequest, omRequest);\n   }\n \n+  @Override\n+  public TransactionContext preAppendTransaction(TransactionContext trx)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNjk5OQ==", "bodyText": "Can we add a log line when we create & delete the marker file? It will help us with troubleshooting issues with preparation.", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547736999", "createdAt": "2020-12-23T07:08:48Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManagerPrepareState.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.server.ServerUtils;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerStateMachine;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerRatisServer;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.PrepareStatusResponse.PrepareStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+\n+/**\n+ * Controls the prepare state of the {@link OzoneManager} containing the\n+ * instance. When prepared, an ozone manager should have no Ratis logs\n+ * remaining, disallow all write requests except prepare and cancel prepare,\n+ * and have a marker file present on disk that will cause it to remain prepared\n+ * on restart.\n+ */\n+public final class OzoneManagerPrepareState {\n+  public static final long NO_PREPARE_INDEX = -1;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OzoneManagerPrepareState.class);\n+\n+  private boolean prepareGateEnabled;\n+  private long prepareIndex;\n+  private PrepareStatus status;\n+  private final ConfigurationSource conf;\n+\n+  public OzoneManagerPrepareState(ConfigurationSource conf) {\n+    prepareGateEnabled = false;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+    this.conf = conf;\n+  }\n+\n+  /**\n+   * Turns on the prepare gate flag, clears the prepare index, and moves the\n+   * prepare status to {@link PrepareStatus#PREPARE_IN_PROGRESS}.\n+   *\n+   * Turning on the prepare gate flag will enable a gate in the\n+   * {@link OzoneManagerStateMachine#preAppendTransaction} (called on leader\n+   * OM only) and {@link OzoneManagerRatisServer#submitRequest}\n+   * (called on all OMs) that block write requests from reaching the OM and\n+   * fail them with error responses to the client.\n+   */\n+  public synchronized void enablePrepareGate() {\n+    prepareGateEnabled = true;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_IN_PROGRESS;\n+  }\n+\n+  /**\n+   * Removes the prepare marker file, clears the prepare index, turns off\n+   * the prepare gate, and moves the prepare status to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED}.\n+   * This can be called from any state to clear the current prepare state.\n+   *\n+   * @throws IOException If the prepare marker file exists but cannot be\n+   * deleted.\n+   */\n+  public synchronized void cancelPrepare()\n+      throws IOException {\n+    deletePrepareMarkerFile();\n+    prepareIndex = NO_PREPARE_INDEX;\n+    prepareGateEnabled = false;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+  }\n+\n+  /**\n+   * Enables the prepare gate, writes the prepare marker file, sets the in\n+   * memory prepare index, and\n+   * moves the prepare status to {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * This can be called from any state to move the OM into prepare mode.\n+   *\n+   * @param index The log index to prepare the OM on.\n+   * @throws IOException If the marker file cannot be written.\n+   */\n+  public synchronized void finishPrepare(long index) throws IOException {\n+    finishPrepare(index, true);\n+  }\n+\n+  private void finishPrepare(long index, boolean writeFile) throws IOException {\n+    // Enabling the prepare gate is idempotent, and may have already been\n+    // performed if we are the leader.If we are a follower, we must ensure this\n+    // is run now case we become the leader.\n+    enablePrepareGate();\n+\n+    if (writeFile) {\n+      writePrepareMarkerFile(index);\n+    }\n+    prepareIndex = index;\n+    status = PrepareStatus.PREPARE_COMPLETED;\n+  }\n+\n+  /**\n+   * Uses the on disk marker file to determine the OM's prepare state.\n+   * If the marker file exists and contains an index matching {@code\n+   * expectedPrepareIndex}, the necessary steps will be taken to finish\n+   * preparation and the state will be moved to\n+   * {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * Else, the status will be moved to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} and any preparation steps will\n+   * be cancelled.\n+   *\n+   * @return The status the OM is in after this method call.\n+   * @throws IOException If the marker file cannot be read, and it cannot be\n+   * deleted as part of moving to the\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} state.\n+   */\n+  public synchronized PrepareStatus restorePrepare(long expectedPrepareIndex)\n+      throws IOException {\n+    boolean prepareIndexRead = true;\n+    long prepareMarkerIndex = NO_PREPARE_INDEX;\n+\n+    File prepareMarkerFile = getPrepareMarkerFile();\n+    if (prepareMarkerFile.exists()) {\n+      byte[] data = new byte[(int) prepareMarkerFile.length()];\n+      try(FileInputStream stream = new FileInputStream(prepareMarkerFile)) {\n+        stream.read(data);\n+      } catch (IOException e) {\n+        LOG.error(\"Failed to read prepare marker file {} while restoring OM.\",\n+            prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+\n+      try {\n+        prepareMarkerIndex = Long.parseLong(\n+            new String(data, StandardCharsets.UTF_8));\n+      } catch (NumberFormatException e) {\n+        LOG.error(\"Failed to parse log index from prepare marker file {} \" +\n+            \"while restoring OM.\", prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+    } else {\n+      // No marker file found.\n+      prepareIndexRead = false;\n+    }\n+\n+    boolean prepareRestored = false;\n+    if (prepareIndexRead) {\n+      if (prepareMarkerIndex != expectedPrepareIndex) {\n+        LOG.error(\"Failed to restore OM prepare state, because the expected \" +\n+            \"prepare index {} does not match the index {} written to the \" +\n+            \"marker file.\", expectedPrepareIndex, prepareMarkerIndex);\n+      } else {\n+        // Prepare state can only be restored if we read the expected index\n+        // from the marker file.\n+        prepareRestored = true;\n+      }\n+    }\n+\n+    if (prepareRestored) {\n+      enablePrepareGate();\n+      // Do not rewrite the marker file, since we verified it already exists.\n+      finishPrepare(prepareMarkerIndex, false);\n+    } else {\n+      // If the potentially faulty marker file cannot be deleted,\n+      // propagate the IOException.\n+      // If there is no marker file, this call sets the in memory state only.\n+      cancelPrepare();\n+    }\n+\n+    return status;\n+  }\n+\n+  /**\n+   * If the prepare gate is enabled, always returns true.\n+   * If the prepare gate is disabled, returns true only if {@code\n+   * requestType} is {@code Prepare} or {@code CancelPrepare}. Returns false\n+   * otherwise.\n+   */\n+  public synchronized boolean requestAllowed(Type requestType) {\n+    boolean requestAllowed = true;\n+\n+    if (prepareGateEnabled) {\n+      // TODO: Also return true for cancel prepare when it is implemented.\n+      requestAllowed = (requestType == Type.Prepare);\n+    }\n+\n+    return requestAllowed;\n+  }\n+\n+  /**\n+   * @return the current log index and status of preparation.\n+   * Both fields are returned together to provide a consistent view of the\n+   * state, which would not be guaranteed if they had to be retrieved through\n+   * separate getters.\n+   */\n+  public synchronized State getState() {\n+    return new State(prepareIndex, status);\n+  }\n+\n+  /**\n+   * Creates a prepare marker file inside {@code metadataDir} which contains\n+   * the log index {@code index}. If a marker file already exists, it will be\n+   * overwritten.\n+   */\n+  private void writePrepareMarkerFile(long index) throws IOException {\n+    File markerFile = getPrepareMarkerFile();\n+    File parentDir = markerFile.getParentFile();\n+    if (!parentDir.mkdirs()) {\n+      throw new IOException(\"Failed to create necessary directories in \" +\n+          \"marker file path: \" + parentDir);\n+    }\n+\n+    try(FileOutputStream stream = new FileOutputStream(markerFile)) {\n+      stream.write(Long.toString(index).getBytes(StandardCharsets.UTF_8));\n+    }\n+  }\n+\n+  private void deletePrepareMarkerFile()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc0OTY2NQ==", "bodyText": "I believe this should be NOT_SUPPORTED_OPERATION_WHEN_PREPARED.", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547749665", "createdAt": "2020-12-23T07:25:41Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/om/TestOzoneManagerPrepare.java", "diffHunk": "@@ -138,77 +112,116 @@ public void testPrepareWithTransactions() throws Exception {\n    */\n //  @Test\n   public void testPrepareDownedOM() throws Exception {\n+    setup();\n     // Index of the OM that will be shut down during this test.\n     final int shutdownOMIndex = 2;\n-\n-    MiniOzoneHAClusterImpl cluster = getCluster();\n-    OzoneClient ozClient = OzoneClientFactory.getRpcClient(getConf());\n-\n-    String volumeName = UUID.randomUUID().toString();\n-    String bucketName = UUID.randomUUID().toString();\n-    ObjectStore store = ozClient.getObjectStore();\n+    List<OzoneManager> runningOms = cluster.getOzoneManagersList();\n \n     // Create keys with all 3 OMs up.\n-    store.createVolume(volumeName);\n-    OzoneVolume volume = store.getVolume(volumeName);\n-    volume.createBucket(bucketName);\n-\n-    Set<String> writtenKeys = new HashSet<>();\n-    for (int i = 1; i <= 50; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n-\n-    // Make sure all OMs have logs from writing data, so we can check that\n-    // they are purged after prepare.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      LambdaTestUtils.await(timeoutMillis, 1000,\n-          () -> logFilesPresentInRatisPeer(om));\n-    }\n+    Set<String> writtenKeys = writeKeysAndWaitForLogs(10, runningOms);\n \n     // Shut down one OM.\n     cluster.stopOzoneManager(shutdownOMIndex);\n     OzoneManager downedOM = cluster.getOzoneManager(shutdownOMIndex);\n     Assert.assertFalse(downedOM.isRunning());\n+    Assert.assertEquals(runningOms.remove(shutdownOMIndex), downedOM);\n \n     // Write keys with the remaining OMs up.\n-    for (int i = 51; i <= 100; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n+    writtenKeys.addAll(\n+        writeKeysAndWaitForLogs(10, runningOms));\n \n-    OzoneManagerProtocol ozoneManagerClient =\n-        ozClient.getObjectStore().getClientProxy().getOzoneManagerClient();\n-    long prepareIndex = ozoneManagerClient.prepareOzoneManager(\n-        PREPARE_FLUSH_WAIT_TIMEOUT_SECONDS, PREPARE_FLUSH_INTERVAL_SECONDS);\n+    long prepareIndex = submitPrepareRequest();\n \n     // Check that the two live OMs are prepared.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      if (om != downedOM) {\n-        // Follower may still be applying transactions.\n-        waitAndCheckPrepared(om, prepareIndex);\n-      }\n-    }\n+    assertClusterPrepared(prepareIndex, runningOms);\n \n     // Restart the downed OM and wait for it to catch up.\n     // Since prepare was the last Ratis transaction, it should have all data\n     // it missed once it receives the prepare transaction.\n     cluster.restartOzoneManager(downedOM, true);\n-    LambdaTestUtils.await(timeoutMillis, 2000,\n-        () -> checkPrepared(downedOM, prepareIndex));\n+    runningOms.add(shutdownOMIndex, downedOM);\n \n     // Make sure all OMs are prepared and still have data.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      List<OmKeyInfo> readKeys = om.getMetadataManager().listKeys(volumeName,\n-          bucketName, null, keyPrefix, 100);\n+    assertClusterPrepared(prepareIndex, runningOms);\n+    assertKeysWritten(writtenKeys, runningOms);\n+  }\n+\n+  @Test\n+  public void testPrepareWithRestart() throws Exception {\n+    setup();\n+    writeKeysAndWaitForLogs(10);\n+    long prepareIndex = submitPrepareRequest();\n+    assertClusterPrepared(prepareIndex);\n+\n+    // Restart all ozone managers.\n+    cluster.restartOzoneManager();\n+\n+    // No check for cleared logs, since Ratis meta transactions may slip in\n+    // on restart.\n+    assertClusterPrepared(prepareIndex);\n+  }\n \n-      Assert.assertEquals(writtenKeys.size(), readKeys.size());\n-      for (OmKeyInfo keyInfo: readKeys) {\n-        Assert.assertTrue(writtenKeys.contains(keyInfo.getKeyName()));\n+  /**\n+   * Issues requests on ten different threads, for which one is a prepare and\n+   * the rest are create volume. We cannot be sure of the exact order that\n+   * the requests will execute, so this test checks that the cluster ends in\n+   * a prepared state, and that create volume requests either succeed, or fail\n+   * indicating the cluster was prepared before they were encountered.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testPrepareWithMultipleThreads() throws Exception {\n+    setup();\n+    final int numThreads = 10;\n+    final int prepareTaskIndex = 5;\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n+    // For the prepare task, the future will return a log index.\n+    // For the create volume tasks, 0 (dummy value) will be returned.\n+    List<Future<Long>> tasks = new ArrayList<>();\n+\n+    for (int i = 0; i < numThreads; i++) {\n+      Callable<Long> task;\n+      if (i == prepareTaskIndex) {\n+        task = this::submitPrepareRequest;\n+      } else {\n+        String volumeName = VOLUME + i;\n+        task = () -> {\n+          clientProtocol.createVolume(volumeName);\n+          return 0L;\n+        };\n       }\n+      tasks.add(executorService.submit(task));\n     }\n+\n+    // For each task, wait for it to complete and check its result.\n+    for (int i = 0; i < numThreads; i++) {\n+      Future<Long> future = tasks.get(i);\n+\n+      if (i == prepareTaskIndex) {\n+        assertClusterPrepared(future.get());\n+        assertRatisLogsCleared();\n+      } else {\n+        try {\n+          // If this throws an exception, it should be an OMException\n+          // indicating failure because the cluster was already prepared.\n+          // If no exception is thrown, the volume should be created.\n+          future.get();\n+          String volumeName = VOLUME + i;\n+          Assert.assertTrue(clientProtocol.listVolumes(volumeName, \"\", 1)\n+              .stream()\n+              .anyMatch((vol) -> vol.getName().equals(volumeName)));\n+        } catch (ExecutionException ex) {\n+          Throwable cause = ex.getCause();\n+          Assert.assertTrue(cause instanceof OMException);\n+          Assert.assertEquals(OMException.ResultCodes.NOT_SUPPORTED_OPERATION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d"}, "originalPosition": 294}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd45733ce74faadf7a38c0829e3193f8f4250522", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/bd45733ce74faadf7a38c0829e3193f8f4250522", "committedDate": "2020-12-23T15:29:29Z", "message": "Do not raise error if directories for marker file already exist"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db07867ac8e0501000ab475b2d8e797c81642480", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/db07867ac8e0501000ab475b2d8e797c81642480", "committedDate": "2020-12-23T16:06:55Z", "message": "Fix typos and add/improve log lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddb9d7e098d5d1695ba52cd66c0567f427eceff3", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/ddb9d7e098d5d1695ba52cd66c0567f427eceff3", "committedDate": "2020-12-23T17:52:24Z", "message": "Add unit test for pre append"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6cf4ca6fc06c9557a60529238dab6a310f30087", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/f6cf4ca6fc06c9557a60529238dab6a310f30087", "committedDate": "2020-12-23T18:21:52Z", "message": "Fix missed omexception result change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eb4fb23e7e51f635958dbb639401dc20fde9779", "author": {"user": {"login": "errose28", "name": "Ethan Rose"}}, "url": "https://github.com/apache/ozone/commit/0eb4fb23e7e51f635958dbb639401dc20fde9779", "committedDate": "2020-12-23T20:21:24Z", "message": "Comment out test failing due to missing features and add waits for remaining tests\n\nTest involving OM restart should pass after HDDS-4610 and RATIS-1241."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjc4NzAz", "url": "https://github.com/apache/ozone/pull/1705#pullrequestreview-561278703", "createdAt": "2021-01-04T19:21:25Z", "commit": {"oid": "0eb4fb23e7e51f635958dbb639401dc20fde9779"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2137, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}