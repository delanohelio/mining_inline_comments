{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1OTM3NDY4", "number": 1611, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMzo0M1rOE8gt6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0MjozN1rOE9XoBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODg2MDU2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDoxMzo0M1rOH4rOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDo1MjowOFrOH5txFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDU4Nw==", "bodyText": "Can we also reset SCMSafeModeManager#setInSafeMode to true? In some scenarios, we alreadt use safemode status check to reject some create type operations for new containers/pipelines.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r529190587", "createdAt": "2020-11-24T04:13:43Z", "author": {"login": "linyiqun"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {\n+    boolean containersFound = true;\n+    while (containersFound) {\n+      containersFound = false;\n+      for (DatanodeDetails datanodeDetails : scmNodeManager.getAllNodes()) {\n+        try {\n+          for (ContainerID id : scmNodeManager.getContainers(datanodeDetails)) {\n+            try {\n+              final ContainerInfo container = containerManager.getContainer(id);\n+              if (container.getState() == HddsProtos.LifeCycleState.OPEN ||\n+                  container.getState() == HddsProtos.LifeCycleState.CLOSING) {\n+                containersFound = true;\n+                if (container.getState() == HddsProtos.LifeCycleState.OPEN) {\n+                  eventQueue.fireEvent(SCMEvents.CLOSE_CONTAINER, id);\n+                }\n+              }\n+            } catch (ContainerNotFoundException cnfe) {\n+              LOG.warn(\"Container {} is not managed by ContainerManager.\",\n+                  id, cnfe);\n+              continue;\n+            }\n+          }\n+        } catch (NodeNotFoundException e) {\n+          continue;\n+        }\n+      }\n+      try {\n+        if (containersFound) {\n+          LOG.info(\"Waiting for all containers to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  private void waitForAllPipelinesToDestroy() throws IOException {\n+    boolean pipelineFound = true;\n+    while (pipelineFound) {\n+      pipelineFound = false;\n+      for (Pipeline pipeline : pipelineManager.getPipelines()) {\n+        if (pipeline.getPipelineState() != CLOSED) {\n+          pipelineFound = true;\n+          pipelineManager.finalizeAndDestroyPipeline(pipeline, false);\n+        }\n+      }\n+      try {\n+        if (pipelineFound) {\n+          LOG.info(\"Waiting for all pipelines to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  // This should be called in the context of a separate finalize upgrade thread.\n+  // This function can block indefinitely till the conditions are met to safely\n+  // finalize Upgrade.\n+\n+  public void preFinalizeUpgrade() throws IOException {\n+    /**\n+     * Ask pipeline manager to not create any new pipelines. Pipeline\n+     * creation will remain frozen until postFinalizeUpgrade().\n+     */\n+    pipelineManager.freezePipelineCreation();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzAxMg==", "bodyText": "That is another route but we will need stop SCM from coming out of safe mode until upgrade is complete. Also safe mode is good to enter when the SCM is starts. Here the SCM was already running and I just needed a way to pause pipeline creation for an upgrade window.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530107012", "createdAt": "2020-11-25T04:52:28Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {\n+    boolean containersFound = true;\n+    while (containersFound) {\n+      containersFound = false;\n+      for (DatanodeDetails datanodeDetails : scmNodeManager.getAllNodes()) {\n+        try {\n+          for (ContainerID id : scmNodeManager.getContainers(datanodeDetails)) {\n+            try {\n+              final ContainerInfo container = containerManager.getContainer(id);\n+              if (container.getState() == HddsProtos.LifeCycleState.OPEN ||\n+                  container.getState() == HddsProtos.LifeCycleState.CLOSING) {\n+                containersFound = true;\n+                if (container.getState() == HddsProtos.LifeCycleState.OPEN) {\n+                  eventQueue.fireEvent(SCMEvents.CLOSE_CONTAINER, id);\n+                }\n+              }\n+            } catch (ContainerNotFoundException cnfe) {\n+              LOG.warn(\"Container {} is not managed by ContainerManager.\",\n+                  id, cnfe);\n+              continue;\n+            }\n+          }\n+        } catch (NodeNotFoundException e) {\n+          continue;\n+        }\n+      }\n+      try {\n+        if (containersFound) {\n+          LOG.info(\"Waiting for all containers to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  private void waitForAllPipelinesToDestroy() throws IOException {\n+    boolean pipelineFound = true;\n+    while (pipelineFound) {\n+      pipelineFound = false;\n+      for (Pipeline pipeline : pipelineManager.getPipelines()) {\n+        if (pipeline.getPipelineState() != CLOSED) {\n+          pipelineFound = true;\n+          pipelineManager.finalizeAndDestroyPipeline(pipeline, false);\n+        }\n+      }\n+      try {\n+        if (pipelineFound) {\n+          LOG.info(\"Waiting for all pipelines to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  // This should be called in the context of a separate finalize upgrade thread.\n+  // This function can block indefinitely till the conditions are met to safely\n+  // finalize Upgrade.\n+\n+  public void preFinalizeUpgrade() throws IOException {\n+    /**\n+     * Ask pipeline manager to not create any new pipelines. Pipeline\n+     * creation will remain frozen until postFinalizeUpgrade().\n+     */\n+    pipelineManager.freezePipelineCreation();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDU4Nw=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4MDcyNg==", "bodyText": "Okay, makes sense to me.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530280726", "createdAt": "2020-11-25T10:52:08Z", "author": {"login": "linyiqun"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {\n+    boolean containersFound = true;\n+    while (containersFound) {\n+      containersFound = false;\n+      for (DatanodeDetails datanodeDetails : scmNodeManager.getAllNodes()) {\n+        try {\n+          for (ContainerID id : scmNodeManager.getContainers(datanodeDetails)) {\n+            try {\n+              final ContainerInfo container = containerManager.getContainer(id);\n+              if (container.getState() == HddsProtos.LifeCycleState.OPEN ||\n+                  container.getState() == HddsProtos.LifeCycleState.CLOSING) {\n+                containersFound = true;\n+                if (container.getState() == HddsProtos.LifeCycleState.OPEN) {\n+                  eventQueue.fireEvent(SCMEvents.CLOSE_CONTAINER, id);\n+                }\n+              }\n+            } catch (ContainerNotFoundException cnfe) {\n+              LOG.warn(\"Container {} is not managed by ContainerManager.\",\n+                  id, cnfe);\n+              continue;\n+            }\n+          }\n+        } catch (NodeNotFoundException e) {\n+          continue;\n+        }\n+      }\n+      try {\n+        if (containersFound) {\n+          LOG.info(\"Waiting for all containers to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  private void waitForAllPipelinesToDestroy() throws IOException {\n+    boolean pipelineFound = true;\n+    while (pipelineFound) {\n+      pipelineFound = false;\n+      for (Pipeline pipeline : pipelineManager.getPipelines()) {\n+        if (pipeline.getPipelineState() != CLOSED) {\n+          pipelineFound = true;\n+          pipelineManager.finalizeAndDestroyPipeline(pipeline, false);\n+        }\n+      }\n+      try {\n+        if (pipelineFound) {\n+          LOG.info(\"Waiting for all pipelines to close.\");\n+          Thread.sleep(5000);\n+        }\n+      } catch (InterruptedException e) {\n+        continue;\n+      }\n+    }\n+  }\n+\n+  // This should be called in the context of a separate finalize upgrade thread.\n+  // This function can block indefinitely till the conditions are met to safely\n+  // finalize Upgrade.\n+\n+  public void preFinalizeUpgrade() throws IOException {\n+    /**\n+     * Ask pipeline manager to not create any new pipelines. Pipeline\n+     * creation will remain frozen until postFinalizeUpgrade().\n+     */\n+    pipelineManager.freezePipelineCreation();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5MDU4Nw=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzU4Mzk2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/hdds/scm/exceptions/SCMException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjozMDozNFrOH5ZOdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNDo1MzowNlrOH5jLFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0NDE4Mg==", "bodyText": "I don't see any usages for this.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r529944182", "createdAt": "2020-11-24T22:30:34Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/hdds/scm/exceptions/SCMException.java", "diffHunk": "@@ -124,6 +124,7 @@ public ResultCodes getResult() {\n     FAILED_TO_ALLOCATE_ENOUGH_BLOCKS,\n     INTERNAL_ERROR,\n     FAILED_TO_INIT_PIPELINE_CHOOSE_POLICY,\n-    FAILED_TO_INIT_LEADER_CHOOSE_POLICY\n+    FAILED_TO_INIT_LEADER_CHOOSE_POLICY,\n+    FAILED_TO_FINALIZE_UPGRADE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwNzE1Nw==", "bodyText": "yes, left over code when I added UpgradeException. I will remove this.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530107157", "createdAt": "2020-11-25T04:53:06Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/hdds/scm/exceptions/SCMException.java", "diffHunk": "@@ -124,6 +124,7 @@ public ResultCodes getResult() {\n     FAILED_TO_ALLOCATE_ENOUGH_BLOCKS,\n     INTERNAL_ERROR,\n     FAILED_TO_INIT_PIPELINE_CHOOSE_POLICY,\n-    FAILED_TO_INIT_LEADER_CHOOSE_POLICY\n+    FAILED_TO_INIT_LEADER_CHOOSE_POLICY,\n+    FAILED_TO_FINALIZE_UPGRADE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0NDE4Mg=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzY0NzM2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/SCMPipelineManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo0MDowOVrOH5Z2xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNTowMDozMFrOH5jSpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NDUwMA==", "bodyText": "Do we want to throw an exception here? The background pipeline creator will keep trying to create pipelines, and the logs may be filled with exceptions. Is there a way to do this more cleaner? Maybe something like\nStop pipeline creator --> Add flag in pipeline manager to stop createPipeline (for manual pipeline creation) -> Destroy existing pipelines", "url": "https://github.com/apache/ozone/pull/1611#discussion_r529954500", "createdAt": "2020-11-24T22:40:09Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/SCMPipelineManager.java", "diffHunk": "@@ -268,6 +275,12 @@ public Pipeline createPipeline(ReplicationType type,\n     }\n     lock.writeLock().lock();\n     try {\n+      if (freezePipelineCreation.get()) {\n+        LOG.debug(\"Pipeline creation is frozen while an upgrade is in \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwOTA5Mw==", "bodyText": "OZONE_SCM_PIPELINE_CREATION_INTERVAL_DEFAULT is 2 minutes. I thought that upgrade finalization should be few minutes. Its possible that we may have few messages in the log to indicate that pipeline creation is frozen due to upgrade. But I can add a \"pause\" for pipeline creator as suggested.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530109093", "createdAt": "2020-11-25T05:00:30Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/pipeline/SCMPipelineManager.java", "diffHunk": "@@ -268,6 +275,12 @@ public Pipeline createPipeline(ReplicationType type,\n     }\n     lock.writeLock().lock();\n     try {\n+      if (freezePipelineCreation.get()) {\n+        LOG.debug(\"Pipeline creation is frozen while an upgrade is in \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NDUwMA=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzY2NTcwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo0Mjo0NVrOH5aB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMzoxNDoxOFrOH8Rlww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NzM1NQ==", "bodyText": "This may become a costly operation during finalize. If we have destroyed all pipelines, the containers are automatically closed. So, we maybe able to skip this.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r529957355", "createdAt": "2020-11-24T22:42:45Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEwOTU5MQ==", "bodyText": "Yes, but shouldnt we wait for all containers to close before we finalize the upgrade ? Because as part of closing the containers wemay excercise older layout version of the code otherwirse.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530109591", "createdAt": "2020-11-25T05:02:11Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NzM1NQ=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4NTgxNw==", "bodyText": "Agree the point that @avijayanhwx  mentioned. With the number of containers/pipeline becomes more large, this operation cal be very costly. can we just add a flag switch to avoid write type ops for container/pipelines, like freezePipelineCreation we added above.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530285817", "createdAt": "2020-11-25T11:00:10Z", "author": {"login": "linyiqun"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NzM1NQ=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk2NDgwMw==", "bodyText": "Agreed and removed the \"waitForAllContainersToClose()\" call. Leaving the function around for now just in case we need it in future.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r532964803", "createdAt": "2020-11-30T23:14:18Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1166,4 +1172,107 @@ public String getClusterId() {\n   public HDDSLayoutVersionManager getLayoutVersionManager() {\n     return scmLayoutVersionManager;\n   }\n+\n+  private void waitForAllContainersToClose() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NzM1NQ=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzcwMDIzOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo0ODoxMVrOH5aX6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTowODowNlrOH6AorA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2Mjk4NQ==", "bodyText": "What happens it this is invoked while the SCM (or OM) is being finalized? If it restarts, we may be OK with losing state, but how about the case when SCM is running & currently finalizing, and that time someone invokes finalize again?", "url": "https://github.com/apache/ozone/pull/1611#discussion_r529962985", "createdAt": "2020-11-24T22:48:11Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4OTg2OA==", "bodyText": "yes, there is a. clientId based check. But I will add additional safeguards to prevent this.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530589868", "createdAt": "2020-11-25T19:08:06Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2Mjk4NQ=="}, "originalCommit": {"oid": "4cf3297d0a3a0371b2d9091a126a42f3fcb8bd54"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzgzMDE2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/NodeStateManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozMzo0NFrOH6BXDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMDozMDozM1rOH6Hz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMTc0Mw==", "bodyText": "Nit: as we statically import HEALTHY_READONLY, we can leave out the qualification of NodeState here, as we do in forceNodesToHealthyReadOnly", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530601743", "createdAt": "2020-11-25T19:33:44Z", "author": {"login": "fapifta"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/NodeStateManager.java", "diffHunk": "@@ -289,7 +292,7 @@ private void initialiseState2EventMap() {\n    */\n   private void initializeStateMachine() {\n     stateMachine.addTransition(\n-        NodeState.HEALTHY_READONLY, NodeState.HEALTHY,\n+        NodeState.HEALTHY_READONLY, HEALTHY,\n         NodeLifeCycleEvent.LAYOUT_MATCH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNzQ1MA==", "bodyText": "yup, will change.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530707450", "createdAt": "2020-11-26T00:30:33Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/NodeStateManager.java", "diffHunk": "@@ -289,7 +292,7 @@ private void initialiseState2EventMap() {\n    */\n   private void initializeStateMachine() {\n     stateMachine.addTransition(\n-        NodeState.HEALTHY_READONLY, NodeState.HEALTHY,\n+        NodeState.HEALTHY_READONLY, HEALTHY,\n         NodeLifeCycleEvent.LAYOUT_MATCH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMTc0Mw=="}, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg1NjcwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0MjozN1rOH6BnIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMzoxODo0NFrOH8RstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTg1OA==", "bodyText": "Aren't we want to do a noop when the action is not present?", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530605858", "createdAt": "2020-11-25T19:42:37Z", "author": {"login": "fapifta"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.STARTING_FINALIZATION;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  public StatusAndMessages preFinalize(String upgradeClientID, T id)\n+      throws UpgradeException {\n+    switch (versionManager.getUpgradeState()) {\n+    case STARTING_FINALIZATION:\n+      return STARTING_MSG;\n+    case FINALIZATION_IN_PROGRESS:\n+      return FINALIZATION_IN_PROGRESS_MSG;\n+    case FINALIZATION_DONE:\n+    case ALREADY_FINALIZED:\n+      return FINALIZED_MSG;\n+    default:\n+      if (!versionManager.needsFinalization()) {\n+        throw new UpgradeException(\"Upgrade found in inconsistent state. \" +\n+            \"Upgrade state is FINALIZATION_REQUIRED while MLV has been \" +\n+            \"upgraded to SLV.\", INVALID_REQUEST);\n+      }\n+      versionManager.setUpgradeState(STARTING_FINALIZATION);\n+\n+      clientID = upgradeClientID;\n+      this.component = id;\n+      return FINALIZATION_REQUIRED_MSG;\n+    }\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)\n+      throws IOException {\n+    StatusAndMessages response = preFinalize(upgradeClientID, id);\n+    if (response.status() != FINALIZATION_REQUIRED) {\n+      return response;\n+    }\n+\n+    /**\n+     * Overriding class should schedule actual finalization logic\n+     * in a separate thread here.\n+     */\n+    return STARTING_MSG;\n+  }\n+\n+  @Override\n+  public synchronized StatusAndMessages reportStatus(\n+      String upgradeClientID, boolean takeover\n+  ) throws UpgradeException {\n+    if (takeover) {\n+      clientID = upgradeClientID;\n+    }\n+    assertClientId(upgradeClientID);\n+    List<String> returningMsgs = new ArrayList<>(msgs.size()+10);\n+    Status status = isDone ? FINALIZATION_DONE : FINALIZATION_IN_PROGRESS;\n+    while (msgs.size() > 0) {\n+      returningMsgs.add(msgs.poll());\n+    }\n+    return new StatusAndMessages(status, returningMsgs);\n+  }\n+\n+  private void assertClientId(String id) throws UpgradeException {\n+    if (!this.clientID.equals(id)) {\n+      throw new UpgradeException(\"Unknown client tries to get finalization \" +\n+          \"status.\\n The requestor is not the initiating client of the \" +\n+          \"finalization, if you want to take over, and get unsent status \" +\n+          \"messages, check -takeover option.\", INVALID_REQUEST);\n+    }\n+  }\n+\n+  protected void finalizeFeature(LayoutFeature feature, Storage config)\n+      throws UpgradeException {\n+    Optional<? extends UpgradeAction> action = feature.onFinalizeAction();\n+\n+    if (action.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNzg5Nw==", "bodyText": "why do we want to do noop ? action is not present we do not have to do anything.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530707897", "createdAt": "2020-11-26T00:32:31Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.STARTING_FINALIZATION;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  public StatusAndMessages preFinalize(String upgradeClientID, T id)\n+      throws UpgradeException {\n+    switch (versionManager.getUpgradeState()) {\n+    case STARTING_FINALIZATION:\n+      return STARTING_MSG;\n+    case FINALIZATION_IN_PROGRESS:\n+      return FINALIZATION_IN_PROGRESS_MSG;\n+    case FINALIZATION_DONE:\n+    case ALREADY_FINALIZED:\n+      return FINALIZED_MSG;\n+    default:\n+      if (!versionManager.needsFinalization()) {\n+        throw new UpgradeException(\"Upgrade found in inconsistent state. \" +\n+            \"Upgrade state is FINALIZATION_REQUIRED while MLV has been \" +\n+            \"upgraded to SLV.\", INVALID_REQUEST);\n+      }\n+      versionManager.setUpgradeState(STARTING_FINALIZATION);\n+\n+      clientID = upgradeClientID;\n+      this.component = id;\n+      return FINALIZATION_REQUIRED_MSG;\n+    }\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)\n+      throws IOException {\n+    StatusAndMessages response = preFinalize(upgradeClientID, id);\n+    if (response.status() != FINALIZATION_REQUIRED) {\n+      return response;\n+    }\n+\n+    /**\n+     * Overriding class should schedule actual finalization logic\n+     * in a separate thread here.\n+     */\n+    return STARTING_MSG;\n+  }\n+\n+  @Override\n+  public synchronized StatusAndMessages reportStatus(\n+      String upgradeClientID, boolean takeover\n+  ) throws UpgradeException {\n+    if (takeover) {\n+      clientID = upgradeClientID;\n+    }\n+    assertClientId(upgradeClientID);\n+    List<String> returningMsgs = new ArrayList<>(msgs.size()+10);\n+    Status status = isDone ? FINALIZATION_DONE : FINALIZATION_IN_PROGRESS;\n+    while (msgs.size() > 0) {\n+      returningMsgs.add(msgs.poll());\n+    }\n+    return new StatusAndMessages(status, returningMsgs);\n+  }\n+\n+  private void assertClientId(String id) throws UpgradeException {\n+    if (!this.clientID.equals(id)) {\n+      throw new UpgradeException(\"Unknown client tries to get finalization \" +\n+          \"status.\\n The requestor is not the initiating client of the \" +\n+          \"finalization, if you want to take over, and get unsent status \" +\n+          \"messages, check -takeover option.\", INVALID_REQUEST);\n+    }\n+  }\n+\n+  protected void finalizeFeature(LayoutFeature feature, Storage config)\n+      throws UpgradeException {\n+    Optional<? extends UpgradeAction> action = feature.onFinalizeAction();\n+\n+    if (action.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTg1OA=="}, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcxMzA3Nw==", "bodyText": "Sorry for this, but my wording was not correct as it seems.\nLet me put it this way:\nHere if action is present in the optional, we emit a noop message and return, I believe we want to emit a noop message and return if action.isPresent is false, so we miss a negation in the condition.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r530713077", "createdAt": "2020-11-26T00:52:55Z", "author": {"login": "fapifta"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.STARTING_FINALIZATION;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  public StatusAndMessages preFinalize(String upgradeClientID, T id)\n+      throws UpgradeException {\n+    switch (versionManager.getUpgradeState()) {\n+    case STARTING_FINALIZATION:\n+      return STARTING_MSG;\n+    case FINALIZATION_IN_PROGRESS:\n+      return FINALIZATION_IN_PROGRESS_MSG;\n+    case FINALIZATION_DONE:\n+    case ALREADY_FINALIZED:\n+      return FINALIZED_MSG;\n+    default:\n+      if (!versionManager.needsFinalization()) {\n+        throw new UpgradeException(\"Upgrade found in inconsistent state. \" +\n+            \"Upgrade state is FINALIZATION_REQUIRED while MLV has been \" +\n+            \"upgraded to SLV.\", INVALID_REQUEST);\n+      }\n+      versionManager.setUpgradeState(STARTING_FINALIZATION);\n+\n+      clientID = upgradeClientID;\n+      this.component = id;\n+      return FINALIZATION_REQUIRED_MSG;\n+    }\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)\n+      throws IOException {\n+    StatusAndMessages response = preFinalize(upgradeClientID, id);\n+    if (response.status() != FINALIZATION_REQUIRED) {\n+      return response;\n+    }\n+\n+    /**\n+     * Overriding class should schedule actual finalization logic\n+     * in a separate thread here.\n+     */\n+    return STARTING_MSG;\n+  }\n+\n+  @Override\n+  public synchronized StatusAndMessages reportStatus(\n+      String upgradeClientID, boolean takeover\n+  ) throws UpgradeException {\n+    if (takeover) {\n+      clientID = upgradeClientID;\n+    }\n+    assertClientId(upgradeClientID);\n+    List<String> returningMsgs = new ArrayList<>(msgs.size()+10);\n+    Status status = isDone ? FINALIZATION_DONE : FINALIZATION_IN_PROGRESS;\n+    while (msgs.size() > 0) {\n+      returningMsgs.add(msgs.poll());\n+    }\n+    return new StatusAndMessages(status, returningMsgs);\n+  }\n+\n+  private void assertClientId(String id) throws UpgradeException {\n+    if (!this.clientID.equals(id)) {\n+      throw new UpgradeException(\"Unknown client tries to get finalization \" +\n+          \"status.\\n The requestor is not the initiating client of the \" +\n+          \"finalization, if you want to take over, and get unsent status \" +\n+          \"messages, check -takeover option.\", INVALID_REQUEST);\n+    }\n+  }\n+\n+  protected void finalizeFeature(LayoutFeature feature, Storage config)\n+      throws UpgradeException {\n+    Optional<? extends UpgradeAction> action = feature.onFinalizeAction();\n+\n+    if (action.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTg1OA=="}, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk2NjU4MQ==", "bodyText": "yes, I see now :) , I will fix it.", "url": "https://github.com/apache/ozone/pull/1611#discussion_r532966581", "createdAt": "2020-11-30T23:18:44Z", "author": {"login": "prashantpogde"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/BasicUpgradeFinalizer.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.INVALID_REQUEST;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.LAYOUT_FEATURE_FINALIZATION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.PERSIST_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.REMOVE_UPGRADE_TO_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes.UPDATE_LAYOUT_VERSION_FAILED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_DONE;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_IN_PROGRESS;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.FINALIZATION_REQUIRED;\n+import static org.apache.hadoop.ozone.upgrade.UpgradeFinalizer.Status.STARTING_FINALIZATION;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.hadoop.ozone.common.Storage;\n+import org.apache.hadoop.ozone.upgrade.LayoutFeature.UpgradeAction;\n+import org.apache.hadoop.ozone.upgrade.UpgradeException.ResultCodes;\n+\n+/**\n+ * UpgradeFinalizer implementation for the Storage Container Manager service.\n+ */\n+@SuppressWarnings(\"checkstyle:VisibilityModifier\")\n+public class BasicUpgradeFinalizer<T, V extends AbstractLayoutVersionManager>\n+    implements UpgradeFinalizer<T> {\n+\n+  protected V versionManager;\n+  protected String clientID;\n+  protected T component;\n+\n+  private Queue<String> msgs = new ConcurrentLinkedQueue<>();\n+  protected boolean isDone = false;\n+\n+  public BasicUpgradeFinalizer(V versionManager) {\n+    this.versionManager = versionManager;\n+  }\n+\n+  public StatusAndMessages preFinalize(String upgradeClientID, T id)\n+      throws UpgradeException {\n+    switch (versionManager.getUpgradeState()) {\n+    case STARTING_FINALIZATION:\n+      return STARTING_MSG;\n+    case FINALIZATION_IN_PROGRESS:\n+      return FINALIZATION_IN_PROGRESS_MSG;\n+    case FINALIZATION_DONE:\n+    case ALREADY_FINALIZED:\n+      return FINALIZED_MSG;\n+    default:\n+      if (!versionManager.needsFinalization()) {\n+        throw new UpgradeException(\"Upgrade found in inconsistent state. \" +\n+            \"Upgrade state is FINALIZATION_REQUIRED while MLV has been \" +\n+            \"upgraded to SLV.\", INVALID_REQUEST);\n+      }\n+      versionManager.setUpgradeState(STARTING_FINALIZATION);\n+\n+      clientID = upgradeClientID;\n+      this.component = id;\n+      return FINALIZATION_REQUIRED_MSG;\n+    }\n+  }\n+\n+  /*\n+   * This method must be overriden by the component implementing the\n+   * finalization logic.\n+   */\n+  public StatusAndMessages finalize(String upgradeClientID, T id)\n+      throws IOException {\n+    StatusAndMessages response = preFinalize(upgradeClientID, id);\n+    if (response.status() != FINALIZATION_REQUIRED) {\n+      return response;\n+    }\n+\n+    /**\n+     * Overriding class should schedule actual finalization logic\n+     * in a separate thread here.\n+     */\n+    return STARTING_MSG;\n+  }\n+\n+  @Override\n+  public synchronized StatusAndMessages reportStatus(\n+      String upgradeClientID, boolean takeover\n+  ) throws UpgradeException {\n+    if (takeover) {\n+      clientID = upgradeClientID;\n+    }\n+    assertClientId(upgradeClientID);\n+    List<String> returningMsgs = new ArrayList<>(msgs.size()+10);\n+    Status status = isDone ? FINALIZATION_DONE : FINALIZATION_IN_PROGRESS;\n+    while (msgs.size() > 0) {\n+      returningMsgs.add(msgs.poll());\n+    }\n+    return new StatusAndMessages(status, returningMsgs);\n+  }\n+\n+  private void assertClientId(String id) throws UpgradeException {\n+    if (!this.clientID.equals(id)) {\n+      throw new UpgradeException(\"Unknown client tries to get finalization \" +\n+          \"status.\\n The requestor is not the initiating client of the \" +\n+          \"finalization, if you want to take over, and get unsent status \" +\n+          \"messages, check -takeover option.\", INVALID_REQUEST);\n+    }\n+  }\n+\n+  protected void finalizeFeature(LayoutFeature feature, Storage config)\n+      throws UpgradeException {\n+    Optional<? extends UpgradeAction> action = feature.onFinalizeAction();\n+\n+    if (action.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNTg1OA=="}, "originalCommit": {"oid": "62ebb3e3d8b02ea282814d47f90a9b70b03850fc"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4504, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}