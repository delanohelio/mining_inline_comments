{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODQyODM5", "number": 1670, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMDozNlrOFDFjdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0Nzo0OFrOFDGz1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzgxMDQ3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/codec/ContainerReplicaHistoryListCodec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMDozNlrOICkkLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODo1MDoxNlrOIN86zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NzE0OQ==", "bodyText": "Based on 16 bytes per container-DN combination, it comes to around 16KB for a degenerate case where a container has been in 1000 Datanodes through its lifecycle. Hence, I think we should be OK on the replica history growth over time.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539567149", "createdAt": "2020-12-09T19:00:36Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/codec/ContainerReplicaHistoryListCodec.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.ozone.recon.codec;\n+\n+import org.apache.hadoop.hdds.utils.db.Codec;\n+import org.apache.hadoop.hdds.utils.db.LongCodec;\n+import org.apache.hadoop.ozone.recon.scm.ContainerReplicaHistory;\n+import org.apache.hadoop.ozone.recon.scm.ContainerReplicaHistoryList;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Codec for ContainerReplicaHistoryList.\n+ */\n+public class ContainerReplicaHistoryListCodec\n+    implements Codec<ContainerReplicaHistoryList> {\n+\n+  // UUID takes 2 long to store. Each timestamp takes 1 long to store.\n+  static final int SIZE_PER_ENTRY = 4 * Long.BYTES;\n+  private final Codec<Long> lc = new LongCodec();\n+\n+  @Override\n+  public byte[] toPersistedFormat(ContainerReplicaHistoryList obj)\n+      throws IOException {\n+\n+    List<ContainerReplicaHistory> lst = obj.getList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwMDQ5NA==", "bodyText": "Each entry costs 32 bytes (4*8). Should be fine anyway.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r551500494", "createdAt": "2021-01-04T18:50:16Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/codec/ContainerReplicaHistoryListCodec.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.ozone.recon.codec;\n+\n+import org.apache.hadoop.hdds.utils.db.Codec;\n+import org.apache.hadoop.hdds.utils.db.LongCodec;\n+import org.apache.hadoop.ozone.recon.scm.ContainerReplicaHistory;\n+import org.apache.hadoop.ozone.recon.scm.ContainerReplicaHistoryList;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * Codec for ContainerReplicaHistoryList.\n+ */\n+public class ContainerReplicaHistoryListCodec\n+    implements Codec<ContainerReplicaHistoryList> {\n+\n+  // UUID takes 2 long to store. Each timestamp takes 1 long to store.\n+  static final int SIZE_PER_ENTRY = 4 * Long.BYTES;\n+  private final Codec<Long> lc = new LongCodec();\n+\n+  @Override\n+  public byte[] toPersistedFormat(ContainerReplicaHistoryList obj)\n+      throws IOException {\n+\n+    List<ContainerReplicaHistory> lst = obj.getList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NzE0OQ=="}, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzgyMzEzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ContainerReplicaHistory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMzoyNVrOICkreA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMzoyNVrOICkreA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTAxNg==", "bodyText": "Can we add some documentation here on on the ContainerEndpoint API class that Recon can only track first and last seen time of the container replica on a DN. It cannot track intermediate states where a replica can move out a DN and then come back in the future again to the same DN. All Recon guarantees is first and last seen time, and not the whole interval in between the 2 times.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539569016", "createdAt": "2020-12-09T19:03:25Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ContainerReplicaHistory.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.scm;\n+\n+import java.util.UUID;\n+\n+/**\n+ * A ContainerReplica timestamp class that tracks first and last seen time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzk0MjgwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTozMDo1M1rOIClxCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODo0MjoyNlrOIN8qwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NjgyNg==", "bodyText": "I don't see any usages for this method.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539586826", "createdAt": "2020-12-09T19:30:53Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "diffHunk": "@@ -171,23 +182,93 @@ public void addNewContainer(long containerId,\n \n   /**\n    * Add a container Replica for given DataNode.\n-   *\n-   * @param containerID\n-   * @param replica\n    */\n   @Override\n   public void updateContainerReplica(ContainerID containerID,\n       ContainerReplica replica)\n       throws ContainerNotFoundException {\n     super.updateContainerReplica(containerID, replica);\n-    // Update container_history table\n-    long currentTime = System.currentTimeMillis();\n-    String datanodeHost = replica.getDatanodeDetails().getHostName();\n-    containerSchemaManager.upsertContainerHistory(containerID.getId(),\n-        datanodeHost, currentTime);\n+\n+    final long currTime = System.currentTimeMillis();\n+    final long id = containerID.getId();\n+    final DatanodeDetails dnInfo = replica.getDatanodeDetails();\n+    final UUID uuid = dnInfo.getUuid();\n+\n+    // Map from DataNode UUID to replica last seen time\n+    final Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+        replicaHistoryMap.get(id);\n+\n+    boolean flushToDB = false;\n+\n+    // If replica doesn't exist in in-memory map, add to DB and add to map\n+    if (replicaLastSeenMap == null) {\n+      // putIfAbsent to avoid TOCTOU\n+      replicaHistoryMap.putIfAbsent(id,\n+          new ConcurrentHashMap<UUID, ContainerReplicaHistory>() {{\n+            put(uuid, new ContainerReplicaHistory(uuid, currTime, currTime));\n+          }});\n+      flushToDB = true;\n+    } else {\n+      // ContainerID exists, update timestamp in memory\n+      final ContainerReplicaHistory ts = replicaLastSeenMap.get(uuid);\n+      if (ts == null) {\n+        // New Datanode\n+        replicaLastSeenMap.put(uuid,\n+            new ContainerReplicaHistory(uuid, currTime, currTime));\n+        flushToDB = true;\n+      } else {\n+        // if the object exists, only update the last seen time field\n+        ts.setLastSeenTime(currTime);\n+      }\n+    }\n+\n+    if (flushToDB) {\n+      containerSchemaManager.upsertContainerHistory(id, uuid, currTime);\n+    }\n   }\n \n+  /**\n+   * Remove a Container Replica of a given DataNode.\n+   */\n+  @Override\n+  public void removeContainerReplica(ContainerID containerID,\n+      ContainerReplica replica) throws ContainerNotFoundException,\n+      ContainerReplicaNotFoundException {\n+    super.removeContainerReplica(containerID, replica);\n+\n+    final long id = containerID.getId();\n+    final DatanodeDetails dnInfo = replica.getDatanodeDetails();\n+    final UUID uuid = dnInfo.getUuid();\n+\n+    final Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+        replicaHistoryMap.get(id);\n+    if (replicaLastSeenMap != null) {\n+      final ContainerReplicaHistory ts = replicaLastSeenMap.get(uuid);\n+      if (ts != null) {\n+        // Flush to DB, then remove from in-memory map\n+        containerSchemaManager.upsertContainerHistory(id, uuid,\n+            ts.getLastSeenTime());\n+        replicaLastSeenMap.remove(uuid);\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n   public ContainerSchemaManager getContainerSchemaManager() {\n     return containerSchemaManager;\n   }\n+\n+  @VisibleForTesting\n+  public Map<Long, Map<UUID, ContainerReplicaHistory>> getReplicaHistoryMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ5NjM4NQ==", "bodyText": "It is referenced only in TestReconContainerManager#testUpdateContainerReplica", "url": "https://github.com/apache/ozone/pull/1670#discussion_r551496385", "createdAt": "2021-01-04T18:42:26Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "diffHunk": "@@ -171,23 +182,93 @@ public void addNewContainer(long containerId,\n \n   /**\n    * Add a container Replica for given DataNode.\n-   *\n-   * @param containerID\n-   * @param replica\n    */\n   @Override\n   public void updateContainerReplica(ContainerID containerID,\n       ContainerReplica replica)\n       throws ContainerNotFoundException {\n     super.updateContainerReplica(containerID, replica);\n-    // Update container_history table\n-    long currentTime = System.currentTimeMillis();\n-    String datanodeHost = replica.getDatanodeDetails().getHostName();\n-    containerSchemaManager.upsertContainerHistory(containerID.getId(),\n-        datanodeHost, currentTime);\n+\n+    final long currTime = System.currentTimeMillis();\n+    final long id = containerID.getId();\n+    final DatanodeDetails dnInfo = replica.getDatanodeDetails();\n+    final UUID uuid = dnInfo.getUuid();\n+\n+    // Map from DataNode UUID to replica last seen time\n+    final Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+        replicaHistoryMap.get(id);\n+\n+    boolean flushToDB = false;\n+\n+    // If replica doesn't exist in in-memory map, add to DB and add to map\n+    if (replicaLastSeenMap == null) {\n+      // putIfAbsent to avoid TOCTOU\n+      replicaHistoryMap.putIfAbsent(id,\n+          new ConcurrentHashMap<UUID, ContainerReplicaHistory>() {{\n+            put(uuid, new ContainerReplicaHistory(uuid, currTime, currTime));\n+          }});\n+      flushToDB = true;\n+    } else {\n+      // ContainerID exists, update timestamp in memory\n+      final ContainerReplicaHistory ts = replicaLastSeenMap.get(uuid);\n+      if (ts == null) {\n+        // New Datanode\n+        replicaLastSeenMap.put(uuid,\n+            new ContainerReplicaHistory(uuid, currTime, currTime));\n+        flushToDB = true;\n+      } else {\n+        // if the object exists, only update the last seen time field\n+        ts.setLastSeenTime(currTime);\n+      }\n+    }\n+\n+    if (flushToDB) {\n+      containerSchemaManager.upsertContainerHistory(id, uuid, currTime);\n+    }\n   }\n \n+  /**\n+   * Remove a Container Replica of a given DataNode.\n+   */\n+  @Override\n+  public void removeContainerReplica(ContainerID containerID,\n+      ContainerReplica replica) throws ContainerNotFoundException,\n+      ContainerReplicaNotFoundException {\n+    super.removeContainerReplica(containerID, replica);\n+\n+    final long id = containerID.getId();\n+    final DatanodeDetails dnInfo = replica.getDatanodeDetails();\n+    final UUID uuid = dnInfo.getUuid();\n+\n+    final Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+        replicaHistoryMap.get(id);\n+    if (replicaLastSeenMap != null) {\n+      final ContainerReplicaHistory ts = replicaLastSeenMap.get(uuid);\n+      if (ts != null) {\n+        // Flush to DB, then remove from in-memory map\n+        containerSchemaManager.upsertContainerHistory(id, uuid,\n+            ts.getLastSeenTime());\n+        replicaLastSeenMap.remove(uuid);\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n   public ContainerSchemaManager getContainerSchemaManager() {\n     return containerSchemaManager;\n   }\n+\n+  @VisibleForTesting\n+  public Map<Long, Map<UUID, ContainerReplicaHistory>> getReplicaHistoryMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NjgyNg=="}, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzk4NjgxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0MTowMVrOICmLLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoyMjozNFrOIRhyQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzUxNg==", "bodyText": "Is there any reason why we cannot maintain the ScmDB and replica history map only in this class and move the related methods (getContainerHistory, upsertContainerHistory, flushDb) from the ContainerSchemaManager to this class? The ContainerEndpoint class already has an instance of the Recon container manager. After this change, maybe we can also rename ContainerSchemaManager to ContainerHealthSchemaManager?", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539593516", "createdAt": "2020-12-09T19:41:01Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "diffHunk": "@@ -65,13 +73,16 @@\n   public ReconContainerManager(\n       ConfigurationSource conf,\n       Table<ContainerID, ContainerInfo> containerStore,\n-      BatchOperationHandler batchHandler,\n+      DBStore batchHandler,\n       PipelineManager pipelineManager,\n       StorageContainerServiceProvider scm,\n       ContainerSchemaManager containerSchemaManager) throws IOException {\n     super(conf, containerStore, batchHandler, pipelineManager);\n     this.scmClient = scm;\n     this.containerSchemaManager = containerSchemaManager;\n+    this.replicaHistoryMap = new ConcurrentHashMap<>();\n+    containerSchemaManager.setReplicaHistoryMap(replicaHistoryMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI1MDI0MQ==", "bodyText": "done!", "url": "https://github.com/apache/ozone/pull/1670#discussion_r555250241", "createdAt": "2021-01-11T18:22:34Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/scm/ReconContainerManager.java", "diffHunk": "@@ -65,13 +73,16 @@\n   public ReconContainerManager(\n       ConfigurationSource conf,\n       Table<ContainerID, ContainerInfo> containerStore,\n-      BatchOperationHandler batchHandler,\n+      DBStore batchHandler,\n       PipelineManager pipelineManager,\n       StorageContainerServiceProvider scm,\n       ContainerSchemaManager containerSchemaManager) throws IOException {\n     super(conf, containerStore, batchHandler, pipelineManager);\n     this.scmClient = scm;\n     this.containerSchemaManager = containerSchemaManager;\n+    this.replicaHistoryMap = new ConcurrentHashMap<>();\n+    containerSchemaManager.setReplicaHistoryMap(replicaHistoryMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzUxNg=="}, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODAwNDE5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/spi/impl/ContainerDBServiceProviderImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0NTowNlrOICmVNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0NTowNlrOICmVNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NjA4NA==", "bodyText": "Nit. Method name can just be getContainerReplicaHistory.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539596084", "createdAt": "2020-12-09T19:45:06Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/spi/impl/ContainerDBServiceProviderImpl.java", "diffHunk": "@@ -184,6 +214,34 @@ public long getKeyCountForContainer(Long containerID) throws IOException {\n     return keyCount == null ? 0L : keyCount;\n   }\n \n+  /**\n+   * Get the container replica history of the given containerID.\n+   *\n+   * @param containerID the given containerId.\n+   * @return A map of ContainerReplicaWithTimestamp of the given containerID.\n+   * @throws IOException\n+   */\n+  @Override\n+  public Map<UUID, ContainerReplicaHistory> getContainerReplicaHistoryMap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODAxNjIxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/persistence/ContainerSchemaManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0Nzo0OFrOICmcFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxOToyNjoyNFrOIN-DrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5Nzg0Ng==", "bodyText": "Can we support a batch interface that uses the RocksDB BatchOperation? That will help with faster flushing.", "url": "https://github.com/apache/ozone/pull/1670#discussion_r539597846", "createdAt": "2020-12-09T19:47:48Z", "author": {"login": "avijayanhwx"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/persistence/ContainerSchemaManager.java", "diffHunk": "@@ -113,40 +142,121 @@ public void insertUnhealthyContainerRecords(List<UnhealthyContainers> recs) {\n     unhealthyContainersDao.insert(recs);\n   }\n \n-  public void upsertContainerHistory(long containerID, String datanode,\n-                                     long time) {\n-    DSLContext dslContext = containerSchemaDefinition.getDSLContext();\n-    Record2<Long, String> recordToFind =\n-        dslContext.newRecord(\n-        CONTAINER_HISTORY.CONTAINER_ID,\n-        CONTAINER_HISTORY.DATANODE_HOST).value1(containerID).value2(datanode);\n-    ContainerHistory newRecord = new ContainerHistory();\n-    newRecord.setContainerId(containerID);\n-    newRecord.setDatanodeHost(datanode);\n-    newRecord.setLastReportTimestamp(time);\n-    ContainerHistory record = containerHistoryDao.findById(recordToFind);\n-    if (record != null) {\n-      newRecord.setFirstReportTimestamp(record.getFirstReportTimestamp());\n-      containerHistoryDao.update(newRecord);\n-    } else {\n-      newRecord.setFirstReportTimestamp(time);\n-      containerHistoryDao.insert(newRecord);\n+  public void upsertContainerHistory(long containerID, UUID uuid, long time) {\n+    Map<UUID, ContainerReplicaHistory> tsMap;\n+    try {\n+      tsMap = dbServiceProvider.getContainerReplicaHistoryMap(containerID);\n+      ContainerReplicaHistory ts = tsMap.get(uuid);\n+      if (ts == null) {\n+        // New entry\n+        tsMap.put(uuid, new ContainerReplicaHistory(uuid, time, time));\n+      } else {\n+        // Entry exists, update last seen time and put it back to DB.\n+        ts.setLastSeenTime(time);\n+      }\n+      dbServiceProvider.storeContainerReplicaHistoryMap(containerID, tsMap);\n+    } catch (IOException e) {\n+      LOG.debug(\"Error on DB operations. {}\", e.getMessage());\n     }\n   }\n \n   public List<ContainerHistory> getAllContainerHistory(long containerID) {\n-    return containerHistoryDao.fetchByContainerId(containerID);\n+    // First, get the existing entries from DB\n+    Map<UUID, ContainerReplicaHistory> resMap;\n+    try {\n+      resMap = dbServiceProvider.getContainerReplicaHistoryMap(containerID);\n+    } catch (IOException ex) {\n+      resMap = new HashMap<>();\n+      LOG.debug(\"Unable to retrieve container replica history from RDB.\");\n+    }\n+\n+    // Then, update the entries with the latest in-memory info, if available\n+    if (replicaHistoryMap != null) {\n+      Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+          replicaHistoryMap.get(containerID);\n+      if (replicaLastSeenMap != null) {\n+        Map<UUID, ContainerReplicaHistory> finalResMap = resMap;\n+        replicaLastSeenMap.forEach((k, v) ->\n+            finalResMap.merge(k, v, (old, latest) -> latest));\n+        resMap = finalResMap;\n+      }\n+    }\n+\n+    // Finally, convert map to list for output\n+    List<ContainerHistory> resList = new ArrayList<>();\n+    for (Map.Entry<UUID, ContainerReplicaHistory> entry : resMap.entrySet()) {\n+      final UUID uuid = entry.getKey();\n+      String hostname = \"N/A\";\n+      // Attempt to retrieve hostname from NODES table\n+      if (nodeDB != null) {\n+        try {\n+          DatanodeDetails dnDetails = nodeDB.get(uuid);\n+          if (dnDetails != null) {\n+            hostname = dnDetails.getHostName();\n+          }\n+        } catch (IOException ex) {\n+          LOG.debug(\"Unable to retrieve from NODES table of node {}. {}\",\n+              uuid, ex.getMessage());\n+        }\n+      }\n+      final long firstSeenTime = entry.getValue().getFirstSeenTime();\n+      final long lastSeenTime = entry.getValue().getLastSeenTime();\n+      resList.add(new ContainerHistory(containerID, uuid.toString(), hostname,\n+          firstSeenTime, lastSeenTime));\n+    }\n+    return resList;\n   }\n \n   public List<ContainerHistory> getLatestContainerHistory(long containerID,\n                                                           int limit) {\n-    DSLContext dslContext = containerSchemaDefinition.getDSLContext();\n-    // Get container history sorted in descending order of last report timestamp\n-    return dslContext.select()\n-        .from(CONTAINER_HISTORY)\n-        .where(CONTAINER_HISTORY.CONTAINER_ID.eq(containerID))\n-        .orderBy(CONTAINER_HISTORY.LAST_REPORT_TIMESTAMP.desc())\n-        .limit(limit)\n-        .fetchInto(ContainerHistory.class);\n+    List<ContainerHistory> res = getAllContainerHistory(containerID);\n+    res.sort(comparingLong(ContainerHistory::getLastSeenTime).reversed());\n+    return res.stream().limit(limit).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Should only be called once during ReconContainerManager init.\n+   */\n+  public void setReplicaHistoryMap(\n+      Map<Long, Map<UUID, ContainerReplicaHistory>> replicaHistoryMap) {\n+    this.replicaHistoryMap = replicaHistoryMap;\n+  }\n+\n+  /**\n+   * Should only be called once during ReconContainerManager init.\n+   */\n+  public void setScmDBStore(DBStore scmDBStore) {\n+    this.scmDBStore = scmDBStore;\n+    try {\n+      this.nodeDB = ReconSCMDBDefinition.NODES.getTable(scmDBStore);\n+    } catch (IOException ex) {\n+      LOG.debug(\"Failed to get NODES table. {}\", ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Flush the container replica history in-memory map to DB.\n+   * @param clearMap true to clear the in-memory map after flushing completes.\n+   */\n+  public void flushReplicaHistoryMapToDB(boolean clearMap) {\n+    if (replicaHistoryMap == null) {\n+      return;\n+    }\n+    synchronized (replicaHistoryMap) {\n+      try {\n+        for (Map.Entry<Long, Map<UUID, ContainerReplicaHistory>> entry :\n+            replicaHistoryMap.entrySet()) {\n+          final long containerId = entry.getKey();\n+          final Map<UUID, ContainerReplicaHistory> map = entry.getValue();\n+          dbServiceProvider.storeContainerReplicaHistoryMap(containerId, map);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxOTE0OQ==", "bodyText": "Good idea. I'll try", "url": "https://github.com/apache/ozone/pull/1670#discussion_r551519149", "createdAt": "2021-01-04T19:26:24Z", "author": {"login": "smengcl"}, "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/persistence/ContainerSchemaManager.java", "diffHunk": "@@ -113,40 +142,121 @@ public void insertUnhealthyContainerRecords(List<UnhealthyContainers> recs) {\n     unhealthyContainersDao.insert(recs);\n   }\n \n-  public void upsertContainerHistory(long containerID, String datanode,\n-                                     long time) {\n-    DSLContext dslContext = containerSchemaDefinition.getDSLContext();\n-    Record2<Long, String> recordToFind =\n-        dslContext.newRecord(\n-        CONTAINER_HISTORY.CONTAINER_ID,\n-        CONTAINER_HISTORY.DATANODE_HOST).value1(containerID).value2(datanode);\n-    ContainerHistory newRecord = new ContainerHistory();\n-    newRecord.setContainerId(containerID);\n-    newRecord.setDatanodeHost(datanode);\n-    newRecord.setLastReportTimestamp(time);\n-    ContainerHistory record = containerHistoryDao.findById(recordToFind);\n-    if (record != null) {\n-      newRecord.setFirstReportTimestamp(record.getFirstReportTimestamp());\n-      containerHistoryDao.update(newRecord);\n-    } else {\n-      newRecord.setFirstReportTimestamp(time);\n-      containerHistoryDao.insert(newRecord);\n+  public void upsertContainerHistory(long containerID, UUID uuid, long time) {\n+    Map<UUID, ContainerReplicaHistory> tsMap;\n+    try {\n+      tsMap = dbServiceProvider.getContainerReplicaHistoryMap(containerID);\n+      ContainerReplicaHistory ts = tsMap.get(uuid);\n+      if (ts == null) {\n+        // New entry\n+        tsMap.put(uuid, new ContainerReplicaHistory(uuid, time, time));\n+      } else {\n+        // Entry exists, update last seen time and put it back to DB.\n+        ts.setLastSeenTime(time);\n+      }\n+      dbServiceProvider.storeContainerReplicaHistoryMap(containerID, tsMap);\n+    } catch (IOException e) {\n+      LOG.debug(\"Error on DB operations. {}\", e.getMessage());\n     }\n   }\n \n   public List<ContainerHistory> getAllContainerHistory(long containerID) {\n-    return containerHistoryDao.fetchByContainerId(containerID);\n+    // First, get the existing entries from DB\n+    Map<UUID, ContainerReplicaHistory> resMap;\n+    try {\n+      resMap = dbServiceProvider.getContainerReplicaHistoryMap(containerID);\n+    } catch (IOException ex) {\n+      resMap = new HashMap<>();\n+      LOG.debug(\"Unable to retrieve container replica history from RDB.\");\n+    }\n+\n+    // Then, update the entries with the latest in-memory info, if available\n+    if (replicaHistoryMap != null) {\n+      Map<UUID, ContainerReplicaHistory> replicaLastSeenMap =\n+          replicaHistoryMap.get(containerID);\n+      if (replicaLastSeenMap != null) {\n+        Map<UUID, ContainerReplicaHistory> finalResMap = resMap;\n+        replicaLastSeenMap.forEach((k, v) ->\n+            finalResMap.merge(k, v, (old, latest) -> latest));\n+        resMap = finalResMap;\n+      }\n+    }\n+\n+    // Finally, convert map to list for output\n+    List<ContainerHistory> resList = new ArrayList<>();\n+    for (Map.Entry<UUID, ContainerReplicaHistory> entry : resMap.entrySet()) {\n+      final UUID uuid = entry.getKey();\n+      String hostname = \"N/A\";\n+      // Attempt to retrieve hostname from NODES table\n+      if (nodeDB != null) {\n+        try {\n+          DatanodeDetails dnDetails = nodeDB.get(uuid);\n+          if (dnDetails != null) {\n+            hostname = dnDetails.getHostName();\n+          }\n+        } catch (IOException ex) {\n+          LOG.debug(\"Unable to retrieve from NODES table of node {}. {}\",\n+              uuid, ex.getMessage());\n+        }\n+      }\n+      final long firstSeenTime = entry.getValue().getFirstSeenTime();\n+      final long lastSeenTime = entry.getValue().getLastSeenTime();\n+      resList.add(new ContainerHistory(containerID, uuid.toString(), hostname,\n+          firstSeenTime, lastSeenTime));\n+    }\n+    return resList;\n   }\n \n   public List<ContainerHistory> getLatestContainerHistory(long containerID,\n                                                           int limit) {\n-    DSLContext dslContext = containerSchemaDefinition.getDSLContext();\n-    // Get container history sorted in descending order of last report timestamp\n-    return dslContext.select()\n-        .from(CONTAINER_HISTORY)\n-        .where(CONTAINER_HISTORY.CONTAINER_ID.eq(containerID))\n-        .orderBy(CONTAINER_HISTORY.LAST_REPORT_TIMESTAMP.desc())\n-        .limit(limit)\n-        .fetchInto(ContainerHistory.class);\n+    List<ContainerHistory> res = getAllContainerHistory(containerID);\n+    res.sort(comparingLong(ContainerHistory::getLastSeenTime).reversed());\n+    return res.stream().limit(limit).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Should only be called once during ReconContainerManager init.\n+   */\n+  public void setReplicaHistoryMap(\n+      Map<Long, Map<UUID, ContainerReplicaHistory>> replicaHistoryMap) {\n+    this.replicaHistoryMap = replicaHistoryMap;\n+  }\n+\n+  /**\n+   * Should only be called once during ReconContainerManager init.\n+   */\n+  public void setScmDBStore(DBStore scmDBStore) {\n+    this.scmDBStore = scmDBStore;\n+    try {\n+      this.nodeDB = ReconSCMDBDefinition.NODES.getTable(scmDBStore);\n+    } catch (IOException ex) {\n+      LOG.debug(\"Failed to get NODES table. {}\", ex.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Flush the container replica history in-memory map to DB.\n+   * @param clearMap true to clear the in-memory map after flushing completes.\n+   */\n+  public void flushReplicaHistoryMapToDB(boolean clearMap) {\n+    if (replicaHistoryMap == null) {\n+      return;\n+    }\n+    synchronized (replicaHistoryMap) {\n+      try {\n+        for (Map.Entry<Long, Map<UUID, ContainerReplicaHistory>> entry :\n+            replicaHistoryMap.entrySet()) {\n+          final long containerId = entry.getKey();\n+          final Map<UUID, ContainerReplicaHistory> map = entry.getValue();\n+          dbServiceProvider.storeContainerReplicaHistoryMap(containerId, map);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5Nzg0Ng=="}, "originalCommit": {"oid": "2479d124e92509621e49e2a224f98f7a942d0f1a"}, "originalPosition": 220}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4581, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}