{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjczMDI3", "number": 1195, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNTo0NTo1OVrOENj_6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNjoxODoxNVrOENkIuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNjU2NzQ3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNTo0NTo1OVrOGwReQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNTo0NTo1OVrOGwReQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI3MTEwNA==", "bodyText": "More arguments (not counting exception) than placeholders:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +\n          \n          \n            \n                            \"UnDeletedKeys:{}\", volumeName, bucketName, keyName,\n          \n          \n            \n                        auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),\n          \n          \n            \n                    LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKeys:{}, \" +\n          \n          \n            \n                            \"UnDeletedKeys:{}\", volumeName, bucketName,\n          \n          \n            \n                        auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),", "url": "https://github.com/apache/ozone/pull/1195#discussion_r453271104", "createdAt": "2020-07-12T05:45:59Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -116,99 +98,144 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n         getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n-    try {\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-            keyName);\n-        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-        omKeyInfoList.add(omKeyInfo);\n-        unDeletedKeys.add(omKeyInfo);\n-      }\n \n-      // Check if any of the key in the batch cannot be deleted. If exists the\n-      // batch will delete failed.\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n \n-        String objectKey = omMetadataManager.getOzoneKey(\n-            volumeName, bucketName, keyName);\n+    boolean acquiredLock =\n+        omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+\n+    int indexFailed = 0;\n+    int length = deleteKeys.size();\n+    OzoneManagerProtocolProtos.DeleteKeyArgs.Builder unDeletedKeys =\n+        OzoneManagerProtocolProtos.DeleteKeyArgs.newBuilder()\n+            .setVolumeName(volumeName).setBucketName(bucketName);\n+\n+    boolean deleteStatus = true;\n+    try {\n \n-        // Validate bucket and volume exists or not.\n-        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n+      for (indexFailed = 0; indexFailed < length; indexFailed++) {\n+        keyName = deleteKeyArgs.getKeys(indexFailed);\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            keyName);\n         OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n \n         if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found: \" + keyName, KEY_NOT_FOUND);\n+          deleteStatus = false;\n+          LOG.error(\"Received a request to delete a Key does not exist {}\",\n+              objectKey);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n+          continue;\n         }\n \n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n+        try {\n+          // check Acl\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          omKeyInfoList.add(omKeyInfo);\n+        } catch (Exception ex) {\n+          deleteStatus = false;\n+          LOG.error(\"Acl check failed for Key: {}\", objectKey, ex);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n         }\n       }\n \n+      // Mark all keys which can be deleted, in cache as deleted.\n+      for (OmKeyInfo omKeyInfo : omKeyInfoList) {\n+        omMetadataManager.getKeyTable().addCacheEntry(\n+            new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+                omKeyInfo.getKeyName())),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+      }\n+\n       omClientResponse = new OMKeysDeleteResponse(omResponse\n-          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()).build(),\n-          omKeyInfoList, trxnLogIndex, ozoneManager.isRatisEnabled());\n+          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+              .setStatus(deleteStatus).setUnDeletedKeys(unDeletedKeys))\n+          .setStatus(deleteStatus ? OK : PARTIAL_DELETE)\n+          .setSuccess(deleteStatus).build(),\n+          omKeyInfoList, trxnLogIndex,\n+          ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n+\n     } catch (IOException ex) {\n-      if (ex instanceof OMReplayException) {\n-        result = Result.REPLAY;\n-        omClientResponse = new OMKeyDeleteResponse(createReplayOMResponse(\n-            omResponse));\n-      } else {\n-        result = Result.FAILURE;\n-        exception = ex;\n-\n-        omClientResponse = new OMKeyDeleteResponse(\n-            createOperationKeysErrorOMResponse(omResponse, exception,\n-                unDeletedKeys));\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      // reset deleteKeys as request failed.\n+      deleteKeys = new ArrayList<>();\n+      // Add all keys which are failed due to any other exception .\n+      for (int i = indexFailed; i < length; i++) {\n+        unDeletedKeys.addKeys(deleteKeyArgs.getKeys(i));\n       }\n \n+      omResponse.setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+          .setStatus(false).setUnDeletedKeys(unDeletedKeys).build()).build();\n+      omClientResponse = new OMKeysDeleteResponse(omResponse.build());\n+\n     } finally {\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n       addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n           omDoubleBufferHelper);\n     }\n \n-    // Performing audit logging outside of the lock.\n-    if (result != Result.REPLAY) {\n-      auditLog(auditLogger, buildAuditMessage(\n-          OMAction.DELETE_KEY, auditMap, exception, userInfo));\n-    }\n+    auditMap = buildDeleteKeysAuditMap(volumeName, bucketName, deleteKeys,\n+        unDeletedKeys.getKeysList());\n+\n+    auditLog(auditLogger, buildAuditMessage(DELETE_KEYS, auditMap, exception,\n+        userInfo));\n+\n \n     switch (result) {\n     case SUCCESS:\n-      omMetrics.decNumKeys();\n-      LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyName);\n-      break;\n-    case REPLAY:\n-      LOG.debug(\"Replayed Transaction {} ignored. Request: {}\",\n-          trxnLogIndex, deleteKeyRequest);\n+      omMetrics.decNumKeys(deleteKeys.size());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Keys delete success. Volume:{}, Bucket:{}, Keys:{}\",\n+            volumeName, bucketName, auditMap.get(DELETED_KEYS_LIST));\n+      }\n       break;\n     case FAILURE:\n+      omMetrics.decNumKeys(deleteKeys.size());\n       omMetrics.incNumKeyDeleteFails();\n-      LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}.\" +\n-          \" Exception:{}\", volumeName, bucketName, keyName, exception);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +\n+                \"UnDeletedKeys:{}\", volumeName, bucketName, keyName,\n+            auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b46762e9cbf2a319ee95ac6d9f0fb50c9311ecff"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNjU5MDAzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNjoxODoxNVrOGwRooA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMlQwNjoxODoxNVrOGwRooA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI3Mzc2MA==", "bodyText": "Nit: log level mismatch (isDebugEnabled vs. error).", "url": "https://github.com/apache/ozone/pull/1195#discussion_r453273760", "createdAt": "2020-07-12T06:18:15Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -116,99 +98,144 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n         getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n-    try {\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-            keyName);\n-        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-        omKeyInfoList.add(omKeyInfo);\n-        unDeletedKeys.add(omKeyInfo);\n-      }\n \n-      // Check if any of the key in the batch cannot be deleted. If exists the\n-      // batch will delete failed.\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n \n-        String objectKey = omMetadataManager.getOzoneKey(\n-            volumeName, bucketName, keyName);\n+    boolean acquiredLock =\n+        omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+\n+    int indexFailed = 0;\n+    int length = deleteKeys.size();\n+    OzoneManagerProtocolProtos.DeleteKeyArgs.Builder unDeletedKeys =\n+        OzoneManagerProtocolProtos.DeleteKeyArgs.newBuilder()\n+            .setVolumeName(volumeName).setBucketName(bucketName);\n+\n+    boolean deleteStatus = true;\n+    try {\n \n-        // Validate bucket and volume exists or not.\n-        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n+      for (indexFailed = 0; indexFailed < length; indexFailed++) {\n+        keyName = deleteKeyArgs.getKeys(indexFailed);\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            keyName);\n         OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n \n         if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found: \" + keyName, KEY_NOT_FOUND);\n+          deleteStatus = false;\n+          LOG.error(\"Received a request to delete a Key does not exist {}\",\n+              objectKey);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n+          continue;\n         }\n \n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n+        try {\n+          // check Acl\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          omKeyInfoList.add(omKeyInfo);\n+        } catch (Exception ex) {\n+          deleteStatus = false;\n+          LOG.error(\"Acl check failed for Key: {}\", objectKey, ex);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n         }\n       }\n \n+      // Mark all keys which can be deleted, in cache as deleted.\n+      for (OmKeyInfo omKeyInfo : omKeyInfoList) {\n+        omMetadataManager.getKeyTable().addCacheEntry(\n+            new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+                omKeyInfo.getKeyName())),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+      }\n+\n       omClientResponse = new OMKeysDeleteResponse(omResponse\n-          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()).build(),\n-          omKeyInfoList, trxnLogIndex, ozoneManager.isRatisEnabled());\n+          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+              .setStatus(deleteStatus).setUnDeletedKeys(unDeletedKeys))\n+          .setStatus(deleteStatus ? OK : PARTIAL_DELETE)\n+          .setSuccess(deleteStatus).build(),\n+          omKeyInfoList, trxnLogIndex,\n+          ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n+\n     } catch (IOException ex) {\n-      if (ex instanceof OMReplayException) {\n-        result = Result.REPLAY;\n-        omClientResponse = new OMKeyDeleteResponse(createReplayOMResponse(\n-            omResponse));\n-      } else {\n-        result = Result.FAILURE;\n-        exception = ex;\n-\n-        omClientResponse = new OMKeyDeleteResponse(\n-            createOperationKeysErrorOMResponse(omResponse, exception,\n-                unDeletedKeys));\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      // reset deleteKeys as request failed.\n+      deleteKeys = new ArrayList<>();\n+      // Add all keys which are failed due to any other exception .\n+      for (int i = indexFailed; i < length; i++) {\n+        unDeletedKeys.addKeys(deleteKeyArgs.getKeys(i));\n       }\n \n+      omResponse.setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+          .setStatus(false).setUnDeletedKeys(unDeletedKeys).build()).build();\n+      omClientResponse = new OMKeysDeleteResponse(omResponse.build());\n+\n     } finally {\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n       addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n           omDoubleBufferHelper);\n     }\n \n-    // Performing audit logging outside of the lock.\n-    if (result != Result.REPLAY) {\n-      auditLog(auditLogger, buildAuditMessage(\n-          OMAction.DELETE_KEY, auditMap, exception, userInfo));\n-    }\n+    auditMap = buildDeleteKeysAuditMap(volumeName, bucketName, deleteKeys,\n+        unDeletedKeys.getKeysList());\n+\n+    auditLog(auditLogger, buildAuditMessage(DELETE_KEYS, auditMap, exception,\n+        userInfo));\n+\n \n     switch (result) {\n     case SUCCESS:\n-      omMetrics.decNumKeys();\n-      LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyName);\n-      break;\n-    case REPLAY:\n-      LOG.debug(\"Replayed Transaction {} ignored. Request: {}\",\n-          trxnLogIndex, deleteKeyRequest);\n+      omMetrics.decNumKeys(deleteKeys.size());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Keys delete success. Volume:{}, Bucket:{}, Keys:{}\",\n+            volumeName, bucketName, auditMap.get(DELETED_KEYS_LIST));\n+      }\n       break;\n     case FAILURE:\n+      omMetrics.decNumKeys(deleteKeys.size());\n       omMetrics.incNumKeyDeleteFails();\n-      LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}.\" +\n-          \" Exception:{}\", volumeName, bucketName, keyName, exception);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b46762e9cbf2a319ee95ac6d9f0fb50c9311ecff"}, "originalPosition": 283}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3971, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}