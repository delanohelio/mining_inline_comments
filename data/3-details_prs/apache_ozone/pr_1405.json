{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgxNjYzMDA1", "number": 1405, "title": "HDDS-4143. Implement a factory for OM Requests that returns an instance based on layout version.", "bodyText": "What changes were proposed in this pull request?\n\nImplement Generic factory which stores different instances of Type 'T' sharded by a key & version. A single key can be associated with different versions of 'T'. This is to support a typical use case during upgrade to have multiple versions of a class / method / object and chose them based  on current layout version at runtime. Before finalizing, an older version is typically needed, and after finalize, a newer version is needed.\nUsing the generic factory, we scan all the different OM \"write\" requests and associate them with versions.\nPersist current MLV to Ratis requests.\nLayout feature code refactoring. Added more comments and tests.\n\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-4141\nhttps://issues.apache.org/jira/browse/HDDS-4143\nHow was this patch tested?\nUnit tested.", "createdAt": "2020-09-07T22:19:28Z", "url": "https://github.com/apache/ozone/pull/1405", "merged": true, "mergeCommit": {"oid": "86c4c9b628e266706f80aedc09ed520723cf283c"}, "closed": true, "closedAt": "2020-09-15T17:40:25Z", "author": {"login": "avijayanhwx"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdGqiEEAH2gAyNDgxNjYzMDA1OjJiY2M3NWZlY2YwYWIzYTUzZGRkZGRiY2Q5YWU0MjM2ZTliZmM5Mzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI5vPWgFqTQ4ODE0MDE4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2bcc75fecf0ab3a53dddddbcd9ae4236e9bfc937", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/2bcc75fecf0ab3a53dddddbcd9ae4236e9bfc937", "committedDate": "2020-09-07T22:14:00Z", "message": "Commit 1."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af28891ac0d6ebc81d8b56dc92334d8e30bd679b", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/af28891ac0d6ebc81d8b56dc92334d8e30bd679b", "committedDate": "2020-09-07T22:14:11Z", "message": "Commit 2."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13356b920e4cc0e90102d5193df6468671a02521", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/13356b920e4cc0e90102d5193df6468671a02521", "committedDate": "2020-09-07T22:14:18Z", "message": "Commit 3."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06bee3e6962c94278dc604320bc5b15bc4b273ef", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/06bee3e6962c94278dc604320bc5b15bc4b273ef", "committedDate": "2020-09-07T22:14:27Z", "message": "Integration test fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40e47a18ddd4e94b01bc28922699aed8dfacf4d9", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/40e47a18ddd4e94b01bc28922699aed8dfacf4d9", "committedDate": "2020-09-07T22:28:08Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f37fd02da6e15efff27f12e2b0449fbb5ba694d3", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/f37fd02da6e15efff27f12e2b0449fbb5ba694d3", "committedDate": "2020-09-08T15:17:59Z", "message": "Fix acceptance tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9e3d2014747d87a3583d91c822ce4af6f58600f", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/c9e3d2014747d87a3583d91c822ce4af6f58600f", "committedDate": "2020-09-08T19:35:24Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/6fd391a766e862918859b2cb441594882f0c250f", "committedDate": "2020-09-08T19:35:31Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjY4ODky", "url": "https://github.com/apache/ozone/pull/1405#pullrequestreview-484668892", "createdAt": "2020-09-09T05:22:36Z", "commit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNToyMjozNlrOHO3HKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNToyMjozNlrOHO3HKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM0NTA2Nw==", "bodyText": "Instead of a new method, we can use annotation.", "url": "https://github.com/apache/ozone/pull/1405#discussion_r485345067", "createdAt": "2020-09-09T05:22:36Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/bucket/OMBucketSetPropertyRequest.java", "diffHunk": "@@ -206,4 +207,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       return omClientResponse;\n     }\n   }\n+\n+  public static String getRequestType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd391a766e862918859b2cb441594882f0c250f"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5c5be6c60d40f83c97cc2ca400107071ed427a2", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/d5c5be6c60d40f83c97cc2ca400107071ed427a2", "committedDate": "2020-09-09T20:07:17Z", "message": "Merge remote-tracking branch 'upstream/HDDS-3698-upgrade' into HDDS-4143-upgrade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7774112146837c7b54441d16c791c3e4dbad9ddc", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/7774112146837c7b54441d16c791c3e4dbad9ddc", "committedDate": "2020-09-11T22:00:44Z", "message": "Address review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5281c2615e479e3a6b6685e1cc776b548d78b4da", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/5281c2615e479e3a6b6685e1cc776b548d78b4da", "committedDate": "2020-09-12T00:52:53Z", "message": "Add onFinalize to Instance factory."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTExNDg1", "url": "https://github.com/apache/ozone/pull/1405#pullrequestreview-488111485", "createdAt": "2020-09-14T20:20:46Z", "commit": {"oid": "5281c2615e479e3a6b6685e1cc776b548d78b4da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDoyMDo0NlrOHRlLHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMDoyMDo0NlrOHRlLHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5Njg5Mg==", "bodyText": "I think we need a \",\" here instead of \"+\".", "url": "https://github.com/apache/ozone/pull/1405#discussion_r488196892", "createdAt": "2020-09-14T20:20:46Z", "author": {"login": "fapifta"}, "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/upgrade/LayoutVersionInstanceFactory.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.upgrade;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.stream.Collectors.toList;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.PriorityQueue;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * Generic factory which stores different instances of Type 'T' sharded by\n+ * a key & version. A single key can be associated with different versions\n+ * of 'T'.\n+ *\n+ * Why does this class exist?\n+ * A typical use case during upgrade is to have multiple versions of a class\n+ * / method / object and chose them based  on current layout\n+ * version at runtime. Before finalizing, an older version is typically\n+ * needed, and after finalize, a newer version is needed. This class serves\n+ * this purpose in a generic way.\n+ *\n+ * For example, we can create a Factory to create multiple versions of\n+ * OMRequests sharded by Request Type & Layout Version Supported.\n+ */\n+public class LayoutVersionInstanceFactory<T> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(LayoutVersionInstanceFactory.class);\n+\n+  /**\n+   * The factory will maintain ALL instances > MLV and 1 instance <= MLV in a\n+   * priority queue (ordered by version). By doing that it guarantees O(1)\n+   * lookup at all times, since we always would lookup the first element (top\n+   * of the PQ).\n+   * Multiple entries will be there ONLY during pre-finalized state.\n+   * On finalization, we will be removing the entry one by one until we reach\n+   * a single entry. On a regular component instance (finalized), there will\n+   * be a single request version associated with a request always.\n+   */\n+  private final Map<String, PriorityQueue<VersionedInstance<T>>> instances =\n+      new HashMap<>();\n+\n+  /**\n+   * Register an instance with a given factory key (key + version).\n+   * For safety reasons we dont allow (1) re-registering, (2) registering an\n+   * instance with version > SLV.\n+   *\n+   * @param lvm LayoutVersionManager\n+   * @param key VersionFactoryKey key to associate with instance.\n+   * @param instance instance to register.\n+   */\n+  public boolean register(LayoutVersionManager lvm, VersionFactoryKey key,\n+                       T instance) {\n+    // If version is not passed in, go defensive and set the highest possible\n+    // version (SLV).\n+    int version = key.getVersion() == null ?\n+        lvm.getSoftwareLayoutVersion() : key.getVersion();\n+\n+    checkArgument(lvm.getSoftwareLayoutVersion() >= key.getVersion(),\n+        String.format(\"Cannot register key %s since the version is greater \" +\n+                \"than the Software layout version %d\",\n+        key, lvm.getSoftwareLayoutVersion()));\n+\n+    // If we reach here, we know that the passed in version belongs to\n+    // [0, SLV].\n+    String primaryKey = key.getKey();\n+    instances.computeIfAbsent(primaryKey, s ->\n+        new PriorityQueue<>(Comparator.comparingInt(o -> o.version)));\n+\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    Optional<VersionedInstance<T>> existingInstance =\n+        versionedInstances.parallelStream()\n+        .filter(v -> v.version == key.getVersion()).findAny();\n+\n+    if (existingInstance.isPresent()) {\n+      throw new IllegalArgumentException(String.format(\"Cannot register key \" +\n+          \"%s since there is an existing entry already.\", key));\n+    }\n+\n+    if (!versionedInstances.isEmpty() && isValid(lvm, version)) {\n+      VersionedInstance<T> currentPeek = versionedInstances.peek();\n+      if (currentPeek.version < version) {\n+        // Current peek < passed in version (and <= MLV). Hence, we can\n+        // remove it, since the passed in a better candidate.\n+        versionedInstances.poll();\n+        // Add the passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else if (currentPeek.version > lvm.getMetadataLayoutVersion()) {\n+        // Current peak is > MLV, hence we don't need to remove that. Just\n+        // add passed in instance.\n+        versionedInstances.offer(new VersionedInstance<>(version, instance));\n+        return true;\n+      } else {\n+        // Current peek <= MLV and > passed in version, and hence a better\n+        // canidate. Retaining the peek, and ignoring the passed in instance.\n+        return false;\n+      }\n+    } else {\n+      // Passed in instance version > MLV (or the first version to be\n+      // registered), hence can be registered.\n+      versionedInstances.offer(new VersionedInstance<>(version, instance));\n+      return true;\n+    }\n+  }\n+\n+  private boolean isValid(LayoutVersionManager lvm, int version) {\n+    return version <= lvm.getMetadataLayoutVersion();\n+  }\n+\n+  /**\n+   * From the list of versioned instances for a given \"key\", this\n+   * returns the \"floor\" value corresponding to the given version.\n+   * For example, if we have key = \"CreateKey\",  entry -> [(1, CreateKeyV1),\n+   * (3, CreateKeyV2), and if the passed in key = CreateKey & version = 2, we\n+   * return CreateKeyV1.\n+   * Since this is a priority queue based implementation, we use a O(1) peek()\n+   * lookup to get the current valid version.\n+   * @param lvm LayoutVersionManager\n+   * @param key Key and Version.\n+   * @return instance.\n+   */\n+  public T get(LayoutVersionManager lvm, VersionFactoryKey key) {\n+    Integer version = key.getVersion();\n+    // If version is not passed in, go defensive and set the highest allowed\n+    // version (MLV).\n+    if (version == null) {\n+      version = lvm.getMetadataLayoutVersion();\n+    }\n+\n+    checkArgument(lvm.getMetadataLayoutVersion() >= version,\n+        String.format(\"Cannot get key %s since the version is greater \" +\n+                \"than the Metadata layout version %d\",\n+            key, lvm.getMetadataLayoutVersion()));\n+\n+    String primaryKey = key.getKey();\n+    PriorityQueue<VersionedInstance<T>> versionedInstances =\n+        instances.get(primaryKey);\n+    if (versionedInstances == null || versionedInstances.isEmpty()) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    }\n+\n+    VersionedInstance<T> value = versionedInstances.peek();\n+    if (value == null || value.version > version) {\n+      throw new IllegalArgumentException(\n+          \"No suitable instance found for request : \" + key);\n+    } else {\n+      return value.instance;\n+    }\n+  }\n+\n+  /**\n+   * To be called on finalization when there is an MLV update.\n+   * @param lvm LayoutVersionManager instance.\n+   */\n+  public void onFinalize(LayoutVersionManager lvm) {\n+    Iterator<Map.Entry<String, PriorityQueue<VersionedInstance<T>>>> iterator =\n+        instances.entrySet().iterator();\n+    while (iterator.hasNext()) {\n+      Map.Entry<String, PriorityQueue<VersionedInstance<T>>> next =\n+          iterator.next();\n+      PriorityQueue<VersionedInstance<T>> vInstances = next.getValue();\n+      VersionedInstance<T> prevInstance = null;\n+      while (!vInstances.isEmpty() &&\n+          vInstances.peek().version < lvm.getMetadataLayoutVersion()) {\n+        prevInstance = vInstances.poll();\n+        LOG.info(\"Unregistering {} from factory. \", prevInstance.instance);\n+      }\n+\n+      if ((vInstances.isEmpty() ||\n+          vInstances.peek().version > lvm.getMetadataLayoutVersion())\n+          && prevInstance != null) {\n+        vInstances.offer(prevInstance);\n+      }\n+\n+      if (vInstances.isEmpty()) {\n+        LOG.info(\"Unregistering '{}' from factory since it has no entries.\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5281c2615e479e3a6b6685e1cc776b548d78b4da"}, "originalPosition": 206}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "547e3d07037520c4672fffe3b84c9356991cc6b4", "author": {"user": {"login": "avijayanhwx", "name": null}}, "url": "https://github.com/apache/ozone/commit/547e3d07037520c4672fffe3b84c9356991cc6b4", "committedDate": "2020-09-14T20:59:36Z", "message": "Address minor review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTQwMTg4", "url": "https://github.com/apache/ozone/pull/1405#pullrequestreview-488140188", "createdAt": "2020-09-14T21:04:49Z", "commit": {"oid": "547e3d07037520c4672fffe3b84c9356991cc6b4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2483, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}