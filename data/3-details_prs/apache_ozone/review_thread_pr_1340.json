{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzI0NTY4", "number": 1340, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToxOToyNFrOEcBXNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMjoyNlrOElz2-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODE3OTEwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToxOToyNFrOHGTWVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToxOToyNFrOHGTWVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MDUxNg==", "bodyText": "refer to OM-HA, the rpcProxy should be a result of Proxy.newProxyInstance(.... which relies on FailoverProxyProvider to switch between different ScmBlockLocationProtocolService.\n    OzoneManagerProtocolPB proxy = (OzoneManagerProtocolPB) RetryProxy.create(\n        OzoneManagerProtocolPB.class, failoverProxyProvider, retryPolicy);\n    return proxy;", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476370516", "createdAt": "2020-08-25T11:19:24Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -73,15 +75,19 @@\n   private static final RpcController NULL_RPC_CONTROLLER = null;\n \n   private final ScmBlockLocationProtocolPB rpcProxy;\n+  private SCMBlockLocationFailoverProxyProvider failoverProxyProvider;\n \n   /**\n    * Creates a new StorageContainerLocationProtocolClientSideTranslatorPB.\n    *\n-   * @param rpcProxy {@link StorageContainerLocationProtocolPB} RPC proxy\n+   * @param proxyProvider {@link SCMBlockLocationFailoverProxyProvider}\n+   * failover proxy provider.\n    */\n   public ScmBlockLocationProtocolClientSideTranslatorPB(\n-      ScmBlockLocationProtocolPB rpcProxy) {\n-    this.rpcProxy = rpcProxy;\n+      SCMBlockLocationFailoverProxyProvider proxyProvider) {\n+    Preconditions.checkState(proxyProvider != null);\n+    this.failoverProxyProvider = proxyProvider;\n+    this.rpcProxy = proxyProvider.getCurrentProxy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODE4ODIyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToyMjoxN1rOHGTb6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToyMjoxN1rOHGTb6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3MTk0Ng==", "bodyText": "We need consider the case that current follower SCM does not know current leader.\ncheck this\n  public OMResponse submitRequest(OMRequest payload) throws IOException {\n    try {\n      OMResponse omResponse =\n          rpcProxy.submitRequest(NULL_RPC_CONTROLLER, payload);\n\n      if (omResponse.hasLeaderOMNodeId() && omFailoverProxyProvider != null) {\n        String leaderOmId = omResponse.getLeaderOMNodeId();\n\n        // Failover to the OM node returned by OMResponse leaderOMNodeId if\n        // current proxy is not pointing to that node.\n        omFailoverProxyProvider.performFailoverIfRequired(leaderOmId);\n      }", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476371946", "createdAt": "2020-08-25T11:22:17Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/protocolPB/ScmBlockLocationProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -105,6 +111,11 @@ private SCMBlockLocationResponse submitRequest(\n     try {\n       SCMBlockLocationResponse response =\n           rpcProxy.send(NULL_RPC_CONTROLLER, req);\n+      if (response.getStatus() ==", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODIwOTU2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToyODo1OVrOHGTouQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMToyODo1OVrOHGTouQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NTIyNQ==", "bodyText": "This is not used.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476375225", "createdAt": "2020-08-25T11:28:59Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODIxNDg3OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTozMDoyOVrOHGTr5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTozMDoyOVrOHGTr5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NjAzNw==", "bodyText": "I guess this method is not needed.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476376037", "createdAt": "2020-08-25T11:30:29Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODI0ODA3OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTozOTowMlrOHGT_8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMTozOTowMlrOHGT_8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTE2OQ==", "bodyText": "Should not call performFailover() in FailoverProxyProvider, it is job of RetryInvocationHandler to call performFailover() in its RetryInvocationHandler.ProxyDescriptor.failover()", "url": "https://github.com/apache/ozone/pull/1340#discussion_r476381169", "createdAt": "2020-08-25T11:39:02Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+  private ScmBlockLocationProtocol currentProxy;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  private Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        resultList.add(NetUtils.createSocketAddr(scmAddress));\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  public ScmBlockLocationProtocolPB getCurrentProxy() {\n+    return (ScmBlockLocationProtocolPB) getProxy().proxy;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {\n+    if (!currentProxySCMNodeId.equals(newLeaderNodeId)) {\n+      if (scmProxies.containsKey(newLeaderNodeId)) {\n+        lastAttemptedLeader = currentProxySCMNodeId;\n+        currentProxySCMNodeId = newLeaderNodeId;\n+        currentProxyIndex = scmNodeIDList.indexOf(currentProxySCMNodeId);\n+        return true;\n+      }\n+    } else {\n+      lastAttemptedLeader = currentProxySCMNodeId;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates proxy object if it does not already exist.\n+   */\n+  private void createSCMProxyIfNeeded(ProxyInfo proxyInfo,\n+                                     String nodeId) {\n+    if (proxyInfo.proxy == null) {\n+      InetSocketAddress address = scmProxyInfoMap.get(nodeId).getAddress();\n+      try {\n+        ScmBlockLocationProtocolPB proxy = createSCMProxy(address);\n+        try {\n+          proxyInfo.proxy = proxy;\n+        } catch (IllegalAccessError iae) {\n+          scmProxies.put(nodeId,\n+              new ProxyInfo<>(proxy, proxyInfo.proxyInfo));\n+        }\n+      } catch (IOException ioe) {\n+        LOG.error(\"{} Failed to create RPC proxy to SCM at {}\",\n+            this.getClass().getSimpleName(), address, ioe);\n+        throw new RuntimeException(ioe);\n+      }\n+    }\n+  }\n+\n+  private ScmBlockLocationProtocolPB createSCMProxy(\n+      InetSocketAddress scmAddress) throws IOException {\n+    Configuration hadoopConf =\n+        LegacyHadoopConfigurationSource.asHadoopConfiguration(conf);\n+    RPC.setProtocolEngine(hadoopConf, ScmBlockLocationProtocol.class,\n+        ProtobufRpcEngine.class);\n+    return RPC.getProxy(ScmBlockLocationProtocolPB.class, scmVersion,\n+        scmAddress, UserGroupInformation.getCurrentUser(), hadoopConf,\n+        NetUtils.getDefaultSocketFactory(hadoopConf),\n+        (int)conf.getObject(SCMBlockClientConfig.class).getRpcTimeOut());\n+  }\n+\n+  public RetryPolicy getSCMBlockLocationRetryPolicy(\n+      String suggestedLeader) {\n+    RetryPolicy retryPolicy = new RetryPolicy() {\n+      @Override\n+      public RetryAction shouldRetry(Exception e, int retry,\n+                                     int failover, boolean b) {\n+        if (suggestedLeader == null) {\n+          performFailover(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4Mjk1MTQzOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0NTozOFrOHHCKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0NTozOFrOHHCKUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzNzQ5MQ==", "bodyText": "miss access modifier, such as public", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477137491", "createdAt": "2020-08-26T08:45:38Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  SCMProxyInfo(String serviceID, String nodeID, InetSocketAddress rpcAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzI3Njc4OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDowOToyMlrOHHFUHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDowOToyMlrOHHFUHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4OTE1MQ==", "bodyText": "may be NPE ?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r477189151", "createdAt": "2020-08-26T10:09:22Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1053,6 +1053,22 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    return scmHAManager.getSuggestedLeader().getAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f811ed461002c3d4817dd9093d419182d4fa37ff"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTkxMTMxOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNDoxN1rOHIIRCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozOTo1OFrOHIIeDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NjA4OA==", "bodyText": "no need to call nextProxyIndex().\nSince the real failover is done by performFailoverToAssignedLeader(), it is called by RetryPolicy.shouldRetry() and submitRequest()", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478286088", "createdAt": "2020-08-27T09:34:17Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        if (scmAddress.contains(\":\")) {\n+          resultList.add(NetUtils.createSocketAddr(scmAddress));\n+        } else {\n+          final int port = getPortNumberFromConfigKeys(conf,\n+              ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+              .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+          resultList.add(NetUtils.createSocketAddr(scmAddress + \":\" + port));\n+        }\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4OTQyMg==", "bodyText": "Sure. Thanks for pointing out.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478289422", "createdAt": "2020-08-27T09:39:58Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        if (scmAddress.contains(\":\")) {\n+          resultList.add(NetUtils.createSocketAddr(scmAddress));\n+        } else {\n+          final int port = getPortNumberFromConfigKeys(conf,\n+              ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+              .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+          resultList.add(NetUtils.createSocketAddr(scmAddress + \":\" + port));\n+        }\n+      }\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // By default, will round robin to next proxy.\n+    nextProxyIndex();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NjA4OA=="}, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTkxODAwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozNjowMlrOHIIVDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOTozOTo0N1rOHIIdfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NzExOA==", "bodyText": "I guess it will be a NPE ?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478287118", "createdAt": "2020-08-27T09:36:02Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1027,6 +1027,25 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    if (scmHAManager.getSuggestedLeader() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4OTI3OA==", "bodyText": "Updated.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r478289278", "createdAt": "2020-08-27T09:39:47Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/server/StorageContainerManager.java", "diffHunk": "@@ -1027,6 +1027,25 @@ public ReplicationManager getReplicationManager() {\n     return replicationManager;\n   }\n \n+  /**\n+   * Check if the current scm is the leader.\n+   * @return - if the current scm is the leader.\n+   */\n+  public boolean checkLeader() {\n+    return scmHAManager.isLeader();\n+  }\n+\n+  /**\n+   * Get suggested leader from Raft.\n+   * @return - suggested leader address.\n+   */\n+  public String getSuggestedLeader() {\n+    if (scmHAManager.getSuggestedLeader() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NzExOA=="}, "originalCommit": {"oid": "046872462842863a56eafb28bfafbf5c130672bc"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNTc4MTA3OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzozNzo0OVrOHKcYgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowNToxM1rOHLcSNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcxMjgzNA==", "bodyText": "nit: might be useful to print which class current impl is.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480712834", "createdAt": "2020-09-01T03:37:49Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,33 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTc5OA==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r481759798", "createdAt": "2020-09-02T06:05:13Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,33 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcxMjgzNA=="}, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNTgyMjcyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMzo0MzoyNlrOHKc10g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowNToyNFrOHLcS-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcyMDMzOA==", "bodyText": "The default implementation of getTrimmedStringCollection seems does not validate the format of ip address in string: https://github.com/apache/hadoop-ozone/blob/34ee8311b0d0a37878fe1fd2e5d8c1b91aa8cc8f/hadoop-hdds/config/src/main/java/org/apache/hadoop/hdds/conf/ConfigurationSource.java#L99\nIs the format is already validated somewhere else? if not this implementation will be fragile.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r480720338", "createdAt": "2020-09-01T03:43:26Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        int indexOfComma = scmAddress.lastIndexOf(\":\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc1OTk5Mg==", "bodyText": "Add a validator", "url": "https://github.com/apache/ozone/pull/1340#discussion_r481759992", "createdAt": "2020-09-02T06:05:24Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (scmAddressList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    } else {\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+        int indexOfComma = scmAddress.lastIndexOf(\":\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDcyMDMzOA=="}, "originalCommit": {"oid": "0966949fb860e722d52f13518862736aed8f53e8"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDE3MjE4OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODoxNDowOFrOHOopng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMjoyNjoyN1rOHQMBAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwODEyNg==", "bodyText": "conf#getObject is a heavy call, we can avoid calling it twice.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485108126", "createdAt": "2020-09-08T18:14:08Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjEyOQ==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486736129", "createdAt": "2020-09-11T02:26:27Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwODEyNg=="}, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDIxMjMyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODoyNjowNlrOHOpCuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozMToxM1rOHPrO7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDU1NQ==", "bodyText": "Can we avoid putting null proxy?\nWhile reading, instead of checking if proxyInfo.proxy == null, we can do proxyInfo#contains.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485114555", "createdAt": "2020-09-08T18:26:06Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTAyMQ==", "bodyText": "ProxyInfo is defined in FailoverProxyProvider. Interface is defined already.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486199021", "createdAt": "2020-09-10T09:31:13Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDU1NQ=="}, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDIyMzM2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODoyOTozMVrOHOpJqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNDo1MzozM1rOHO2nsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjMzMA==", "bodyText": "What is the reason for not doing anything here?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485116330", "createdAt": "2020-09-08T18:29:31Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzNzAxMA==", "bodyText": "The input protocol ScmBlockLocationProtocolPB is difficult to use here. We mainly use performFailoverToAssignedLeader", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485337010", "createdAt": "2020-09-09T04:53:33Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjMzMA=="}, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDIzNDgxOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODozMjo1OFrOHOpQqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwOTozMjozNFrOHPrSJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODEyMA==", "bodyText": "This can be made private.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r485118120", "createdAt": "2020-09-08T18:32:58Z", "author": {"login": "nandakumar131"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTg0Ng==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r486199846", "createdAt": "2020-09-10T09:32:34Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMBlockLocationFailoverProxyProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.hdds.scm.protocol.ScmBlockLocationProtocol;\n+import org.apache.hadoop.hdds.scm.protocolPB.ScmBlockLocationProtocolPB;\n+import org.apache.hadoop.hdds.utils.LegacyHadoopConfigurationSource;\n+import org.apache.hadoop.io.retry.FailoverProxyProvider;\n+import org.apache.hadoop.io.retry.RetryPolicy;\n+import org.apache.hadoop.io.retry.RetryPolicy.RetryAction;\n+import org.apache.hadoop.ipc.ProtobufRpcEngine;\n+import org.apache.hadoop.ipc.RPC;\n+import org.apache.hadoop.net.NetUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_NAMES;\n+import static org.apache.hadoop.hdds.scm.ScmConfigKeys.OZONE_SCM_SERVICE_IDS_KEY;\n+import static org.apache.hadoop.hdds.HddsUtils.getScmAddressForBlockClients;\n+import static org.apache.hadoop.hdds.HddsUtils.getPortNumberFromConfigKeys;\n+import static org.apache.hadoop.hdds.HddsUtils.getHostName;\n+\n+/**\n+ * Failover proxy provider for SCM.\n+ */\n+public class SCMBlockLocationFailoverProxyProvider implements\n+    FailoverProxyProvider<ScmBlockLocationProtocolPB>, Closeable {\n+  public static final Logger LOG =\n+      LoggerFactory.getLogger(SCMBlockLocationFailoverProxyProvider.class);\n+\n+  private Map<String, ProxyInfo<ScmBlockLocationProtocolPB>> scmProxies;\n+  private Map<String, SCMProxyInfo> scmProxyInfoMap;\n+  private List<String> scmNodeIDList;\n+\n+  private String currentProxySCMNodeId;\n+  private int currentProxyIndex;\n+\n+  private final ConfigurationSource conf;\n+  private final long scmVersion;\n+\n+  private final String scmServiceId;\n+\n+  private String lastAttemptedLeader;\n+\n+  private final int maxRetryCount;\n+  private final long retryInterval;\n+\n+  public static final String SCM_DUMMY_NODEID_PREFIX = \"scm\";\n+\n+  public SCMBlockLocationFailoverProxyProvider(ConfigurationSource conf) {\n+    this.conf = conf;\n+    this.scmVersion = RPC.getProtocolVersion(ScmBlockLocationProtocol.class);\n+    this.scmServiceId = conf.getTrimmed(OZONE_SCM_SERVICE_IDS_KEY);\n+    this.scmProxies = new HashMap<>();\n+    this.scmProxyInfoMap = new HashMap<>();\n+    this.scmNodeIDList = new ArrayList<>();\n+    loadConfigs();\n+\n+    this.currentProxyIndex = 0;\n+    currentProxySCMNodeId = scmNodeIDList.get(currentProxyIndex);\n+\n+    this.maxRetryCount = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryCount();\n+    this.retryInterval = conf.getObject(SCMBlockClientConfig.class)\n+        .getRetryInterval();\n+  }\n+\n+  @VisibleForTesting\n+  protected Collection<InetSocketAddress> getSCMAddressList() {\n+    Collection<String> scmAddressList =\n+        conf.getTrimmedStringCollection(OZONE_SCM_NAMES);\n+    Collection<InetSocketAddress> resultList = new ArrayList<>();\n+    if (!scmAddressList.isEmpty()) {\n+      final int port = getPortNumberFromConfigKeys(conf,\n+          ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_ADDRESS_KEY)\n+          .orElse(ScmConfigKeys.OZONE_SCM_BLOCK_CLIENT_PORT_DEFAULT);\n+      for (String scmAddress : scmAddressList) {\n+        LOG.info(\"SCM Address for proxy is {}\", scmAddress);\n+\n+        Optional<String> hostname = getHostName(scmAddress);\n+        if (hostname.isPresent()) {\n+          resultList.add(NetUtils.createSocketAddr(\n+              hostname.get() + \":\" + port));\n+        }\n+      }\n+    }\n+    if (resultList.isEmpty()) {\n+      // fall back\n+      resultList.add(getScmAddressForBlockClients(conf));\n+    }\n+    return resultList;\n+  }\n+\n+  private void loadConfigs() {\n+    Collection<InetSocketAddress> scmAddressList = getSCMAddressList();\n+    int scmNodeIndex = 1;\n+    for (InetSocketAddress scmAddress : scmAddressList) {\n+      String nodeId = SCM_DUMMY_NODEID_PREFIX + scmNodeIndex;\n+      if (scmAddress == null) {\n+        LOG.error(\"Failed to create SCM proxy for {}.\", nodeId);\n+        continue;\n+      }\n+      scmNodeIndex++;\n+      SCMProxyInfo scmProxyInfo = new SCMProxyInfo(\n+          scmServiceId, nodeId, scmAddress);\n+      ProxyInfo<ScmBlockLocationProtocolPB> proxy = new ProxyInfo<>(\n+          null, scmProxyInfo.toString());\n+      scmProxies.put(nodeId, proxy);\n+      scmProxyInfoMap.put(nodeId, scmProxyInfo);\n+      scmNodeIDList.add(nodeId);\n+    }\n+\n+    if (scmProxies.isEmpty()) {\n+      throw new IllegalArgumentException(\"Could not find any configured \" +\n+          \"addresses for SCM. Please configure the system with \"\n+          + OZONE_SCM_NAMES);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public synchronized String getCurrentProxyOMNodeId() {\n+    return currentProxySCMNodeId;\n+  }\n+\n+  @Override\n+  public synchronized ProxyInfo getProxy() {\n+    ProxyInfo currentProxyInfo = scmProxies.get(currentProxySCMNodeId);\n+    createSCMProxyIfNeeded(currentProxyInfo, currentProxySCMNodeId);\n+    return currentProxyInfo;\n+  }\n+\n+  @Override\n+  public void performFailover(ScmBlockLocationProtocolPB newLeader) {\n+    // Should do nothing here.\n+    LOG.debug(\"Failing over to next proxy. {}\", getCurrentProxyOMNodeId());\n+  }\n+\n+  public void performFailoverToAssignedLeader(String newLeader) {\n+    if (newLeader == null) {\n+      // If newLeader is not assigned, it will fail over to next proxy.\n+      nextProxyIndex();\n+    } else {\n+      if (!assignLeaderToNode(newLeader)) {\n+        LOG.debug(\"Failing over OM proxy to nodeId: {}\", newLeader);\n+        nextProxyIndex();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Class<ScmBlockLocationProtocolPB> getInterface() {\n+    return ScmBlockLocationProtocolPB.class;\n+  }\n+\n+  @Override\n+  public synchronized void close() throws IOException {\n+    for (ProxyInfo<ScmBlockLocationProtocolPB> proxy : scmProxies.values()) {\n+      ScmBlockLocationProtocolPB scmProxy = proxy.proxy;\n+      if (scmProxy != null) {\n+        RPC.stopProxy(scmProxy);\n+      }\n+    }\n+  }\n+\n+  public RetryAction getRetryAction(int failovers) {\n+    if (failovers < maxRetryCount) {\n+      return new RetryAction(RetryAction.RetryDecision.FAILOVER_AND_RETRY,\n+          getRetryInterval());\n+    } else {\n+      return RetryAction.FAIL;\n+    }\n+  }\n+\n+  private synchronized long getRetryInterval() {\n+    // TODO add exponential backup\n+    return retryInterval;\n+  }\n+\n+  private synchronized int nextProxyIndex() {\n+    lastAttemptedLeader = currentProxySCMNodeId;\n+\n+    // round robin the next proxy\n+    currentProxyIndex = (currentProxyIndex + 1) % scmProxies.size();\n+    currentProxySCMNodeId =  scmNodeIDList.get(currentProxyIndex);\n+    return currentProxyIndex;\n+  }\n+\n+  synchronized boolean assignLeaderToNode(String newLeaderNodeId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODEyMA=="}, "originalCommit": {"oid": "362e6f5446fd50f6521007ad9efd5b0ae44a234a"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwMDkyOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNToxN1rOHVfRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwNjo1MDoyOVrOHYlMmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDQzNA==", "bodyText": "should this configuration group prefix with hdds.scmclient to match with the package name?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294434", "createdAt": "2020-09-21T19:25:17Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzMwNg==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537306", "createdAt": "2020-09-27T06:50:29Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDQzNA=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwMjY2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNTo0NlrOHVfSKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwNjo1MDowN1rOHYlMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDY5Ng==", "bodyText": "OzoneManager=>StorageContainerManger", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492294696", "createdAt": "2020-09-21T19:25:46Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzI3Mg==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537272", "createdAt": "2020-09-27T06:50:07Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NDY5Ng=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgwNjcwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyNjo1OVrOHVfUjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwNjo1MDowNlrOHYlMdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ==", "bodyText": "OzoneManager=>StorageContainerManger", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492295311", "createdAt": "2020-09-21T19:26:59Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +\n+          \"If ipc.client.ping is set to true and this rpc-timeout \" +\n+          \"is greater than the value of ipc.ping.interval, the effective \" +\n+          \"value of the rpc-timeout is rounded up to multiple of \" +\n+          \"ipc.ping.interval.\"\n+  )\n+  private long rpcTimeOut = 15 * 60 * 1000;\n+\n+  @Config(key = SCM_CLIENT_FAILOVER_MAX_RETRY,\n+      defaultValue = \"15\",\n+      type = ConfigType.INT,\n+      tags = {OZONE, SCM, CLIENT},\n+      description = \"Max retry count for SCM Client when failover happens.\"\n+  )\n+  private int retryCount = 15;\n+\n+  @Config(key = SCM_CLIENT_RETRY_INTERVAL,\n+      defaultValue = \"2s\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTc4OQ==", "bodyText": "Also the description does not match with the configuration key and needs to be updated.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492295789", "createdAt": "2020-09-21T19:27:49Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +\n+          \"If ipc.client.ping is set to true and this rpc-timeout \" +\n+          \"is greater than the value of ipc.ping.interval, the effective \" +\n+          \"value of the rpc-timeout is rounded up to multiple of \" +\n+          \"ipc.ping.interval.\"\n+  )\n+  private long rpcTimeOut = 15 * 60 * 1000;\n+\n+  @Config(key = SCM_CLIENT_FAILOVER_MAX_RETRY,\n+      defaultValue = \"15\",\n+      type = ConfigType.INT,\n+      tags = {OZONE, SCM, CLIENT},\n+      description = \"Max retry count for SCM Client when failover happens.\"\n+  )\n+  private int retryCount = 15;\n+\n+  @Config(key = SCM_CLIENT_RETRY_INTERVAL,\n+      defaultValue = \"2s\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzI3MA==", "bodyText": "Updated", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537270", "createdAt": "2020-09-27T06:50:06Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMClientConfig.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import org.apache.hadoop.hdds.conf.Config;\n+import org.apache.hadoop.hdds.conf.ConfigGroup;\n+import org.apache.hadoop.hdds.conf.ConfigType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.hadoop.hdds.conf.ConfigTag.CLIENT;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.OZONE;\n+import static org.apache.hadoop.hdds.conf.ConfigTag.SCM;\n+\n+/**\n+ * Config for SCM Block Client.\n+ */\n+@ConfigGroup(prefix = \"ozone.scmclient\")\n+public class SCMClientConfig {\n+  public static final String SCM_CLIENT_RPC_TIME_OUT = \"rpc.timeout\";\n+  public static final String SCM_CLIENT_FAILOVER_MAX_RETRY =\n+      \"failover.max.retry\";\n+  public static final String SCM_CLIENT_RETRY_INTERVAL =\n+      \"failover.retry.interval\";\n+\n+  @Config(key = SCM_CLIENT_RPC_TIME_OUT,\n+      defaultValue = \"15m\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +\n+          \"If ipc.client.ping is set to true and this rpc-timeout \" +\n+          \"is greater than the value of ipc.ping.interval, the effective \" +\n+          \"value of the rpc-timeout is rounded up to multiple of \" +\n+          \"ipc.ping.interval.\"\n+  )\n+  private long rpcTimeOut = 15 * 60 * 1000;\n+\n+  @Config(key = SCM_CLIENT_FAILOVER_MAX_RETRY,\n+      defaultValue = \"15\",\n+      type = ConfigType.INT,\n+      tags = {OZONE, SCM, CLIENT},\n+      description = \"Max retry count for SCM Client when failover happens.\"\n+  )\n+  private int retryCount = 15;\n+\n+  @Config(key = SCM_CLIENT_RETRY_INTERVAL,\n+      defaultValue = \"2s\",\n+      type = ConfigType.TIME,\n+      tags = {OZONE, SCM, CLIENT},\n+      timeUnit = TimeUnit.MILLISECONDS,\n+      description = \"RpcClient timeout on waiting for the response from \" +\n+          \"OzoneManager. The default value is set to 15 minutes. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTMxMQ=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgxNDQ3OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToyOToyNlrOHVfZhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwNjo1MzoyNVrOHYlNcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjU4MQ==", "bodyText": "missing getter for nodeid and serviceid?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492296581", "createdAt": "2020-09-21T19:29:26Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  public SCMProxyInfo(String serviceID, String nodeID,\n+                      InetSocketAddress rpcAddress) {\n+    Preconditions.checkNotNull(rpcAddress);\n+    this.serviceId = serviceID;\n+    this.nodeId = nodeID;\n+    this.rpcAddrStr = rpcAddress.toString();\n+    this.rpcAddr = rpcAddress;\n+    if (rpcAddr.isUnresolved()) {\n+      LOG.warn(\"SCM address {} for serviceID {} remains unresolved \" +\n+              \"for node ID {} Check your ozone-site.xml file to ensure scm \" +\n+              \"addresses are configured properly.\",\n+          rpcAddress, serviceId, nodeId);\n+    }\n+  }\n+\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(\"nodeId=\")\n+        .append(nodeId)\n+        .append(\",nodeAddress=\")\n+        .append(rpcAddrStr).toString();\n+  }\n+\n+  public InetSocketAddress getAddress() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUzNzUyMQ==", "bodyText": "Updated.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495537521", "createdAt": "2020-09-27T06:53:25Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/framework/src/main/java/org/apache/hadoop/hdds/scm/proxy/SCMProxyInfo.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.proxy;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * Class to store SCM proxy info.\n+ */\n+public class SCMProxyInfo {\n+  private String serviceId;\n+  private String nodeId;\n+  private String rpcAddrStr;\n+  private InetSocketAddress rpcAddr;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SCMProxyInfo.class);\n+\n+  public SCMProxyInfo(String serviceID, String nodeID,\n+                      InetSocketAddress rpcAddress) {\n+    Preconditions.checkNotNull(rpcAddress);\n+    this.serviceId = serviceID;\n+    this.nodeId = nodeID;\n+    this.rpcAddrStr = rpcAddress.toString();\n+    this.rpcAddr = rpcAddress;\n+    if (rpcAddr.isUnresolved()) {\n+      LOG.warn(\"SCM address {} for serviceID {} remains unresolved \" +\n+              \"for node ID {} Check your ozone-site.xml file to ensure scm \" +\n+              \"addresses are configured properly.\",\n+          rpcAddress, serviceId, nodeId);\n+    }\n+  }\n+\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(\"nodeId=\")\n+        .append(nodeId)\n+        .append(\",nodeAddress=\")\n+        .append(rpcAddrStr).toString();\n+  }\n+\n+  public InetSocketAddress getAddress() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NjU4MQ=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDgyNDI0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMjoyNlrOHVffpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwMzo1Mjo1NFrOHYkZjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODE0OA==", "bodyText": "Should we send back the leader known by this SCM follower instead of null to avoid unnecessary client retry?", "url": "https://github.com/apache/ozone/pull/1340#discussion_r492298148", "createdAt": "2020-09-21T19:32:26Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,26 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");\n+    } else {\n+      return ((SCMBlockProtocolServer) impl).getScm().checkLeader();\n+    }\n+  }\n+\n   @Override\n   public SCMBlockLocationResponse send(RpcController controller,\n       SCMBlockLocationRequest request) throws ServiceException {\n+    if (!isLeader()) {\n+      SCMBlockLocationResponse.Builder response = createSCMBlockResponse(\n+          request.getCmdType(),\n+          request.getTraceID());\n+      response.setSuccess(false);\n+      response.setStatus(Status.SCM_NOT_LEADER);\n+      response.setLeaderSCMNodeId(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyNDIzNw==", "bodyText": "@xiaoyuyao We decide to implement suggestedLeader in following JIRA https://issues.apache.org/jira/browse/HDDS-4281. To use suggestedLeader from Ratis, we may need a more well-rounded strategy.", "url": "https://github.com/apache/ozone/pull/1340#discussion_r495524237", "createdAt": "2020-09-27T03:52:54Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/protocol/ScmBlockLocationProtocolServerSideTranslatorPB.java", "diffHunk": "@@ -94,9 +95,26 @@ public ScmBlockLocationProtocolServerSideTranslatorPB(\n         .setTraceID(traceID);\n   }\n \n+  private boolean isLeader() throws ServiceException {\n+    if (!(impl instanceof SCMBlockProtocolServer)) {\n+      throw new ServiceException(\"Should be SCMBlockProtocolServer\");\n+    } else {\n+      return ((SCMBlockProtocolServer) impl).getScm().checkLeader();\n+    }\n+  }\n+\n   @Override\n   public SCMBlockLocationResponse send(RpcController controller,\n       SCMBlockLocationRequest request) throws ServiceException {\n+    if (!isLeader()) {\n+      SCMBlockLocationResponse.Builder response = createSCMBlockResponse(\n+          request.getCmdType(),\n+          request.getTraceID());\n+      response.setSuccess(false);\n+      response.setStatus(Status.SCM_NOT_LEADER);\n+      response.setLeaderSCMNodeId(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODE0OA=="}, "originalCommit": {"oid": "277efde99dc3f324ee7b760a99b8d608f0eb1a3f"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3907, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}