{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMDgyNjA1", "number": 1150, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo0NTo1OFrOEKNeNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDo0NzowNFrOET7YbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTQxOTQzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocol/OzoneManagerProtocol.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo0NTo1OFrOGrHw6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMjo0NDoxOFrOGr7irA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTE2MA==", "bodyText": "Should we make this to Map<OmKeyArgs, String> so that it will be consistent with the renameKey() API and  the batch of the rename does not to have the same volume/bucket name, e.g. /vol1/bucket1/key1->/vol1/bucket2/key2 and /vol2/bucket1/key1->/vol2/bucket1/key2?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r447869160", "createdAt": "2020-06-30T17:45:58Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocol/OzoneManagerProtocol.java", "diffHunk": "@@ -216,6 +217,13 @@ OmKeyLocationInfo allocateBlock(OmKeyArgs args, long clientID,\n    */\n   void renameKey(OmKeyArgs args, String toKeyName) throws IOException;\n \n+  /**\n+   * Rename existing keys within a bucket.\n+   * @param keyMap The key is new key name nad value is original key OmKeyArgs.\n+   * @throws IOException\n+   */\n+  void renameKeys(Map<String, OmKeyArgs> keyMap) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcxNzQ4NA==", "bodyText": "I'll make this to Map<OmKeyArgs, String> to consistent with the renameKey() API.\nIn addition, the API was added to OzoneBucket and currently only supports renaming keys under the same bucket.\nOzoneBucket bucket = volume.getBucket(bucketName);\nMap<String, String> keyMap = new HashMap();\nkeyMap.put(keyName1, newKeyName1);\nbucket.renameKeys(keyMap);", "url": "https://github.com/apache/ozone/pull/1150#discussion_r448717484", "createdAt": "2020-07-02T02:44:18Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocol/OzoneManagerProtocol.java", "diffHunk": "@@ -216,6 +217,13 @@ OmKeyLocationInfo allocateBlock(OmKeyArgs args, long clientID,\n    */\n   void renameKey(OmKeyArgs args, String toKeyName) throws IOException;\n \n+  /**\n+   * Rename existing keys within a bucket.\n+   * @param keyMap The key is new key name nad value is original key OmKeyArgs.\n+   * @throws IOException\n+   */\n+  void renameKeys(Map<String, OmKeyArgs> keyMap) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTE2MA=="}, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTQ0MjMyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocolPB/OzoneManagerProtocolClientSideTranslatorPB.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1MjozNFrOGrH_xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1MjozNFrOGrH_xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3Mjk2NA==", "bodyText": "Do we need to update the datasize here?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r447872964", "createdAt": "2020-06-30T17:52:34Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocolPB/OzoneManagerProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -672,6 +676,32 @@ public OmKeyInfo lookupKey(OmKeyArgs args) throws IOException {\n     return OmKeyInfo.getFromProtobuf(resp.getKeyInfo());\n   }\n \n+  @Override\n+  public void renameKeys(Map<String, OmKeyArgs> keyMap) throws IOException {\n+    RenameKeysRequest.Builder reqKeys = RenameKeysRequest.newBuilder();\n+    List<RenameKeyRequest> renameKeyRequestList  = new ArrayList<>();\n+    for (Map.Entry< String, OmKeyArgs > entry : keyMap.entrySet()) {\n+      RenameKeyRequest.Builder reqKey = RenameKeyRequest.newBuilder();\n+      OmKeyArgs args = entry.getValue();\n+      KeyArgs keyArgs = KeyArgs.newBuilder()\n+          .setVolumeName(args.getVolumeName())\n+          .setBucketName(args.getBucketName())\n+          .setKeyName(args.getKeyName())\n+          .setModificationTime(Time.now())\n+          .setDataSize(args.getDataSize()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTQ2MTQ4OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OmRenameKeyInfo.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1NzozMlrOGrILnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1NzozMlrOGrILnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NTk5OQ==", "bodyText": "newKeyInfo.keyName already cover toKeyName?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r447875999", "createdAt": "2020-06-30T17:57:32Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OmRenameKeyInfo.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om;\n+\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * This class is used for rename keys.\n+ */\n+public class OmRenameKeyInfo {\n+\n+  private String toKeyName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTQ2NjA5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1ODo0OFrOGrIOkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNzo1ODo0OFrOGrIOkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3Njc1NQ==", "bodyText": "I think we need to set the modification time here.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r447876755", "createdAt": "2020-06-30T17:58:48Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeysRequest);\n+\n+    return getOmRequest().toBuilder()\n+        .setRenameKeysRequest(renameKeysRequest.toBuilder())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTQ4NDk2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxODowMzo0OVrOGrIaMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMzozOTozMVrOGr8Uwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3OTcyOA==", "bodyText": "unRenamedKeys is not updated inside the loop. Can we add a unit test for the returned unRenamedKeys upon failure?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r447879728", "createdAt": "2020-06-30T18:03:49Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeysRequest);\n+\n+    return getOmRequest().toBuilder()\n+        .setRenameKeysRequest(renameKeysRequest.toBuilder())\n+        .setUserInfo(getUserInfo()).build();\n+\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODczMDMwNg==", "bodyText": "Although we have put the list of unDeletedKeys and unRenamedKeys into the response. Currently, renameKeys and DeleteKeys in OzoneBucket.java and ClientProtocol.java are still void.\nI had added TODO to the OMClientRequest and created a jira(HDDS-3916), and I'll change those separately.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r448730306", "createdAt": "2020-07-02T03:39:31Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeysRequest);\n+\n+    return getOmRequest().toBuilder()\n+        .setRenameKeysRequest(renameKeysRequest.toBuilder())\n+        .setUserInfo(getUserInfo()).build();\n+\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3OTcyOA=="}, "originalCommit": {"oid": "af9aedb96b650e1845413f1148a59d261b461972"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODU3NjgxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoxODo1OFrOGsMgJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDowMTo0N1rOGsrLKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTM2NA==", "bodyText": "Shouldn't all renamed keys be logged to audit?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r448995364", "createdAt": "2020-07-02T13:18:58Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);\n+      }\n+\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        toKeyName = renameKeyRequest.getToKeyName();\n+        auditMap = buildAuditMap(renameKeyArgs, renameKeyRequest);\n+        renameRequest = renameKeyRequest;\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          throw new OMException(\"Key name is empty\",\n+              OMException.ResultCodes.INVALID_KEY_NAME);\n+        }\n+        // check Acls to see if user has access to perform delete operation on\n+        // old key and create operation on new key\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+            IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+        // Validate bucket and volume exists or not.\n+        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+        // Check if toKey exists\n+        fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          // Check if this transaction is a replay of ratis logs.\n+          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+            // Check if fromKey is still in the DB and created before this\n+            // replay.\n+            // For example, lets say we have the following sequence of\n+            // transactions.\n+            //   Trxn 1 : Create Key1\n+            //   Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+            // Now if these transactions are replayed:\n+            //   Replay Trxn 1 : Creates Key1 again it does not exist in DB\n+            //   Replay Trxn 2 : Key2 is not created as it exists in DB and\n+            //                   the request would be deemed a replay. But\n+            //                   Key1 is still in the DB and needs to be\n+            //                   deleted.\n+            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+            if (fromKeyValue != null) {\n+              // Check if this replay transaction was after the fromKey was\n+              // created. If so, we have to delete the fromKey.\n+              if (ozoneManager.isRatisEnabled() &&\n+                  trxnLogIndex > fromKeyValue.getUpdateID()) {\n+                // Add to cache. Only fromKey should be deleted. ToKey already\n+                // exists in DB as this transaction is a replay.\n+                result = Result.DELETE_FROM_KEY_ONLY;\n+                renameKeyInfoList.add(new OmRenameKeyInfo(\n+                    null, fromKeyValue));\n+              }\n+            }\n+\n+            if (result == null) {\n+              result = Result.REPLAY;\n+              // If toKey exists and fromKey does not, then no further action is\n+              // required. Return a dummy OMClientResponse.\n+              omClientResponse =\n+                  new OMKeysRenameResponse(createReplayOMResponse(\n+                      omResponse));\n+            }\n+          } else {\n+            // This transaction is not a replay. toKeyName should not exist\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else {\n+          // fromKeyName should exist\n+          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+          if (fromKeyValue == null) {\n+            // TODO: Add support for renaming open key\n+            throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+          }\n+\n+          fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+          fromKeyValue.setKeyName(toKeyName);\n+          //Set modification time\n+          fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n+\n+          renameKeyInfoList\n+              .add(new OmRenameKeyInfo(fromKeyName, fromKeyValue));\n+        }\n+      }\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()).build(),\n+          renameKeyInfoList, trxnLogIndex);\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse = new OMKeyDeleteResponse(\n+          createRenameKeysErrorOMResponse(omResponse, exception,\n+              unRenamedKeys));\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+    }\n+\n+    if (result == Result.SUCCESS || result == Result.FAILURE) {\n+      auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEY, auditMap,\n+          exception, getOmRequest().getUserInfo()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b73fe6fe0a9a76feb9b0c9924cc6120f2143b592"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MjA2MQ==", "bodyText": "Thanks @adoroszlai  for the review. Fixed this issue.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r449052061", "createdAt": "2020-07-02T14:41:20Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);\n+      }\n+\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        toKeyName = renameKeyRequest.getToKeyName();\n+        auditMap = buildAuditMap(renameKeyArgs, renameKeyRequest);\n+        renameRequest = renameKeyRequest;\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          throw new OMException(\"Key name is empty\",\n+              OMException.ResultCodes.INVALID_KEY_NAME);\n+        }\n+        // check Acls to see if user has access to perform delete operation on\n+        // old key and create operation on new key\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+            IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+        // Validate bucket and volume exists or not.\n+        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+        // Check if toKey exists\n+        fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          // Check if this transaction is a replay of ratis logs.\n+          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+            // Check if fromKey is still in the DB and created before this\n+            // replay.\n+            // For example, lets say we have the following sequence of\n+            // transactions.\n+            //   Trxn 1 : Create Key1\n+            //   Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+            // Now if these transactions are replayed:\n+            //   Replay Trxn 1 : Creates Key1 again it does not exist in DB\n+            //   Replay Trxn 2 : Key2 is not created as it exists in DB and\n+            //                   the request would be deemed a replay. But\n+            //                   Key1 is still in the DB and needs to be\n+            //                   deleted.\n+            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+            if (fromKeyValue != null) {\n+              // Check if this replay transaction was after the fromKey was\n+              // created. If so, we have to delete the fromKey.\n+              if (ozoneManager.isRatisEnabled() &&\n+                  trxnLogIndex > fromKeyValue.getUpdateID()) {\n+                // Add to cache. Only fromKey should be deleted. ToKey already\n+                // exists in DB as this transaction is a replay.\n+                result = Result.DELETE_FROM_KEY_ONLY;\n+                renameKeyInfoList.add(new OmRenameKeyInfo(\n+                    null, fromKeyValue));\n+              }\n+            }\n+\n+            if (result == null) {\n+              result = Result.REPLAY;\n+              // If toKey exists and fromKey does not, then no further action is\n+              // required. Return a dummy OMClientResponse.\n+              omClientResponse =\n+                  new OMKeysRenameResponse(createReplayOMResponse(\n+                      omResponse));\n+            }\n+          } else {\n+            // This transaction is not a replay. toKeyName should not exist\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else {\n+          // fromKeyName should exist\n+          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+          if (fromKeyValue == null) {\n+            // TODO: Add support for renaming open key\n+            throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+          }\n+\n+          fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+          fromKeyValue.setKeyName(toKeyName);\n+          //Set modification time\n+          fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n+\n+          renameKeyInfoList\n+              .add(new OmRenameKeyInfo(fromKeyName, fromKeyValue));\n+        }\n+      }\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()).build(),\n+          renameKeyInfoList, trxnLogIndex);\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse = new OMKeyDeleteResponse(\n+          createRenameKeysErrorOMResponse(omResponse, exception,\n+              unRenamedKeys));\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+    }\n+\n+    if (result == Result.SUCCESS || result == Result.FAILURE) {\n+      auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEY, auditMap,\n+          exception, getOmRequest().getUserInfo()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTM2NA=="}, "originalCommit": {"oid": "b73fe6fe0a9a76feb9b0c9924cc6120f2143b592"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMTQxNg==", "bodyText": "Thanks, but the new code only logs key names, other info eg. volume/bucket is missing.  Also, if result is failure, then all keys are logged as \"failure\", although only the last key failed (and we don't even know which one is last, since auditMap is a hashmap).", "url": "https://github.com/apache/ozone/pull/1150#discussion_r449131416", "createdAt": "2020-07-02T16:21:57Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);\n+      }\n+\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        toKeyName = renameKeyRequest.getToKeyName();\n+        auditMap = buildAuditMap(renameKeyArgs, renameKeyRequest);\n+        renameRequest = renameKeyRequest;\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          throw new OMException(\"Key name is empty\",\n+              OMException.ResultCodes.INVALID_KEY_NAME);\n+        }\n+        // check Acls to see if user has access to perform delete operation on\n+        // old key and create operation on new key\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+            IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+        // Validate bucket and volume exists or not.\n+        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+        // Check if toKey exists\n+        fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          // Check if this transaction is a replay of ratis logs.\n+          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+            // Check if fromKey is still in the DB and created before this\n+            // replay.\n+            // For example, lets say we have the following sequence of\n+            // transactions.\n+            //   Trxn 1 : Create Key1\n+            //   Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+            // Now if these transactions are replayed:\n+            //   Replay Trxn 1 : Creates Key1 again it does not exist in DB\n+            //   Replay Trxn 2 : Key2 is not created as it exists in DB and\n+            //                   the request would be deemed a replay. But\n+            //                   Key1 is still in the DB and needs to be\n+            //                   deleted.\n+            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+            if (fromKeyValue != null) {\n+              // Check if this replay transaction was after the fromKey was\n+              // created. If so, we have to delete the fromKey.\n+              if (ozoneManager.isRatisEnabled() &&\n+                  trxnLogIndex > fromKeyValue.getUpdateID()) {\n+                // Add to cache. Only fromKey should be deleted. ToKey already\n+                // exists in DB as this transaction is a replay.\n+                result = Result.DELETE_FROM_KEY_ONLY;\n+                renameKeyInfoList.add(new OmRenameKeyInfo(\n+                    null, fromKeyValue));\n+              }\n+            }\n+\n+            if (result == null) {\n+              result = Result.REPLAY;\n+              // If toKey exists and fromKey does not, then no further action is\n+              // required. Return a dummy OMClientResponse.\n+              omClientResponse =\n+                  new OMKeysRenameResponse(createReplayOMResponse(\n+                      omResponse));\n+            }\n+          } else {\n+            // This transaction is not a replay. toKeyName should not exist\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else {\n+          // fromKeyName should exist\n+          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+          if (fromKeyValue == null) {\n+            // TODO: Add support for renaming open key\n+            throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+          }\n+\n+          fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+          fromKeyValue.setKeyName(toKeyName);\n+          //Set modification time\n+          fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n+\n+          renameKeyInfoList\n+              .add(new OmRenameKeyInfo(fromKeyName, fromKeyValue));\n+        }\n+      }\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()).build(),\n+          renameKeyInfoList, trxnLogIndex);\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse = new OMKeyDeleteResponse(\n+          createRenameKeysErrorOMResponse(omResponse, exception,\n+              unRenamedKeys));\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+    }\n+\n+    if (result == Result.SUCCESS || result == Result.FAILURE) {\n+      auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEY, auditMap,\n+          exception, getOmRequest().getUserInfo()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTM2NA=="}, "originalCommit": {"oid": "b73fe6fe0a9a76feb9b0c9924cc6120f2143b592"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ5Nzg5Ng==", "bodyText": "Thanks adoroszlai  for the tip\uff0cI'll add a volume/bucket to the key.\nOn how to locate the failed key. We can see this in the Exception in client. Typically, the failed keys are displayed in the log with an Exception, such as:\n17:45:30.550 [OM StateMachine ApplyTransaction Thread - 0] ERROR OMAudit - user=micahzhao | ip=127.0.0.1 | op=RENAME_KEY {dir/key2=dir/file2, dir/file1=dir/file2} | ret=FAILURE\norg.apache.hadoop.ozone.om.exceptions.OMException: Key not found /a88fb570-5b5d-43db-81e0-d6597f4ea81f/4ad1e6c3-41c3-439d-8082-ae24a601ba38/dir/file1\nat org.apache.hadoop.ozone.om.request.key.OMKeysRenameRequest.validateAndUpdateCache\u2026\u2026", "url": "https://github.com/apache/ozone/pull/1150#discussion_r449497896", "createdAt": "2020-07-03T10:01:47Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    Set<OmKeyInfo> unRenamedKeys = new HashSet<>();\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String toKey = null;\n+    String fromKey = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        unRenamedKeys.add(omKeyInfo);\n+      }\n+\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs renameKeyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = renameKeyArgs.getVolumeName();\n+        bucketName = renameKeyArgs.getBucketName();\n+        fromKeyName = renameKeyArgs.getKeyName();\n+        toKeyName = renameKeyRequest.getToKeyName();\n+        auditMap = buildAuditMap(renameKeyArgs, renameKeyRequest);\n+        renameRequest = renameKeyRequest;\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          throw new OMException(\"Key name is empty\",\n+              OMException.ResultCodes.INVALID_KEY_NAME);\n+        }\n+        // check Acls to see if user has access to perform delete operation on\n+        // old key and create operation on new key\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+            IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+        // Validate bucket and volume exists or not.\n+        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+        // Check if toKey exists\n+        fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          // Check if this transaction is a replay of ratis logs.\n+          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+            // Check if fromKey is still in the DB and created before this\n+            // replay.\n+            // For example, lets say we have the following sequence of\n+            // transactions.\n+            //   Trxn 1 : Create Key1\n+            //   Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+            // Now if these transactions are replayed:\n+            //   Replay Trxn 1 : Creates Key1 again it does not exist in DB\n+            //   Replay Trxn 2 : Key2 is not created as it exists in DB and\n+            //                   the request would be deemed a replay. But\n+            //                   Key1 is still in the DB and needs to be\n+            //                   deleted.\n+            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+            if (fromKeyValue != null) {\n+              // Check if this replay transaction was after the fromKey was\n+              // created. If so, we have to delete the fromKey.\n+              if (ozoneManager.isRatisEnabled() &&\n+                  trxnLogIndex > fromKeyValue.getUpdateID()) {\n+                // Add to cache. Only fromKey should be deleted. ToKey already\n+                // exists in DB as this transaction is a replay.\n+                result = Result.DELETE_FROM_KEY_ONLY;\n+                renameKeyInfoList.add(new OmRenameKeyInfo(\n+                    null, fromKeyValue));\n+              }\n+            }\n+\n+            if (result == null) {\n+              result = Result.REPLAY;\n+              // If toKey exists and fromKey does not, then no further action is\n+              // required. Return a dummy OMClientResponse.\n+              omClientResponse =\n+                  new OMKeysRenameResponse(createReplayOMResponse(\n+                      omResponse));\n+            }\n+          } else {\n+            // This transaction is not a replay. toKeyName should not exist\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else {\n+          // fromKeyName should exist\n+          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+          if (fromKeyValue == null) {\n+            // TODO: Add support for renaming open key\n+            throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+          }\n+\n+          fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+          fromKeyValue.setKeyName(toKeyName);\n+          //Set modification time\n+          fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n+\n+          renameKeyInfoList\n+              .add(new OmRenameKeyInfo(fromKeyName, fromKeyValue));\n+        }\n+      }\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()).build(),\n+          renameKeyInfoList, trxnLogIndex);\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      omClientResponse = new OMKeyDeleteResponse(\n+          createRenameKeysErrorOMResponse(omResponse, exception,\n+              unRenamedKeys));\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+    }\n+\n+    if (result == Result.SUCCESS || result == Result.FAILURE) {\n+      auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEY, auditMap,\n+          exception, getOmRequest().getUserInfo()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTM2NA=="}, "originalCommit": {"oid": "b73fe6fe0a9a76feb9b0c9924cc6120f2143b592"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNzgxMzgwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMKeysRenameResponse.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQwMzoyNTo0NVrOGvAY2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNTo1MDoyMlrOGvqpdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk0MjYxNg==", "bodyText": "Adding to the cache should be done as part of ValidateAndUpdateCache.\nAs in HA, we return the response without DB flush to be completed. So, if we don't update the cache before returning the response, subsequent requests might thing still key exists.\nPosted PR for DeleteKeys regarding the same issue #1169", "url": "https://github.com/apache/ozone/pull/1150#discussion_r451942616", "createdAt": "2020-07-09T03:25:45Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMKeysRenameResponse.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.KEY_TABLE;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Response for RenameKeys request.\n+ */\n+@CleanupTableInfo(cleanupTables = {KEY_TABLE})\n+public class OMKeysRenameResponse extends OMClientResponse {\n+\n+  private List<OmRenameKeyInfo> renameKeyInfoList;\n+  private long trxnLogIndex;\n+  private String fromKeyName = null;\n+  private String toKeyName = null;\n+\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse,\n+                              List<OmRenameKeyInfo> renameKeyInfoList,\n+                              long trxnLogIndex) {\n+    super(omResponse);\n+    this.renameKeyInfoList = renameKeyInfoList;\n+    this.trxnLogIndex = trxnLogIndex;\n+  }\n+\n+\n+  /**\n+   * For when the request is not successful or it is a replay transaction.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  @Override\n+  public void addToDBBatch(OMMetadataManager omMetadataManager,\n+                           BatchOperation batchOperation) throws IOException {\n+    boolean acquiredLock = false;\n+    for (OmRenameKeyInfo omRenameKeyInfo : renameKeyInfoList) {\n+      String volumeName = omRenameKeyInfo.getNewKeyInfo().getVolumeName();\n+      String bucketName = omRenameKeyInfo.getNewKeyInfo().getBucketName();\n+      fromKeyName = omRenameKeyInfo.getFromKeyName();\n+      OmKeyInfo newKeyInfo = omRenameKeyInfo.getNewKeyInfo();\n+      toKeyName = newKeyInfo.getKeyName();\n+      Table<String, OmKeyInfo> keyTable = omMetadataManager\n+          .getKeyTable();\n+      try {\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                volumeName, bucketName);\n+        // If toKeyName is null, then we need to only delete the fromKeyName\n+        // from KeyTable. This is the case of replay where toKey exists but\n+        // fromKey has not been deleted.\n+        if (deleteFromKeyOnly()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe8c69a7305f10d151af3aa9768002866d7f6586"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk0MzA4NQ==", "bodyText": "And also replay code is now not required, as it is taken care of by HDDS-3354.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r451943085", "createdAt": "2020-07-09T03:27:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMKeysRenameResponse.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.KEY_TABLE;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Response for RenameKeys request.\n+ */\n+@CleanupTableInfo(cleanupTables = {KEY_TABLE})\n+public class OMKeysRenameResponse extends OMClientResponse {\n+\n+  private List<OmRenameKeyInfo> renameKeyInfoList;\n+  private long trxnLogIndex;\n+  private String fromKeyName = null;\n+  private String toKeyName = null;\n+\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse,\n+                              List<OmRenameKeyInfo> renameKeyInfoList,\n+                              long trxnLogIndex) {\n+    super(omResponse);\n+    this.renameKeyInfoList = renameKeyInfoList;\n+    this.trxnLogIndex = trxnLogIndex;\n+  }\n+\n+\n+  /**\n+   * For when the request is not successful or it is a replay transaction.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  @Override\n+  public void addToDBBatch(OMMetadataManager omMetadataManager,\n+                           BatchOperation batchOperation) throws IOException {\n+    boolean acquiredLock = false;\n+    for (OmRenameKeyInfo omRenameKeyInfo : renameKeyInfoList) {\n+      String volumeName = omRenameKeyInfo.getNewKeyInfo().getVolumeName();\n+      String bucketName = omRenameKeyInfo.getNewKeyInfo().getBucketName();\n+      fromKeyName = omRenameKeyInfo.getFromKeyName();\n+      OmKeyInfo newKeyInfo = omRenameKeyInfo.getNewKeyInfo();\n+      toKeyName = newKeyInfo.getKeyName();\n+      Table<String, OmKeyInfo> keyTable = omMetadataManager\n+          .getKeyTable();\n+      try {\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                volumeName, bucketName);\n+        // If toKeyName is null, then we need to only delete the fromKeyName\n+        // from KeyTable. This is the case of replay where toKey exists but\n+        // fromKey has not been deleted.\n+        if (deleteFromKeyOnly()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk0MjYxNg=="}, "originalCommit": {"oid": "fe8c69a7305f10d151af3aa9768002866d7f6586"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzNDk5OQ==", "bodyText": "Thanks Bharat for the suggestion, I have taken a close look at the implementation of #1169 with some very nice changes. In this PR I will synchronize the #1169 changes here to make sure they are implemented the same.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r452634999", "createdAt": "2020-07-10T05:50:22Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/response/key/OMKeysRenameResponse.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.response.key;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.BatchOperation;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.response.CleanupTableInfo;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.apache.hadoop.ozone.om.OmMetadataManagerImpl.KEY_TABLE;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Response for RenameKeys request.\n+ */\n+@CleanupTableInfo(cleanupTables = {KEY_TABLE})\n+public class OMKeysRenameResponse extends OMClientResponse {\n+\n+  private List<OmRenameKeyInfo> renameKeyInfoList;\n+  private long trxnLogIndex;\n+  private String fromKeyName = null;\n+  private String toKeyName = null;\n+\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse,\n+                              List<OmRenameKeyInfo> renameKeyInfoList,\n+                              long trxnLogIndex) {\n+    super(omResponse);\n+    this.renameKeyInfoList = renameKeyInfoList;\n+    this.trxnLogIndex = trxnLogIndex;\n+  }\n+\n+\n+  /**\n+   * For when the request is not successful or it is a replay transaction.\n+   * For a successful request, the other constructor should be used.\n+   */\n+  public OMKeysRenameResponse(@Nonnull OMResponse omResponse) {\n+    super(omResponse);\n+    checkStatusNotOK();\n+  }\n+\n+  @Override\n+  public void addToDBBatch(OMMetadataManager omMetadataManager,\n+                           BatchOperation batchOperation) throws IOException {\n+    boolean acquiredLock = false;\n+    for (OmRenameKeyInfo omRenameKeyInfo : renameKeyInfoList) {\n+      String volumeName = omRenameKeyInfo.getNewKeyInfo().getVolumeName();\n+      String bucketName = omRenameKeyInfo.getNewKeyInfo().getBucketName();\n+      fromKeyName = omRenameKeyInfo.getFromKeyName();\n+      OmKeyInfo newKeyInfo = omRenameKeyInfo.getNewKeyInfo();\n+      toKeyName = newKeyInfo.getKeyName();\n+      Table<String, OmKeyInfo> keyTable = omMetadataManager\n+          .getKeyTable();\n+      try {\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                volumeName, bucketName);\n+        // If toKeyName is null, then we need to only delete the fromKeyName\n+        // from KeyTable. This is the case of replay where toKey exists but\n+        // fromKey has not been deleted.\n+        if (deleteFromKeyOnly()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk0MjYxNg=="}, "originalCommit": {"oid": "fe8c69a7305f10d151af3aa9768002866d7f6586"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzEwODk3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo1MDoyNVrOGxMhbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzoyNTo0MFrOG5i5eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ==", "bodyText": "What's the benefit of building a Map<OmKeyArgs, String> compared to passing plain Map<String, String> keyMap directly?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r454238575", "createdAt": "2020-07-14T09:50:25Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxNTM1NA==", "bodyText": "The main purpose here is to keep up with the renameKey implementation and help make the code implementation clearer.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r454315354", "createdAt": "2020-07-14T12:21:54Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NTQ5Ng==", "bodyText": "The signature of OzoneManagerProtocol#renameKeys(Map<OmKeyArgs, String> keyMap) accepts a batch of keys in different volumes/buckets.  But RpcClient#renameKeys only supports renaming multiple keys in a single volume/bucket.\nMy concern is:\n\nlots of object conversion String -> OmKeyArgs -> KeyArgs\nvolume/bucket existence check performed for each key\n\nI think given the limitation in current RpcClient the above is unnecessary overhead.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456775496", "createdAt": "2020-07-18T10:25:51Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAxMTEwMQ==", "bodyText": "Here I'll modify RPCClient to use Map <OmKeyArgs, String> keyArgsMap directly.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r457011101", "createdAt": "2020-07-20T03:19:38Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA0MjcxMQ==", "bodyText": "It seems none of the methods implementing ClientProtocol have OmKeyArgs in the signature.  So I don't think renameKeys should do that either.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r457042711", "createdAt": "2020-07-20T04:39:45Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA1MTQ1Mw==", "bodyText": "Thanks for @adoroszlai 's reply. At present, our client calls RpcClient#renameKeys through OzoneBucket#renameKeys to batch renameKeys.  OzoneBucket is a bucket-level API, we can only rename Keys in a single volume/bucket use it.\nI will remove the volume/bucket existence check in OMKeysRenameRequest, it had already checked here. Any other suggestions for changes?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r457051453", "createdAt": "2020-07-20T04:59:24Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwODk1NA==", "bodyText": "Thanks @captainzmc for removing the existence check.  However, bucket link resolution is still performed for each key, which seems unnecessary since all keys are in the same volume/bucket.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462408954", "createdAt": "2020-07-29T15:57:10Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczNzQ1Mg==", "bodyText": "Thanks @adoroszlai's feedback.  I had added new commit to fix the problem.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462737452", "createdAt": "2020-07-30T05:04:48Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0NzA2MQ==", "bodyText": "I agree with @adoroszlai here, we don't need KeyArgs.\nHDDS-3930 created a new message DeleteKeyArgs {\nrequired string volumeName = 1;\nrequired string bucketName = 2;\nrepeated string keys = 3;\n}\nwe can come up with a new proto structure here some thing like below.\nmessage RenameKeysRequest {\noptional RenameKeyArgs renameKeyArgs = 1;\n}\nmessage RenameKeyArgs {\nrequired string volumeName = 1;\nrequired string bucketName = 2;\nrepeated RenameKey renameKeys = 3;\n}\nmessage RenameKey {\nrequired string fromKeyName;\nrequired string toKeyName;\n}\nI am not completely sure what is the benefit to be consistent with RenameKeyRequest message structure.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462747061", "createdAt": "2020-07-30T05:39:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0ODUyOA==", "bodyText": "sorry missed this, it has been already addressed. But I see we pass volumeName/bucketName with each Renamekey, we can set them only once, as right now rename is supported within a single volume/bucket", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462748528", "createdAt": "2020-07-30T05:44:47Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5Mzc4NQ==", "bodyText": "Thanks for @bharatviswa504 's suggestion.  Agree with your idea, I had already updated this PR. KeyArgs is no longer used. And set volumeName and bucketName only once. Can you help take another look?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462993785", "createdAt": "2020-07-30T13:25:40Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/rpc/RpcClient.java", "diffHunk": "@@ -750,6 +751,25 @@ public void renameKey(String volumeName, String bucketName,\n     ozoneManagerClient.renameKey(keyArgs, toKeyName);\n   }\n \n+  @Override\n+  public void renameKeys(String volumeName, String bucketName,\n+                         Map<String, String> keyMap) throws IOException {\n+    verifyVolumeName(volumeName);\n+    verifyBucketName(bucketName);\n+    HddsClientUtils.checkNotNull(keyMap);\n+    Map <OmKeyArgs, String> keyArgsMap = new HashMap<>();\n+    for (Map.Entry< String, String > entry : keyMap.entrySet()) {\n+      OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+          .setVolumeName(volumeName)\n+          .setBucketName(bucketName)\n+          .setKeyName(entry.getKey())\n+          .build();\n+      keyArgsMap.put(keyArgs, entry.getValue());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODU3NQ=="}, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzEyMTM1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo1Mzo0NlrOGxMowg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo1Mzo0NlrOGxMowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MDQ1MA==", "bodyText": "Replay logic was removed in 90e8211.  Can you please update the PR (also to resolve conflicts)?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r454240450", "createdAt": "2020-07-14T09:53:46Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  /**\n+   * Stores the result of request execution for Rename Requests.\n+   */\n+  private enum Result {\n+    SUCCESS,\n+    DELETE_FROM_KEY_ONLY,\n+    REPLAY,\n+    FAILURE,\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyNmae\n+    List<RenameKeyArgs> unRenamedKeys = new ArrayList<>();\n+\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = keyArgs.getVolumeName();\n+        bucketName = keyArgs.getBucketName();\n+        fromKeyName = keyArgs.getKeyName();\n+        toKeyName = renameKeyRequest.getToKeyName();\n+        renameRequest = renameKeyRequest;\n+\n+        RenameKeyArgs renameKeyArgs = RenameKeyArgs.newBuilder()\n+            .setVolumeName(volumeName).setBucketName(bucketName)\n+            .setFromKeyName(fromKeyName).setToKeyName(toKeyName).build();\n+\n+        try {\n+          // Validate bucket and volume exists or not.\n+          validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(renameKeyArgs);\n+          LOG.error(\"Validate bucket and volume exists failed\" +\n+              \"volumeName {} bucketName {}\", volumeName, bucketName, ex);\n+          continue;\n+        }\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          renameStatus = false;\n+          unRenamedKeys.add(renameKeyArgs);\n+          LOG.error(\"Key name is empty fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName);\n+          continue;\n+        }\n+\n+        try {\n+          // check Acls to see if user has access to perform delete operation\n+          // on old key and create operation on new key\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(renameKeyArgs);\n+          LOG.error(\"Acl check failed for fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName, ex);\n+          continue;\n+        }\n+\n+        // Check if toKey exists\n+        String fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        String toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          // Check if this transaction is a replay of ratis logs.\n+          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+            // Check if fromKey is still in the DB and created before this\n+            // replay.\n+            // For example, lets say we have the following sequence of\n+            // transactions.\n+            //   Trxn 1 : Create Key1\n+            //   Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+            // Now if these transactions are replayed:\n+            //   Replay Trxn 1 : Creates Key1 again it does not exist in DB\n+            //   Replay Trxn 2 : Key2 is not created as it exists in DB and\n+            //                   the request would be deemed a replay. But\n+            //                   Key1 is still in the DB and needs to be\n+            //                   deleted.\n+            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+            if (fromKeyValue != null) {\n+              // Check if this replay transaction was after the fromKey was\n+              // created. If so, we have to delete the fromKey.\n+              if (ozoneManager.isRatisEnabled() &&\n+                  trxnLogIndex > fromKeyValue.getUpdateID()) {\n+                acquiredLock =\n+                    omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                        volumeName, bucketName);\n+                // Add to cache. Only fromKey should be deleted. ToKey already\n+                // exists in DB as this transaction is a replay.\n+                Table<String, OmKeyInfo> keyTable = omMetadataManager\n+                    .getKeyTable();\n+                keyTable.addCacheEntry(new CacheKey<>(fromKey),\n+                    new CacheValue<>(Optional.absent(), trxnLogIndex));\n+                renameKeyInfoList.add(new OmRenameKeyInfo(\n+                    null, fromKeyValue));\n+              }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e7b564705860dc19589883a98e33ed9df749d3"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzQxNTY2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoxMTo1MlrOGzUlTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoxMTo1MlrOGzUlTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2Nzc4OA==", "bodyText": "Please consider changing to UnsupportedOperationException as\n\nNotImplementedException represents the case where the author has yet to implement the logic at this point in the program", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456467788", "createdAt": "2020-07-17T14:11:52Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManager.java", "diffHunk": "@@ -2202,6 +2202,14 @@ public OmKeyInfo lookupKey(OmKeyArgs args) throws IOException {\n     }\n   }\n \n+\n+  @Override\n+  public void renameKeys(Map<OmKeyArgs, String> omKeyArgsMap)\n+      throws IOException {\n+    throw new NotImplementedException(\"OzoneManager does not require this to \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzU2NTE3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OTo1MVrOGzWBDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0OTo1MVrOGzWBDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MTI3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // fromKeyName -> toKeyNmae\n          \n          \n            \n                // fromKeyName -> toKeyName", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456491277", "createdAt": "2020-07-17T14:49:51Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyNmae", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTQ5MzUwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocolPB/OzoneManagerProtocolClientSideTranslatorPB.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDoyNzo0MVrOGznXzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDoyNzo0MVrOGznXzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NTYyOQ==", "bodyText": "Shouldn't modification time be updated on OM server-side?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456775629", "createdAt": "2020-07-18T10:27:41Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/protocolPB/OzoneManagerProtocolClientSideTranslatorPB.java", "diffHunk": "@@ -675,6 +678,31 @@ public OmKeyInfo lookupKey(OmKeyArgs args) throws IOException {\n     return OmKeyInfo.getFromProtobuf(resp.getKeyInfo());\n   }\n \n+  @Override\n+  public void renameKeys(Map<OmKeyArgs, String> keyMap) throws IOException {\n+    RenameKeysRequest.Builder reqKeys = RenameKeysRequest.newBuilder();\n+    List<RenameKeyRequest> renameKeyRequestList  = new ArrayList<>();\n+    for (Map.Entry< OmKeyArgs, String> entry : keyMap.entrySet()) {\n+      RenameKeyRequest.Builder reqKey = RenameKeyRequest.newBuilder();\n+      OmKeyArgs args = entry.getKey();\n+      KeyArgs keyArgs = KeyArgs.newBuilder()\n+          .setVolumeName(args.getVolumeName())\n+          .setBucketName(args.getBucketName())\n+          .setKeyName(args.getKeyName())\n+          .setModificationTime(Time.now()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTQ5Mzk2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDoyODozNFrOGznYCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDoyODozNFrOGznYCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NTY4OQ==", "bodyText": "I think this belongs to a separate test case.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456775689", "createdAt": "2020-07-18T10:28:34Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "diffHunk": "@@ -1227,12 +1231,76 @@ public void testRenameKey()\n     } catch (OMException e) {\n       oe = e;\n     }\n-    Assert.assertEquals(ResultCodes.KEY_NOT_FOUND, oe.getResult());\n+    Assert.assertEquals(KEY_NOT_FOUND, oe.getResult());\n \n     key = bucket.getKey(toKeyName);\n     Assert.assertEquals(toKeyName, key.getName());\n   }\n \n+  @Test\n+  public void testKeysRename() throws Exception {\n+    String volumeName = UUID.randomUUID().toString();\n+    String bucketName = UUID.randomUUID().toString();\n+    String keyName1 = \"dir/file1\";\n+    String keyName2 = \"dir/file2\";\n+\n+    String newKeyName1 = \"dir/key1\";\n+    String newKeyName2 = \"dir/key2\";\n+\n+    String value = \"sample value\";\n+    store.createVolume(volumeName);\n+    OzoneVolume volume = store.getVolume(volumeName);\n+    volume.createBucket(bucketName);\n+    OzoneBucket bucket = volume.getBucket(bucketName);\n+    OzoneOutputStream out1 = bucket.createKey(keyName1,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out1.write(value.getBytes());\n+    out1.close();\n+    OzoneOutputStream out2 = bucket.createKey(keyName2,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out2.write(value.getBytes());\n+    out2.close();\n+    OzoneKey key1 = bucket.getKey(keyName1);\n+    OzoneKey key2 = bucket.getKey(keyName2);\n+    Assert.assertEquals(keyName1, key1.getName());\n+    Assert.assertEquals(keyName2, key2.getName());\n+\n+    Map<String, String> keyMap = new HashMap();\n+    keyMap.put(keyName1, newKeyName1);\n+    keyMap.put(keyName2, newKeyName2);\n+    bucket.renameKeys(keyMap);\n+\n+    Assert.assertEquals(newKeyName1, bucket.getKey(newKeyName1).getName());\n+    Assert.assertEquals(newKeyName2, bucket.getKey(newKeyName2).getName());\n+\n+    // old key should not exist\n+    try {\n+      bucket.getKey(keyName1);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(KEY_NOT_FOUND, ex.getResult());\n+    }\n+    try {\n+      bucket.getKey(keyName2);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(KEY_NOT_FOUND, ex.getResult());\n+    }\n+\n+    // rename nonexistent key\n+    Map<String, String> keyMap1 = new HashMap();\n+    keyMap1.put(keyName1, keyName2);\n+    keyMap1.put(newKeyName2, keyName2);\n+    try {\n+      bucket.renameKeys(keyMap1);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(PARTIAL_RENAME, ex.getResult());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTQ5NTA2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozMDowOVrOGznYmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozMDowOVrOGznYmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NTgzMg==", "bodyText": "This was recently removed in HDDS-3062, so it seems to be accidentally being added back (due to merge conflict?).", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456775832", "createdAt": "2020-07-18T10:30:09Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "diffHunk": "@@ -1227,12 +1231,76 @@ public void testRenameKey()\n     } catch (OMException e) {\n       oe = e;\n     }\n-    Assert.assertEquals(ResultCodes.KEY_NOT_FOUND, oe.getResult());\n+    Assert.assertEquals(KEY_NOT_FOUND, oe.getResult());\n \n     key = bucket.getKey(toKeyName);\n     Assert.assertEquals(toKeyName, key.getName());\n   }\n \n+  @Test\n+  public void testKeysRename() throws Exception {\n+    String volumeName = UUID.randomUUID().toString();\n+    String bucketName = UUID.randomUUID().toString();\n+    String keyName1 = \"dir/file1\";\n+    String keyName2 = \"dir/file2\";\n+\n+    String newKeyName1 = \"dir/key1\";\n+    String newKeyName2 = \"dir/key2\";\n+\n+    String value = \"sample value\";\n+    store.createVolume(volumeName);\n+    OzoneVolume volume = store.getVolume(volumeName);\n+    volume.createBucket(bucketName);\n+    OzoneBucket bucket = volume.getBucket(bucketName);\n+    OzoneOutputStream out1 = bucket.createKey(keyName1,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out1.write(value.getBytes());\n+    out1.close();\n+    OzoneOutputStream out2 = bucket.createKey(keyName2,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out2.write(value.getBytes());\n+    out2.close();\n+    OzoneKey key1 = bucket.getKey(keyName1);\n+    OzoneKey key2 = bucket.getKey(keyName2);\n+    Assert.assertEquals(keyName1, key1.getName());\n+    Assert.assertEquals(keyName2, key2.getName());\n+\n+    Map<String, String> keyMap = new HashMap();\n+    keyMap.put(keyName1, newKeyName1);\n+    keyMap.put(keyName2, newKeyName2);\n+    bucket.renameKeys(keyMap);\n+\n+    Assert.assertEquals(newKeyName1, bucket.getKey(newKeyName1).getName());\n+    Assert.assertEquals(newKeyName2, bucket.getKey(newKeyName2).getName());\n+\n+    // old key should not exist\n+    try {\n+      bucket.getKey(keyName1);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(KEY_NOT_FOUND, ex.getResult());\n+    }\n+    try {\n+      bucket.getKey(keyName2);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(KEY_NOT_FOUND, ex.getResult());\n+    }\n+\n+    // rename nonexistent key\n+    Map<String, String> keyMap1 = new HashMap();\n+    keyMap1.put(keyName1, keyName2);\n+    keyMap1.put(newKeyName2, keyName2);\n+    try {\n+      bucket.renameKeys(keyMap1);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(PARTIAL_RENAME, ex.getResult());\n+    }\n+  }\n+\n+  // Listing all volumes in the cluster feature has to be fixed after HDDS-357.\n+  // TODO: fix this\n+  @Ignore", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTQ5Njg3OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozMjo0MlrOGznZag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozMjo0MlrOGznZag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NjA0Mg==", "bodyText": "Please add support for bucket links.  Example:\nhttps://github.com/apache/hadoop-ozone/blob/3571d7e72688b008c2667997cb4d824ccc9a8a3e/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java#L134-L136\nauditMap needs to be created beforehand, eg.:\nhttps://github.com/apache/hadoop-ozone/blob/3571d7e72688b008c2667997cb4d824ccc9a8a3e/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java#L106", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456776042", "createdAt": "2020-07-18T10:32:42Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyNmae\n+    List<RenameKeyArgs> unRenamedKeys = new ArrayList<>();\n+\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        volumeName = keyArgs.getVolumeName();\n+        bucketName = keyArgs.getBucketName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTQ5OTkwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozODowNFrOGzna_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozODowNFrOGzna_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NjQ0Ng==", "bodyText": "Can you please extract to a helper method (eg. createTestKey) to avoid duplication?  (Also include following bucket.getKey and following assertEquals calls.)", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456776446", "createdAt": "2020-07-18T10:38:04Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "diffHunk": "@@ -1227,12 +1231,76 @@ public void testRenameKey()\n     } catch (OMException e) {\n       oe = e;\n     }\n-    Assert.assertEquals(ResultCodes.KEY_NOT_FOUND, oe.getResult());\n+    Assert.assertEquals(KEY_NOT_FOUND, oe.getResult());\n \n     key = bucket.getKey(toKeyName);\n     Assert.assertEquals(toKeyName, key.getName());\n   }\n \n+  @Test\n+  public void testKeysRename() throws Exception {\n+    String volumeName = UUID.randomUUID().toString();\n+    String bucketName = UUID.randomUUID().toString();\n+    String keyName1 = \"dir/file1\";\n+    String keyName2 = \"dir/file2\";\n+\n+    String newKeyName1 = \"dir/key1\";\n+    String newKeyName2 = \"dir/key2\";\n+\n+    String value = \"sample value\";\n+    store.createVolume(volumeName);\n+    OzoneVolume volume = store.getVolume(volumeName);\n+    volume.createBucket(bucketName);\n+    OzoneBucket bucket = volume.getBucket(bucketName);\n+    OzoneOutputStream out1 = bucket.createKey(keyName1,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out1.write(value.getBytes());\n+    out1.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTUwMDkwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozOTo1MlrOGznbdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMDozOTo1MlrOGznbdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3NjU2NA==", "bodyText": "Can you please extract to helper method (eg. assertKeyRenamed), and also include preceding assertEquals(newKeyName...) call?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r456776564", "createdAt": "2020-07-18T10:39:52Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/client/rpc/TestOzoneRpcClientAbstract.java", "diffHunk": "@@ -1227,12 +1231,76 @@ public void testRenameKey()\n     } catch (OMException e) {\n       oe = e;\n     }\n-    Assert.assertEquals(ResultCodes.KEY_NOT_FOUND, oe.getResult());\n+    Assert.assertEquals(KEY_NOT_FOUND, oe.getResult());\n \n     key = bucket.getKey(toKeyName);\n     Assert.assertEquals(toKeyName, key.getName());\n   }\n \n+  @Test\n+  public void testKeysRename() throws Exception {\n+    String volumeName = UUID.randomUUID().toString();\n+    String bucketName = UUID.randomUUID().toString();\n+    String keyName1 = \"dir/file1\";\n+    String keyName2 = \"dir/file2\";\n+\n+    String newKeyName1 = \"dir/key1\";\n+    String newKeyName2 = \"dir/key2\";\n+\n+    String value = \"sample value\";\n+    store.createVolume(volumeName);\n+    OzoneVolume volume = store.getVolume(volumeName);\n+    volume.createBucket(bucketName);\n+    OzoneBucket bucket = volume.getBucket(bucketName);\n+    OzoneOutputStream out1 = bucket.createKey(keyName1,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out1.write(value.getBytes());\n+    out1.close();\n+    OzoneOutputStream out2 = bucket.createKey(keyName2,\n+        value.getBytes().length, STAND_ALONE,\n+        ONE, new HashMap<>());\n+    out2.write(value.getBytes());\n+    out2.close();\n+    OzoneKey key1 = bucket.getKey(keyName1);\n+    OzoneKey key2 = bucket.getKey(keyName2);\n+    Assert.assertEquals(keyName1, key1.getName());\n+    Assert.assertEquals(keyName2, key2.getName());\n+\n+    Map<String, String> keyMap = new HashMap();\n+    keyMap.put(keyName1, newKeyName1);\n+    keyMap.put(keyName2, newKeyName2);\n+    bucket.renameKeys(keyMap);\n+\n+    Assert.assertEquals(newKeyName1, bucket.getKey(newKeyName1).getName());\n+    Assert.assertEquals(newKeyName2, bucket.getKey(newKeyName2).getName());\n+\n+    // old key should not exist\n+    try {\n+      bucket.getKey(keyName1);\n+    } catch (OMException ex) {\n+      Assert.assertEquals(KEY_NOT_FOUND, ex.getResult());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e698a7cdacc2f2cb089c9695789a3a540150b6ee"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDAzMDY2OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzozMjozOVrOG0Mpkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzozMjozOVrOG0Mpkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM4NjM4Nw==", "bodyText": "audit map cannot have multiple volume and bucket entries: each new call overwrites the previous values.\nvolumeName and bucketName reflect values from previous loop iteration (or null for first one).\nkey list should be processed for audit only after the loop, not on each iteration.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r457386387", "createdAt": "2020-07-20T13:32:39Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time in preExecute.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyName\n+    List<RenameKeyArgs> unRenamedKeys = new ArrayList<>();\n+\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = null;\n+    RenameKeyRequest renameRequest = null;\n+    String volumeName = null;\n+    String bucketName = null;\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            renameKeyRequest.getKeyArgs();\n+        auditMap = buildAuditMap(volumeName, bucketName, renameKeyInfoList,\n+            unRenamedKeys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e6fd89947564cd83fe726227f8ad0617dd41044"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTA3MzY1OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNToxNjo1OFrOG5Tcsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNToxNjo1OFrOG5Tcsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0MDY1OQ==", "bodyText": "Volume and bucket are already added to auditMap in resolveBucketLink, also accounting for the case when the requested bucket is a link.  Please remove these two lines to avoid overwriting the requested volume/bucket with the resolved one.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      auditMap.put(VOLUME, volumeName);\n          \n          \n            \n                      auditMap.put(BUCKET, bucketName);", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462740659", "createdAt": "2020-07-30T05:16:58Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+  private String volumeName = null;\n+  private String bucketName = null;\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time in preExecute.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyName\n+    List<RenameKeyArgs> unRenamedKeys = new ArrayList<>();\n+\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        // resolve Bucket Link at the first time.\n+        if (bucketName == null) {\n+          keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+          volumeName = keyArgs.getVolumeName();\n+          bucketName = keyArgs.getBucketName();\n+          auditMap.put(VOLUME, volumeName);\n+          auditMap.put(BUCKET, bucketName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1070e962c0cace7a49a8da4f8e6a0f7c0536c31"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTA3ODMxOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNToxOTo1NVrOG5Tfeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNToxOTo1NVrOG5Tfeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0MTM3MA==", "bodyText": "For all other keys I think we should verify that the volume/bucket is the same as for the first key.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462741370", "createdAt": "2020-07-30T05:19:55Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmRenameKeyInfo;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.BUCKET;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.VOLUME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+  private String volumeName = null;\n+  private String bucketName = null;\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+\n+    RenameKeysRequest renameKeys = getOmRequest().getRenameKeysRequest();\n+    Preconditions.checkNotNull(renameKeys);\n+\n+    List<RenameKeyRequest> renameKeyList = new ArrayList<>();\n+    for (RenameKeyRequest renameKey : renameKeys.getRenameKeyRequestList()) {\n+      // Set modification time in preExecute.\n+      KeyArgs.Builder newKeyArgs = renameKey.getKeyArgs().toBuilder()\n+          .setModificationTime(Time.now());\n+      renameKey.toBuilder().setKeyArgs(newKeyArgs);\n+      renameKeyList.add(renameKey);\n+\n+    }\n+    RenameKeysRequest renameKeysRequest = RenameKeysRequest\n+        .newBuilder().addAllRenameKeyRequest(renameKeyList).build();\n+    return getOmRequest().toBuilder().setRenameKeysRequest(renameKeysRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    OMClientResponse omClientResponse = null;\n+    // fromKeyName -> toKeyName\n+    List<RenameKeyArgs> unRenamedKeys = new ArrayList<>();\n+\n+    List<OmRenameKeyInfo> renameKeyInfoList = new ArrayList<>();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      for (RenameKeyRequest renameKeyRequest : renameKeysRequest\n+          .getRenameKeyRequestList()) {\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            renameKeyRequest.getKeyArgs();\n+\n+        // resolve Bucket Link at the first time.\n+        if (bucketName == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1070e962c0cace7a49a8da4f8e6a0f7c0536c31"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTA4ODAzOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/interface-client/src/main/resources/proto.lock", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNToyNToyNVrOG5TlPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzoyNjowMVrOG5i6Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0Mjg0Ng==", "bodyText": "Please remove changes to proto.lock from the patch.  See HDDS-3991 for details.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462742846", "createdAt": "2020-07-30T05:25:25Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/interface-client/src/main/resources/proto.lock", "diffHunk": "@@ -83,6 +83,10 @@\n                 \"name\": \"DeleteKeys\",\n                 \"integer\": 38\n               },\n+              {\n+                \"name\": \"RenameKeys\",\n+                \"integer\": 39\n+              },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1070e962c0cace7a49a8da4f8e6a0f7c0536c31"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5Mzk5OQ==", "bodyText": "Thanks for @adoroszlai 's advice. Fixed the issues mentioned above. Can you help take another look?", "url": "https://github.com/apache/ozone/pull/1150#discussion_r462993999", "createdAt": "2020-07-30T13:26:01Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/interface-client/src/main/resources/proto.lock", "diffHunk": "@@ -83,6 +83,10 @@\n                 \"name\": \"DeleteKeys\",\n                 \"integer\": 38\n               },\n+              {\n+                \"name\": \"RenameKeys\",\n+                \"integer\": 39\n+              },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc0Mjg0Ng=="}, "originalCommit": {"oid": "e1070e962c0cace7a49a8da4f8e6a0f7c0536c31"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDc5NDIyOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1MDoyM1rOG5j6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1MDoyM1rOG5j6Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxMDMyNg==", "bodyText": "Avoid eager toString() call in logging (especially debug).\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      auditMap.toString());\n          \n          \n            \n                      auditMap);", "url": "https://github.com/apache/ozone/pull/1150#discussion_r463010326", "createdAt": "2020-07-30T13:50:23Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmRenameKeys;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysMap;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    RenameKeysArgs renameKeysArgs = renameKeysRequest.getRenameKeysArgs();\n+    String volumeName = renameKeysArgs.getVolumeName();\n+    String bucketName = renameKeysArgs.getBucketName();\n+    OMClientResponse omClientResponse = null;\n+\n+    List<RenameKeysMap> unRenamedKeys = new ArrayList<>();\n+\n+    // fromKeyName -> toKeyName\n+    Map<String, String> renamedKeys = new HashMap<>();\n+\n+    Map<String, OmKeyInfo> fromKeyAndToKeyInfo = new HashMap<>();\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      ResolvedBucket bucket = ozoneManager.resolveBucketLink(\n+          Pair.of(volumeName, bucketName));\n+      bucket.audit(auditMap);\n+      volumeName = bucket.realVolume();\n+      bucketName = bucket.realBucket();\n+\n+      for (RenameKeysMap renameKey : renameKeysArgs.getRenameKeysMapList()) {\n+\n+        fromKeyName = renameKey.getFromKeyName();\n+        toKeyName = renameKey.getToKeyName();\n+        RenameKeysMap.Builder unRenameKey = RenameKeysMap.newBuilder();\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Key name is empty fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName);\n+          continue;\n+        }\n+\n+        try {\n+          // check Acls to see if user has access to perform delete operation\n+          // on old key and create operation on new key\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Acl check failed for fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName, ex);\n+          continue;\n+        }\n+\n+        // Check if toKey exists\n+        String fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        String toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request name of new key {} already exists\",\n+              toKeyName);\n+        }\n+\n+        // fromKeyName should exist\n+        fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+        if (fromKeyValue == null) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request to rename a Key does not exist {}\",\n+              fromKey);\n+          continue;\n+        }\n+\n+        fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+        fromKeyValue.setKeyName(toKeyName);\n+\n+        //Set modification time\n+        fromKeyValue.setModificationTime(Time.now());\n+\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                volumeName, bucketName);\n+        // Add to cache.\n+        // fromKey should be deleted, toKey should be added with newly updated\n+        // omKeyInfo.\n+        Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n+        keyTable.addCacheEntry(new CacheKey<>(fromKey),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+        keyTable.addCacheEntry(new CacheKey<>(toKey),\n+            new CacheValue<>(Optional.of(fromKeyValue), trxnLogIndex));\n+        renamedKeys.put(fromKeyName, toKeyName);\n+        fromKeyAndToKeyInfo.put(fromKeyName, fromKeyValue);\n+        if (acquiredLock) {\n+          omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+          acquiredLock = false;\n+        }\n+      }\n+\n+      acquiredLock =\n+          omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+      OmRenameKeys newOmRenameKeys =\n+          new OmRenameKeys(volumeName, bucketName, null, fromKeyAndToKeyInfo);\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()\n+              .setStatus(renameStatus)\n+              .addAllUnRenamedKeys(unRenamedKeys))\n+          .setStatus(renameStatus ? OK : PARTIAL_RENAME)\n+          .setSuccess(renameStatus).build(),\n+          newOmRenameKeys);\n+\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      omResponse.setRenameKeysResponse(RenameKeysResponse.newBuilder()\n+          .setStatus(renameStatus).addAllUnRenamedKeys(unRenamedKeys).build());\n+      omClientResponse = new OMKeysRenameResponse(omResponse.build());\n+\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditMap = buildAuditMap(auditMap, renamedKeys, unRenamedKeys);\n+    auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEYS, auditMap,\n+        exception, getOmRequest().getUserInfo()));\n+\n+    switch (result) {\n+    case SUCCESS:\n+      LOG.debug(\"Rename Keys is successfully completed for auditMap:{}.\",\n+          auditMap.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f5fda0f24ecef4f5014c1a85839c542ee579a4d"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDc5NTAwOnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1MDozMlrOG5j6hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1MDozMlrOG5j6hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxMDQzNw==", "bodyText": "Avoid eager toString() call in logging.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Rename keys failed for auditMap:{}.\", auditMap.toString());\n          \n          \n            \n                  LOG.error(\"Rename keys failed for auditMap:{}.\", auditMap);", "url": "https://github.com/apache/ozone/pull/1150#discussion_r463010437", "createdAt": "2020-07-30T13:50:32Z", "author": {"login": "adoroszlai"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmRenameKeys;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysMap;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    RenameKeysArgs renameKeysArgs = renameKeysRequest.getRenameKeysArgs();\n+    String volumeName = renameKeysArgs.getVolumeName();\n+    String bucketName = renameKeysArgs.getBucketName();\n+    OMClientResponse omClientResponse = null;\n+\n+    List<RenameKeysMap> unRenamedKeys = new ArrayList<>();\n+\n+    // fromKeyName -> toKeyName\n+    Map<String, String> renamedKeys = new HashMap<>();\n+\n+    Map<String, OmKeyInfo> fromKeyAndToKeyInfo = new HashMap<>();\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      ResolvedBucket bucket = ozoneManager.resolveBucketLink(\n+          Pair.of(volumeName, bucketName));\n+      bucket.audit(auditMap);\n+      volumeName = bucket.realVolume();\n+      bucketName = bucket.realBucket();\n+\n+      for (RenameKeysMap renameKey : renameKeysArgs.getRenameKeysMapList()) {\n+\n+        fromKeyName = renameKey.getFromKeyName();\n+        toKeyName = renameKey.getToKeyName();\n+        RenameKeysMap.Builder unRenameKey = RenameKeysMap.newBuilder();\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Key name is empty fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName);\n+          continue;\n+        }\n+\n+        try {\n+          // check Acls to see if user has access to perform delete operation\n+          // on old key and create operation on new key\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Acl check failed for fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName, ex);\n+          continue;\n+        }\n+\n+        // Check if toKey exists\n+        String fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        String toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request name of new key {} already exists\",\n+              toKeyName);\n+        }\n+\n+        // fromKeyName should exist\n+        fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+        if (fromKeyValue == null) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request to rename a Key does not exist {}\",\n+              fromKey);\n+          continue;\n+        }\n+\n+        fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+        fromKeyValue.setKeyName(toKeyName);\n+\n+        //Set modification time\n+        fromKeyValue.setModificationTime(Time.now());\n+\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+                volumeName, bucketName);\n+        // Add to cache.\n+        // fromKey should be deleted, toKey should be added with newly updated\n+        // omKeyInfo.\n+        Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n+        keyTable.addCacheEntry(new CacheKey<>(fromKey),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+        keyTable.addCacheEntry(new CacheKey<>(toKey),\n+            new CacheValue<>(Optional.of(fromKeyValue), trxnLogIndex));\n+        renamedKeys.put(fromKeyName, toKeyName);\n+        fromKeyAndToKeyInfo.put(fromKeyName, fromKeyValue);\n+        if (acquiredLock) {\n+          omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+          acquiredLock = false;\n+        }\n+      }\n+\n+      acquiredLock =\n+          omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+      OmRenameKeys newOmRenameKeys =\n+          new OmRenameKeys(volumeName, bucketName, null, fromKeyAndToKeyInfo);\n+      omClientResponse = new OMKeysRenameResponse(omResponse\n+          .setRenameKeysResponse(RenameKeysResponse.newBuilder()\n+              .setStatus(renameStatus)\n+              .addAllUnRenamedKeys(unRenamedKeys))\n+          .setStatus(renameStatus ? OK : PARTIAL_RENAME)\n+          .setSuccess(renameStatus).build(),\n+          newOmRenameKeys);\n+\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      omResponse.setRenameKeysResponse(RenameKeysResponse.newBuilder()\n+          .setStatus(renameStatus).addAllUnRenamedKeys(unRenamedKeys).build());\n+      omClientResponse = new OMKeysRenameResponse(omResponse.build());\n+\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditMap = buildAuditMap(auditMap, renamedKeys, unRenamedKeys);\n+    auditLog(auditLogger, buildAuditMessage(OMAction.RENAME_KEYS, auditMap,\n+        exception, getOmRequest().getUserInfo()));\n+\n+    switch (result) {\n+    case SUCCESS:\n+      LOG.debug(\"Rename Keys is successfully completed for auditMap:{}.\",\n+          auditMap.toString());\n+      break;\n+    case FAILURE:\n+      ozoneManager.getMetrics().incNumKeyRenameFails();\n+      LOG.error(\"Rename keys failed for auditMap:{}.\", auditMap.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f5fda0f24ecef4f5014c1a85839c542ee579a4d"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MzMxMzA5OnYy", "diffSide": "RIGHT", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDo0NzowNFrOG572xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNToyMjoyNlrOG58WIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMjY5Mw==", "bodyText": "I think here we should acquire lock and release lock at end of the operation.\nLets say this thread checked the fromKey and toKey and other delete thread acquire the lock and deleted the fromKey and this thread waiting for lock, once delete completes we update the cache and rename it to toKey.\nSo, now we renamed a deleted Key.\nAnd also there can be other scenarios like commitKey committed toKey and this thread assumes there is no such Key.\nTo avoid these kinds of scenarios check of Key from Table and add to Response should be done holding lock.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r463402693", "createdAt": "2020-07-31T04:47:04Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmRenameKeys;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysMap;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    RenameKeysArgs renameKeysArgs = renameKeysRequest.getRenameKeysArgs();\n+    String volumeName = renameKeysArgs.getVolumeName();\n+    String bucketName = renameKeysArgs.getBucketName();\n+    OMClientResponse omClientResponse = null;\n+\n+    List<RenameKeysMap> unRenamedKeys = new ArrayList<>();\n+\n+    // fromKeyName -> toKeyName\n+    Map<String, String> renamedKeys = new HashMap<>();\n+\n+    Map<String, OmKeyInfo> fromKeyAndToKeyInfo = new HashMap<>();\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      ResolvedBucket bucket = ozoneManager.resolveBucketLink(\n+          Pair.of(volumeName, bucketName));\n+      bucket.audit(auditMap);\n+      volumeName = bucket.realVolume();\n+      bucketName = bucket.realBucket();\n+\n+      for (RenameKeysMap renameKey : renameKeysArgs.getRenameKeysMapList()) {\n+\n+        fromKeyName = renameKey.getFromKeyName();\n+        toKeyName = renameKey.getToKeyName();\n+        RenameKeysMap.Builder unRenameKey = RenameKeysMap.newBuilder();\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Key name is empty fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName);\n+          continue;\n+        }\n+\n+        try {\n+          // check Acls to see if user has access to perform delete operation\n+          // on old key and create operation on new key\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Acl check failed for fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName, ex);\n+          continue;\n+        }\n+\n+        // Check if toKey exists\n+        String fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        String toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request name of new key {} already exists\",\n+              toKeyName);\n+        }\n+\n+        // fromKeyName should exist\n+        fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+        if (fromKeyValue == null) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request to rename a Key does not exist {}\",\n+              fromKey);\n+          continue;\n+        }\n+\n+        fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+        fromKeyValue.setKeyName(toKeyName);\n+\n+        //Set modification time\n+        fromKeyValue.setModificationTime(Time.now());\n+\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab6714b4fcc8a2bb238a6bf241d211fce5dad3a5"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMDcyMw==", "bodyText": "Thank @bharatviswa504 . Agreed and  updated  this PR  to fix the problem.", "url": "https://github.com/apache/ozone/pull/1150#discussion_r463410723", "createdAt": "2020-07-31T05:22:26Z", "author": {"login": "captainzmc"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysRenameRequest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmRenameKeys;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeysRenameResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysMap;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.RenameKeysResponse;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.OK;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.PARTIAL_RENAME;\n+import static org.apache.hadoop.ozone.OzoneConsts.RENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.OzoneConsts.UNRENAMED_KEYS_MAP;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename keys request.\n+ */\n+public class OMKeysRenameRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMKeysRenameRequest.class);\n+\n+  public OMKeysRenameRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeysRequest renameKeysRequest = getOmRequest().getRenameKeysRequest();\n+    RenameKeysArgs renameKeysArgs = renameKeysRequest.getRenameKeysArgs();\n+    String volumeName = renameKeysArgs.getVolumeName();\n+    String bucketName = renameKeysArgs.getBucketName();\n+    OMClientResponse omClientResponse = null;\n+\n+    List<RenameKeysMap> unRenamedKeys = new ArrayList<>();\n+\n+    // fromKeyName -> toKeyName\n+    Map<String, String> renamedKeys = new HashMap<>();\n+\n+    Map<String, OmKeyInfo> fromKeyAndToKeyInfo = new HashMap<>();\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue = null;\n+    Result result = null;\n+    Map<String, String> auditMap = new LinkedHashMap<>();\n+    String fromKeyName = null;\n+    String toKeyName = null;\n+    boolean acquiredLock = false;\n+    boolean renameStatus = true;\n+\n+    try {\n+      ResolvedBucket bucket = ozoneManager.resolveBucketLink(\n+          Pair.of(volumeName, bucketName));\n+      bucket.audit(auditMap);\n+      volumeName = bucket.realVolume();\n+      bucketName = bucket.realBucket();\n+\n+      for (RenameKeysMap renameKey : renameKeysArgs.getRenameKeysMapList()) {\n+\n+        fromKeyName = renameKey.getFromKeyName();\n+        toKeyName = renameKey.getToKeyName();\n+        RenameKeysMap.Builder unRenameKey = RenameKeysMap.newBuilder();\n+\n+        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Key name is empty fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName);\n+          continue;\n+        }\n+\n+        try {\n+          // check Acls to see if user has access to perform delete operation\n+          // on old key and create operation on new key\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+        } catch (Exception ex) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Acl check failed for fromKeyName {} toKeyName {}\",\n+              fromKeyName, toKeyName, ex);\n+          continue;\n+        }\n+\n+        // Check if toKey exists\n+        String fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            fromKeyName);\n+        String toKey =\n+            omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+        if (toKeyValue != null) {\n+\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request name of new key {} already exists\",\n+              toKeyName);\n+        }\n+\n+        // fromKeyName should exist\n+        fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+        if (fromKeyValue == null) {\n+          renameStatus = false;\n+          unRenamedKeys.add(\n+              unRenameKey.setFromKeyName(fromKeyName).setToKeyName(toKeyName)\n+                  .build());\n+          LOG.error(\"Received a request to rename a Key does not exist {}\",\n+              fromKey);\n+          continue;\n+        }\n+\n+        fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+        fromKeyValue.setKeyName(toKeyName);\n+\n+        //Set modification time\n+        fromKeyValue.setModificationTime(Time.now());\n+\n+        acquiredLock =\n+            omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMjY5Mw=="}, "originalCommit": {"oid": "ab6714b4fcc8a2bb238a6bf241d211fce5dad3a5"}, "originalPosition": 187}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4156, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}