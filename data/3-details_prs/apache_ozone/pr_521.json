{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNDIxODIx", "number": 521, "title": "HDDS-2592 Add Datanode command to allow the datanode to persist its admin state", "bodyText": "What changes were proposed in this pull request?\nWhen the datanode state is change in SCMNodeManager a Datanode Command is created to transmit the new datanode state to the datanode. The datanode will then persist this state in the \"datanodeID.yaml\" file.\nThe current datanode.yaml file simply persists a DatanodeDetails object in YAML format. Therefore two new fields have been added to DatanodeDetails to support this:\npersistedOpState,\npersistedOpStateExpiryEpochSec\nThe first is the operational state and the second is the seconds from the epoch the setting should expire (for maintenance mode).\nWhen a datanode starts up, it will read these values and supply them in the heartbeat to SCM.\nIf SCM notices the DN was registered before, SCM is seen as the source of truth and will update the DN state to that set in SCM if they differ.\nIf the DN was never registered with SCM (eg if SCM was restarted), then the DN state is seen as the source of truth and SCM will be updated accordingly.\nThis change also moves the state expiry time into the NodeStatus object, so it now carries operationalState, healthState and State expiry.\nNote that the DN does not do anything with the persisted operational state. They are simply persisted and reported in the heartbeat. In this respect the DNs are being used as a form of distributed storage for the operational state so the decommission process can survive a restart.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-2592\nHow was this patch tested?\nTested manually using a docker build. This change still needs unit tests added if the current approach is agreed upon.", "createdAt": "2020-02-03T16:59:04Z", "url": "https://github.com/apache/ozone/pull/521", "merged": true, "mergeCommit": {"oid": "d902586b7ca39083ba66ea19778b537212bc42d3"}, "closed": true, "closedAt": "2020-03-31T21:58:41Z", "author": {"login": "sodonnel"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb58iKjAH2gAyMzcwNDIxODIxOjgyNTQyY2UyYzk2YTNjZmIxMDM2ZDA5MjhmZDdiMThjYmE4YWIyN2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFe_NlAFqTM2MDIwNzM2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "82542ce2c96a3cfb1036d0928fd7b18cba8ab27a", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/82542ce2c96a3cfb1036d0928fd7b18cba8ab27a", "committedDate": "2020-01-13T13:40:14Z", "message": "Store operational state exiry in the NodeStatus object"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "773d9289f9b3d1fb6d14a8004a0683c0960c33a0", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/773d9289f9b3d1fb6d14a8004a0683c0960c33a0", "committedDate": "2020-01-14T10:48:01Z", "message": "Added new datanode command to transfer any change in the operational state to the datanode via the existing command queue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1649a5da864a512194c1d8dcd23a05c9bbfdbf99", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/1649a5da864a512194c1d8dcd23a05c9bbfdbf99", "committedDate": "2020-01-14T11:13:04Z", "message": "Used the HddsProto operational state everywhere and fixed some style issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78747387cd3c1dbda27b7b4da9cd8427d05f7b3d", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/78747387cd3c1dbda27b7b4da9cd8427d05f7b3d", "committedDate": "2020-01-15T15:36:01Z", "message": "Handle the SetNodeOperationalState command on the datanode and persist the values in the datanode yaml file (datanode.id) and ensure the parameters are sent with registration and the heartbeat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05", "author": {"user": null}, "url": "https://github.com/apache/ozone/commit/2c8ed938a26764a3f95b33b2dd05b8691c8dee05", "committedDate": "2020-01-17T12:00:52Z", "message": "Handle the persisted NodeStatus and expiry from the datanode on SCM during registration and heartbeat"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjA5Mzkz", "url": "https://github.com/apache/ozone/pull/521#pullrequestreview-353209393", "createdAt": "2020-02-04T18:39:16Z", "commit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozOToxNlrOFlfEzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo0OToyN1rOFlfZyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDc2NA==", "bodyText": "Shouldn't this be also inside the if != null ? , I am going to presume that even if we have no data, datanodeDetailsYaml.getPersistedOpStateExpiryEpochSec is going to return zero, but since the expiry is a long, JVM would initialize it to zero by default, would it not?. So curious why this check is outside the if.", "url": "https://github.com/apache/ozone/pull/521#discussion_r374850764", "createdAt": "2020-02-04T18:39:16Z", "author": {"login": "anuengineer"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/helpers/DatanodeIdYaml.java", "diffHunk": "@@ -82,6 +83,12 @@ public static DatanodeDetails readDatanodeIdFile(File path)\n           .setIpAddress(datanodeDetailsYaml.getIpAddress())\n           .setHostName(datanodeDetailsYaml.getHostName())\n           .setCertSerialId(datanodeDetailsYaml.getCertSerialId());\n+      if (datanodeDetailsYaml.getPersistedOpState() != null) {\n+        builder.setPersistedOpState(HddsProtos.NodeOperationalState.valueOf(\n+            datanodeDetailsYaml.getPersistedOpState()));\n+      }\n+      builder.setPersistedOpStateExpiry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MzU2OQ==", "bodyText": "We can add this to the Dn reports if you want to propagate this back into SCM.", "url": "https://github.com/apache/ozone/pull/521#discussion_r374853569", "createdAt": "2020-02-04T18:44:39Z", "author": {"login": "anuengineer"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/commandhandler/SetNodeOperationalStateCommandHandler.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.container.common.statemachine.commandhandler;\n+\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos;\n+import org.apache.hadoop.hdds.scm.HddsServerUtil;\n+import org.apache.hadoop.hdds.scm.ScmConfigKeys;\n+import org.apache.hadoop.ozone.container.common.helpers.ContainerUtils;\n+import org.apache.hadoop.ozone.container.common.statemachine.SCMConnectionManager;\n+import org.apache.hadoop.ozone.container.common.statemachine.StateContext;\n+import org.apache.hadoop.ozone.container.ozoneimpl.OzoneContainer;\n+import org.apache.hadoop.ozone.protocol.commands.SCMCommand;\n+import org.apache.hadoop.ozone.protocol.commands.SetNodeOperationalStateCommand;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import org.apache.hadoop.hdds.protocol.proto.\n+    StorageContainerDatanodeProtocolProtos.SCMCommandProto.Type;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Handle the SetNodeOperationalStateCommand sent from SCM to the datanode\n+ * to persist the current operational state.\n+ */\n+public class SetNodeOperationalStateCommandHandler implements CommandHandler {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SetNodeOperationalStateCommandHandler.class);\n+  private final Configuration conf;\n+  private final AtomicInteger invocationCount = new AtomicInteger(0);\n+  private final AtomicLong totalTime = new AtomicLong(0);\n+\n+  /**\n+   * Set Node State command handler.\n+   *\n+   * @param conf - Configuration for the datanode.\n+   */\n+  public SetNodeOperationalStateCommandHandler(Configuration conf) {\n+    this.conf = conf;\n+  }\n+\n+  /**\n+   * Handles a given SCM command.\n+   *\n+   * @param command - SCM Command\n+   * @param container - Ozone Container.\n+   * @param context - Current Context.\n+   * @param connectionManager - The SCMs that we are talking to.\n+   */\n+  @Override\n+  public void handle(SCMCommand command, OzoneContainer container,\n+      StateContext context, SCMConnectionManager connectionManager) {\n+    long startTime = Time.monotonicNow();\n+    invocationCount.incrementAndGet();\n+    StorageContainerDatanodeProtocolProtos.SetNodeOperationalStateCommandProto\n+        setNodeCmdProto = null;\n+\n+    if (command.getType() != Type.setNodeOperationalStateCommand) {\n+      LOG.warn(\"Skipping handling command, expected command \"\n+              + \"type {} but found {}\",\n+          Type.setNodeOperationalStateCommand, command.getType());\n+      return;\n+    }\n+    SetNodeOperationalStateCommand setNodeCmd =\n+        (SetNodeOperationalStateCommand) command;\n+    setNodeCmdProto = setNodeCmd.getProto();\n+    DatanodeDetails dni = context.getParent().getDatanodeDetails();\n+    dni.setPersistedOpState(setNodeCmdProto.getNodeOperationalState());\n+    dni.setPersistedOpStateExpiryEpochSec(\n+        setNodeCmd.getStateExpiryEpochSeconds());\n+    try {\n+      persistDatanodeDetails(dni);\n+    } catch (IOException ioe) {\n+      LOG.error(\"Failed to persist the datanode state\", ioe);\n+      // TODO - this should probably be raised, but it will break the command", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NjEzNg==", "bodyText": "Since zero is the default value for the long, would it make sense to enforce time; that is for each set command we need an explicit time. In that case, we can define a constant called INFINITY and set it to something like -1; but in the source, it will be very explicit when someone reads code, and in the command handler we can enforce the requirement (or perhaps better on the SCM side). So commands like decommission will have an infinite value explicitly set by SCM and it would be more obvious and explicit.", "url": "https://github.com/apache/ozone/pull/521#discussion_r374856136", "createdAt": "2020-02-04T18:49:27Z", "author": {"login": "anuengineer"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/helpers/DatanodeIdYaml.java", "diffHunk": "@@ -105,6 +112,8 @@ public static DatanodeDetails readDatanodeIdFile(File path)\n     private String ipAddress;\n     private String hostName;\n     private String certSerialId;\n+    private String persistedOpState;\n+    private long persistedOpStateExpiryEpochSec = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjA3MzYx", "url": "https://github.com/apache/ozone/pull/521#pullrequestreview-360207361", "createdAt": "2020-02-18T10:01:54Z", "commit": {"oid": "2c8ed938a26764a3f95b33b2dd05b8691c8dee05"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3827, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}