{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2Njc4NTQ3", "number": 1557, "title": "HDDS-4357: Rename : make rename an atomic ops by updating key path entry in dir/file table", "bodyText": "What changes were proposed in this pull request?\nThis task is to handle rename key path request and make it an atomic operation by updating the DirTable or FileTable.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-4357\nHow was this patch tested?\nAdded TestOzoneFileSystemV1 UT. I will add more unit test cases eventually.", "createdAt": "2020-11-06T11:16:56Z", "url": "https://github.com/apache/ozone/pull/1557", "merged": true, "mergeCommit": {"oid": "ff04733f18879572db9c28a8a68e4122ea42708b"}, "closed": true, "closedAt": "2020-11-19T15:53:46Z", "author": {"login": "rakeshadr"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZ0_xuAH2gAyNTE2Njc4NTQ3Ojg3MDkwY2RjNTY3YjJmN2ZlN2MwZTgzNmFhNTU0MzhlYTUxYTM5Y2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeCiAXgH2gAyNTE2Njc4NTQ3OjA0NWUzYTBkMDE3NmJjMDA4ODM2MjMwZmJjNGFhMDZkMDI4ZjdjYTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "committedDate": "2020-11-06T11:10:04Z", "message": "HDDS-4357: Rename : make rename an atomic ops by updating key path entry in dir/file table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTk2MTI1", "url": "https://github.com/apache/ozone/pull/1557#pullrequestreview-525596125", "createdAt": "2020-11-07T04:14:04Z", "commit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwNDoxNDowNFrOHvDKRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wN1QwNDoxNDo0MVrOHvDKiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NjkwMQ==", "bodyText": "Can we add additional test cases that can fully cover current rename logic:\n\n\nRename to a existed file, failed.\n\n\nRename to a existed folder:\nRename from /a, to /b, final key will be /b/a\n\n\nRename to a parent folder:\ncase1: parent folder does't exist, and then failed\ncase2: parent folder existed, then succeed", "url": "https://github.com/apache/ozone/pull/1557#discussion_r519096901", "createdAt": "2020-11-07T04:14:04Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,44 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+\n+  protected void testRenameDir() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir = root + \"/dir1\";\n+    final Path source = new Path(fs.getUri().toString() + dir);\n+    final Path dest = new Path(source.toString() + \".renamed\");\n+    // Add a sub-dir to the directory to be moved.\n+    final Path subdir = new Path(source, \"sub_dir1\");\n+    fs.mkdirs(subdir);\n+    LOG.info(\"Created dir {}\", subdir);\n+\n+    // case-1) source is a sub-dir to destin\n+    final Path sourceRoot = new Path(fs.getUri().toString() + root);\n+    LOG.info(\"Rename op-> source:/root_dir to destin:/root_dir/dir1/sub_dir1\");\n+    try {\n+      fs.rename(sourceRoot, subdir);\n+      Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n+              \" its own subdirectory\");\n+    } catch (OMException e) {\n+      // expected\n+    }\n+\n+    LOG.info(\"Will move {} to {}\", source, dest);\n+    fs.rename(source, dest);\n+\n+    assertTrue(\"Directory rename failed\", fs.exists(dest));\n+    // Verify that the subdir is also renamed i.e. keys corresponding to the\n+    // sub-directories of the renamed directory have also been renamed.\n+    assertTrue(\"Keys under the renamed directory not renamed\",\n+            fs.exists(new Path(dest, \"sub_dir1\")));\n+\n+    // Test if one path belongs to other FileSystem.\n+    Path fakeDir = new Path(fs.getUri().toString() + \"fake\" + dir);\n+    LambdaTestUtils.intercept(IllegalArgumentException.class, \"Wrong FS\",\n+            () -> fs.rename(fakeDir, dest));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5Njk3MQ==", "bodyText": "Comment is not right, here source is parent dir,", "url": "https://github.com/apache/ozone/pull/1557#discussion_r519096971", "createdAt": "2020-11-07T04:14:41Z", "author": {"login": "linyiqun"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,44 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+\n+  protected void testRenameDir() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir = root + \"/dir1\";\n+    final Path source = new Path(fs.getUri().toString() + dir);\n+    final Path dest = new Path(source.toString() + \".renamed\");\n+    // Add a sub-dir to the directory to be moved.\n+    final Path subdir = new Path(source, \"sub_dir1\");\n+    fs.mkdirs(subdir);\n+    LOG.info(\"Created dir {}\", subdir);\n+\n+    // case-1) source is a sub-dir to destin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NzMzMjky", "url": "https://github.com/apache/ozone/pull/1557#pullrequestreview-527733292", "createdAt": "2020-11-11T00:33:14Z", "commit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDozMzoxNFrOHw0_qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDo1ODoxN1rOHw1s2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTk2MA==", "bodyText": "Minor:\nCheck if fromKey exists", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520961960", "createdAt": "2020-11-11T00:33:14Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ==", "bodyText": "How this works for Object Store API when used from shell.\nIn Object Store scenario how you will distinguish between file and dir.", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520962991", "createdAt": "2020-11-11T00:36:16Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // fromKeyName should exist\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source exists\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MzUzMA==", "bodyText": "Question: What is meant here by should not exist?", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520973530", "createdAt": "2020-11-11T00:58:17Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // fromKeyName should exist\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source exists\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+      OmKeyInfo toKeyValue;\n+\n+      // Destination exists cases:\n+      if(toKeyFileStatus != null) {\n+\n+        toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-1) src == destin then check source and destin of same type\n+          // If dst is a file then return true. Otherwise fail the operation.\n+          if (!toKeyFileStatus.isDirectory()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-2) If dst is a directory, rename source as sub-path of it.\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // If new destination '/dst/source' exists.\n+            throw new OMException(String.format(\n+                    \"Failed to rename %s to %s, file already exists or not \" +\n+                            \"empty!\", fromKeyName, newToKeyName),\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+\n+          omClientResponse = renameKey(toKeyValue.getObjectID(), trxnLogIndex,\n+                  fromKeyValue, isRenameDirectory, newToKeyName,\n+                  keyArgs.getModificationTime(), omResponse, ozoneManager);\n+          result = Result.SUCCESS;\n+        } else {\n+          // case-3) destination is a file and should not exist", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce"}, "originalPosition": 178}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/86647aab902ab199236e7cea22a553eae6e26998", "committedDate": "2020-11-11T09:40:26Z", "message": "Fixed review comments - added bunch of unit test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MTI1OTI2", "url": "https://github.com/apache/ozone/pull/1557#pullrequestreview-528125926", "createdAt": "2020-11-11T12:25:30Z", "commit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTc4ODkx", "url": "https://github.com/apache/ozone/pull/1557#pullrequestreview-529578891", "createdAt": "2020-11-12T23:18:22Z", "commit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoxODoyMlrOHySpeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDo0Mjo0MlrOHyUwJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NjM3Ng==", "bodyText": "Not got when parent is null, why we need to return keyName", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522496376", "createdAt": "2020-11-12T23:18:22Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java", "diffHunk": "@@ -162,4 +162,46 @@ public static boolean isImmediateChild(String parentKey, String childKey) {\n \n     return parentPath.equals(childParent);\n   }\n+\n+  /**\n+   * The function returns parent directory from the given absolute path. For\n+   * example, the given key path '/a/b/c/d/e/file1' then it returns parent\n+   * directory name as 'e'.\n+   *\n+   * @param keyName key name\n+   */\n+  public static String getParentDir(@Nonnull String keyName) {\n+    java.nio.file.Path fileName = Paths.get(keyName).getParent();\n+    if (fileName != null) {\n+      return fileName.toString();\n+    }\n+    // failed to converts a path key\n+    return keyName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNzk3MQ==", "bodyText": "Minor: When toKeyParentDirStatus null means intermediate directories does not exist. So, should we change the exception when it is file and null.", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522507971", "createdAt": "2020-11-12T23:41:25Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -696,4 +697,91 @@ public static String getAbsolutePath(String prefixName, String fileName) {\n     }\n     return prefixName.concat(OzoneConsts.OZONE_URI_DELIMITER).concat(fileName);\n   }\n+\n+  /**\n+   * Build DirectoryInfo from OmKeyInfo.\n+   *\n+   * @param keyInfo omKeyInfo\n+   * @return omDirectoryInfo object\n+   */\n+  public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n+    OmDirectoryInfo.Builder builder = new OmDirectoryInfo.Builder();\n+    builder.setParentObjectID(keyInfo.getParentObjectID());\n+    builder.setAcls(keyInfo.getAcls());\n+    builder.addAllMetadata(keyInfo.getMetadata());\n+    builder.setCreationTime(keyInfo.getCreationTime());\n+    builder.setModificationTime(keyInfo.getModificationTime());\n+    builder.setObjectID(keyInfo.getObjectID());\n+    builder.setUpdateID(keyInfo.getUpdateID());\n+    builder.setName(OzoneFSUtils.getFileName(keyInfo.getKeyName()));\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Verify that the given toKey directory is a sub directory of fromKey\n+   * directory.\n+   * <p>\n+   * For example, special case of renaming a directory to its own\n+   * sub-directory is not allowed.\n+   *\n+   * @param fromKeyName source path\n+   * @param toKeyName   destination path\n+   * @throws OMException if the dest dir is a sub-dir of source dir.\n+   */\n+  public static void verifyToDirIsASubDirOfFromDirectory(String fromKeyName,\n+      String toKeyName, boolean isDir) throws OMException {\n+    if (!isDir) {\n+      return;\n+    }\n+    Path dstParent = Paths.get(toKeyName).getParent();\n+    while (dstParent != null) {\n+      if (Paths.get(fromKeyName).equals(dstParent)) {\n+        throw new OMException(\"Cannot rename a directory to its own \" +\n+                \"subdirectory\", OMException.ResultCodes.KEY_RENAME_ERROR);\n+        // TODO: Existing rename throws java.lang.IllegalArgumentException.\n+        //       Should we throw same exception ?\n+      }\n+      dstParent = dstParent.getParent();\n+    }\n+  }\n+\n+  /**\n+   * Verify parent exists for the destination path and return destination\n+   * path parent Id.\n+   * <p>\n+   * Check whether dst parent dir exists or not. If the parent exists, then the\n+   * source can be renamed to dst path.\n+   *\n+   * @param volumeName  volume name\n+   * @param bucketName  bucket name\n+   * @param toKeyName   destination path\n+   * @param fromKeyName source path\n+   * @param metaMgr     metadata manager\n+   * @throws IOException if the destination parent dir doesn't exists.\n+   */\n+  public static long getToKeyNameParentId(String volumeName,\n+      String bucketName, String toKeyName, String fromKeyName,\n+      OMMetadataManager metaMgr) throws IOException {\n+\n+    int totalDirsCount = OzoneFSUtils.getFileCount(toKeyName);\n+    // skip parent is root '/'\n+    if (totalDirsCount <= 1) {\n+      String bucketKey = metaMgr.getBucketKey(volumeName, bucketName);\n+      OmBucketInfo omBucketInfo =\n+              metaMgr.getBucketTable().get(bucketKey);\n+      return omBucketInfo.getObjectID();\n+    }\n+\n+    String toKeyParentDir = OzoneFSUtils.getParentDir(toKeyName);\n+\n+    OzoneFileStatus toKeyParentDirStatus = getOMKeyInfoIfExists(metaMgr,\n+            volumeName, bucketName, toKeyParentDir, 0);\n+    // check if the immediate parent exists\n+    if (toKeyParentDirStatus == null || toKeyParentDirStatus.isFile()) {\n+      throw new OMException(String.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODg4OQ==", "bodyText": "Minor: isDir is missing in javaDoc", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522508889", "createdAt": "2020-11-12T23:43:08Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -696,4 +697,91 @@ public static String getAbsolutePath(String prefixName, String fileName) {\n     }\n     return prefixName.concat(OzoneConsts.OZONE_URI_DELIMITER).concat(fileName);\n   }\n+\n+  /**\n+   * Build DirectoryInfo from OmKeyInfo.\n+   *\n+   * @param keyInfo omKeyInfo\n+   * @return omDirectoryInfo object\n+   */\n+  public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n+    OmDirectoryInfo.Builder builder = new OmDirectoryInfo.Builder();\n+    builder.setParentObjectID(keyInfo.getParentObjectID());\n+    builder.setAcls(keyInfo.getAcls());\n+    builder.addAllMetadata(keyInfo.getMetadata());\n+    builder.setCreationTime(keyInfo.getCreationTime());\n+    builder.setModificationTime(keyInfo.getModificationTime());\n+    builder.setObjectID(keyInfo.getObjectID());\n+    builder.setUpdateID(keyInfo.getUpdateID());\n+    builder.setName(OzoneFSUtils.getFileName(keyInfo.getKeyName()));\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Verify that the given toKey directory is a sub directory of fromKey\n+   * directory.\n+   * <p>\n+   * For example, special case of renaming a directory to its own\n+   * sub-directory is not allowed.\n+   *\n+   * @param fromKeyName source path\n+   * @param toKeyName   destination path\n+   * @throws OMException if the dest dir is a sub-dir of source dir.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTMyOA==", "bodyText": "General mv supports it,\n$ mv /tmp/f1 /Users/bviswanadham/f1\nIs this semantics of rename API in Fs?", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522515328", "createdAt": "2020-11-12T23:54:22Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if fromKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // case-1) fromKeyName should exist, otw throws exception\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source existed\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // case-2) Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+\n+      // Check if toKey exists.\n+      if(toKeyFileStatus != null) {\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-4) If dst is a directory then rename source as sub-path of it\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // case-5) If new destin '/dst/source' exists then throws exception\n+            throw new OMException(String.format(\n+                    \"Failed to rename %s to %s, file already exists or not \" +\n+                            \"empty!\", fromKeyName, newToKeyName),\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+\n+          omClientResponse = renameKey(toKeyValue.getObjectID(), trxnLogIndex,\n+                  fromKeyValue, isRenameDirectory, newToKeyName,\n+                  keyArgs.getModificationTime(), omResponse, ozoneManager);\n+          result = Result.SUCCESS;\n+        } else {\n+          // case-6) If destination is a file type and if exists then throws", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxOTk3MQ==", "bodyText": "Same for directory also.", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522519971", "createdAt": "2020-11-13T00:08:58Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if fromKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // case-1) fromKeyName should exist, otw throws exception\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source existed\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // case-2) Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+\n+      // Check if toKey exists.\n+      if(toKeyFileStatus != null) {\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-4) If dst is a directory then rename source as sub-path of it\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // case-5) If new destin '/dst/source' exists then throws exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTg1MQ==", "bodyText": "Okay reading more I see FS As RenameOptions only when OverWrite then it will do.\nWith out any rename options, we fail if dest exists.\nCorrect me if I am missing something here.", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522521851", "createdAt": "2020-11-13T00:14:49Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if fromKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // case-1) fromKeyName should exist, otw throws exception\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source existed\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // case-2) Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+\n+      // Check if toKey exists.\n+      if(toKeyFileStatus != null) {\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-4) If dst is a directory then rename source as sub-path of it\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // case-5) If new destin '/dst/source' exists then throws exception\n+            throw new OMException(String.format(\n+                    \"Failed to rename %s to %s, file already exists or not \" +\n+                            \"empty!\", fromKeyName, newToKeyName),\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+\n+          omClientResponse = renameKey(toKeyValue.getObjectID(), trxnLogIndex,\n+                  fromKeyValue, isRenameDirectory, newToKeyName,\n+                  keyArgs.getModificationTime(), omResponse, ozoneManager);\n+          result = Result.SUCCESS;\n+        } else {\n+          // case-6) If destination is a file type and if exists then throws", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTMyOA=="}, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMDg1NA==", "bodyText": "Minor: Test is doing different, comment says different", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522530854", "createdAt": "2020-11-13T00:42:42Z", "author": {"login": "bharatviswa504"}, "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,160 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+  /**\n+   * Case-1) fromKeyName should exist, otw throws exception.\n+   */\n+  protected void testRenameWithNonExistentSource() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = root + \"/dir2\";\n+    final Path source = new Path(fs.getUri().toString() + dir1);\n+    final Path destin = new Path(fs.getUri().toString() + dir2);\n+\n+    // creates destin\n+    fs.mkdirs(destin);\n+    LOG.info(\"Created destin dir: {}\", destin);\n+\n+    LOG.info(\"Rename op-> source:{} to destin:{}}\", source, destin);\n+    try {\n+      fs.rename(source, destin);\n+      Assert.fail(\"Should throw exception : Source doesn't exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Case-2) Cannot rename a directory to its own subdirectory.\n+   */\n+  protected void testRenameDirToItsOwnSubDir() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final Path dir1Path = new Path(fs.getUri().toString() + dir1);\n+    // Add a sub-dir1 to the directory to be moved.\n+    final Path subDir1 = new Path(dir1Path, \"sub_dir1\");\n+    fs.mkdirs(subDir1);\n+    LOG.info(\"Created dir1 {}\", subDir1);\n+\n+    final Path sourceRoot = new Path(fs.getUri().toString() + root);\n+    LOG.info(\"Rename op-> source:{} to destin:{}\", sourceRoot, subDir1);\n+    try {\n+      fs.rename(sourceRoot, subDir1);\n+      Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n+              \" its own subdirectory\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Case-5) If new destin '/dst/source' exists then throws exception.\n+   * If destination is a directory then rename source as sub-path of it.\n+   * <p>\n+   * For example: rename /a to /b will lead to /b/a. This new path should\n+   * not exist.\n+   */\n+  protected void testRenameToNewSubDirShouldNotExist() throws Exception {\n+    // Case-5.a) Rename directory from /a to /b.\n+    // created /a\n+    final Path aSourcePath = new Path(fs.getUri().toString() + \"/a\");\n+    fs.mkdirs(aSourcePath);\n+\n+    // created /b\n+    final Path bDestinPath = new Path(fs.getUri().toString() + \"/b\");\n+    fs.mkdirs(bDestinPath);\n+\n+    // Add a sub-directory '/a/c' to '/a'. This is to verify that after", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86647aab902ab199236e7cea22a553eae6e26998"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/6cbffbae9349c7481e8e9aeeebff0d147be61819", "committedDate": "2020-11-13T18:51:17Z", "message": "Fixed review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyODgxOTM0", "url": "https://github.com/apache/ozone/pull/1557#pullrequestreview-532881934", "createdAt": "2020-11-17T22:56:34Z", "commit": {"oid": "6cbffbae9349c7481e8e9aeeebff0d147be61819"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0dee8edda7c57113eba4b15f31afe1814dcd7a5", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/e0dee8edda7c57113eba4b15f31afe1814dcd7a5", "committedDate": "2020-11-19T07:46:26Z", "message": "Fixed NPE and removed duplciate entries in TableCache during listStatus"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b78899f274d2a5a7e1708d5cf44912e6d556581", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/3b78899f274d2a5a7e1708d5cf44912e6d556581", "committedDate": "2020-11-19T08:49:11Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6283887ba48329a903961e67a9f875532b220c2", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/d6283887ba48329a903961e67a9f875532b220c2", "committedDate": "2020-11-19T10:19:46Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "045e3a0d0176bc008836230fbc4aa06d028f7ca9", "author": {"user": {"login": "rakeshadr", "name": "Rakesh Radhakrishnan"}}, "url": "https://github.com/apache/ozone/commit/045e3a0d0176bc008836230fbc4aa06d028f7ca9", "committedDate": "2020-11-19T13:11:55Z", "message": "trigger new CI check"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2244, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}