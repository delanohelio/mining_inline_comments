{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MDQzMjEx", "number": 1314, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjo0NjoxM1rOEXc0Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMToyNTozM1rOFALxew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDI0ODU0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjo0NjoxM1rOG_P3Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjoxOTowOVrOH9MCPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3MzMzNQ==", "bodyText": "Can be a private method", "url": "https://github.com/apache/ozone/pull/1314#discussion_r468973335", "createdAt": "2020-08-12T02:46:13Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {\n+    // only init once\n+    if (termOfLeaderSCM.isPresent()) {\n+      return;\n+    }\n+\n+    AtomicInteger scmNum = new AtomicInteger(0);\n+    AtomicInteger activeScmNum = new AtomicInteger(0);\n+\n+    getParent().getConnectionManager().getValues()\n+        .forEach(endpoint -> {\n+          if (endpoint.isPassive()) {\n+            return;\n+          }\n+          scmNum.incrementAndGet();\n+          if (endpoint.getState()\n+              == EndpointStateMachine.EndPointStates.HEARTBEAT) {\n+            activeScmNum.incrementAndGet();\n+          }\n+        });\n+\n+    // majority SCMs should be in HEARTBEAT state.\n+    if (activeScmNum.get() < scmNum.get() / 2 + 1) {\n+      return;\n+    }\n+\n+    // if commandQueue is not empty, init termOfLeaderSCM\n+    // with the largest term found in commandQueue\n+    commandQueue.stream()\n+        .mapToLong(SCMCommand::getTerm)\n+        .max()\n+        .ifPresent(term -> termOfLeaderSCM = Optional.of(term));\n+  }\n+\n+  /**\n+   * monotonically increase termOfLeaderSCM.\n+   * Always record the latest term that has seen.\n+   */\n+  void updateTermOfLeaderSCM(SCMCommand<?> command) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d780e7c6461880a509e8c48aaa2620238bd0202"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMjM2NA==", "bodyText": "Sure", "url": "https://github.com/apache/ozone/pull/1314#discussion_r533922364", "createdAt": "2020-12-02T06:19:09Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {\n+    // only init once\n+    if (termOfLeaderSCM.isPresent()) {\n+      return;\n+    }\n+\n+    AtomicInteger scmNum = new AtomicInteger(0);\n+    AtomicInteger activeScmNum = new AtomicInteger(0);\n+\n+    getParent().getConnectionManager().getValues()\n+        .forEach(endpoint -> {\n+          if (endpoint.isPassive()) {\n+            return;\n+          }\n+          scmNum.incrementAndGet();\n+          if (endpoint.getState()\n+              == EndpointStateMachine.EndPointStates.HEARTBEAT) {\n+            activeScmNum.incrementAndGet();\n+          }\n+        });\n+\n+    // majority SCMs should be in HEARTBEAT state.\n+    if (activeScmNum.get() < scmNum.get() / 2 + 1) {\n+      return;\n+    }\n+\n+    // if commandQueue is not empty, init termOfLeaderSCM\n+    // with the largest term found in commandQueue\n+    commandQueue.stream()\n+        .mapToLong(SCMCommand::getTerm)\n+        .max()\n+        .ifPresent(term -> termOfLeaderSCM = Optional.of(term));\n+  }\n+\n+  /**\n+   * monotonically increase termOfLeaderSCM.\n+   * Always record the latest term that has seen.\n+   */\n+  void updateTermOfLeaderSCM(SCMCommand<?> command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3MzMzNQ=="}, "originalCommit": {"oid": "8d780e7c6461880a509e8c48aaa2620238bd0202"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDI0ODY0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMjo0NjoyMFrOG_P3LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjoxODozOFrOH9MBgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3MzM1Nw==", "bodyText": "Can be a private method", "url": "https://github.com/apache/ozone/pull/1314#discussion_r468973357", "createdAt": "2020-08-12T02:46:20Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d780e7c6461880a509e8c48aaa2620238bd0202"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMjE3OA==", "bodyText": "Sure", "url": "https://github.com/apache/ozone/pull/1314#discussion_r533922178", "createdAt": "2020-12-02T06:18:38Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk3MzM1Nw=="}, "originalCommit": {"oid": "8d780e7c6461880a509e8c48aaa2620238bd0202"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjIzMDczOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjoxNDozMlrOHD-CLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjoyMTo0M1rOH9MFeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkyNDE0MA==", "bodyText": "Shall we use AtomicLong for termOfLeaderSCM?", "url": "https://github.com/apache/ozone/pull/1314#discussion_r473924140", "createdAt": "2020-08-20T12:14:32Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {\n+    // only init once\n+    if (termOfLeaderSCM.isPresent()) {\n+      return;\n+    }\n+\n+    AtomicInteger scmNum = new AtomicInteger(0);\n+    AtomicInteger activeScmNum = new AtomicInteger(0);\n+\n+    getParent().getConnectionManager().getValues()\n+        .forEach(endpoint -> {\n+          if (endpoint.isPassive()) {\n+            return;\n+          }\n+          scmNum.incrementAndGet();\n+          if (endpoint.getState()\n+              == EndpointStateMachine.EndPointStates.HEARTBEAT) {\n+            activeScmNum.incrementAndGet();\n+          }\n+        });\n+\n+    // majority SCMs should be in HEARTBEAT state.\n+    if (activeScmNum.get() < scmNum.get() / 2 + 1) {\n+      return;\n+    }\n+\n+    // if commandQueue is not empty, init termOfLeaderSCM\n+    // with the largest term found in commandQueue\n+    commandQueue.stream()\n+        .mapToLong(SCMCommand::getTerm)\n+        .max()\n+        .ifPresent(term -> termOfLeaderSCM = Optional.of(term));\n+  }\n+\n+  /**\n+   * monotonically increase termOfLeaderSCM.\n+   * Always record the latest term that has seen.\n+   */\n+  void updateTermOfLeaderSCM(SCMCommand<?> command) {\n+    if (!termOfLeaderSCM.isPresent()) {\n+      LOG.error(\"should init termOfLeaderSCM before update it.\");\n+      return;\n+    }\n+\n+    termOfLeaderSCM = Optional.of(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyMzE5NA==", "bodyText": "Good Point.\nSince this is executed in a single thread, let's do this first. We surely need to consider the thread safety in future change.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r533923194", "createdAt": "2020-12-02T06:21:43Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -470,6 +484,65 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n     }\n   }\n \n+  /**\n+   * After startup, datanode needs detect latest leader SCM before handling\n+   * any SCMCommand, so that it won't be disturbed by stale leader SCM.\n+   *\n+   * The rule is: after majority SCMs are in HEARTBEAT state and has\n+   * heard from leader SCMs (commandQueue is not empty), datanode will init\n+   * termOfLeaderSCM with the max term found in commandQueue.\n+   *\n+   * The init process also works for non-HA mode. In that case, term of all\n+   * SCMCommands will be 0.\n+   */\n+  void initTermOfLeaderSCM() {\n+    // only init once\n+    if (termOfLeaderSCM.isPresent()) {\n+      return;\n+    }\n+\n+    AtomicInteger scmNum = new AtomicInteger(0);\n+    AtomicInteger activeScmNum = new AtomicInteger(0);\n+\n+    getParent().getConnectionManager().getValues()\n+        .forEach(endpoint -> {\n+          if (endpoint.isPassive()) {\n+            return;\n+          }\n+          scmNum.incrementAndGet();\n+          if (endpoint.getState()\n+              == EndpointStateMachine.EndPointStates.HEARTBEAT) {\n+            activeScmNum.incrementAndGet();\n+          }\n+        });\n+\n+    // majority SCMs should be in HEARTBEAT state.\n+    if (activeScmNum.get() < scmNum.get() / 2 + 1) {\n+      return;\n+    }\n+\n+    // if commandQueue is not empty, init termOfLeaderSCM\n+    // with the largest term found in commandQueue\n+    commandQueue.stream()\n+        .mapToLong(SCMCommand::getTerm)\n+        .max()\n+        .ifPresent(term -> termOfLeaderSCM = Optional.of(term));\n+  }\n+\n+  /**\n+   * monotonically increase termOfLeaderSCM.\n+   * Always record the latest term that has seen.\n+   */\n+  void updateTermOfLeaderSCM(SCMCommand<?> command) {\n+    if (!termOfLeaderSCM.isPresent()) {\n+      LOG.error(\"should init termOfLeaderSCM before update it.\");\n+      return;\n+    }\n+\n+    termOfLeaderSCM = Optional.of(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkyNDE0MA=="}, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjMwMjEzOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjozNDowMlrOHD-tKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNjoyNjoxOFrOH9MLmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNTE0Ng==", "bodyText": "Any case SCMNodeManager would not require SCMHAManager?\nNote that PipelineManager will always rely on SCMHAManager", "url": "https://github.com/apache/ozone/pull/1314#discussion_r473935146", "createdAt": "2020-08-20T12:34:02Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "diffHunk": "@@ -130,6 +135,14 @@ public SCMNodeManager(OzoneConfiguration conf,\n     this.useHostname = conf.getBoolean(\n         DFSConfigKeysLegacy.DFS_DATANODE_USE_DN_HOSTNAME,\n         DFSConfigKeysLegacy.DFS_DATANODE_USE_DN_HOSTNAME_DEFAULT);\n+    this.scmhaManager = scmhaManager;\n+  }\n+\n+  public SCMNodeManager(OzoneConfiguration conf,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzkyNDc2Mw==", "bodyText": "Quite a lot of unit tests rely on this old Ctor.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r533924763", "createdAt": "2020-12-02T06:26:18Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "diffHunk": "@@ -130,6 +135,14 @@ public SCMNodeManager(OzoneConfiguration conf,\n     this.useHostname = conf.getBoolean(\n         DFSConfigKeysLegacy.DFS_DATANODE_USE_DN_HOSTNAME,\n         DFSConfigKeysLegacy.DFS_DATANODE_USE_DN_HOSTNAME_DEFAULT);\n+    this.scmhaManager = scmhaManager;\n+  }\n+\n+  public SCMNodeManager(OzoneConfiguration conf,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNTE0Ng=="}, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTkwNTc2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjozNToyM1rOHO4qMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxMjowMzoyNVrOHPwRwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3MDQxOA==", "bodyText": "I am confused on when termOfLeaderSCM is updated to the newest leader term. Is termOfLeaderSCM updated in during leader selection?", "url": "https://github.com/apache/ozone/pull/1314#discussion_r485370418", "createdAt": "2020-09-09T06:35:23Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -478,7 +551,26 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n   public SCMCommand getNextCommand() {\n     lock.lock();\n     try {\n-      return commandQueue.poll();\n+      initTermOfLeaderSCM();\n+      if (!termOfLeaderSCM.isPresent()) {\n+        return null;      // not ready yet\n+      }\n+\n+      while (true) {\n+        SCMCommand<?> command = commandQueue.poll();\n+        if (command == null) {\n+          return null;\n+        }\n+\n+        updateTermOfLeaderSCM(command);\n+        if (command.getTerm() == termOfLeaderSCM.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4MTY2NQ==", "bodyText": "Do you mean whether termOfLeaderSCM is updated in leader election of SCM ? No, it won't. Datanode detects the latest SCM term by heartbeat with SCMs, whose interval is larger than 30s.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r486281665", "createdAt": "2020-09-10T12:03:25Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/container-service/src/main/java/org/apache/hadoop/ozone/container/common/statemachine/StateContext.java", "diffHunk": "@@ -478,7 +551,26 @@ public void execute(ExecutorService service, long time, TimeUnit unit)\n   public SCMCommand getNextCommand() {\n     lock.lock();\n     try {\n-      return commandQueue.poll();\n+      initTermOfLeaderSCM();\n+      if (!termOfLeaderSCM.isPresent()) {\n+        return null;      // not ready yet\n+      }\n+\n+      while (true) {\n+        SCMCommand<?> command = commandQueue.poll();\n+        if (command == null) {\n+          return null;\n+        }\n+\n+        updateTermOfLeaderSCM(command);\n+        if (command.getTerm() == termOfLeaderSCM.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3MDQxOA=="}, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTkxMDcwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/test/java/org/apache/hadoop/hdds/scm/ha/MockSCMHAManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjozNzoxMlrOHO4tDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNjo1ODo1NlrOHP9WzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3MTE1MA==", "bodyText": "another challenge is how to test such change. ideally we can have a minicluster setup with configurable nodes so we can simulate the scenario of split brian.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r485371150", "createdAt": "2020-09-09T06:37:12Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/server-scm/src/test/java/org/apache/hadoop/hdds/scm/ha/MockSCMHAManager.java", "diffHunk": "@@ -78,8 +79,8 @@ public void start() throws IOException {\n    * {@inheritDoc}\n    */\n   @Override\n-  public boolean isLeader() {\n-    return isLeader;\n+  public Optional<Long> isLeader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4MjE1OQ==", "bodyText": "Good point. We need add a lot of test cases, including UT and acceptance test, before merging 2823 back to master.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r486282159", "createdAt": "2020-09-10T12:04:30Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/test/java/org/apache/hadoop/hdds/scm/ha/MockSCMHAManager.java", "diffHunk": "@@ -78,8 +79,8 @@ public void start() throws IOException {\n    * {@inheritDoc}\n    */\n   @Override\n-  public boolean isLeader() {\n-    return isLeader;\n+  public Optional<Long> isLeader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3MTE1MA=="}, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5NTk0OQ==", "bodyText": "Agreed. I have been thinking about it and we might be some testing infrastructure to simulate these complicated consensus cases. E.g. split-brian.\nOM HA might have done something similar.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r486495949", "createdAt": "2020-09-10T16:58:56Z", "author": {"login": "amaliujia"}, "path": "hadoop-hdds/server-scm/src/test/java/org/apache/hadoop/hdds/scm/ha/MockSCMHAManager.java", "diffHunk": "@@ -78,8 +79,8 @@ public void start() throws IOException {\n    * {@inheritDoc}\n    */\n   @Override\n-  public boolean isLeader() {\n-    return isLeader;\n+  public Optional<Long> isLeader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM3MTE1MA=="}, "originalCommit": {"oid": "b0ed6364c9bd8421fdd027add93c110386dcac68"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NzM3MjExOnYy", "diffSide": "RIGHT", "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMToyNTozM1rOH-VwQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxMjoxMDozNVrOH-YZiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEzMDE3Nw==", "bodyText": "Nit: Try not to list all the commands by name. It would be hard to maintain the correctness of the comments.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r535130177", "createdAt": "2020-12-03T11:25:33Z", "author": {"login": "timmylicheng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "diffHunk": "@@ -656,8 +669,57 @@ public void setContainers(DatanodeDetails datanodeDetails,\n   // Since datanode commands are added through event queue, onMessage method\n   // should take care of adding commands to command queue.\n   // Refactor and remove all the usage of this method and delete this method.\n+  /**\n+   * Only leader SCM can send SCMCommand to datanode, and needs record its\n+   * term in the command so that datanode can distinguish commands from stale\n+   * leader SCM by comparing term.\n+   *\n+   * There are 7 SCMCommands:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92be0d6c391bfac3670014d16270a30d9456e470"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3MzUxMg==", "bodyText": "Good point. I've removed the comments for good.\nAs discussed in design of SCMContext, we will query and inject the term before firing event of DATANODE_COMMAND explicitly for all related places. I will revisit this code in dev of phase 2.0.", "url": "https://github.com/apache/ozone/pull/1314#discussion_r535173512", "createdAt": "2020-12-03T12:10:35Z", "author": {"login": "GlenGeng"}, "path": "hadoop-hdds/server-scm/src/main/java/org/apache/hadoop/hdds/scm/node/SCMNodeManager.java", "diffHunk": "@@ -656,8 +669,57 @@ public void setContainers(DatanodeDetails datanodeDetails,\n   // Since datanode commands are added through event queue, onMessage method\n   // should take care of adding commands to command queue.\n   // Refactor and remove all the usage of this method and delete this method.\n+  /**\n+   * Only leader SCM can send SCMCommand to datanode, and needs record its\n+   * term in the command so that datanode can distinguish commands from stale\n+   * leader SCM by comparing term.\n+   *\n+   * There are 7 SCMCommands:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEzMDE3Nw=="}, "originalCommit": {"oid": "92be0d6c391bfac3670014d16270a30d9456e470"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3880, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}