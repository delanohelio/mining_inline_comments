{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1MTMzNTk4", "number": 1732, "title": "HDDS.4387. Create a Trash File System that will be used by Trash Emptier", "bodyText": "What changes were proposed in this pull request?\nThis change introduces a new FS that will be used by the trash emptier.\nWhat is the link to the Apache JIRA\nhttps://issues.apache.org/jira/browse/HDDS-4387\nHow was this patch tested?\nmanually, existing trash unit tests that tests renames.", "createdAt": "2020-12-24T04:38:43Z", "url": "https://github.com/apache/ozone/pull/1732", "merged": true, "mergeCommit": {"oid": "f9e5d26278df10530437e3cc9aaeefdf8ab9388f"}, "closed": true, "closedAt": "2021-01-07T04:06:34Z", "author": {"login": "sadanand48"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdrxVF_AFqTU2MDU3MDQ3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtsF91AFqTU2MzE5NzU0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTcwNDc2", "url": "https://github.com/apache/ozone/pull/1732#pullrequestreview-560570476", "createdAt": "2021-01-01T05:04:23Z", "commit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwNTcwNTA2", "url": "https://github.com/apache/ozone/pull/1732#pullrequestreview-560570506", "createdAt": "2021-01-01T05:05:14Z", "commit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQwNTowNToxNVrOINOABg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMVQwNToyNjoxMlrOINOFzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMTc4Mg==", "bodyText": "please remove wildcards", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550731782", "createdAt": "2021-01-01T05:05:15Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjE3Ng==", "bodyText": "In order to remove the null/empty functions, I feel we can stop import from Filesystem.java", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732176", "createdAt": "2021-01-01T05:10:20Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjkzMQ==", "bodyText": "Lets not use the rpc sever here and lets use the following call in\n`\n@OverRide\npublic OMResponse submitRequest(RpcController controller,\nOMRequest request) throws ServiceException {\nreturn dispatcher.processRequest(request, this::processRequest,\n    request.getCmdType(), request.getTraceID());\n\n}\n`", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732931", "createdAt": "2021-01-01T05:21:26Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      LOG.info(trashRoot.toString());\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathPrefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathPrefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          String k = kv.getKey();\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) throws IOException {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        LOG.info(newPath);\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();\n+        String keyName = src.getKeyName();\n+\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            OzoneManagerProtocolProtos.KeyArgs.newBuilder().setKeyName(keyName)\n+            .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n+        String toKeyName = dst.getKeyName();\n+\n+        OzoneManagerProtocolProtos.RenameKeyRequest renameKeyRequest =\n+            OzoneManagerProtocolProtos.RenameKeyRequest.newBuilder()\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n+        OzoneManagerProtocolProtos.OMRequest omRequest =\n+            OzoneManagerProtocolProtos.OMRequest.newBuilder()\n+            .setClientId(UUID.randomUUID().toString())\n+            .setRenameKeyRequest(renameKeyRequest)\n+            .setCmdType(OzoneManagerProtocolProtos.Type.RenameKey).build();\n+        try {\n+          ozoneManager.getOmServerProtocol().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjk0Ng==", "bodyText": "ozone/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/protocolPB/OzoneManagerProtocolServerSideTranslatorPB.java\n    \n    \n         Line 119\n      in\n      b0d54d4\n    \n    \n    \n    \n\n        \n          \n           public OMResponse submitRequest(RpcController controller,", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732946", "createdAt": "2021-01-01T05:21:41Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      LOG.info(trashRoot.toString());\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathPrefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathPrefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          String k = kv.getKey();\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) throws IOException {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        LOG.info(newPath);\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();\n+        String keyName = src.getKeyName();\n+\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            OzoneManagerProtocolProtos.KeyArgs.newBuilder().setKeyName(keyName)\n+            .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n+        String toKeyName = dst.getKeyName();\n+\n+        OzoneManagerProtocolProtos.RenameKeyRequest renameKeyRequest =\n+            OzoneManagerProtocolProtos.RenameKeyRequest.newBuilder()\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n+        OzoneManagerProtocolProtos.OMRequest omRequest =\n+            OzoneManagerProtocolProtos.OMRequest.newBuilder()\n+            .setClientId(UUID.randomUUID().toString())\n+            .setRenameKeyRequest(renameKeyRequest)\n+            .setCmdType(OzoneManagerProtocolProtos.Type.RenameKey).build();\n+        try {\n+          ozoneManager.getOmServerProtocol().", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjkzMQ=="}, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMzIxNw==", "bodyText": "this code is similar between listStatus and getFileStatus, lets have a common function to avoid duplication of code", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550733217", "createdAt": "2021-01-01T05:25:40Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMzI2Mw==", "bodyText": "debug logging, please convert to trace.", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550733263", "createdAt": "2021-01-01T05:26:12Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      LOG.info(trashRoot.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c1a9e9c040594222e4423d754ec5813559926ff"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f1b9fa05944f416bbf4d68fb2e9fbfa986a184e", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/5f1b9fa05944f416bbf4d68fb2e9fbfa986a184e", "committedDate": "2021-01-05T08:40:31Z", "message": "Create a Trash File System that will be used by Trash Emptier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1bb9fc4997a29fbc49c2cf24e5dcca2791ec8f3", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/b1bb9fc4997a29fbc49c2cf24e5dcca2791ec8f3", "committedDate": "2021-01-05T08:40:31Z", "message": "fix checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a185bd6aa97591c439486cfe1a6c78984f067fc", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/1a185bd6aa97591c439486cfe1a6c78984f067fc", "committedDate": "2021-01-05T08:40:31Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "committedDate": "2021-01-05T08:41:15Z", "message": "trigger new CI check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f47aa12e0aae6ac203cd07946af52beb045d76c", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/9f47aa12e0aae6ac203cd07946af52beb045d76c", "committedDate": "2021-01-05T08:28:20Z", "message": "address comments"}, "afterCommit": {"oid": "c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "committedDate": "2021-01-05T08:41:15Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05593741a55cff6fd82f74fc0d8989b377070ed9", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/05593741a55cff6fd82f74fc0d8989b377070ed9", "committedDate": "2021-01-05T08:51:27Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/8b62859ba191191fdd611a02c6a7d55c331c7582", "committedDate": "2021-01-05T14:21:47Z", "message": "add test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9e9d1b489953ef3a8a59b520e50fbcf40f5954f", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/b9e9d1b489953ef3a8a59b520e50fbcf40f5954f", "committedDate": "2021-01-05T17:02:12Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTQzNjAy", "url": "https://github.com/apache/ozone/pull/1732#pullrequestreview-561943602", "createdAt": "2021-01-05T16:34:06Z", "commit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "state": "DISMISSED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNjozNDowNlrOIOeT9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzowODowM1rOIOfl-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzYwNg==", "bodyText": "Lets also add that ${result} also has Trash in the name ?", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552047606", "createdAt": "2021-01-05T16:34:06Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/dist/src/main/smoketest/ozonefs/ozonefs.robot", "diffHunk": "@@ -92,10 +92,16 @@ Touch file\n     ${result} =    Execute               ozone sh key list ${VOLUME}/${BUCKET} | jq -r '.name'\n                    Should contain        ${result}       TOUCHFILE-${SCHEME}.txt\n \n+Delete file with Trash\n+                   Execute               ozone fs -touch ${DEEP_URL}/testFile.txt\n+    ${result} =    Execute               ozone fs -rm ${DEEP_URL}/testFile.txt\n+                   Should contain        ${result}     testFile.txt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzgxMA==", "bodyText": "Also lets check if the file is actually present in the path", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552047810", "createdAt": "2021-01-05T16:34:24Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/dist/src/main/smoketest/ozonefs/ozonefs.robot", "diffHunk": "@@ -92,10 +92,16 @@ Touch file\n     ${result} =    Execute               ozone sh key list ${VOLUME}/${BUCKET} | jq -r '.name'\n                    Should contain        ${result}       TOUCHFILE-${SCHEME}.txt\n \n+Delete file with Trash\n+                   Execute               ozone fs -touch ${DEEP_URL}/testFile.txt\n+    ${result} =    Execute               ozone fs -rm ${DEEP_URL}/testFile.txt\n+                   Should contain        ${result}     testFile.txt", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzYwNg=="}, "originalCommit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODg4MA==", "bodyText": "Lets also add a function to convert OzoneFileStatus to FileStatus ?", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552048880", "createdAt": "2021-01-05T16:36:04Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2Nzk0Mg==", "bodyText": "why are we deleting only the first entry ? and ignoring the rest of the entries here ?", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552067942", "createdAt": "2021-01-05T17:06:54Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  private OmKeyArgs constructOmKeyArgs(Path path) {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key = ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    this.ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    return keyArgs;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathprefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathprefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();\n+        String keyName = src.getKeyName();\n+\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            OzoneManagerProtocolProtos.KeyArgs.newBuilder().setKeyName(keyName)\n+            .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n+        String toKeyName = dst.getKeyName();\n+\n+        OzoneManagerProtocolProtos.RenameKeyRequest renameKeyRequest =\n+            OzoneManagerProtocolProtos.RenameKeyRequest.newBuilder()\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n+        OzoneManagerProtocolProtos.OMRequest omRequest =\n+            OzoneManagerProtocolProtos.OMRequest.newBuilder()\n+            .setClientId(UUID.randomUUID().toString())\n+            .setRenameKeyRequest(renameKeyRequest)\n+            .setCmdType(OzoneManagerProtocolProtos.Type.RenameKey).build();\n+        try {\n+          ozoneManager.getOmServerProtocol().\n+              submitRequest(NULL_RPC_CONTROLLER, omRequest);\n+        } catch (ServiceException e) {\n+          LOG.error(\"Couldn't send rename request.\");\n+        }\n+\n+      }\n+      return true;\n+    }\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    final private boolean recursive;\n+\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      LOG.trace(\"Deleting keys: {}\", keyPathList);\n+\n+      String volumeName;\n+      String bucketName;\n+      List<String> keyList = keyPathList.stream()\n+          .map(p -> new OFSPath(p).getKeyName())\n+          .collect(Collectors.toList());\n+\n+      if(!keyPathList.isEmpty()){\n+        OFSPath p = new OFSPath(keyPathList.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2ODYwMg==", "bodyText": "Lets have a helper function to convert src,dst to OzoneManagerProtocolProtos.RenameKeyRequest", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552068602", "createdAt": "2021-01-05T17:08:03Z", "author": {"login": "mukul1987"}, "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  private OmKeyArgs constructOmKeyArgs(Path path) {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key = ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    this.ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    return keyArgs;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathprefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathprefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582"}, "originalPosition": 336}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ace5ae23dd5d26de58f72da4872153e72e09af6", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/4ace5ae23dd5d26de58f72da4872153e72e09af6", "committedDate": "2021-01-06T06:21:11Z", "message": "addressed comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "114baba37894236ead568184f956839479d09be1", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/114baba37894236ead568184f956839479d09be1", "committedDate": "2021-01-06T06:33:06Z", "message": "added comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77471b696b6419453b0069d677bdfa4994252191", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/77471b696b6419453b0069d677bdfa4994252191", "committedDate": "2021-01-06T08:21:27Z", "message": "code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a5627100e939de7b02e2378078f5d0e85eae99a", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/3a5627100e939de7b02e2378078f5d0e85eae99a", "committedDate": "2021-01-06T11:21:38Z", "message": "resolve failing check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "279a4c9acfcec1261a89e4baa4c15ad702bf3194", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/279a4c9acfcec1261a89e4baa4c15ad702bf3194", "committedDate": "2021-01-06T12:29:21Z", "message": "trigger new CI check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64e1761da9647352716e9dc8f1ef32b14303cc43", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/64e1761da9647352716e9dc8f1ef32b14303cc43", "committedDate": "2021-01-06T17:08:40Z", "message": "resolve check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99deab7195c1647e62d1f24f1a9f31b394c1a2db", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/99deab7195c1647e62d1f24f1a9f31b394c1a2db", "committedDate": "2021-01-06T17:29:12Z", "message": "resolve check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9c022cc5883a9cc1f8f2a3873fa804391a3bd4b", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/c9c022cc5883a9cc1f8f2a3873fa804391a3bd4b", "committedDate": "2021-01-06T17:31:22Z", "message": "remove unused variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2904bfa18ead7c04924894c81c545ad76b46bd6a", "author": {"user": {"login": "sadanand48", "name": "Sadanand Shenoy"}}, "url": "https://github.com/apache/ozone/commit/2904bfa18ead7c04924894c81c545ad76b46bd6a", "committedDate": "2021-01-06T19:11:52Z", "message": "resolve failing check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMTk3NDUx", "url": "https://github.com/apache/ozone/pull/1732#pullrequestreview-563197451", "createdAt": "2021-01-07T04:05:48Z", "commit": {"oid": "2904bfa18ead7c04924894c81c545ad76b46bd6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMTk3NTQ3", "url": "https://github.com/apache/ozone/pull/1732#pullrequestreview-563197547", "createdAt": "2021-01-07T04:06:10Z", "commit": {"oid": "2904bfa18ead7c04924894c81c545ad76b46bd6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1897, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}