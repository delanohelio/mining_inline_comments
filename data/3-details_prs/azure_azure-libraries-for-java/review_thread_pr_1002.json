{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNjI4NDE4", "number": 1002, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMzo1ODo0OFrODc2cwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDoyMDozMFrODc2nAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTc4ODE4OnYy", "diffSide": "RIGHT", "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMzo1ODo0OFrOFlHdQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDowODoyMFrOFlHkQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzgwOA==", "bodyText": "Is it possible to have UPPERCASE of getProtocol?", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374463808", "createdAt": "2020-02-04T03:58:48Z", "author": {"login": "weidongxu-microsoft"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NTYwMw==", "bodyText": "I haven't met a UPPERCASE protocol url, but I think we could handle it.", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374465603", "createdAt": "2020-02-04T04:08:20Z", "author": {"login": "ChenTanyi"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzgwOA=="}, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTgxNDQwOnYy", "diffSide": "RIGHT", "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNDoyMDozMFrOFlHspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwNzowMzozMlrOFlJ0Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2Nzc0OQ==", "bodyText": "Not sure about doOnNext, it could still follow by an Error instead of Complete. Maybe doOnSuccess?\nInput of doOnSuccess could be null.", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374467749", "createdAt": "2020-02-04T04:20:30Z", "author": {"login": "weidongxu-microsoft"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n+        }\n+\n+        String[] scopes;\n+        if (this.scopes == null || this.scopes.length == 0) {\n+            scopes = new String[] {getDefaultScopeFromRequest(context.getHttpRequest())};\n+        } else {\n+            scopes = this.scopes;\n+        }\n+        assert scopes.length > 0;\n+\n+        Mono<AccessToken> tokenResult;\n+        AccessToken token = tokenCache.get(scopes[0]);\n+        if (token == null || token.isExpired()) {\n+            tokenResult = this.credential.getToken(new TokenRequestContext().addScopes(scopes)).doOnNext(accessToken -> this.tokenCache.put(scopes[0], accessToken));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTYyNA==", "bodyText": "I'll test about it, since we don't catch exception, if the credential get token with error it will throw it and the pipeline will be terminated.", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374479624", "createdAt": "2020-02-04T05:24:01Z", "author": {"login": "ChenTanyi"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n+        }\n+\n+        String[] scopes;\n+        if (this.scopes == null || this.scopes.length == 0) {\n+            scopes = new String[] {getDefaultScopeFromRequest(context.getHttpRequest())};\n+        } else {\n+            scopes = this.scopes;\n+        }\n+        assert scopes.length > 0;\n+\n+        Mono<AccessToken> tokenResult;\n+        AccessToken token = tokenCache.get(scopes[0]);\n+        if (token == null || token.isExpired()) {\n+            tokenResult = this.credential.getToken(new TokenRequestContext().addScopes(scopes)).doOnNext(accessToken -> this.tokenCache.put(scopes[0], accessToken));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2Nzc0OQ=="}, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MDkxMg==", "bodyText": "The point here is that I do not want to write to the cache unless it is a success (+ token not null).", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374480912", "createdAt": "2020-02-04T05:29:57Z", "author": {"login": "weidongxu-microsoft"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n+        }\n+\n+        String[] scopes;\n+        if (this.scopes == null || this.scopes.length == 0) {\n+            scopes = new String[] {getDefaultScopeFromRequest(context.getHttpRequest())};\n+        } else {\n+            scopes = this.scopes;\n+        }\n+        assert scopes.length > 0;\n+\n+        Mono<AccessToken> tokenResult;\n+        AccessToken token = tokenCache.get(scopes[0]);\n+        if (token == null || token.isExpired()) {\n+            tokenResult = this.credential.getToken(new TokenRequestContext().addScopes(scopes)).doOnNext(accessToken -> this.tokenCache.put(scopes[0], accessToken));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2Nzc0OQ=="}, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjQxOA==", "bodyText": "https://stackoverflow.com/questions/55976963/is-there-a-difference-between-doonsuccess-vs-doonnext-for-a-mono As SO said, it seems doOnNext is more likely to be used which would skip when data is null.", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1002#discussion_r374502418", "createdAt": "2020-02-04T07:03:32Z", "author": {"login": "ChenTanyi"}, "path": "azure-mgmt-resources/src/main/java/com/azure/management/BearerTokenAuthenticationPolicy.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.management;\n+\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.AzureEnvironment;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Rewrite the BearerTokenAuthenticationPolicy, it will use default scope when scopes parameter is empty.\n+ */\n+public class BearerTokenAuthenticationPolicy implements HttpPipelinePolicy {\n+    private static final String AUTHORIZATION_HEADER_KEY = \"Authorization\";\n+    private static final String AUTHORIZATION_HEADER_VALUE_FORMAT = \"Bearer %s\";\n+\n+    private final Map<String, AccessToken> tokenCache;\n+    private final TokenCredential credential;\n+    private final String[] scopes;\n+    private final AzureEnvironment environment;\n+\n+    public BearerTokenAuthenticationPolicy(TokenCredential credential, String... scopes) {\n+        Objects.requireNonNull(credential);\n+        this.credential = credential;\n+        this.scopes = scopes;\n+        this.tokenCache = new HashMap<>();\n+\n+        if (credential instanceof AzureTokenCredential) {\n+            this.environment = ((AzureTokenCredential) credential).getEnvironment();\n+        } else {\n+            this.environment = AzureEnvironment.AZURE;\n+        }\n+    }\n+\n+    private String getDefaultScopeFromRequest(HttpRequest request) {\n+        String host = request.getUrl().getHost();\n+        String resource = this.environment.getManagementEndpoint();\n+        for (Map.Entry<String, String> endpoint : this.environment.endpoints().entrySet()) {\n+            if (host.contains(endpoint.getValue())) {\n+                if (endpoint.getKey().equals(AzureEnvironment.Endpoint.KEYVAULT.identifier())) {\n+                    resource = String.format(\"https://%s/\", endpoint.getValue().replaceAll(\"^\\\\.*\", \"\"));\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.GRAPH.identifier())) {\n+                    resource = this.environment.getGraphEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.LOG_ANALYTICS.identifier())) {\n+                    resource = this.environment.getLogAnalyticsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.APPLICATION_INSIGHTS.identifier())) {\n+                    resource = this.environment.getApplicationInsightsEndpoint();\n+                    break;\n+                } else if (endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_STORE.identifier())\n+                        || endpoint.getKey().equals(AzureEnvironment.Endpoint.DATA_LAKE_ANALYTICS.identifier())) {\n+                    resource = this.environment.getDataLakeEndpointResourceId();\n+                    break;\n+                }\n+            }\n+        }\n+        return resource + \"/.default\";\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        if (\"http\".equals(context.getHttpRequest().getUrl().getProtocol())) {\n+            return Mono.error(new RuntimeException(\"token credentials require a URL using the HTTPS protocol scheme\"));\n+        }\n+\n+        String[] scopes;\n+        if (this.scopes == null || this.scopes.length == 0) {\n+            scopes = new String[] {getDefaultScopeFromRequest(context.getHttpRequest())};\n+        } else {\n+            scopes = this.scopes;\n+        }\n+        assert scopes.length > 0;\n+\n+        Mono<AccessToken> tokenResult;\n+        AccessToken token = tokenCache.get(scopes[0]);\n+        if (token == null || token.isExpired()) {\n+            tokenResult = this.credential.getToken(new TokenRequestContext().addScopes(scopes)).doOnNext(accessToken -> this.tokenCache.put(scopes[0], accessToken));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2Nzc0OQ=="}, "originalCommit": {"oid": "7b5a88a836b9dfb7c3f209359705aa5824621804"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2582, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}