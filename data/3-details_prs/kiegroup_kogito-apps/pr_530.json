{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NjA1MjY0", "number": 530, "title": "KOGITO-3763 - Improved numeric feature handling", "bodyText": "This PR includes the following changes which target higher stability explanations when numeric features are involved:\n\nless strict filtering for sparse encoding of numeric features (this is useful to address stability for negative impact on regression problems)\nsample weighting is stricter, this means that only very similar samples will receive high sample weights (this generally generates better fitting linear models wrt the prediction to explain)\nreduced standard deviation to 1% of the original value when perturbing a number (so a new \"perturbed\" number is generated from a normal distribution centered on the original feature value with stdDev equals to 1% of the original value)\nreduced variance when perturbing int values\nincluded the original feature value in min / max scaling (which is performed during sparse encoding), this fixes cases where all the original value doesn't fall in the value range of the sampled perturbed values (which is rare but can still happen)\nsmall bug in feature perturbation size (a missing +1 in DataUtils#perturbFeature)\nintroduced local saliency stability metric: this measures the fraction of times that the top K positive/negative features are exactly the same across a no. of explaimability runs on the same Prediction\nadded missing Math.abs in sparse encoding check that the generated value is within the required threshold\n\nSee https://issues.redhat.com/browse/KOGITO-3763\nMany thanks for submitting your Pull Request \u2764\ufe0f!\nPlease make sure that your PR meets the following requirements:\n\n You have read the contributors guide\n Pull Request title is properly formatted: KOGITO-XYZ Subject\n Pull Request title contains the target branch if not targeting master: [0.9.x] KOGITO-XYZ Subject\n Pull Request contains link to the JIRA issue\n Pull Request contains link to any dependent or related Pull Request\n Pull Request contains description of the issue\n Pull Request does not include fixes for issues other than the main ticket", "createdAt": "2020-11-09T09:06:13Z", "url": "https://github.com/kiegroup/kogito-apps/pull/530", "merged": true, "mergeCommit": {"oid": "fae3e0ba7ac4e7d113e1cf11e10ba5ff0949b3fe"}, "closed": true, "closedAt": "2020-12-14T18:28:17Z", "author": {"login": "tteofili"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdaw78XgH2gAyNTE3NjA1MjY0OjI1YjZhYjAxZDllZjBmMTk4NjlhNWYwODkwMjUyY2JhOGM4NTJkODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmInefgH2gAyNTE3NjA1MjY0OjgzOWYyODg0M2NjM2MyZThmNmRmNGM2YmZlYTAzN2ViNTVkZTRmYmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/25b6ab01d9ef0f19869a5f0890252cba8c852d84", "committedDate": "2020-11-09T09:00:11Z", "message": "KOGITO-3769 - Make LimeExplainer optionally generate more diverse samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d83ae430183c0a39b631680f4bc919cc1754dacf", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/d83ae430183c0a39b631680f4bc919cc1754dacf", "committedDate": "2020-11-09T09:01:27Z", "message": "KOGITO-3763 - improved numeric feature encoding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fa407fac9f898d2b1d07152f1dae9e55282c309", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/9fa407fac9f898d2b1d07152f1dae9e55282c309", "committedDate": "2020-11-09T09:01:58Z", "message": "KOGITO-3763 - improved numeric feature encoding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d35eed92e8cb7c7c4c1c771a531bfd794fef05a2", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/d35eed92e8cb7c7c4c1c771a531bfd794fef05a2", "committedDate": "2020-11-09T09:24:02Z", "message": "KOGITO-3763 - do not integrate KOGITO-3769 changes in here"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72baf99f09b97389a72cf3eea8bf0b4099545143", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/72baf99f09b97389a72cf3eea8bf0b4099545143", "committedDate": "2020-11-09T14:59:45Z", "message": "KOGITO-3763 - minor tweaks to tests, reduced stdDev in numeric feature gen"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "112de8a1330b52012a4d5c415b396855bc2f16af", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/112de8a1330b52012a4d5c415b396855bc2f16af", "committedDate": "2020-11-10T10:11:44Z", "message": "KOGITO-3763 - fixing dmn and pmml tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f84ff071b86089deb226af075d1bbddc5150596", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/4f84ff071b86089deb226af075d1bbddc5150596", "committedDate": "2020-11-11T15:35:13Z", "message": "KOGITO-3763 - reduced kernel size for weighting samples, fixed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85160944f1e5d484bc5220ae97847ad52393c73d", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/85160944f1e5d484bc5220ae97847ad52393c73d", "committedDate": "2020-11-11T15:56:28Z", "message": "KOGITO-3763 - improved stability metric API: no need to predict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f82a27d12710a5450bc169c00b7d88291e8624ff", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/f82a27d12710a5450bc169c00b7d88291e8624ff", "committedDate": "2020-11-11T16:01:34Z", "message": "KOGITO-3763 - removed useless commented code in DatasetEncoder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "346374af6a7c33f16b191a3246f80fd82fa7f911", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/346374af6a7c33f16b191a3246f80fd82fa7f911", "committedDate": "2020-11-12T09:04:19Z", "message": "KOGITO-3763 - resolved bugs reported by sonarcloud"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "123b5a88866e17cfc986d1239146a9ea3900713b", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/123b5a88866e17cfc986d1239146a9ea3900713b", "committedDate": "2020-11-12T09:08:06Z", "message": "KOGITO-3763 - reduced cognitive complexity, reported by sonarcloud"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/7db39c4c33c84eca961e21a8c1a0a24628d379e2", "committedDate": "2020-11-12T09:20:14Z", "message": "KOGITO-3763 - removed useless comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MzY5ODg4", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-536369888", "createdAt": "2020-11-23T11:07:05Z", "commit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMTowNzowNVrOH4IrUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMTozODoxNVrOH4JsCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNDQ2NQ==", "bodyText": "do we need finalK?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528624465", "createdAt": "2020-11-23T11:07:05Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -132,4 +139,109 @@ public static double classificationFidelity(List<Pair<Saliency, Prediction>> pai\n         }\n         return evals == 0 ? 0 : acc / evals;\n     }\n+\n+    /**\n+     * Evaluate stability of a local explainer generating {@code Saliencies}.\n+     * Such an evaluation is intended to measure how stable the explanations are in terms of \"are the top k most important\n+     * positive/negative features always the same for a single prediction?\".\n+     *\n+     * @param model                  a model to explain\n+     * @param prediction             the prediction on which explanation stability will be evaluated\n+     * @param saliencyLocalExplainer a local saliency explainer\n+     * @param topK                   no. of top k positive/negative features for which stability report will be generated\n+     * @return a report about stability of all the decisions/predictions (and for each {@code k < topK})\n+     */\n+    public static LocalSaliencyStability getLocalSaliencyStability(PredictionProvider model, Prediction prediction,\n+                                                                   LocalExplainer<Map<String, Saliency>> saliencyLocalExplainer,\n+                                                                   int topK, int runs)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Map<String, List<Saliency>> saliencies = getMultipleSaliencies(model, prediction, saliencyLocalExplainer, runs);\n+\n+        LocalSaliencyStability saliencyStability = new LocalSaliencyStability(saliencies.keySet());\n+        // for each decision, calculate the stability rate for the top k important feature set, for each k < topK\n+        for (Map.Entry<String, List<Saliency>> entry : saliencies.entrySet()) {\n+            for (int k = 1; k <= topK; k++) {\n+                String decision = entry.getKey();\n+                List<Saliency> perDecisionSaliencies = entry.getValue();\n+\n+                int finalK = k;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzMDAyMg==", "bodyText": "If I've got it properly this can be replaced by something like\nMap.Entry maxEntry = Collections.max(collect.entrySet(), Map.Entry.comparingByValue());", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528630022", "createdAt": "2020-11-23T11:17:25Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -132,4 +139,109 @@ public static double classificationFidelity(List<Pair<Saliency, Prediction>> pai\n         }\n         return evals == 0 ? 0 : acc / evals;\n     }\n+\n+    /**\n+     * Evaluate stability of a local explainer generating {@code Saliencies}.\n+     * Such an evaluation is intended to measure how stable the explanations are in terms of \"are the top k most important\n+     * positive/negative features always the same for a single prediction?\".\n+     *\n+     * @param model                  a model to explain\n+     * @param prediction             the prediction on which explanation stability will be evaluated\n+     * @param saliencyLocalExplainer a local saliency explainer\n+     * @param topK                   no. of top k positive/negative features for which stability report will be generated\n+     * @return a report about stability of all the decisions/predictions (and for each {@code k < topK})\n+     */\n+    public static LocalSaliencyStability getLocalSaliencyStability(PredictionProvider model, Prediction prediction,\n+                                                                   LocalExplainer<Map<String, Saliency>> saliencyLocalExplainer,\n+                                                                   int topK, int runs)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Map<String, List<Saliency>> saliencies = getMultipleSaliencies(model, prediction, saliencyLocalExplainer, runs);\n+\n+        LocalSaliencyStability saliencyStability = new LocalSaliencyStability(saliencies.keySet());\n+        // for each decision, calculate the stability rate for the top k important feature set, for each k < topK\n+        for (Map.Entry<String, List<Saliency>> entry : saliencies.entrySet()) {\n+            for (int k = 1; k <= topK; k++) {\n+                String decision = entry.getKey();\n+                List<Saliency> perDecisionSaliencies = entry.getValue();\n+\n+                int finalK = k;\n+                // get the top k positive features list from each saliency and count the frequency of each such list across all saliencies\n+                Map<List<String>, Long> topKPositive = getTopKFeaturesFrequency(perDecisionSaliencies, s -> s.getPositiveFeatures(finalK));\n+                // get the most frequent list of positive features\n+                Pair<List<String>, Long> positiveMostFrequent = getMostFrequent(topKPositive);\n+                double positiveFrequencyRate = (double) positiveMostFrequent.getValue() / (double) perDecisionSaliencies.size();\n+\n+                // get the top k negative features list from each saliency and count the frequency of each such list across all saliencies\n+                Map<List<String>, Long> topKNegative = getTopKFeaturesFrequency(perDecisionSaliencies, s -> s.getNegativeFeatures(finalK));\n+                // get the most frequent list of negative features\n+                Pair<List<String>, Long> negativeMostFrequent = getMostFrequent(topKNegative);\n+                double negativeFrequencyRate = (double) negativeMostFrequent.getValue() / (double) perDecisionSaliencies.size();\n+\n+                // decision stability at k\n+                List<String> positiveFeatureNames = positiveMostFrequent.getKey();\n+                List<String> negativeFeatureNames = negativeMostFrequent.getKey();\n+                saliencyStability.add(decision, k, positiveFeatureNames, positiveFrequencyRate, negativeFeatureNames, negativeFrequencyRate);\n+            }\n+        }\n+        return saliencyStability;\n+    }\n+\n+    /**\n+     * Get multiple saliencies, aggregated by decision name.\n+     *\n+     * @param model                  the model used to perform predictions\n+     * @param prediction             the prediction to explain\n+     * @param saliencyLocalExplainer a local explainer that generates saliences\n+     * @param runs                   the no. of explanations to be generated\n+     * @return the generated saliencies, aggregated by decision name, across the different runs\n+     */\n+    private static Map<String, List<Saliency>> getMultipleSaliencies(PredictionProvider model, Prediction prediction,\n+                                                                     LocalExplainer<Map<String, Saliency>> saliencyLocalExplainer,\n+                                                                     int runs)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Map<String, List<Saliency>> saliencies = new HashMap<>();\n+        int skipped = 0;\n+        for (int i = 0; i < runs; i++) {\n+            Map<String, Saliency> saliencyMap = saliencyLocalExplainer.explainAsync(prediction, model)\n+                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+            for (Map.Entry<String, Saliency> saliencyEntry : saliencyMap.entrySet()) {\n+                // aggregate saliencies by output name\n+                List<FeatureImportance> topFeatures = saliencyEntry.getValue().getTopFeatures(1);\n+                if (!topFeatures.isEmpty() && topFeatures.get(0).getScore() != 0) { // skip empty or 0 valued saliencies\n+                    if (saliencies.containsKey(saliencyEntry.getKey())) {\n+                        List<Saliency> localSaliencies = saliencies.get(saliencyEntry.getKey());\n+                        List<Saliency> updatedSaliencies = new ArrayList<>(localSaliencies);\n+                        updatedSaliencies.add(saliencyEntry.getValue());\n+                        saliencies.put(saliencyEntry.getKey(), updatedSaliencies);\n+                    } else {\n+                        saliencies.put(saliencyEntry.getKey(), List.of(saliencyEntry.getValue()));\n+                    }\n+                } else {\n+                    LOGGER.warn(\"skipping empty / zero saliency for {}\", saliencyEntry.getKey());\n+                    skipped++;\n+                }\n+            }\n+        }\n+        LOGGER.debug(\"skipped {} useless saliencies\", skipped);\n+        return saliencies;\n+    }\n+\n+    private static Map<List<String>, Long> getTopKFeaturesFrequency(List<Saliency> saliencies, Function<Saliency, List<FeatureImportance>> saliencyListFunction) {\n+        return saliencies.stream().map(saliencyListFunction)\n+                .map(l -> l.stream().map(f -> f.getFeature().getName())\n+                        .collect(Collectors.toList()))\n+                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+    }\n+\n+    private static Pair<List<String>, Long> getMostFrequent(Map<List<String>, Long> collect) {\n+        long max = 0L;\n+        Pair<List<String>, Long> topK = Pair.of(Collections.emptyList(), 0L);\n+        for (Map.Entry<List<String>, Long> entry : collect.entrySet()) {\n+            if (entry.getValue() >= max) {\n+                topK = Pair.of(entry.getKey(), entry.getValue());\n+                max = entry.getValue();\n+            }\n+        }\n+        return topK;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzMjc0Ng==", "bodyText": "Do we need public or can we keep it internal?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528632746", "createdAt": "2020-11-23T11:22:33Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LocalSaliencyStability.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Local {@code Saliency} stability evaluation result.\n+ */\n+public class LocalSaliencyStability {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzOTk0OA==", "bodyText": "I have some questions around the getPositiveStabilityScore and getNegativeStabilityScore, what do they represent? Since they are rates how can they be both greater than 0.5?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528639948", "createdAt": "2020-11-23T11:36:03Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -86,17 +89,30 @@ void testPMMLRegression() throws Exception {\n                 }\n                 return outputs;\n             });\n-            PredictionOutput output = model.predictAsync(List.of(input))\n-                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n-                    .get(0);\n+            List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+            assertNotNull(predictionOutputs);\n+            assertFalse(predictionOutputs.isEmpty());\n+            PredictionOutput output = predictionOutputs.get(0);\n+            assertNotNull(output);\n             Prediction prediction = new Prediction(input, output);\n             Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n                     .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n             for (Saliency saliency : saliencyMap.values()) {\n                 assertNotNull(saliency);\n-                double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getPositiveFeatures(2));\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(2));\n                 assertEquals(1d, v);\n             }\n+            int topK = 1;\n+            LocalSaliencyStability stability = ExplainabilityMetrics.getLocalSaliencyStability(model, prediction, limeExplainer, topK, 10);\n+            for (int i = 1; i <= topK; i++) {\n+                for (String decision : stability.getDecisions()) {\n+                    double positiveStabilityScore = stability.getPositiveStabilityScore(decision, i);\n+                    double negativeStabilityScore = stability.getNegativeStabilityScore(decision, i);\n+                    assertThat(positiveStabilityScore).isGreaterThanOrEqualTo(0.5);\n+                    assertThat(negativeStabilityScore).isGreaterThanOrEqualTo(0.5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY0MTAzNQ==", "bodyText": "Do we need public or can we keep it internal?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528641035", "createdAt": "2020-11-23T11:38:15Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -132,4 +139,109 @@ public static double classificationFidelity(List<Pair<Saliency, Prediction>> pai\n         }\n         return evals == 0 ? 0 : acc / evals;\n     }\n+\n+    /**\n+     * Evaluate stability of a local explainer generating {@code Saliencies}.\n+     * Such an evaluation is intended to measure how stable the explanations are in terms of \"are the top k most important\n+     * positive/negative features always the same for a single prediction?\".\n+     *\n+     * @param model                  a model to explain\n+     * @param prediction             the prediction on which explanation stability will be evaluated\n+     * @param saliencyLocalExplainer a local saliency explainer\n+     * @param topK                   no. of top k positive/negative features for which stability report will be generated\n+     * @return a report about stability of all the decisions/predictions (and for each {@code k < topK})\n+     */\n+    public static LocalSaliencyStability getLocalSaliencyStability(PredictionProvider model, Prediction prediction,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NTgyOTQy", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-536582942", "createdAt": "2020-11-23T15:29:29Z", "commit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNToyOToyOVrOH4SmLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNTozMDoxOFrOH4SpBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4Njk4OQ==", "bodyText": "I think it would be good to use assertj also here. It provides much better messages when test fails.", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528786989", "createdAt": "2020-11-23T15:29:29Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -86,17 +89,30 @@ void testPMMLRegression() throws Exception {\n                 }\n                 return outputs;\n             });\n-            PredictionOutput output = model.predictAsync(List.of(input))\n-                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n-                    .get(0);\n+            List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+            assertNotNull(predictionOutputs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4NzI4MQ==", "bodyText": "Please use assertj.", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528787281", "createdAt": "2020-11-23T15:29:47Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -86,17 +89,30 @@ void testPMMLRegression() throws Exception {\n                 }\n                 return outputs;\n             });\n-            PredictionOutput output = model.predictAsync(List.of(input))\n-                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n-                    .get(0);\n+            List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+            assertNotNull(predictionOutputs);\n+            assertFalse(predictionOutputs.isEmpty());\n+            PredictionOutput output = predictionOutputs.get(0);\n+            assertNotNull(output);\n             Prediction prediction = new Prediction(input, output);\n             Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n                     .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n             for (Saliency saliency : saliencyMap.values()) {\n                 assertNotNull(saliency);\n-                double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getPositiveFeatures(2));\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(2));\n                 assertEquals(1d, v);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4NzcxNw==", "bodyText": "Please use assertj also here.", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r528787717", "createdAt": "2020-11-23T15:30:18Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/TypeTest.java", "diffHunk": "@@ -294,6 +294,27 @@ void testEncode(Type type) {\n         }\n     }\n \n+    @Test\n+    void testEncodeNumericSymmetric() {\n+        for (int seed = 0; seed < 5; seed++) {\n+            Random random = new Random();\n+            random.setSeed(seed);\n+            PerturbationContext perturbationContext = new PerturbationContext(random, random.nextInt());\n+            Value<?> target = Type.NUMBER.randomValue(perturbationContext);\n+            Value<?>[] values = new Value<?>[6];\n+            for (int i = 0; i < values.length / 2; i++) {\n+                values[i] = new Value<>(target.asNumber() + target.asNumber() * (1 + i) / 100d);\n+                values[values.length - 1 - i] = new Value<>(target.asNumber() - target.asNumber() * (1 + i) / 100d);\n+            }\n+            List<double[]> vectors = Type.NUMBER.encode(target, values);\n+            assertNotNull(vectors);\n+            assertEquals(values.length, vectors.size());\n+            for (int i = 0; i < vectors.size() / 2; i++) {\n+                assertEquals(vectors.get(i)[0], vectors.get(vectors.size() - 1 - i)[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77ce1f4010b6feb315a66ae99173d54472d3819a", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/77ce1f4010b6feb315a66ae99173d54472d3819a", "committedDate": "2020-11-24T07:20:18Z", "message": "KOGITO-3763 - simplified EM#getMostFrequent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44d81236cdf89672b9823098bbd812620311a7e3", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/44d81236cdf89672b9823098bbd812620311a7e3", "committedDate": "2020-11-24T08:36:56Z", "message": "KOGITO-3763 - using assertJ in PmmlLimeExplainerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f02ace0c1d64abb65a2299dfb0483e4ba34bae87", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/f02ace0c1d64abb65a2299dfb0483e4ba34bae87", "committedDate": "2020-11-24T08:38:30Z", "message": "KOGITO-3602 - using assertJ in TypeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "920cf37dd04455741bd1be6ab4c449a7cdfce38a", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/920cf37dd04455741bd1be6ab4c449a7cdfce38a", "committedDate": "2020-11-24T15:50:10Z", "message": "KOGITO-3763 - using assertJ in PmmlLimeExplainerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f24519754bc0dda092095eeeea00f49da91b75f", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/9f24519754bc0dda092095eeeea00f49da91b75f", "committedDate": "2020-12-02T15:42:52Z", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3763"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3580d487a5dd0f45d40be5a8886a4ee68a30c10e", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/3580d487a5dd0f45d40be5a8886a4ee68a30c10e", "committedDate": "2020-12-02T15:45:33Z", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3763"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTE5OTAx", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-529519901", "createdAt": "2020-11-12T21:42:31Z", "commit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTo0MjozMVrOHyPddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoyNDozM1rOID4mWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0NDE1MQ==", "bodyText": "Is this based on some euristic/rule?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r522444151", "createdAt": "2020-11-12T21:42:31Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n class SampleWeighter {\n \n-    private static final double SIGMA = 0.75;\n+    private static final double SIGMA = 0.675;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTYyMA==", "bodyText": "Can you add a test to cover this branch?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r525371620", "createdAt": "2020-11-17T17:59:06Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -162,7 +162,7 @@ static Feature doubleToFeature(double d) {\n                 perturbationSize = lowerBound;\n             }\n             else if (upperBound > lowerBound) {\n-                perturbationSize = perturbationContext.getRandom().ints(1, lowerBound, upperBound).findFirst().orElse(1);\n+                perturbationSize = perturbationContext.getRandom().ints(1, lowerBound, 1 + upperBound).findFirst().orElse(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NzE3NA==", "bodyText": "Why are you adding originalValue to feature scaling? Can you please clarify?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r527057174", "createdAt": "2020-11-19T17:12:09Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -164,20 +165,28 @@\n         @Override\n         public List<double[]> encode(Value<?> target, Value<?>... values) {\n             // find maximum and minimum values\n-            double[] doubles = new double[values.length];\n+            double[] doubles = new double[values.length + 1];\n             int i = 0;\n             for (Value<?> v : values) {\n                 doubles[i] = v.asNumber();\n                 i++;\n             }\n             double originalValue = target.asNumber();\n+            doubles[i] = originalValue; // include target number in feature scaling", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NzUyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int i = 0;\n          \n          \n            \n                        int valueIndex = 0;", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r527057520", "createdAt": "2020-11-19T17:12:43Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -164,20 +165,28 @@\n         @Override\n         public List<double[]> encode(Value<?> target, Value<?>... values) {\n             // find maximum and minimum values\n-            double[] doubles = new double[values.length];\n+            double[] doubles = new double[values.length + 1];\n             int i = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7db39c4c33c84eca961e21a8c1a0a24628d379e2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMwNjA5NQ==", "bodyText": "Magic number?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r535306095", "createdAt": "2020-12-03T14:59:14Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -130,7 +130,7 @@\n     },\n \n     NUMBER(\"number\") {\n-        private static final double CLUSTER_THRESHOLD = 1e-3;\n+        private static final double CLUSTER_THRESHOLD = 1e-1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3580d487a5dd0f45d40be5a8886a4ee68a30c10e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTE4NA==", "bodyText": "I see the same \"pattern\" in all the tests (not only PMML but all the others too) with only number of samples, topK and positive/negative stability score as difference.\nDoes it make sense to move it to a common method?\nAre all of them magic numbers? Like why 300/500 samples? Why the last assertion is >= 0.5/0.8?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r535905184", "createdAt": "2020-12-04T08:00:34Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -131,16 +144,29 @@ void testPMMLRegressionCategorical() throws Exception {\n             }\n             return outputs;\n         });\n-        PredictionOutput output = model.predictAsync(List.of(input))\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n-                .get(0);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        assertThat(predictionOutputs).isNotNull();\n+        assertThat(predictionOutputs).isNotEmpty();\n+        PredictionOutput output = predictionOutputs.get(0);\n+        assertThat(output).isNotNull();\n         Prediction prediction = new Prediction(input, output);\n         Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n                 .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n         for (Saliency saliency : saliencyMap.values()) {\n-            assertNotNull(saliency);\n-            double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(1));\n-            assertEquals(1d, v);\n+            assertThat(saliency).isNotNull();\n+            double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(2));\n+            assertThat(v).isEqualTo(1d);\n+        }\n+        int topK = 1;\n+        LocalSaliencyStability stability = ExplainabilityMetrics.getLocalSaliencyStability(model, prediction, limeExplainer, topK, 10);\n+        for (int i = 1; i <= topK; i++) {\n+            for (String decision : stability.getDecisions()) {\n+                double positiveStabilityScore = stability.getPositiveStabilityScore(decision, i);\n+                double negativeStabilityScore = stability.getNegativeStabilityScore(decision, i);\n+                assertThat(positiveStabilityScore).isGreaterThanOrEqualTo(0.5);\n+                assertThat(negativeStabilityScore).isGreaterThanOrEqualTo(0.5);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3580d487a5dd0f45d40be5a8886a4ee68a30c10e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk0MjM1OA==", "bodyText": "Why fixed value?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r540942358", "createdAt": "2020-12-11T13:21:49Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -164,20 +165,28 @@\n         @Override\n         public List<double[]> encode(Value<?> target, Value<?>... values) {\n             // find maximum and minimum values\n-            double[] doubles = new double[values.length];\n+            double[] doubles = new double[values.length + 1];\n             int i = 0;\n             for (Value<?> v : values) {\n                 doubles[i] = v.asNumber();\n                 i++;\n             }\n             double originalValue = target.asNumber();\n+            doubles[i] = originalValue; // include target number in feature scaling\n             double min = DoubleStream.of(doubles).min().orElse(Double.MIN_VALUE);\n             double max = DoubleStream.of(doubles).max().orElse(Double.MAX_VALUE);\n-            // feature scaling + kernel based clustering\n-            double threshold = DataUtils.gaussianKernel((originalValue - min) / (max - min), 0, 1);\n-            List<Double> encodedValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min))\n-                    .map(d -> Double.isNaN(d) ? 1 : d).boxed().map(d -> DataUtils.gaussianKernel(d, 0, 1))\n-                    .map(d -> (d - threshold < CLUSTER_THRESHOLD) ? 1d : 0d).collect(Collectors.toList());\n+\n+            // feature scaling\n+            List<Double> scaledValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min)).boxed().collect(Collectors.toList());\n+            double scaledOriginalValue = scaledValues.remove(i); // extract the scaled original value (it must not appear in encoded values)\n+\n+            // kernel based clustering\n+            double sigma = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3580d487a5dd0f45d40be5a8886a4ee68a30c10e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk0Mzk2MA==", "bodyText": "What about make both of them warn or debug?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r540943960", "createdAt": "2020-12-11T13:24:33Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -132,4 +139,102 @@ public static double classificationFidelity(List<Pair<Saliency, Prediction>> pai\n         }\n         return evals == 0 ? 0 : acc / evals;\n     }\n+\n+    /**\n+     * Evaluate stability of a local explainer generating {@code Saliencies}.\n+     * Such an evaluation is intended to measure how stable the explanations are in terms of \"are the top k most important\n+     * positive/negative features always the same for a single prediction?\".\n+     *\n+     * @param model                  a model to explain\n+     * @param prediction             the prediction on which explanation stability will be evaluated\n+     * @param saliencyLocalExplainer a local saliency explainer\n+     * @param topK                   no. of top k positive/negative features for which stability report will be generated\n+     * @return a report about stability of all the decisions/predictions (and for each {@code k < topK})\n+     */\n+    public static LocalSaliencyStability getLocalSaliencyStability(PredictionProvider model, Prediction prediction,\n+                                                                   LocalExplainer<Map<String, Saliency>> saliencyLocalExplainer,\n+                                                                   int topK, int runs)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Map<String, List<Saliency>> saliencies = getMultipleSaliencies(model, prediction, saliencyLocalExplainer, runs);\n+\n+        LocalSaliencyStability saliencyStability = new LocalSaliencyStability(saliencies.keySet());\n+        // for each decision, calculate the stability rate for the top k important feature set, for each k < topK\n+        for (Map.Entry<String, List<Saliency>> entry : saliencies.entrySet()) {\n+            for (int k = 1; k <= topK; k++) {\n+                String decision = entry.getKey();\n+                List<Saliency> perDecisionSaliencies = entry.getValue();\n+\n+                int finalK = k;\n+                // get the top k positive features list from each saliency and count the frequency of each such list across all saliencies\n+                Map<List<String>, Long> topKPositive = getTopKFeaturesFrequency(perDecisionSaliencies, s -> s.getPositiveFeatures(finalK));\n+                // get the most frequent list of positive features\n+                Pair<List<String>, Long> positiveMostFrequent = getMostFrequent(topKPositive);\n+                double positiveFrequencyRate = (double) positiveMostFrequent.getValue() / (double) perDecisionSaliencies.size();\n+\n+                // get the top k negative features list from each saliency and count the frequency of each such list across all saliencies\n+                Map<List<String>, Long> topKNegative = getTopKFeaturesFrequency(perDecisionSaliencies, s -> s.getNegativeFeatures(finalK));\n+                // get the most frequent list of negative features\n+                Pair<List<String>, Long> negativeMostFrequent = getMostFrequent(topKNegative);\n+                double negativeFrequencyRate = (double) negativeMostFrequent.getValue() / (double) perDecisionSaliencies.size();\n+\n+                // decision stability at k\n+                List<String> positiveFeatureNames = positiveMostFrequent.getKey();\n+                List<String> negativeFeatureNames = negativeMostFrequent.getKey();\n+                saliencyStability.add(decision, k, positiveFeatureNames, positiveFrequencyRate, negativeFeatureNames, negativeFrequencyRate);\n+            }\n+        }\n+        return saliencyStability;\n+    }\n+\n+    /**\n+     * Get multiple saliencies, aggregated by decision name.\n+     *\n+     * @param model                  the model used to perform predictions\n+     * @param prediction             the prediction to explain\n+     * @param saliencyLocalExplainer a local explainer that generates saliences\n+     * @param runs                   the no. of explanations to be generated\n+     * @return the generated saliencies, aggregated by decision name, across the different runs\n+     */\n+    private static Map<String, List<Saliency>> getMultipleSaliencies(PredictionProvider model, Prediction prediction,\n+                                                                     LocalExplainer<Map<String, Saliency>> saliencyLocalExplainer,\n+                                                                     int runs)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+        Map<String, List<Saliency>> saliencies = new HashMap<>();\n+        int skipped = 0;\n+        for (int i = 0; i < runs; i++) {\n+            Map<String, Saliency> saliencyMap = saliencyLocalExplainer.explainAsync(prediction, model)\n+                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+            for (Map.Entry<String, Saliency> saliencyEntry : saliencyMap.entrySet()) {\n+                // aggregate saliencies by output name\n+                List<FeatureImportance> topFeatures = saliencyEntry.getValue().getTopFeatures(1);\n+                if (!topFeatures.isEmpty() && topFeatures.get(0).getScore() != 0) { // skip empty or 0 valued saliencies\n+                    if (saliencies.containsKey(saliencyEntry.getKey())) {\n+                        List<Saliency> localSaliencies = saliencies.get(saliencyEntry.getKey());\n+                        List<Saliency> updatedSaliencies = new ArrayList<>(localSaliencies);\n+                        updatedSaliencies.add(saliencyEntry.getValue());\n+                        saliencies.put(saliencyEntry.getKey(), updatedSaliencies);\n+                    } else {\n+                        saliencies.put(saliencyEntry.getKey(), List.of(saliencyEntry.getValue()));\n+                    }\n+                } else {\n+                    LOGGER.warn(\"skipping empty / zero saliency for {}\", saliencyEntry.getKey());\n+                    skipped++;\n+                }\n+            }\n+        }\n+        LOGGER.debug(\"skipped {} useless saliencies\", skipped);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3580d487a5dd0f45d40be5a8886a4ee68a30c10e"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59a83e1c4e624334d9e8616ecfb9a538d7d8975", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/b59a83e1c4e624334d9e8616ecfb9a538d7d8975", "committedDate": "2020-12-11T14:42:15Z", "message": "KOGITO-3763 - consistent debug level in metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53696c9d78ef55cb9ae5a76c354ab4db9311cf8d", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/53696c9d78ef55cb9ae5a76c354ab4db9311cf8d", "committedDate": "2020-12-11T14:58:56Z", "message": "KOGITO-3763 - renamed index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6713f89de9a5f3718465b8e66d2571ff208712b0", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/6713f89de9a5f3718465b8e66d2571ff208712b0", "committedDate": "2020-12-11T15:40:00Z", "message": "KOGITO-3763 - checking stability on dummy models"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2", "committedDate": "2020-12-11T16:37:39Z", "message": "KOGITO-3763 - added validation utils to validate local saliency stability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMzQ3Mzgy", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-551347382", "createdAt": "2020-12-14T13:08:01Z", "commit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzowODowMVrOIFPliQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMTo1M1rOIFPvHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2OTE2MQ==", "bodyText": "Would it be possible make \"0.01\" a constant and move it somewhere up to be more visible. I think it is better to have constants visible rather than hidden inside mothods etc.", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542369161", "createdAt": "2020-12-14T13:08:01Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -150,12 +150,13 @@\n             // sample from a standard normal distribution and center around feature value\n             double normalDistributionSample = perturbationContext.getRandom().nextGaussian();\n             if (originalFeatureValue != 0d) {\n-                normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                double stDev = originalFeatureValue * 0.01; // set std dev at 1% of feature value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MDczNw==", "bodyText": "Same here. Can we make \"1d\" a constant and move it to more visible place?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542370737", "createdAt": "2020-12-14T13:10:32Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -150,12 +150,13 @@\n             // sample from a standard normal distribution and center around feature value\n             double normalDistributionSample = perturbationContext.getRandom().nextGaussian();\n             if (originalFeatureValue != 0d) {\n-                normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                double stDev = originalFeatureValue * 0.01; // set std dev at 1% of feature value\n+                normalDistributionSample = normalDistributionSample * originalFeatureValue + stDev;\n             }\n             if (intValue) {\n                 normalDistributionSample = (int) normalDistributionSample;\n                 if (normalDistributionSample == originalFeatureValue) {\n-                    normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    normalDistributionSample = (int) normalDistributionSample + 1d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MTYxNQ==", "bodyText": "+1 for using assertj instead of junit asserts.", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542371615", "createdAt": "2020-12-14T13:11:53Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -25,6 +25,11 @@\n       <artifactId>quarkus-junit5</artifactId>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNDM3ODI2", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-551437826", "createdAt": "2020-12-14T14:46:10Z", "commit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNDU5MDUx", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-551459051", "createdAt": "2020-12-14T15:07:32Z", "commit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNDc0MjI5", "url": "https://github.com/kiegroup/kogito-apps/pull/530#pullrequestreview-551474229", "createdAt": "2020-12-14T15:22:33Z", "commit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyMjozM1rOIFVrPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyNzo0NlrOIFV8zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ2ODkyNA==", "bodyText": "just wondering.. if Double.isNan(d) is true the previous call at line 180\n            List<Double> scaledValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min)).boxed().collect(Collectors.toList());\n\nshould have crashed right?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542468924", "createdAt": "2020-12-14T15:22:33Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -164,20 +165,28 @@\n         @Override\n         public List<double[]> encode(Value<?> target, Value<?>... values) {\n             // find maximum and minimum values\n-            double[] doubles = new double[values.length];\n-            int i = 0;\n+            double[] doubles = new double[values.length + 1];\n+            int valueIndex = 0;\n             for (Value<?> v : values) {\n-                doubles[i] = v.asNumber();\n-                i++;\n+                doubles[valueIndex] = v.asNumber();\n+                valueIndex++;\n             }\n             double originalValue = target.asNumber();\n+            doubles[valueIndex] = originalValue; // include target number in feature scaling\n             double min = DoubleStream.of(doubles).min().orElse(Double.MIN_VALUE);\n             double max = DoubleStream.of(doubles).max().orElse(Double.MAX_VALUE);\n-            // feature scaling + kernel based clustering\n-            double threshold = DataUtils.gaussianKernel((originalValue - min) / (max - min), 0, 1);\n-            List<Double> encodedValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min))\n-                    .map(d -> Double.isNaN(d) ? 1 : d).boxed().map(d -> DataUtils.gaussianKernel(d, 0, 1))\n-                    .map(d -> (d - threshold < CLUSTER_THRESHOLD) ? 1d : 0d).collect(Collectors.toList());\n+\n+            // feature scaling\n+            List<Double> scaledValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min)).boxed().collect(Collectors.toList());\n+            double scaledOriginalValue = scaledValues.remove(valueIndex); // extract the scaled original value (it must not appear in encoded values)\n+\n+            // kernel based clustering\n+            double sigma = 1;\n+            double threshold = DataUtils.gaussianKernel(scaledOriginalValue, scaledOriginalValue, sigma);\n+            List<Double> clusteredValues = scaledValues.stream()\n+                    .map(d -> Double.isNaN(d) ? 0 : d).map(d -> DataUtils.gaussianKernel(d, scaledOriginalValue, sigma)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MTkzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void testPrequalificationDMNExplanation1() throws ExecutionException, InterruptedException, TimeoutException {\n          \n          \n            \n                void testPrequalificationDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542471931", "createdAt": "2020-12-14T15:26:11Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/PrequalificationDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeConfig;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.PerturbationContext;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+import org.kie.kogito.explainability.utils.ValidationUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class PrequalificationDmnLimeExplainerTest {\n+\n+    @Test\n+    void testPrequalificationDMNExplanation1() throws ExecutionException, InterruptedException, TimeoutException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzQyMQ==", "bodyText": "And rename Prequalification-1 file?", "url": "https://github.com/kiegroup/kogito-apps/pull/530#discussion_r542473421", "createdAt": "2020-12-14T15:27:46Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/PrequalificationDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeConfig;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.PerturbationContext;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+import org.kie.kogito.explainability.utils.ValidationUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class PrequalificationDmnLimeExplainerTest {\n+\n+    @Test\n+    void testPrequalificationDMNExplanation1() throws ExecutionException, InterruptedException, TimeoutException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MTkzMQ=="}, "originalCommit": {"oid": "4a42ffb10648bb781ec9fd7f0b74b1e80b5fcfe2"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4f49c55decbc6258ece0a5376082bbed9252a53", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/b4f49c55decbc6258ece0a5376082bbed9252a53", "committedDate": "2020-12-14T16:17:39Z", "message": "Update explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/PrequalificationDmnLimeExplainerTest.java\n\nCo-authored-by: Jacopo Rota <jacopo.r00ta@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "839f28843cc3c2e8f6df4c6bfea037eb55de4fbb", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/839f28843cc3c2e8f6df4c6bfea037eb55de4fbb", "committedDate": "2020-12-14T16:48:43Z", "message": "KOGITO-3763 - fixed NaN encoding issue"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4681, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}