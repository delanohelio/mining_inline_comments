{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODM2NTA4", "number": 342, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MToyOVrOERiISA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MjoyN1rOERiJqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIwNDI0OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MToyOVrOG2TJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MToyOVrOG2TJ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDEwMw==", "bodyText": "I've moved the old content of this class to TraceEventConsumerInfinispanIT since it's an integration test that uses also infinispan.", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590103", "createdAt": "2020-07-23T16:51:29Z", "author": {"login": "r00ta"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODIwNzc3OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MjoyN1rOG2TL_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MjoyN1rOG2TL_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDY1NA==", "bodyText": "This is the new test that checks that both events are processed. With the old implementation only the first one was processed", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590654", "createdAt": "2020-07-23T16:52:27Z", "author": {"login": "r00ta"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {\n \n-    @Inject\n+    @InjectMock\n     TrustyService trustyService;\n \n-    @Inject\n-    TrustyStorageService trustyStorageService;\n-\n     KafkaProducer<String, String> producer;\n \n     @BeforeEach\n     public void setup() {\n-        trustyStorageService.getDecisionsStorage().clear();\n-\n-        System.err.println(\"kafka.bootstrap.servers: \" + System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"));\n-\n-        producer = KafkaProducer.create(Vertx.vertx(), Map.of(\n-                \"bootstrap.servers\", System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"),\n-                \"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"acks\", \"all\"\n-        ));\n+        producer = generateProducer();\n     }\n \n     @Test\n-    void testCorrectCloudEvent() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent()));\n-        Decision storedDecision = trustyService.getDecisionById(CORRECT_CLOUDEVENT_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildCorrectDecision(), storedDecision);\n-    }\n-\n-    @Test\n-    void testCloudEventWithErrors() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildTraceEventWithErrors()));\n-        Decision storedDecision = trustyService.getDecisionById(CLOUDEVENT_WITH_ERRORS_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildDecisionWithErrors(), storedDecision);\n-    }\n+    public void eventLoopIsNotStoppedWithException() throws Exception {\n+        String executionIdException = \"idException\";\n+        String executionIdNoException = \"idNoException\";\n+        doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeDecision(eq(executionIdException), any(Decision.class));\n+        doNothing().when(trustyService).storeDecision(eq(executionIdNoException), any(Decision.class));\n \n-    private CompletableFuture<Void> sendToKafka(String payload) {\n-        CompletableFuture<Void> future = new CompletableFuture<>();\n-        producer.write(KafkaProducerRecord.create(\"trusty-service-test\", payload), event -> {\n-            if (event.succeeded()) {\n-                future.complete(null);\n-            } else {\n-                future.completeExceptionally(event.cause());\n-            }\n-        });\n-        return future;\n-    }\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdException)), producer);\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdNoException)), producer);\n \n-    private void sendToKafkaAndWaitForCompletion(String payload) throws Exception {\n-        sendToKafka(payload)\n-                .thenRunAsync(() -> LOG.info(\"Sent payload to Kafka (length: {})\", payload.length()), CompletableFuture.delayedExecutor(2L, TimeUnit.SECONDS))\n-                .get(15L, TimeUnit.SECONDS);\n+        verify(trustyService, times(2)).storeDecision(any(String.class), any(Decision.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "originalPosition": 117}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 852, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}