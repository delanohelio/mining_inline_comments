{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTU5NjQ1", "number": 428, "title": "KOGITO-3228: add outcome ids to saliency model", "bodyText": "JIRA task", "createdAt": "2020-09-01T15:25:39Z", "url": "https://github.com/kiegroup/kogito-apps/pull/428", "merged": true, "mergeCommit": {"oid": "b023860bdf56a11b0ecd4c04e355b0bc718cae7f"}, "closed": true, "closedAt": "2020-09-04T14:40:57Z", "author": {"login": "kostola"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdE6IG-gBqjM3MTkxNzIzOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFmI0ggFqTQ4MjcwMjIwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2462e4d7063a7e833822ff8127d65563a973a48", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/c2462e4d7063a7e833822ff8127d65563a973a48", "committedDate": "2020-09-02T08:56:09Z", "message": "KOGITO-3228: fix test"}, "afterCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/c4de24b95ac188e9ef3d653604c019edb5a8384a", "committedDate": "2020-09-02T11:16:09Z", "message": "KOGITO-3228: add status details field to explainability result"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNzMzODM1", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-480733835", "createdAt": "2020-09-02T11:38:49Z", "commit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTozODo0OVrOHLrHUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo0Mzo0OFrOHL38kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA==", "bodyText": "What is the reason of this change?\ngetPrediction is plain local method and localExplainer.explainAsync already create the CompletableFuture internally.\nI don't see the reason to add this additional wrapper. Btw you should not use any *Async methods without providing the executor in a managed environment", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482002768", "createdAt": "2020-09-02T11:38:49Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA==", "bodyText": "Please add an assertion on the value too", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482003730", "createdAt": "2020-09-02T11:40:44Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "diffHunk": "@@ -57,27 +58,49 @@ void init() {\n         localExplainerMock = mock(LocalExplainer.class);\n         predictionProviderMock = mock(PredictionProvider.class);\n         explanationService = new ExplanationServiceImpl(localExplainerMock);\n-\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock))).thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n     }\n \n     @Test\n-    void explainAsync() throws InterruptedException, ExecutionException, TimeoutException {\n-        CompletionStage<ExplainabilityResultDto> explainAsync = explanationService.explainAsync(REQUEST, predictionProviderMock);\n+    void testExplainAsyncSucceeded() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n \n-        ExplainabilityResultDto resultDto = explainAsync.toCompletableFuture()\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n \n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.SUCCEEDED, resultDto.getStatus());\n+        assertNull(resultDto.getStatusDetails());\n         assertEquals(SALIENCY_MAP.size(), resultDto.getSaliencies().size());\n         assertTrue(resultDto.getSaliencies().containsKey(\"key\"));\n \n         SaliencyDto saliencyDto = resultDto.getSaliencies().get(\"key\");\n         assertEquals(SALIENCY.getPerFeatureImportance().size(), saliencyDto.getFeatureImportance().size());\n \n         FeatureImportanceDto featureImportanceDto1 = saliencyDto.getFeatureImportance().get(0);\n-        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureId());\n+        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA==", "bodyText": "Wdym?\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482170910", "createdAt": "2020-09-02T15:39:45Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -43,16 +47,29 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+// TODO: improve this test with decision values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng==", "bodyText": "Can you please update/re-enable these assertions?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482171566", "createdAt": "2020-09-02T15:40:38Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -75,48 +92,48 @@ void testInvalidPayload() {\n \n     @Test\n     void testExceptionsAreCatched() {\n-        Message<String> message = mockMessage(buildCloudEventJsonString(new ExplainabilityResultDto(\"test\", emptyMap())));\n+        Message<String> message = mockMessage(buildCloudEventJsonString(ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, emptyMap())));\n \n         doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeExplainabilityResult(any(String.class), any(ExplainabilityResult.class));\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n     @Test\n     public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null));\n+        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(resultDto);\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n \n         Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(resultDto.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(resultDto.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(resultDto.getSaliencies().containsKey(\"saliency\"));\n-        Assertions.assertEquals(resultDto.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-                explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n+        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n+        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMTUwOQ==", "bodyText": "From what I can see, the only reason to add this dependency is ExplainabilityStatus. Is this really needed? We have Saliency and many other classes that are sort of duplicated here so I don't know if it makes sense to add the dependency just for a simple enum. Wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482211509", "createdAt": "2020-09-02T16:41:21Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-storage/trusty-storage-api/pom.xml", "diffHunk": "@@ -13,6 +13,10 @@\n   <name>Kogito :: Trusty Storage API</name>\n \n   <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ==", "bodyText": "Can you please add a log message if there are no Decision that match with executionId?\nCan you also add a test for it?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482213009", "createdAt": "2020-09-02T16:43:48Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +85,43 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n+        Decision decision = service.getDecisionById(executionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef114be0ed09b87b8fe3e93836736f904044bb3b", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/ef114be0ed09b87b8fe3e93836736f904044bb3b", "committedDate": "2020-09-03T07:32:23Z", "message": "KOGITO-3228: add outcome ids to saliency model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35b20c28fef8328844dc1c01f75db4c5c5349722", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/35b20c28fef8328844dc1c01f75db4c5c5349722", "committedDate": "2020-09-03T07:32:23Z", "message": "KOGITO-3228: add status directly to ExplainabilityResultDto instead of boolean attribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01c0deea104fb557702d054f9dc7435d5417c467", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/01c0deea104fb557702d054f9dc7435d5417c467", "committedDate": "2020-09-03T07:32:23Z", "message": "KOGITO-3228: fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7a184c1bdcb33d367f48022bd4576266680da81", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/d7a184c1bdcb33d367f48022bd4576266680da81", "committedDate": "2020-09-03T07:32:23Z", "message": "KOGITO-3228: add status details field to explainability result"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "committedDate": "2020-09-03T07:32:23Z", "message": "KOGITO-3228: add 'explanation' prefix to saliencies endpoint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "committedDate": "2020-09-03T08:57:37Z", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/884822e982dead2623cdf7b4bba86435d7eb58f7", "committedDate": "2020-09-02T13:22:20Z", "message": "KOGITO-3228: add 'explanation' prefix to saliencies endpoint"}, "afterCommit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "committedDate": "2020-09-03T08:57:37Z", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c01963439757c1823b0abef8b6ac4c69c004e1bf", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/c01963439757c1823b0abef8b6ac4c69c004e1bf", "committedDate": "2020-09-03T09:38:40Z", "message": "KOGITO-3228: remove explainability-api dependency from trusty-storage-api"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjc2NjQw", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-481676640", "createdAt": "2020-09-03T09:47:12Z", "commit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTo0NzoxMlrOHMe8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTo0NzoxMlrOHMe8VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA==", "bodyText": "Is the try catch needed in this case? Is there a test for such scenario?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482851924", "createdAt": "2020-09-03T09:47:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "committedDate": "2020-09-03T10:54:14Z", "message": "KOGITO-3228: improve ExplainabilityResultConsumerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164", "author": {"user": {"login": "kostola", "name": "Alessandro Costa"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/6479a29d043ee911e695c46b44f9ae1060a22164", "committedDate": "2020-09-03T11:04:43Z", "message": "KOGITO-3228: handle IllegalArgumentException in ExplainabilityResultConsumer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxODAxMDU3", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-481801057", "createdAt": "2020-09-03T12:45:56Z", "commit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDQ5Mzc4", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-482449378", "createdAt": "2020-09-04T08:12:04Z", "commit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjowNFrOHNEEuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMzo1NFrOHNEIqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA==", "bodyText": "Shouldn't we rather throw or exception or return some error info here?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460280", "createdAt": "2020-09-04T08:12:04Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460664", "createdAt": "2020-09-04T08:12:46Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461072", "createdAt": "2020-09-04T08:13:31Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTI4OQ==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461289", "createdAt": "2020-09-04T08:13:54Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;\n         }\n         List<FeatureImportance> featureImportance = dto.getFeatureImportance() == null ? null :\n                 dto.getFeatureImportance().stream()\n                         .map(ExplainabilityResultConsumer::featureImportanceFrom)\n                         .collect(Collectors.toList());\n-        return new Saliency(featureImportance);\n+        return new Saliency(outcomeId, outcomeName, featureImportance);\n     }\n-}\n \n+    protected static ExplainabilityStatus statusFrom(org.kie.kogito.explainability.api.ExplainabilityStatus status) {\n+        switch (status) {\n+            case SUCCEEDED:\n+                return ExplainabilityStatus.SUCCEEDED;\n+            case FAILED:\n+                return ExplainabilityStatus.FAILED;\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNjY2MzYy", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-482666362", "createdAt": "2020-09-04T13:47:46Z", "commit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNzAyMjA0", "url": "https://github.com/kiegroup/kogito-apps/pull/428#pullrequestreview-482702204", "createdAt": "2020-09-04T14:32:53Z", "commit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4741, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}