{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NTIyOTc1", "number": 439, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo1OToxMlrOEhNdHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoyMVrOEogoTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjU4OTA5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo1OToxMlrOHOZjDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDowMToxN1rOHOeqQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDY4NQ==", "bodyText": "remove print", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484860685", "createdAt": "2020-09-08T11:59:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0NDQ0OQ==", "bodyText": "ouch! sure :)", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484944449", "createdAt": "2020-09-08T14:01:17Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDY4NQ=="}, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjYwNDM1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjowMzozNlrOHOZsMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjoyMTo1NVrOHPPkKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg==", "bodyText": "what are the cases in which ExplainabilityMetrics.impactScore returns 0?", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863026", "createdAt": "2020-09-08T12:03:36Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            if (!topFeatures.isEmpty()) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0NTYwMw==", "bodyText": "when the drop of important features doesn't trigger a flipped prediction (or a significant drop in the output score).", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484945603", "createdAt": "2020-09-08T14:02:55Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            if (!topFeatures.isEmpty()) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg=="}, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0NTcwNQ==", "bodyText": "Can you please add a comment with this explaination?", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r485745705", "createdAt": "2020-09-09T16:21:55Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            if (!topFeatures.isEmpty()) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg=="}, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjYwNzYwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjowNDozMFrOHOZuBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjowNDozMFrOHOZuBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzQ5NA==", "bodyText": "not needed?", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863494", "createdAt": "2020-09-08T12:04:30Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjc2MzY4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo0NzowNVrOHObMCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNDoxMzozNlrOHOfNIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzU2Mg==", "bodyText": "Just a proposal changing the contract of the method so to avoid side effects and make it a bit more clean imo\n\n    public static Feature newCompositeFeature(String name, Map<String, Object> map) {\n        List<Feature> features = new LinkedList<>();\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n            features.add(parseFeatureValue(entry.getKey(), entry.getValue()));\n        }\n        return newCompositeFeature(name, features);\n    }\n\n    public static Feature newCompositeFeature(String name, List<Feature> features) {\n        return new Feature(name, Type.COMPOSITE, new Value<>(features));\n    }\n\n    private static Feature parseFeatureValue(String featureName, Object value) {\n        if (value instanceof Map) {\n            return newCompositeFeature(featureName, (Map<String, Object>) value);\n        } else if (value instanceof double[]) {\n            return newVectorFeature(featureName, (double[]) value);\n        } else if (value instanceof LocalTime) {\n            return newTimeFeature(featureName, (LocalTime) value);\n        } else if (value instanceof Duration) {\n            return newDurationFeature(featureName, (Duration) value);\n        } else if (value instanceof URI) {\n            return newURIFeature(featureName, (URI) value);\n        } else if (value instanceof ByteBuffer) {\n            return newBinaryFeature(featureName, (ByteBuffer) value);\n        } else if (value instanceof Currency) {\n            return newCurrencyFeature(featureName, (Currency) value);\n        } else if (value instanceof Boolean) {\n            return newBooleanFeature(featureName, (Boolean) value);\n        } else if (value instanceof Number) {\n            return newNumericalFeature(featureName, (Number) value);\n        } else if (value instanceof String) {\n            return newTextFeature(featureName, (String) value);\n        } else if (value instanceof Feature) {\n            return (Feature) value;\n        } else if (value instanceof List) {\n            List<?> items = (List<?>) value;\n            if (!items.isEmpty()) {\n                if (items.get(0) instanceof Feature) {\n                    return newCompositeFeature(featureName, (List<Feature>) items);\n                } else {\n                    List<?> values = (List<?>) value;\n                    List<Feature> fs = IntStream.range(0, values.size())\n                            .mapToObj(i -> parseFeatureValue(featureName + \"_\" + i, values.get(i)))\n                            .collect(Collectors.toList());\n                    return newCompositeFeature(featureName, fs);\n                }\n            } else {\n                return newCompositeFeature(featureName, Collections.emptyList());\n            }\n        } else {\n            return newObjectFeature(featureName, value);\n        }\n    }", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484887562", "createdAt": "2020-09-08T12:47:05Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -131,11 +133,25 @@ private static void parseFeatureValue(List<Feature> features, Map.Entry<String,\n         } else if (value instanceof Feature) {\n             feature = (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    feature = newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    Map<String, Object> map = new HashMap<>();\n+                    int index = 0;\n+                    for (Object o : (List<?>) value) {\n+                        map.put(featureName + \"_\" + index, o);\n+                        index++;\n+                    }\n+                    List<Feature> fs = new ArrayList<>(map.size());\n+                    for (Map.Entry<String, Object> e : map.entrySet()) {\n+                        parseFeatureValue(fs, e);\n+                    }\n+                    feature = newCompositeFeature(featureName, fs);\n+                }\n+            } else {\n+                feature = newCompositeFeature(featureName, Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1MzM3Ng==", "bodyText": "sounds good to me, thanks.", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484953376", "createdAt": "2020-09-08T14:13:36Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -131,11 +133,25 @@ private static void parseFeatureValue(List<Feature> features, Map.Entry<String,\n         } else if (value instanceof Feature) {\n             feature = (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    feature = newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    Map<String, Object> map = new HashMap<>();\n+                    int index = 0;\n+                    for (Object o : (List<?>) value) {\n+                        map.put(featureName + \"_\" + index, o);\n+                        index++;\n+                    }\n+                    List<Feature> fs = new ArrayList<>(map.size());\n+                    for (Map.Entry<String, Object> e : map.entrySet()) {\n+                        parseFeatureValue(fs, e);\n+                    }\n+                    feature = newCompositeFeature(featureName, fs);\n+                }\n+            } else {\n+                feature = newCompositeFeature(featureName, Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzU2Mg=="}, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODY4MDA4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo1NDoyOVrOHPTa8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo1NDoyOVrOHPTa8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwODg4Mg==", "bodyText": "You can use items instead of create values", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r485808882", "createdAt": "2020-09-09T17:54:29Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -104,43 +108,47 @@ public static Feature newCompositeFeature(String name, List<Feature> features) {\n         return new Feature(name, Type.COMPOSITE, new Value<>(features));\n     }\n \n-    private static void parseFeatureValue(List<Feature> features, Map.Entry<String, Object> entry) {\n-        Object value = entry.getValue();\n-        String featureName = entry.getKey();\n-        Feature feature;\n+    private static Feature parseFeatureValue(String featureName, Object value) {\n         if (value instanceof Map) {\n-            feature = newCompositeFeature(featureName, (Map<String, Object>) value);\n+            return newCompositeFeature(featureName, (Map<String, Object>) value);\n         } else if (value instanceof double[]) {\n-            feature = newVectorFeature(featureName, (double[]) value);\n+            return newVectorFeature(featureName, (double[]) value);\n         } else if (value instanceof LocalTime) {\n-            feature = newTimeFeature(featureName, (LocalTime) value);\n+            return newTimeFeature(featureName, (LocalTime) value);\n         } else if (value instanceof Duration) {\n-            feature = newDurationFeature(featureName, (Duration) value);\n+            return newDurationFeature(featureName, (Duration) value);\n         } else if (value instanceof URI) {\n-            feature = newURIFeature(featureName, (URI) value);\n+            return newURIFeature(featureName, (URI) value);\n         } else if (value instanceof ByteBuffer) {\n-            feature = newBinaryFeature(featureName, (ByteBuffer) value);\n+            return newBinaryFeature(featureName, (ByteBuffer) value);\n         } else if (value instanceof Currency) {\n-            feature = newCurrencyFeature(featureName, (Currency) value);\n+            return newCurrencyFeature(featureName, (Currency) value);\n         } else if (value instanceof Boolean) {\n-            feature = newBooleanFeature(featureName, (Boolean) value);\n+            return newBooleanFeature(featureName, (Boolean) value);\n         } else if (value instanceof Number) {\n-            feature = newNumericalFeature(featureName, (Number) value);\n+            return newNumericalFeature(featureName, (Number) value);\n         } else if (value instanceof String) {\n-            feature = newTextFeature(featureName, (String) value);\n+            return newTextFeature(featureName, (String) value);\n         } else if (value instanceof Feature) {\n-            feature = (Feature) value;\n+            return (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    return newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    List<?> values = (List<?>) value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTEzMDMwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoxMFrOHZpI_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoxMFrOHZpI_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDQ5NA==", "bodyText": "I would suggest to use Assertj. It provides more specific types of asserts and it is easier to see where the problem is.", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650494", "createdAt": "2020-09-29T11:44:10Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTEzMTAwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoyMVrOHZpJaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoyMVrOHZpJaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDYwMA==", "bodyText": "Unexpected new line.", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650600", "createdAt": "2020-09-29T11:44:21Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 689, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}