{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTU5NjQ1", "number": 428, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTozODo0OVrOEfahEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMzo1NFrOEgSaVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzc1NzYzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTozODo0OVrOHLrHUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTowMDoxMVrOHMdCww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA==", "bodyText": "What is the reason of this change?\ngetPrediction is plain local method and localExplainer.explainAsync already create the CompletableFuture internally.\nI don't see the reason to add this additional wrapper. Btw you should not use any *Async methods without providing the executor in a managed environment", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482002768", "createdAt": "2020-09-02T11:38:49Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NDQ5Mg==", "bodyText": "This is needed imho. The implementation of LimeExplainer does not wrap everything in a CompletableFuture, but instead does some computation before, that may lead to an exception being thrown (e.g. when the Prediction object it receives has no inputs).\nWith the original implementation, exceptions thrown directly in explainAsync wouldn't be catched by the exceptionally block and then bubble up to the event loop thread, blocking the whole computation (which means no failure message being sent back to the Trusty Service).\nThis way, even if the localExplainer implementation is not perfect, we are sure to catch every exception it may throw in the exceptionally block.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482754492", "createdAt": "2020-09-03T07:08:43Z", "author": {"login": "kostola"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyMDgwMw==", "bodyText": "As @danielezonca suggested in a chat discussion we had, I now handled this issue using a try catch block instead of calling CompletableFuture::supplyAsync to avoid overloading the event loop too much.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482820803", "createdAt": "2020-09-03T09:00:11Z", "author": {"login": "kostola"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMzc2NDI0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMTo0MDo0NFrOHLrLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODo1ODoxNFrOHMc9uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA==", "bodyText": "Please add an assertion on the value too", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482003730", "createdAt": "2020-09-02T11:40:44Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "diffHunk": "@@ -57,27 +58,49 @@ void init() {\n         localExplainerMock = mock(LocalExplainer.class);\n         predictionProviderMock = mock(PredictionProvider.class);\n         explanationService = new ExplanationServiceImpl(localExplainerMock);\n-\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock))).thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n     }\n \n     @Test\n-    void explainAsync() throws InterruptedException, ExecutionException, TimeoutException {\n-        CompletionStage<ExplainabilityResultDto> explainAsync = explanationService.explainAsync(REQUEST, predictionProviderMock);\n+    void testExplainAsyncSucceeded() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n \n-        ExplainabilityResultDto resultDto = explainAsync.toCompletableFuture()\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n \n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.SUCCEEDED, resultDto.getStatus());\n+        assertNull(resultDto.getStatusDetails());\n         assertEquals(SALIENCY_MAP.size(), resultDto.getSaliencies().size());\n         assertTrue(resultDto.getSaliencies().containsKey(\"key\"));\n \n         SaliencyDto saliencyDto = resultDto.getSaliencies().get(\"key\");\n         assertEquals(SALIENCY.getPerFeatureImportance().size(), saliencyDto.getFeatureImportance().size());\n \n         FeatureImportanceDto featureImportanceDto1 = saliencyDto.getFeatureImportance().get(0);\n-        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureId());\n+        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxOTUxMg==", "bodyText": "Done \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482819512", "createdAt": "2020-09-03T08:58:14Z", "author": {"login": "kostola"}, "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "diffHunk": "@@ -57,27 +58,49 @@ void init() {\n         localExplainerMock = mock(LocalExplainer.class);\n         predictionProviderMock = mock(PredictionProvider.class);\n         explanationService = new ExplanationServiceImpl(localExplainerMock);\n-\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock))).thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n     }\n \n     @Test\n-    void explainAsync() throws InterruptedException, ExecutionException, TimeoutException {\n-        CompletionStage<ExplainabilityResultDto> explainAsync = explanationService.explainAsync(REQUEST, predictionProviderMock);\n+    void testExplainAsyncSucceeded() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n \n-        ExplainabilityResultDto resultDto = explainAsync.toCompletableFuture()\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n \n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.SUCCEEDED, resultDto.getStatus());\n+        assertNull(resultDto.getStatusDetails());\n         assertEquals(SALIENCY_MAP.size(), resultDto.getSaliencies().size());\n         assertTrue(resultDto.getSaliencies().containsKey(\"key\"));\n \n         SaliencyDto saliencyDto = resultDto.getSaliencies().get(\"key\");\n         assertEquals(SALIENCY.getPerFeatureImportance().size(), saliencyDto.getFeatureImportance().size());\n \n         FeatureImportanceDto featureImportanceDto1 = saliencyDto.getFeatureImportance().get(0);\n-        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureId());\n+        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA=="}, "originalCommit": {"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDgyMDk1OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTozOTo0NVrOHL1YHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTowNTo0MlrOHMhjSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA==", "bodyText": "Wdym?\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482170910", "createdAt": "2020-09-02T15:39:45Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -43,16 +47,29 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+// TODO: improve this test with decision values", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDY2Ng==", "bodyText": "Sorry that was a leftover. I implemented that part now.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894666", "createdAt": "2020-09-03T11:05:42Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -43,16 +47,29 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+// TODO: improve this test with decision values", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA=="}, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDgyNTE2OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo0MDozOFrOHL1arg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTowNTo1NVrOHMhjsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng==", "bodyText": "Can you please update/re-enable these assertions?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482171566", "createdAt": "2020-09-02T15:40:38Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -75,48 +92,48 @@ void testInvalidPayload() {\n \n     @Test\n     void testExceptionsAreCatched() {\n-        Message<String> message = mockMessage(buildCloudEventJsonString(new ExplainabilityResultDto(\"test\", emptyMap())));\n+        Message<String> message = mockMessage(buildCloudEventJsonString(ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, emptyMap())));\n \n         doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeExplainabilityResult(any(String.class), any(ExplainabilityResult.class));\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n     @Test\n     public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null));\n+        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(resultDto);\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n \n         Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(resultDto.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(resultDto.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(resultDto.getSaliencies().containsKey(\"saliency\"));\n-        Assertions.assertEquals(resultDto.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-                explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n+        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n+        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDc3MQ==", "bodyText": "Done. It needed some refactoring but now it's ok.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894771", "createdAt": "2020-09-03T11:05:55Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -75,48 +92,48 @@ void testInvalidPayload() {\n \n     @Test\n     void testExceptionsAreCatched() {\n-        Message<String> message = mockMessage(buildCloudEventJsonString(new ExplainabilityResultDto(\"test\", emptyMap())));\n+        Message<String> message = mockMessage(buildCloudEventJsonString(ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, emptyMap())));\n \n         doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeExplainabilityResult(any(String.class), any(ExplainabilityResult.class));\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n     @Test\n     public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null));\n+        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(resultDto);\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n \n         Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(resultDto.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(resultDto.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(resultDto.getSaliencies().containsKey(\"saliency\"));\n-        Assertions.assertEquals(resultDto.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-                explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n+        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n+        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng=="}, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTA3MzYzOnYy", "diffSide": "RIGHT", "path": "trusty/trusty-storage/trusty-storage-api/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo0MToyMVrOHL32tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTo0MDowNFrOHMeqNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMTUwOQ==", "bodyText": "From what I can see, the only reason to add this dependency is ExplainabilityStatus. Is this really needed? We have Saliency and many other classes that are sort of duplicated here so I don't know if it makes sense to add the dependency just for a simple enum. Wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482211509", "createdAt": "2020-09-02T16:41:21Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-storage/trusty-storage-api/pom.xml", "diffHunk": "@@ -13,6 +13,10 @@\n   <name>Kogito :: Trusty Storage API</name>\n \n   <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NzI4NQ==", "bodyText": "I removed the dependency and created a dedicated ExplainabilityStatus enum in trusty-storage-api. When we're done with the first release we may discuss a refactoring of this part.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482847285", "createdAt": "2020-09-03T09:40:04Z", "author": {"login": "kostola"}, "path": "trusty/trusty-storage/trusty-storage-api/pom.xml", "diffHunk": "@@ -13,6 +13,10 @@\n   <name>Kogito :: Trusty Storage API</name>\n \n   <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMTUwOQ=="}, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNTA4Mjc1OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjo0Mzo0OFrOHL38kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTowNjowNFrOHMhj5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ==", "bodyText": "Can you please add a log message if there are no Decision that match with executionId?\nCan you also add a test for it?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482213009", "createdAt": "2020-09-02T16:43:48Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +85,43 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n+        Decision decision = service.getDecisionById(executionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDgyMQ==", "bodyText": "Done \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894821", "createdAt": "2020-09-03T11:06:04Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +85,43 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n+        Decision decision = service.getDecisionById(executionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ=="}, "originalCommit": {"oid": "884822e982dead2623cdf7b4bba86435d7eb58f7"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODk5MDM2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTo0NzoxMlrOHMe8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMTowMDowMVrOHMhXzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA==", "bodyText": "Is the try catch needed in this case? Is there a test for such scenario?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482851924", "createdAt": "2020-09-03T09:47:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2ODAyNw==", "bodyText": "Yes it is needed and there is a test. Please check this discussion.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482868027", "createdAt": "2020-09-03T10:15:00Z", "author": {"login": "kostola"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}, "originalCommit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5MTcyNw==", "bodyText": "This catch is to prevent explainAsync method to throw an unexpected exception instead of return the CompletableFuture", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482891727", "createdAt": "2020-09-03T11:00:01Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}, "originalCommit": {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkwODY4OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjowNFrOHNEEuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MTowM1rOHNHVPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA==", "bodyText": "Shouldn't we rather throw or exception or return some error info here?", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460280", "createdAt": "2020-09-04T08:12:04Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzY2Mw==", "bodyText": "Throwing a IllegalArgumentException is the current behavior of the TrustyServiceImpl when it doesn't find a decision with the associated ID.\nIn this case in my implementation I need to return null when this happens.\nFor me it's not an error and in fact it's logged as warning by the caller method because the computation can continue in a \"best effort\" way even without a Decision object.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483513663", "createdAt": "2020-09-04T09:51:03Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA=="}, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkxMTE3OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjo0NlrOHNEGOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MzoxMlrOHNHZqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460664", "createdAt": "2020-09-04T08:12:46Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDc5NA==", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514794", "createdAt": "2020-09-04T09:53:12Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA=="}, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkxMzkyOnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMzozMVrOHNEH0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwOTo1MzoyMFrOHNHZ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461072", "createdAt": "2020-09-04T08:13:31Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDg2NA==", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514864", "createdAt": "2020-09-04T09:53:20Z", "author": {"login": "kostola"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg=="}, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkxNTQwOnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMzo1NFrOHNEIqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMzo1NFrOHNEIqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTI4OQ==", "bodyText": "Please consider to throw exception.", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461289", "createdAt": "2020-09-04T08:13:54Z", "author": {"login": "jiripetrlik"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;\n         }\n         List<FeatureImportance> featureImportance = dto.getFeatureImportance() == null ? null :\n                 dto.getFeatureImportance().stream()\n                         .map(ExplainabilityResultConsumer::featureImportanceFrom)\n                         .collect(Collectors.toList());\n-        return new Saliency(featureImportance);\n+        return new Saliency(outcomeId, outcomeName, featureImportance);\n     }\n-}\n \n+    protected static ExplainabilityStatus statusFrom(org.kie.kogito.explainability.api.ExplainabilityStatus status) {\n+        switch (status) {\n+            case SUCCEEDED:\n+                return ExplainabilityStatus.SUCCEEDED;\n+            case FAILED:\n+                return ExplainabilityStatus.FAILED;\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 673, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}