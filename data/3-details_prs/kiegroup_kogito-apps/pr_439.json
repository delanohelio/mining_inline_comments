{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NTIyOTc1", "number": 439, "title": "KOGITO-3259 - Fraud Scoring DMN IT for lists of features", "bodyText": "Add an IT for DMN using fraud scoring model whose inputs are based on lists (of transactions).\nAs a side note code similar to the one implemented in ConversionUtils for KOGITO-3194 has been added to FeatureFactory, this way we make sure handling is consistent between explainability-core and explainability-service.\nAt the moment the build will fail because fraud-scoring outputs some fixed output (the blocked merchants) but this will be green as soon as KOGITO-3262 is fixed.\nSee https://issues.redhat.com/browse/KOGITO-3259 and https://issues.redhat.com/browse/KOGITO-3262\nMany thanks for submitting your Pull Request \u2764\ufe0f!\nPlease make sure that your PR meets the following requirements:\n\n You have read the contributors guide\n Pull Request title is properly formatted: KOGITO-XYZ Subject\n Pull Request title contains the target branch if not targeting master: [0.9.x] KOGITO-XYZ Subject\n Pull Request contains link to the JIRA issue\n Pull Request contains link to any dependent or related Pull Request\n Pull Request contains description of the issue\n Pull Request does not include fixes for issues other than the main ticket", "createdAt": "2020-09-04T09:54:47Z", "url": "https://github.com/kiegroup/kogito-apps/pull/439", "merged": true, "mergeCommit": {"oid": "71cd9ff766604bad371a4f5244ecc7c54f0b3212"}, "closed": true, "closedAt": "2020-10-01T16:34:52Z", "author": {"login": "tteofili"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFiBungH2gAyNDc5NTIyOTc1OjhkODdiMmYyMTIxYWY2ODhiYTc4NTM3YzYyNDM3OTA0NDJiMDAwYmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOMs_vgH2gAyNDc5NTIyOTc1Ojc3YzYzMmZhZTZkYzNmMDdiYWIyNzExZDM1NzU4YzA2MzYyOTIyMDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/8d87b2f2121af688ba78537c6243790442b000be", "committedDate": "2020-09-04T09:45:31Z", "message": "KOGITO-3259 - Fraud Scoring DMN IT for lists of features"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MDYxMDE2", "url": "https://github.com/kiegroup/kogito-apps/pull/439#pullrequestreview-484061016", "createdAt": "2020-09-08T11:59:12Z", "commit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMTo1OToxMlrOHOZjDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjo0NzowNVrOHObMCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDY4NQ==", "bodyText": "remove print", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484860685", "createdAt": "2020-09-08T11:59:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg==", "bodyText": "what are the cases in which ExplainabilityMetrics.impactScore returns 0?", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863026", "createdAt": "2020-09-08T12:03:36Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            if (!topFeatures.isEmpty()) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzQ5NA==", "bodyText": "not needed?", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863494", "createdAt": "2020-09-08T12:04:30Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzU2Mg==", "bodyText": "Just a proposal changing the contract of the method so to avoid side effects and make it a bit more clean imo\n\n    public static Feature newCompositeFeature(String name, Map<String, Object> map) {\n        List<Feature> features = new LinkedList<>();\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n            features.add(parseFeatureValue(entry.getKey(), entry.getValue()));\n        }\n        return newCompositeFeature(name, features);\n    }\n\n    public static Feature newCompositeFeature(String name, List<Feature> features) {\n        return new Feature(name, Type.COMPOSITE, new Value<>(features));\n    }\n\n    private static Feature parseFeatureValue(String featureName, Object value) {\n        if (value instanceof Map) {\n            return newCompositeFeature(featureName, (Map<String, Object>) value);\n        } else if (value instanceof double[]) {\n            return newVectorFeature(featureName, (double[]) value);\n        } else if (value instanceof LocalTime) {\n            return newTimeFeature(featureName, (LocalTime) value);\n        } else if (value instanceof Duration) {\n            return newDurationFeature(featureName, (Duration) value);\n        } else if (value instanceof URI) {\n            return newURIFeature(featureName, (URI) value);\n        } else if (value instanceof ByteBuffer) {\n            return newBinaryFeature(featureName, (ByteBuffer) value);\n        } else if (value instanceof Currency) {\n            return newCurrencyFeature(featureName, (Currency) value);\n        } else if (value instanceof Boolean) {\n            return newBooleanFeature(featureName, (Boolean) value);\n        } else if (value instanceof Number) {\n            return newNumericalFeature(featureName, (Number) value);\n        } else if (value instanceof String) {\n            return newTextFeature(featureName, (String) value);\n        } else if (value instanceof Feature) {\n            return (Feature) value;\n        } else if (value instanceof List) {\n            List<?> items = (List<?>) value;\n            if (!items.isEmpty()) {\n                if (items.get(0) instanceof Feature) {\n                    return newCompositeFeature(featureName, (List<Feature>) items);\n                } else {\n                    List<?> values = (List<?>) value;\n                    List<Feature> fs = IntStream.range(0, values.size())\n                            .mapToObj(i -> parseFeatureValue(featureName + \"_\" + i, values.get(i)))\n                            .collect(Collectors.toList());\n                    return newCompositeFeature(featureName, fs);\n                }\n            } else {\n                return newCompositeFeature(featureName, Collections.emptyList());\n            }\n        } else {\n            return newObjectFeature(featureName, value);\n        }\n    }", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484887562", "createdAt": "2020-09-08T12:47:05Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -131,11 +133,25 @@ private static void parseFeatureValue(List<Feature> features, Map.Entry<String,\n         } else if (value instanceof Feature) {\n             feature = (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    feature = newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    Map<String, Object> map = new HashMap<>();\n+                    int index = 0;\n+                    for (Object o : (List<?>) value) {\n+                        map.put(featureName + \"_\" + index, o);\n+                        index++;\n+                    }\n+                    List<Feature> fs = new ArrayList<>(map.size());\n+                    for (Map.Entry<String, Object> e : map.entrySet()) {\n+                        parseFeatureValue(fs, e);\n+                    }\n+                    feature = newCompositeFeature(featureName, fs);\n+                }\n+            } else {\n+                feature = newCompositeFeature(featureName, Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d87b2f2121af688ba78537c6243790442b000be"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/b41d7f6b9a5752023ecbb0095b0687d6b533a0b0", "committedDate": "2020-09-08T14:17:46Z", "message": "KOGITO-3259 - review based improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MjY0Mjcx", "url": "https://github.com/kiegroup/kogito-apps/pull/439#pullrequestreview-485264271", "createdAt": "2020-09-09T17:54:29Z", "commit": {"oid": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo1NDoyOVrOHPTa8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzo1NDoyOVrOHPTa8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwODg4Mg==", "bodyText": "You can use items instead of create values", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r485808882", "createdAt": "2020-09-09T17:54:29Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -104,43 +108,47 @@ public static Feature newCompositeFeature(String name, List<Feature> features) {\n         return new Feature(name, Type.COMPOSITE, new Value<>(features));\n     }\n \n-    private static void parseFeatureValue(List<Feature> features, Map.Entry<String, Object> entry) {\n-        Object value = entry.getValue();\n-        String featureName = entry.getKey();\n-        Feature feature;\n+    private static Feature parseFeatureValue(String featureName, Object value) {\n         if (value instanceof Map) {\n-            feature = newCompositeFeature(featureName, (Map<String, Object>) value);\n+            return newCompositeFeature(featureName, (Map<String, Object>) value);\n         } else if (value instanceof double[]) {\n-            feature = newVectorFeature(featureName, (double[]) value);\n+            return newVectorFeature(featureName, (double[]) value);\n         } else if (value instanceof LocalTime) {\n-            feature = newTimeFeature(featureName, (LocalTime) value);\n+            return newTimeFeature(featureName, (LocalTime) value);\n         } else if (value instanceof Duration) {\n-            feature = newDurationFeature(featureName, (Duration) value);\n+            return newDurationFeature(featureName, (Duration) value);\n         } else if (value instanceof URI) {\n-            feature = newURIFeature(featureName, (URI) value);\n+            return newURIFeature(featureName, (URI) value);\n         } else if (value instanceof ByteBuffer) {\n-            feature = newBinaryFeature(featureName, (ByteBuffer) value);\n+            return newBinaryFeature(featureName, (ByteBuffer) value);\n         } else if (value instanceof Currency) {\n-            feature = newCurrencyFeature(featureName, (Currency) value);\n+            return newCurrencyFeature(featureName, (Currency) value);\n         } else if (value instanceof Boolean) {\n-            feature = newBooleanFeature(featureName, (Boolean) value);\n+            return newBooleanFeature(featureName, (Boolean) value);\n         } else if (value instanceof Number) {\n-            feature = newNumericalFeature(featureName, (Number) value);\n+            return newNumericalFeature(featureName, (Number) value);\n         } else if (value instanceof String) {\n-            feature = newTextFeature(featureName, (String) value);\n+            return newTextFeature(featureName, (String) value);\n         } else if (value instanceof Feature) {\n-            feature = (Feature) value;\n+            return (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    return newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    List<?> values = (List<?>) value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1338825801d540e5d90dc3e8e5da344ed5fc75ae", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/1338825801d540e5d90dc3e8e5da344ed5fc75ae", "committedDate": "2020-09-10T08:48:28Z", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59261e85af5be85b75e8204921b80789aa9ee1fc", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/59261e85af5be85b75e8204921b80789aa9ee1fc", "committedDate": "2020-09-10T12:53:47Z", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab9d7e7ddb875555b792359abd09dc07f4f8ad0e", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/ab9d7e7ddb875555b792359abd09dc07f4f8ad0e", "committedDate": "2020-09-10T16:17:51Z", "message": "KOGITO-3259 - adjusted linearization/dropping to better work with lists"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/86d76de8fd886d435723b8f1e6a3bed63c13e994", "committedDate": "2020-09-15T15:16:38Z", "message": "KOGITO-3259 - minor fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MzgxMDI5", "url": "https://github.com/kiegroup/kogito-apps/pull/439#pullrequestreview-498381029", "createdAt": "2020-09-29T11:44:10Z", "commit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoxMFrOHZpI_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0NDoyMVrOHZpJaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDQ5NA==", "bodyText": "I would suggest to use Assertj. It provides more specific types of asserts and it is easier to see where the problem is.", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650494", "createdAt": "2020-09-29T11:44:10Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDYwMA==", "bodyText": "Unexpected new line.", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650600", "createdAt": "2020-09-29T11:44:21Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f6716caa95475f60c22e8233ca8ff76129b6453", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/4f6716caa95475f60c22e8233ca8ff76129b6453", "committedDate": "2020-09-30T08:19:22Z", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "980dc9fd2938eb98992c9091ffe003262ffa943e", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/980dc9fd2938eb98992c9091ffe003262ffa943e", "committedDate": "2020-09-30T08:43:09Z", "message": "KOGITO-3259 - minor test improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77c632fae6dc3f07bab2711d35758c0636292200", "author": {"user": {"login": "tteofili", "name": "Tommaso Teofili"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/77c632fae6dc3f07bab2711d35758c0636292200", "committedDate": "2020-10-01T08:00:11Z", "message": "KOGITO-3259 - minor code improvements"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4756, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}