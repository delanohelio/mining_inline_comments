{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODM2NTA4", "number": 342, "title": "Kogito 2828 - catch exceptions in event processing to avoid global stop", "bodyText": "While I was working on other messaging stuff I had the chance to experiment this ticket here https://issues.redhat.com/browse/KOGITO-2828 .\nIf there is an exception during the processing of the event the entire even loop is stopped, and no events are consumed anymore. It's good to surround the processing catching all the exceptions to avoid the global stop of the messaging system in case something bad happens.\nMany thanks for submitting your Pull Request \u2764\ufe0f!\nPlease make sure that your PR meets the following requirements:\n\n You have read the contributors guide\n Pull Request title is properly formatted: KOGITO-XYZ Subject\n Pull Request title contains the target branch if not targeting master: [0.9.x] KOGITO-XYZ Subject\n Pull Request contains link to the JIRA issue\n Pull Request contains link to any dependent or related Pull Request\n Pull Request contains description of the issue\n Pull Request does not include fixes for issues other than the main ticket", "createdAt": "2020-07-23T16:50:25Z", "url": "https://github.com/kiegroup/kogito-apps/pull/342", "merged": true, "mergeCommit": {"oid": "ee90b99eadf2aa9871a933e618c8ae28e1fa69d2"}, "closed": true, "closedAt": "2020-07-29T12:40:32Z", "author": {"login": "r00ta"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3wKBBAH2gAyNDU1ODM2NTA4OjBmMWU5NWQwYTVkNzMyZjExMjFjYTM4ZmZjNDZkNzQ5ZDQyOTE1ZjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5qVPrgFqTQ1NzQ3ODYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0f1e95d0a5d732f1121ca38ffc46d749d42915f1", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/0f1e95d0a5d732f1121ca38ffc46d749d42915f1", "committedDate": "2020-07-23T14:18:18Z", "message": "surround event handling with try/catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f3a18e8f0594923eb5fed2e36c7145ad32c0016", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/4f3a18e8f0594923eb5fed2e36c7145ad32c0016", "committedDate": "2020-07-23T15:59:43Z", "message": "implement tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b114e5d0d853593bcb25dd38a5ea13a0a3e111a", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/0b114e5d0d853593bcb25dd38a5ea13a0a3e111a", "committedDate": "2020-07-23T16:45:16Z", "message": "implement tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/9475c6e87a1f91339ae4a24c59ec43a9c604e268", "committedDate": "2020-07-23T16:47:16Z", "message": "add licence headers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzIwNDU3", "url": "https://github.com/kiegroup/kogito-apps/pull/342#pullrequestreview-454320457", "createdAt": "2020-07-23T16:51:29Z", "commit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MToyOVrOG2TJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MToyOVrOG2TJ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDEwMw==", "bodyText": "I've moved the old content of this class to TraceEventConsumerInfinispanIT since it's an integration test that uses also infinispan.", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590103", "createdAt": "2020-07-23T16:51:29Z", "author": {"login": "r00ta"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzIxMTU2", "url": "https://github.com/kiegroup/kogito-apps/pull/342#pullrequestreview-454321156", "createdAt": "2020-07-23T16:52:27Z", "commit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MjoyN1rOG2TL_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNjo1MjoyN1rOG2TL_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MDY1NA==", "bodyText": "This is the new test that checks that both events are processed. With the old implementation only the first one was processed", "url": "https://github.com/kiegroup/kogito-apps/pull/342#discussion_r459590654", "createdAt": "2020-07-23T16:52:27Z", "author": {"login": "r00ta"}, "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/TraceEventConsumerIT.java", "diffHunk": "@@ -16,100 +16,51 @@\n \n package org.kie.kogito.trusty.service.messaging;\n \n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.inject.Inject;\n-\n import io.quarkus.test.common.QuarkusTestResource;\n import io.quarkus.test.junit.QuarkusTest;\n-import io.vertx.core.Vertx;\n+import io.quarkus.test.junit.mockito.InjectMock;\n import io.vertx.kafka.client.producer.KafkaProducer;\n-import io.vertx.kafka.client.producer.KafkaProducerRecord;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n-import org.kie.kogito.trusty.service.TrustyInfinispanServerTestResource;\n import org.kie.kogito.trusty.service.TrustyKafkaTestResource;\n import org.kie.kogito.trusty.service.TrustyService;\n-import org.kie.kogito.trusty.storage.api.TrustyStorageService;\n import org.kie.kogito.trusty.storage.api.model.Decision;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CLOUDEVENT_WITH_ERRORS_ID;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.CORRECT_CLOUDEVENT_ID;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCloudEventJsonString;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectDecision;\n import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildCorrectTraceEvent;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildDecisionWithErrors;\n-import static org.kie.kogito.trusty.service.TrustyServiceTestUtils.buildTraceEventWithErrors;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.generateProducer;\n+import static org.kie.kogito.trusty.service.messaging.KafkaUtils.sendToKafkaAndWaitForCompletion;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n @QuarkusTest\n-@QuarkusTestResource(TrustyInfinispanServerTestResource.class)\n @QuarkusTestResource(TrustyKafkaTestResource.class)\n-class TraceEventConsumerIT {\n-\n-    private static final Logger LOG = LoggerFactory.getLogger(TraceEventConsumerIT.class);\n-\n-    @Inject\n-    TraceEventConsumer traceEventConsumer;\n+public class TraceEventConsumerIT {\n \n-    @Inject\n+    @InjectMock\n     TrustyService trustyService;\n \n-    @Inject\n-    TrustyStorageService trustyStorageService;\n-\n     KafkaProducer<String, String> producer;\n \n     @BeforeEach\n     public void setup() {\n-        trustyStorageService.getDecisionsStorage().clear();\n-\n-        System.err.println(\"kafka.bootstrap.servers: \" + System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"));\n-\n-        producer = KafkaProducer.create(Vertx.vertx(), Map.of(\n-                \"bootstrap.servers\", System.getProperty(TrustyKafkaTestResource.KAFKA_BOOTSTRAP_SERVERS, \"localhost:9092\"),\n-                \"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\",\n-                \"acks\", \"all\"\n-        ));\n+        producer = generateProducer();\n     }\n \n     @Test\n-    void testCorrectCloudEvent() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent()));\n-        Decision storedDecision = trustyService.getDecisionById(CORRECT_CLOUDEVENT_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildCorrectDecision(), storedDecision);\n-    }\n-\n-    @Test\n-    void testCloudEventWithErrors() throws Exception {\n-        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildTraceEventWithErrors()));\n-        Decision storedDecision = trustyService.getDecisionById(CLOUDEVENT_WITH_ERRORS_ID);\n-        assertNotNull(storedDecision);\n-        TraceEventTestUtils.assertDecision(buildDecisionWithErrors(), storedDecision);\n-    }\n+    public void eventLoopIsNotStoppedWithException() throws Exception {\n+        String executionIdException = \"idException\";\n+        String executionIdNoException = \"idNoException\";\n+        doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeDecision(eq(executionIdException), any(Decision.class));\n+        doNothing().when(trustyService).storeDecision(eq(executionIdNoException), any(Decision.class));\n \n-    private CompletableFuture<Void> sendToKafka(String payload) {\n-        CompletableFuture<Void> future = new CompletableFuture<>();\n-        producer.write(KafkaProducerRecord.create(\"trusty-service-test\", payload), event -> {\n-            if (event.succeeded()) {\n-                future.complete(null);\n-            } else {\n-                future.completeExceptionally(event.cause());\n-            }\n-        });\n-        return future;\n-    }\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdException)), producer);\n+        sendToKafkaAndWaitForCompletion(buildCloudEventJsonString(buildCorrectTraceEvent(executionIdNoException)), producer);\n \n-    private void sendToKafkaAndWaitForCompletion(String payload) throws Exception {\n-        sendToKafka(payload)\n-                .thenRunAsync(() -> LOG.info(\"Sent payload to Kafka (length: {})\", payload.length()), CompletableFuture.delayedExecutor(2L, TimeUnit.SECONDS))\n-                .get(15L, TimeUnit.SECONDS);\n+        verify(trustyService, times(2)).storeDecision(any(String.class), any(Decision.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9475c6e87a1f91339ae4a24c59ec43a9c604e268"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a55fc67be82e541fa7ebfc6a6cd650c6ac572023", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/a55fc67be82e541fa7ebfc6a6cd650c6ac572023", "committedDate": "2020-07-23T18:26:12Z", "message": "remove log statement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTEyNTE3", "url": "https://github.com/kiegroup/kogito-apps/pull/342#pullrequestreview-454912517", "createdAt": "2020-07-24T14:03:10Z", "commit": {"oid": "a55fc67be82e541fa7ebfc6a6cd650c6ac572023"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a56d95a15004a33b511bd5468a58283c41371a0c", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/a56d95a15004a33b511bd5468a58283c41371a0c", "committedDate": "2020-07-24T15:58:15Z", "message": "add test on execution type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66afd6a5c7f124f6ab287c79b872114f299aa6f", "author": {"user": {"login": "r00ta", "name": "Jacopo Rota"}}, "url": "https://github.com/kiegroup/kogito-apps/commit/d66afd6a5c7f124f6ab287c79b872114f299aa6f", "committedDate": "2020-07-27T07:00:31Z", "message": "Merge remote-tracking branch 'upstream/master' into KOGITO-2828-fix-processing-events"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NTkwMzcy", "url": "https://github.com/kiegroup/kogito-apps/pull/342#pullrequestreview-456590372", "createdAt": "2020-07-28T12:42:04Z", "commit": {"oid": "d66afd6a5c7f124f6ab287c79b872114f299aa6f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NDc4NjI4", "url": "https://github.com/kiegroup/kogito-apps/pull/342#pullrequestreview-457478628", "createdAt": "2020-07-29T12:38:59Z", "commit": {"oid": "d66afd6a5c7f124f6ab287c79b872114f299aa6f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4940, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}