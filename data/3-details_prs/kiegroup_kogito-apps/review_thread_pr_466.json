{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMDcxNTEy", "number": 466, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToxNTozNFrOEmUXzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzo0ODoxN1rOEndrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjE1MTE4OnYy", "diffSide": "RIGHT", "path": "jobs-service/src/main/resources/META-INF/library.proto", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToxNTozNFrOHWRknQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDo1MDo1NlrOHXGAFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODYyMQ==", "bodyText": "@tiagodolphine do we need the analyze part? AFAIK that would be to break down the content, but this status field is a single value right?", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493118621", "createdAt": "2020-09-23T01:15:34Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/resources/META-INF/library.proto", "diffHunk": "@@ -1,16 +1,20 @@\n package job.service;\n \n+/* @Indexed */\n message JobDetails {\n   optional string id = 1;\n   optional string correlationId = 2;\n+  /* @Field(store = Store.YES, analyze = Analyze.YES, analyzer = @Analyzer(definition = \"keyword\")) */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ4OTMzNA==", "bodyText": "when running the ispn 11 and executing the query string I was getting the error that it was missing the analyze int the attribute so basically when I added it solved the issue... that's why I added, the query in this case use the IN operation.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493489334", "createdAt": "2020-09-23T11:44:09Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/src/main/resources/META-INF/library.proto", "diffHunk": "@@ -1,16 +1,20 @@\n package job.service;\n \n+/* @Indexed */\n message JobDetails {\n   optional string id = 1;\n   optional string correlationId = 2;\n+  /* @Field(store = Store.YES, analyze = Analyze.YES, analyzer = @Analyzer(definition = \"keyword\")) */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODYyMQ=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3NzYyMw==", "bodyText": "yeah, I think thats because of the operator you're using, using in should avoid that.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493977623", "createdAt": "2020-09-24T00:50:56Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/resources/META-INF/library.proto", "diffHunk": "@@ -1,16 +1,20 @@\n package job.service;\n \n+/* @Indexed */\n message JobDetails {\n   optional string id = 1;\n   optional string correlationId = 2;\n+  /* @Field(store = Store.YES, analyze = Analyze.YES, analyzer = @Analyzer(definition = \"keyword\")) */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODYyMQ=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjE1NDIwOnYy", "diffSide": "RIGHT", "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToxNzoxMlrOHWRmSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMToyMTowMVrOHXVoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExOTA1MA==", "bodyText": "perhaps j.status in ( value1, value2 ) ?", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493119050", "createdAt": "2020-09-23T01:17:12Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "diffHunk": "@@ -89,36 +107,37 @@ public InfinispanJobRepository(Vertx vertx,\n \n     @Override\n     public PublisherBuilder<JobDetails> findAll() {\n-        return ReactiveStreams\n-                .fromIterable(queryFactory.from(JobDetails.class)\n-                                      .<JobDetails>build()\n-                                      .list());\n+        Query<JobDetails> query = queryFactory.<JobDetails>create(\"from job.service.JobDetails\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n     @Override\n     public PublisherBuilder<JobDetails> findByStatus(JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"and j.status:(\" + createStatusQuery(status) + \")\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n+    @Override\n     public PublisherBuilder<JobDetails> findByStatusBetweenDatesOrderByPriority(ZonedDateTime from, ZonedDateTime to,\n                                                                                 JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .and()\n-                                                    .having(\"trigger.nextFireTime\")\n-                                                    .between(DateUtil.zonedDateTimeToInstant(from),\n-                                                             DateUtil.zonedDateTimeToInstant(to))\n-                                                    .orderBy(\"priority\", SortOrder.DESC)\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"j.trigger.nextFireTime > :from \" +\n+                                                              \"and j.trigger.nextFireTime < :to \" +\n+                                                              \"and j.status:(\" +  createStatusQuery(status) + \") \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5MDYzOQ==", "bodyText": "I think so, I'll add  IN and test, I just used the :  because it was on the some example on the doc, but they should be the same operation.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493490639", "createdAt": "2020-09-23T11:45:33Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "diffHunk": "@@ -89,36 +107,37 @@ public InfinispanJobRepository(Vertx vertx,\n \n     @Override\n     public PublisherBuilder<JobDetails> findAll() {\n-        return ReactiveStreams\n-                .fromIterable(queryFactory.from(JobDetails.class)\n-                                      .<JobDetails>build()\n-                                      .list());\n+        Query<JobDetails> query = queryFactory.<JobDetails>create(\"from job.service.JobDetails\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n     @Override\n     public PublisherBuilder<JobDetails> findByStatus(JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"and j.status:(\" + createStatusQuery(status) + \")\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n+    @Override\n     public PublisherBuilder<JobDetails> findByStatusBetweenDatesOrderByPriority(ZonedDateTime from, ZonedDateTime to,\n                                                                                 JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .and()\n-                                                    .having(\"trigger.nextFireTime\")\n-                                                    .between(DateUtil.zonedDateTimeToInstant(from),\n-                                                             DateUtil.zonedDateTimeToInstant(to))\n-                                                    .orderBy(\"priority\", SortOrder.DESC)\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"j.trigger.nextFireTime > :from \" +\n+                                                              \"and j.trigger.nextFireTime < :to \" +\n+                                                              \"and j.status:(\" +  createStatusQuery(status) + \") \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExOTA1MA=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUwNzMwMg==", "bodyText": "well, I tried to change and use IN instead of : but I got an error on the query...", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493507302", "createdAt": "2020-09-23T12:03:34Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "diffHunk": "@@ -89,36 +107,37 @@ public InfinispanJobRepository(Vertx vertx,\n \n     @Override\n     public PublisherBuilder<JobDetails> findAll() {\n-        return ReactiveStreams\n-                .fromIterable(queryFactory.from(JobDetails.class)\n-                                      .<JobDetails>build()\n-                                      .list());\n+        Query<JobDetails> query = queryFactory.<JobDetails>create(\"from job.service.JobDetails\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n     @Override\n     public PublisherBuilder<JobDetails> findByStatus(JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"and j.status:(\" + createStatusQuery(status) + \")\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n+    @Override\n     public PublisherBuilder<JobDetails> findByStatusBetweenDatesOrderByPriority(ZonedDateTime from, ZonedDateTime to,\n                                                                                 JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .and()\n-                                                    .having(\"trigger.nextFireTime\")\n-                                                    .between(DateUtil.zonedDateTimeToInstant(from),\n-                                                             DateUtil.zonedDateTimeToInstant(to))\n-                                                    .orderBy(\"priority\", SortOrder.DESC)\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"j.trigger.nextFireTime > :from \" +\n+                                                              \"and j.trigger.nextFireTime < :to \" +\n+                                                              \"and j.status:(\" +  createStatusQuery(status) + \") \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExOTA1MA=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3NzQ1MQ==", "bodyText": "hm, I think  : uses index, that's why you also needed the analyze part. But in should work, I'm using that in data index, whats the error?", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493977451", "createdAt": "2020-09-24T00:50:16Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "diffHunk": "@@ -89,36 +107,37 @@ public InfinispanJobRepository(Vertx vertx,\n \n     @Override\n     public PublisherBuilder<JobDetails> findAll() {\n-        return ReactiveStreams\n-                .fromIterable(queryFactory.from(JobDetails.class)\n-                                      .<JobDetails>build()\n-                                      .list());\n+        Query<JobDetails> query = queryFactory.<JobDetails>create(\"from job.service.JobDetails\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n     @Override\n     public PublisherBuilder<JobDetails> findByStatus(JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"and j.status:(\" + createStatusQuery(status) + \")\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n+    @Override\n     public PublisherBuilder<JobDetails> findByStatusBetweenDatesOrderByPriority(ZonedDateTime from, ZonedDateTime to,\n                                                                                 JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .and()\n-                                                    .having(\"trigger.nextFireTime\")\n-                                                    .between(DateUtil.zonedDateTimeToInstant(from),\n-                                                             DateUtil.zonedDateTimeToInstant(to))\n-                                                    .orderBy(\"priority\", SortOrder.DESC)\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"j.trigger.nextFireTime > :from \" +\n+                                                              \"and j.trigger.nextFireTime < :to \" +\n+                                                              \"and j.status:(\" +  createStatusQuery(status) + \") \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExOTA1MA=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzMzYzNg==", "bodyText": "it was working with IN with the query dsl, but when I changed the query to ickle, it didn't work... so basically I changed the operator : anyway, I think we will not be able to merge this PR because it is not compatible with ispn10, so or we find a way to make it work with both or we need to wait for data-index, wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r494233636", "createdAt": "2020-09-24T11:21:01Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanJobRepository.java", "diffHunk": "@@ -89,36 +107,37 @@ public InfinispanJobRepository(Vertx vertx,\n \n     @Override\n     public PublisherBuilder<JobDetails> findAll() {\n-        return ReactiveStreams\n-                .fromIterable(queryFactory.from(JobDetails.class)\n-                                      .<JobDetails>build()\n-                                      .list());\n+        Query<JobDetails> query = queryFactory.<JobDetails>create(\"from job.service.JobDetails\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n     @Override\n     public PublisherBuilder<JobDetails> findByStatus(JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"and j.status:(\" + createStatusQuery(status) + \")\");\n+        return ReactiveStreams.fromIterable(query.execute().list());\n     }\n \n+    @Override\n     public PublisherBuilder<JobDetails> findByStatusBetweenDatesOrderByPriority(ZonedDateTime from, ZonedDateTime to,\n                                                                                 JobStatus... status) {\n-        return ReactiveStreams.fromIterable(queryFactory.from(JobDetails.class)\n-                                                    .having(\"status\")\n-                                                    .in(Arrays.stream(status)\n-                                                                .map(JobStatus::name)\n-                                                                .collect(Collectors.toList()))\n-                                                    .and()\n-                                                    .having(\"trigger.nextFireTime\")\n-                                                    .between(DateUtil.zonedDateTimeToInstant(from),\n-                                                             DateUtil.zonedDateTimeToInstant(to))\n-                                                    .orderBy(\"priority\", SortOrder.DESC)\n-                                                    .<JobDetails>build()\n-                                                    .list());\n+        Query<JobDetails> query = queryFactory.create(\"from job.service.JobDetails j \" +\n+                                                              \"where \" +\n+                                                              \"j.trigger.nextFireTime > :from \" +\n+                                                              \"and j.trigger.nextFireTime < :to \" +\n+                                                              \"and j.status:(\" +  createStatusQuery(status) + \") \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExOTA1MA=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NjE3NjUzOnYy", "diffSide": "RIGHT", "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanConfiguration.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMToyNDozNVrOHWRzMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwMDo0ODoyNVrOHXF9hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyMjM1Mw==", "bodyText": "@tiagodolphine would be important to try to have a consistent behaviour here compared to other services, see https://github.com/kiegroup/kogito-apps/blob/master/persistence-commons/persistence-commons-infinispan/src/main/java/org/kie/kogito/persistence/infinispan/cache/InfinispanCacheManager.java#L79.\nPoint is that the user should be able to define a template. That template allows users to take over the configuration on Infinispan side to match their need. Then if thats not provided, the default cache configuration would be in place as you specified here.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493122353", "createdAt": "2020-09-23T01:24:35Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanConfiguration.java", "diffHunk": "@@ -50,9 +65,37 @@ private Caches() {\n     @Readiness\n     public HealthCheck infinispanHealthCheck(@ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n                                              Instance<RemoteCacheManager> cacheManagerInstance) {\n-        return persistence\n-                .filter(\"infinispan\"::equals)\n+        return isEnabled(persistence)\n                 .<HealthCheck>map(p -> new InfinispanHealthCheck(cacheManagerInstance))\n                 .orElse(() -> HealthCheckResponse.up(\"In Memory Persistence\"));\n     }\n+\n+    private Optional<String> isEnabled(Optional<String> persistence) {\n+        return persistence\n+                .filter(\"infinispan\"::equals);\n+    }\n+\n+    void initializeCaches(@Observes @Priority(Interceptor.Priority.PLATFORM_BEFORE) StartupEvent startupEvent,\n+                          @ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n+                          RemoteCacheManager remoteCacheManager,\n+                          Event<InfinispanInitialized> initializedEvent) {\n+        isEnabled(persistence)\n+                .map(c -> remoteCacheManager.administration().getOrCreateCache(JOB_DETAILS, getCacheTemplate()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUwMDU3OA==", "bodyText": "My approach it quite different, on the InfinispanConfiguration I\u00b4m running all the requirement to initialize infinispan, like creating the cache and healthcheck, ... but we can migrate maybe to use the same approach of persistence-commons with the InfinispanCacheManager, IMO we could to it on a new JIRA, just for this. The other thing is, I created the template approach in this PR because I need to add more configs to work on ispn11, so the user may use a different template if he changes the .xml template, before it was not even using any template, it was using the default one.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493500578", "createdAt": "2020-09-23T11:55:59Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanConfiguration.java", "diffHunk": "@@ -50,9 +65,37 @@ private Caches() {\n     @Readiness\n     public HealthCheck infinispanHealthCheck(@ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n                                              Instance<RemoteCacheManager> cacheManagerInstance) {\n-        return persistence\n-                .filter(\"infinispan\"::equals)\n+        return isEnabled(persistence)\n                 .<HealthCheck>map(p -> new InfinispanHealthCheck(cacheManagerInstance))\n                 .orElse(() -> HealthCheckResponse.up(\"In Memory Persistence\"));\n     }\n+\n+    private Optional<String> isEnabled(Optional<String> persistence) {\n+        return persistence\n+                .filter(\"infinispan\"::equals);\n+    }\n+\n+    void initializeCaches(@Observes @Priority(Interceptor.Priority.PLATFORM_BEFORE) StartupEvent startupEvent,\n+                          @ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n+                          RemoteCacheManager remoteCacheManager,\n+                          Event<InfinispanInitialized> initializedEvent) {\n+        isEnabled(persistence)\n+                .map(c -> remoteCacheManager.administration().getOrCreateCache(JOB_DETAILS, getCacheTemplate()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyMjM1Mw=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3Njk2NA==", "bodyText": "We can take advantage of the template system inheritance, see https://infinispan.org/docs/11.0.x/titles/configuring/configuring.html#templates-configuring. That way you only specify the indexing class that is needed but gives room for the user to customize the base template. But that's fine if you want to create a JIRA for reviewing that alone.", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r493976964", "createdAt": "2020-09-24T00:48:25Z", "author": {"login": "cristianonicolai"}, "path": "jobs-service/src/main/java/org/kie/kogito/jobs/service/repository/infinispan/InfinispanConfiguration.java", "diffHunk": "@@ -50,9 +65,37 @@ private Caches() {\n     @Readiness\n     public HealthCheck infinispanHealthCheck(@ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n                                              Instance<RemoteCacheManager> cacheManagerInstance) {\n-        return persistence\n-                .filter(\"infinispan\"::equals)\n+        return isEnabled(persistence)\n                 .<HealthCheck>map(p -> new InfinispanHealthCheck(cacheManagerInstance))\n                 .orElse(() -> HealthCheckResponse.up(\"In Memory Persistence\"));\n     }\n+\n+    private Optional<String> isEnabled(Optional<String> persistence) {\n+        return persistence\n+                .filter(\"infinispan\"::equals);\n+    }\n+\n+    void initializeCaches(@Observes @Priority(Interceptor.Priority.PLATFORM_BEFORE) StartupEvent startupEvent,\n+                          @ConfigProperty(name = PERSISTENCE_CONFIG_KEY) Optional<String> persistence,\n+                          RemoteCacheManager remoteCacheManager,\n+                          Event<InfinispanInitialized> initializedEvent) {\n+        isEnabled(persistence)\n+                .map(c -> remoteCacheManager.administration().getOrCreateCache(JOB_DETAILS, getCacheTemplate()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyMjM1Mw=="}, "originalCommit": {"oid": "9923e9b49777505b71841569424c3e8046633823"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODE2MTI1OnYy", "diffSide": "RIGHT", "path": "jobs-service/docker/infinispan/infinispan.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzo0ODoxN1rOHYEZwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNDoxMDoyMVrOHYFTzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDAwMg==", "bodyText": "Don't we want to change the schema to https://infinispan.org/schemas/infinispan-server-11.0.xsd?", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r495000002", "createdAt": "2020-09-25T13:48:17Z", "author": {"login": "ricardozanini"}, "path": "jobs-service/docker/infinispan/infinispan.xml", "diffHunk": "@@ -0,0 +1,27 @@\n+<infinispan xmlns='urn:infinispan:config:10.0' xsi:schemaLocation='urn:infinispan:config:10.0 http://www.infinispan.org/schemas/infinispan-config-10.0.xsd                             urn:infinispan:server:10.0 http://www.infinispan.org/schemas/infinispan-server-10.0.xsd' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n+  <server xmlns='urn:infinispan:server:10.0'>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d71907111fc5b18f7c75f1b484dd2a6f9ea8252e"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAxNDg2Mw==", "bodyText": "updated it to 11", "url": "https://github.com/kiegroup/kogito-apps/pull/466#discussion_r495014863", "createdAt": "2020-09-25T14:10:21Z", "author": {"login": "tiagodolphine"}, "path": "jobs-service/docker/infinispan/infinispan.xml", "diffHunk": "@@ -0,0 +1,27 @@\n+<infinispan xmlns='urn:infinispan:config:10.0' xsi:schemaLocation='urn:infinispan:config:10.0 http://www.infinispan.org/schemas/infinispan-config-10.0.xsd                             urn:infinispan:server:10.0 http://www.infinispan.org/schemas/infinispan-server-10.0.xsd' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>\n+  <server xmlns='urn:infinispan:server:10.0'>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAwMDAwMg=="}, "originalCommit": {"oid": "d71907111fc5b18f7c75f1b484dd2a6f9ea8252e"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 728, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}