{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5MzcxNjQz", "number": 324, "reviewThreads": {"totalCount": 158, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyMDozMVrOERBVSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODoyMToxOFrOETX2lg==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgzMDgzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyMDozMVrOG1f3mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozOTo1MVrOG2GwyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0OTg0OQ==", "bodyText": "Not sure if I get it, but if the input was already MIDNIGHT this is not going to perturb the data right?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458749849", "createdAt": "2020-07-22T12:20:31Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NzA4MA==", "bodyText": "correct", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459387080", "createdAt": "2020-07-23T11:39:51Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0OTg0OQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg0NzQyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNTozMVrOG1gCEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNTozMVrOG1gCEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MjUzMA==", "bodyText": "Same as in another comment: we don't need to sort, this is slower than a linear search for this particular use case", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458752530", "createdAt": "2020-07-22T12:25:31Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg1MjU0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNjo1N1rOG1gFSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNDozODowMlrOG3lehg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzM1NA==", "bodyText": "Why do we look for \" (\"?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458753354", "createdAt": "2020-07-22T12:26:57Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg2NDc5Ng==", "bodyText": "this is suboptimal, I know, but the reason why this happens is because LIME creates word level text features from a full text feature by splitting the text at whitespaces, the name of such features becomes word (feature-name).", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r460864796", "createdAt": "2020-07-27T12:48:13Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzM1NA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzODg4Ng==", "bodyText": "as a side note, this and other feature processing functions will be better structured in a dedicated API in FAI-238.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r460938886", "createdAt": "2020-07-27T14:38:02Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1MzM1NA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg1NTk2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNzo1NlrOG1gHWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyNzo1NlrOG1gHWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1Mzg4Mg==", "bodyText": "Same comments above", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458753882", "createdAt": "2020-07-22T12:27:56Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg2MTIzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyOToyNlrOG1gKhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyOToyNlrOG1gKhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NDY5Mg==", "bodyText": "with this the last value of the array is always excluded", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458754692", "createdAt": "2020-07-22T12:29:26Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg2NTAxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozMDoyNFrOG1gM0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozMDoyNFrOG1gM0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NTI4Mg==", "bodyText": "An exception is going to be raised if the array is composed by only one element, can you also add a test for that?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458755282", "createdAt": "2020-07-22T12:30:24Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg3NzIyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozMzo1NVrOG1gUrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjo0NToyMVrOG2I0Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzI5NQ==", "bodyText": "Is this the hamming distance? afaik if the two strings have different lenght then it is not defined", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458757295", "createdAt": "2020-07-22T12:33:55Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyMDY3NA==", "bodyText": "correct, I'll fix it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459420674", "createdAt": "2020-07-23T12:45:21Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1NzI5NQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 397}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg4MDA3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDo0NlrOG1gWkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNDo0NlrOG1gWkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1Nzc3Nw==", "bodyText": "Math.PI?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458757777", "createdAt": "2020-07-22T12:34:46Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg4MzM2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNTo0MFrOG1gYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjo1MTozMFrOG2JB7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1ODI5OA==", "bodyText": "why 1000?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458758298", "createdAt": "2020-07-22T12:35:40Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 429}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyNDIzOA==", "bodyText": "good point, I've made it configurable.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459424238", "createdAt": "2020-07-23T12:51:30Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1ODI5OA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 429}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg4NjAwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozNjoyOVrOG1gaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjo0NzoyNFrOG2I4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1ODc2Mw==", "bodyText": "why linkedlist?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458758763", "createdAt": "2020-07-22T12:36:29Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);\n+            FeatureDistribution featureDistribution = DataUtils.getFeatureDistribution(doubles);\n+            featureDistributions.add(featureDistribution);\n+        }\n+        return new DataDistribution(featureDistributions);\n+    }\n+\n+    public static List<PredictionInput> linearizeInputs(List<PredictionInput> predictionInputs) {\n+        List<PredictionInput> newInputs = new LinkedList<>();\n+        for (PredictionInput predictionInput : predictionInputs) {\n+            List<Feature> originalFeatures = predictionInput.getFeatures();\n+            List<Feature> flattenedFeatures = getLinearizedFeatures(originalFeatures);\n+            newInputs.add(new PredictionInput(flattenedFeatures));\n+        }\n+        return newInputs;\n+    }\n+\n+    public static List<Feature> getLinearizedFeatures(List<Feature> originalFeatures) {\n+        List<Feature> flattenedFeatures = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 447}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyMTgyNw==", "bodyText": "same as before", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459421827", "createdAt": "2020-07-23T12:47:24Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);\n+            FeatureDistribution featureDistribution = DataUtils.getFeatureDistribution(doubles);\n+            featureDistributions.add(featureDistribution);\n+        }\n+        return new DataDistribution(featureDistributions);\n+    }\n+\n+    public static List<PredictionInput> linearizeInputs(List<PredictionInput> predictionInputs) {\n+        List<PredictionInput> newInputs = new LinkedList<>();\n+        for (PredictionInput predictionInput : predictionInputs) {\n+            List<Feature> originalFeatures = predictionInput.getFeatures();\n+            List<Feature> flattenedFeatures = getLinearizedFeatures(originalFeatures);\n+            newInputs.add(new PredictionInput(flattenedFeatures));\n+        }\n+        return newInputs;\n+    }\n+\n+    public static List<Feature> getLinearizedFeatures(List<Feature> originalFeatures) {\n+        List<Feature> flattenedFeatures = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1ODc2Mw=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 447}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg5MjgxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozODozMlrOG1ge2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjo1MjoxMVrOG2JDoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1OTg5OA==", "bodyText": "What about all the other supported types? can you add a test using for example Boolean and other?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458759898", "createdAt": "2020-07-22T12:38:32Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);\n+            FeatureDistribution featureDistribution = DataUtils.getFeatureDistribution(doubles);\n+            featureDistributions.add(featureDistribution);\n+        }\n+        return new DataDistribution(featureDistributions);\n+    }\n+\n+    public static List<PredictionInput> linearizeInputs(List<PredictionInput> predictionInputs) {\n+        List<PredictionInput> newInputs = new LinkedList<>();\n+        for (PredictionInput predictionInput : predictionInputs) {\n+            List<Feature> originalFeatures = predictionInput.getFeatures();\n+            List<Feature> flattenedFeatures = getLinearizedFeatures(originalFeatures);\n+            newInputs.add(new PredictionInput(flattenedFeatures));\n+        }\n+        return newInputs;\n+    }\n+\n+    public static List<Feature> getLinearizedFeatures(List<Feature> originalFeatures) {\n+        List<Feature> flattenedFeatures = new LinkedList<>();\n+        for (Feature f : originalFeatures) {\n+            linearizeFeature(flattenedFeatures, f);\n+        }\n+        return flattenedFeatures;\n+    }\n+\n+    static void linearizeFeature(List<Feature> flattenedFeatures, Feature f) {\n+        if (Type.UNDEFINED.equals(f.getType())) {\n+            linearizeFeature(flattenedFeatures, (Feature) f.getValue().getUnderlyingObject());\n+        } else if (Type.COMPOSITE.equals(f.getType())) {\n+            List<Feature> features = (List<Feature>) f.getValue().getUnderlyingObject();\n+            for (Feature feature : features) {\n+                linearizeFeature(flattenedFeatures, feature);\n+            }\n+        } else {\n+            if (Type.TEXT.equals(f.getType())) {\n+                for (String w : f.getValue().asString().split(\" \")) {\n+                    Feature outputFeature = FeatureFactory.newTextFeature(w + \" (\" + f.getName() + \")\", w);\n+                    flattenedFeatures.add(outputFeature);\n+                }\n+            } else {\n+                flattenedFeatures.add(f);\n+            }\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQyNDY3Mg==", "bodyText": "the other supported types do not have to be linearized, I'll add tests.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459424672", "createdAt": "2020-07-23T12:52:11Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                // do nothing\n+                f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, String... names) {\n+        Arrays.sort(names);\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = Arrays.stream(names).map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // flip the boolean value\n+                    f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                }\n+                break;\n+            case TIME:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set to midnight\n+                    f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                }\n+                break;\n+            case DURATION:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the duration to 0\n+                    f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                }\n+                break;\n+            case CURRENCY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set the currency to EUR\n+                    f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    String category = feature.getValue().asString();\n+                    if (!\"0\".equals(category)) {\n+                        category = \"0\";\n+                    } else {\n+                        category = \"1\";\n+                    }\n+                    f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                }\n+                break;\n+            case BINARY:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (Arrays.binarySearch(names, feature.getName()) >= 0) {\n+                    // randomly set a non zero value to zero (or decrease it by 1)\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        int idx = random.nextInt(values.length - 1);\n+                        if (values[idx] != 0) {\n+                            values[idx] = 0;\n+                        } else {\n+                            values[idx]--;\n+                        }\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            if (x[i] != y[i]) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length - y.length);\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }\n+        return Math.sqrt(e);\n+    }\n+\n+    public static double gowerDistance(double[] x, double[] y, double lambda) {\n+        return euclideanDistance(x, y) + lambda * hammingDistance(x, y);\n+    }\n+\n+    public static double gaussianKernel(double x) {\n+        return Math.exp(-Math.pow(x, 2) / 2) / Math.sqrt(3.14);\n+    }\n+\n+    public static double exponentialSmoothingKernel(double x, double sigma) {\n+        return Math.sqrt(Math.exp(-(Math.pow(x, 2)) / Math.pow(sigma, 2)));\n+    }\n+\n+    public static FeatureDistribution getFeatureDistribution(double[] doubles) {\n+        double min = DoubleStream.of(doubles).min().orElse(0);\n+        double max = DoubleStream.of(doubles).max().orElse(0);\n+        double mean = getMean(doubles);\n+        double stdDev = getStdDev(doubles, mean);\n+        return new FeatureDistribution(min, max, mean, stdDev);\n+    }\n+\n+    public static DataDistribution generateRandomDataDistribution(int size) {\n+        List<FeatureDistribution> featureDistributions = new LinkedList<>();\n+        for (int i = 0; i < size; i++) {\n+            double[] doubles = generateData(random.nextDouble(), random.nextDouble(), 1000);\n+            FeatureDistribution featureDistribution = DataUtils.getFeatureDistribution(doubles);\n+            featureDistributions.add(featureDistribution);\n+        }\n+        return new DataDistribution(featureDistributions);\n+    }\n+\n+    public static List<PredictionInput> linearizeInputs(List<PredictionInput> predictionInputs) {\n+        List<PredictionInput> newInputs = new LinkedList<>();\n+        for (PredictionInput predictionInput : predictionInputs) {\n+            List<Feature> originalFeatures = predictionInput.getFeatures();\n+            List<Feature> flattenedFeatures = getLinearizedFeatures(originalFeatures);\n+            newInputs.add(new PredictionInput(flattenedFeatures));\n+        }\n+        return newInputs;\n+    }\n+\n+    public static List<Feature> getLinearizedFeatures(List<Feature> originalFeatures) {\n+        List<Feature> flattenedFeatures = new LinkedList<>();\n+        for (Feature f : originalFeatures) {\n+            linearizeFeature(flattenedFeatures, f);\n+        }\n+        return flattenedFeatures;\n+    }\n+\n+    static void linearizeFeature(List<Feature> flattenedFeatures, Feature f) {\n+        if (Type.UNDEFINED.equals(f.getType())) {\n+            linearizeFeature(flattenedFeatures, (Feature) f.getValue().getUnderlyingObject());\n+        } else if (Type.COMPOSITE.equals(f.getType())) {\n+            List<Feature> features = (List<Feature>) f.getValue().getUnderlyingObject();\n+            for (Feature feature : features) {\n+                linearizeFeature(flattenedFeatures, feature);\n+            }\n+        } else {\n+            if (Type.TEXT.equals(f.getType())) {\n+                for (String w : f.getValue().asString().split(\" \")) {\n+                    Feature outputFeature = FeatureFactory.newTextFeature(w + \" (\" + f.getName() + \")\", w);\n+                    flattenedFeatures.add(outputFeature);\n+                }\n+            } else {\n+                flattenedFeatures.add(f);\n+            }\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc1OTg5OA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 473}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjg5Mzc4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozODo0N1rOG1gfcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjozODo0N1rOG1gfcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2MDA0OA==", "bodyText": "capital", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458760048", "createdAt": "2020-07-22T12:38:47Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjk0NDQ0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo1MjozOVrOG1g_Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo1MjozOVrOG1g_Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2ODE2Mg==", "bodyText": "With the current implementation  ExplainabilityMetrics.classificationFidelity(pairs); always returns 0 for these inputs, if this is what it was intended to be tested, can you assert that it's equal to zero?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458768162", "createdAt": "2020-07-22T12:52:39Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelity() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        for (int i = 0; i < 10; i++) {\n+            List<Feature> features = new LinkedList<>();\n+            features.add(FeatureFactory.newTextFeature(\"f-1\", \"foo bar\"));\n+            features.add(FeatureFactory.newTextFeature(\"f-2\", \"bar foo\"));\n+            features.add(FeatureFactory.newTextFeature(\"f-3\", \"brow fox\"));\n+            features.add(FeatureFactory.newTextFeature(\"f-4\", \"lazy dog\"));\n+            features.add(FeatureFactory.newTextFeature(\"f-5\", \"money\"));\n+            PredictionInput input = new PredictionInput(features);\n+            Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+            pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        }\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjk1MTE3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo1NDozNVrOG1hDdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzoyMzoxNVrOG2KSdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2OTI2OA==", "bodyText": "There are no meaningful tests for this method, if this is intended to be public and exposed by the library can you add some?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458769268", "createdAt": "2020-07-22T12:54:35Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());\n+        }\n+        return impact / size;\n+    }\n+\n+    /**\n+     * calculate fidelity (accuracy) of boolean classification outputs using saliency predictor function = sign(sum(saliency.scores))\n+     * see papers:\n+     * - Guidotti Riccardo, et al. \"A survey of methods for explaining black box models.\" ACM computing surveys (2018).\n+     * - Bodria, Francesco, et al. \"Explainability Methods for Natural Language Processing: Applications to Sentiment Analysis (Discussion Paper).\"\n+     *\n+     * @param pairs pairs composed by the saliency and the related prediction\n+     * @return the fidelity accuracy\n+     */\n+    public static double classificationFidelity(List<Pair<Saliency, Prediction>> pairs) {\n+        double acc = 0;\n+        double evals = 0;\n+        for (Pair<Saliency, Prediction> pair : pairs) {\n+            Saliency saliency = pair.getLeft();\n+            Prediction prediction = pair.getRight();\n+            for (Output output : prediction.getOutput().getOutputs()) {\n+                Type type = output.getType();\n+                if (Type.BOOLEAN.equals(type)) {\n+                    double predictorOutput = saliency.getPerFeatureImportance().stream().map(FeatureImportance::getScore).mapToDouble(d -> d).sum();\n+                    double v = output.getValue().asNumber();\n+                    if ((v >= 0 && predictorOutput >= 0) || (v < 0 && predictorOutput < 0)) {\n+                        acc++;\n+                    }\n+                    evals++;\n+                }\n+            }\n+        }\n+        return evals == 0 ? 0 : acc / evals;\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ0NDg1Mg==", "bodyText": "this is tested in ExplainabilityMetricsTest, I'll add more tests there and in ITs.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459444852", "createdAt": "2020-07-23T13:23:15Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());\n+        }\n+        return impact / size;\n+    }\n+\n+    /**\n+     * calculate fidelity (accuracy) of boolean classification outputs using saliency predictor function = sign(sum(saliency.scores))\n+     * see papers:\n+     * - Guidotti Riccardo, et al. \"A survey of methods for explaining black box models.\" ACM computing surveys (2018).\n+     * - Bodria, Francesco, et al. \"Explainability Methods for Natural Language Processing: Applications to Sentiment Analysis (Discussion Paper).\"\n+     *\n+     * @param pairs pairs composed by the saliency and the related prediction\n+     * @return the fidelity accuracy\n+     */\n+    public static double classificationFidelity(List<Pair<Saliency, Prediction>> pairs) {\n+        double acc = 0;\n+        double evals = 0;\n+        for (Pair<Saliency, Prediction> pair : pairs) {\n+            Saliency saliency = pair.getLeft();\n+            Prediction prediction = pair.getRight();\n+            for (Output output : prediction.getOutput().getOutputs()) {\n+                Type type = output.getType();\n+                if (Type.BOOLEAN.equals(type)) {\n+                    double predictorOutput = saliency.getPerFeatureImportance().stream().map(FeatureImportance::getScore).mapToDouble(d -> d).sum();\n+                    double v = output.getValue().asNumber();\n+                    if ((v >= 0 && predictorOutput >= 0) || (v < 0 && predictorOutput < 0)) {\n+                        acc++;\n+                    }\n+                    evals++;\n+                }\n+            }\n+        }\n+        return evals == 0 ? 0 : acc / evals;\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2OTI2OA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjk2Nzg5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo1OTowMVrOG1hN-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzozNjowM1rOG2K0Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3MTk2Mg==", "bodyText": "are these comparable? any link to the paper/documentation?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458771962", "createdAt": "2020-07-22T12:59:01Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1MzUwNg==", "bodyText": "this is the Gower distance d_c(x_c) + lambda*d_n(x_n) (in which the lambda parameter is equals to 1) where x_c are categorical / text values whereas x_n are numeric values in an vector x holding mixed types of data.\nThe idea is to measure how far the outputs end up when you mask the most important features, if your explanation is good, most influential features will produce very different results (with respect to the original), when masked.\nI'll try to find back the link to this specific paper / literature.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459453506", "createdAt": "2020-07-23T13:36:03Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3MTk2Mg=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjk5NzM0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzowNjo1NFrOG1hgbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzozNzowMVrOG2K2tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3NjY4Ng==", "bodyText": "use a do/while to remove (Double.isNaN(finalLoss) that is used just to get in the loop for the first time?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458776686", "createdAt": "2020-07-22T13:06:54Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+    private static final double GOOD_LOSS_THRESHOLD = 0.1;\n+    private static final int MAX_NO_EPOCHS = 15;\n+    private static final double INITIAL_LEARNING_RATE = 0.01;\n+    private static final double DECAY_RATE = 0.01;\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double finalLoss = Double.NaN;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {\n+            double lr = INITIAL_LEARNING_RATE;\n+            int e = 0;\n+            while ((Double.isNaN(finalLoss) || finalLoss > GOOD_LOSS_THRESHOLD) && e < MAX_NO_EPOCHS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1NDEzMg==", "bodyText": "no please, do/while no :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459454132", "createdAt": "2020-07-23T13:37:01Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+    private static final double GOOD_LOSS_THRESHOLD = 0.1;\n+    private static final int MAX_NO_EPOCHS = 15;\n+    private static final double INITIAL_LEARNING_RATE = 0.01;\n+    private static final double DECAY_RATE = 0.01;\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double finalLoss = Double.NaN;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {\n+            double lr = INITIAL_LEARNING_RATE;\n+            int e = 0;\n+            while ((Double.isNaN(finalLoss) || finalLoss > GOOD_LOSS_THRESHOLD) && e < MAX_NO_EPOCHS) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3NjY4Ng=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzAxNTk4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoxMTo1MVrOG1hsgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoxMTo1MVrOG1hsgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc3OTc3Ng==", "bodyText": "the name of the method is a bit misleading, rename to checkAndHandleInfinite?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458779776", "createdAt": "2020-07-22T13:11:51Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+    private static final double GOOD_LOSS_THRESHOLD = 0.1;\n+    private static final int MAX_NO_EPOCHS = 15;\n+    private static final double INITIAL_LEARNING_RATE = 0.01;\n+    private static final double DECAY_RATE = 0.01;\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double finalLoss = Double.NaN;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {\n+            double lr = INITIAL_LEARNING_RATE;\n+            int e = 0;\n+            while ((Double.isNaN(finalLoss) || finalLoss > GOOD_LOSS_THRESHOLD) && e < MAX_NO_EPOCHS) {\n+                double loss = 0;\n+                int i = 0;\n+                for (Pair<double[], Double> sample : trainingSet) {\n+                    double[] doubles = sample.getLeft();\n+                    double predictedOutput = predict(doubles);\n+                    double targetOutput = sample.getRight();\n+                    double diff = checkFinite(targetOutput - predictedOutput);\n+                    if (diff != 0) { // avoid null updates to save computation\n+                        loss += Math.abs(diff) / trainingSet.size();\n+                        for (int j = 0; j < weights.length; j++) {\n+                            double v = lr * diff * doubles[j];\n+                            if (trainingSet.size() == sampleWeights.length) {\n+                                v *= sampleWeights[i];\n+                            }\n+                            v = checkFinite(v);\n+                            weights[j] += v;\n+                            bias += lr * diff * sampleWeights[i];\n+                        }\n+                    }\n+                    i++;\n+                }\n+                lr *= (1d / (1d + DECAY_RATE * e)); // learning rate decay\n+\n+                finalLoss = loss;\n+                e++;\n+                logger.debug(\"epoch {}, loss: {}\", e, loss);\n+            }\n+        }\n+        return finalLoss;\n+    }\n+\n+    private double checkFinite(double diff) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA1MTQ4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyMDowOVrOG1iCTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzozOTo0N1rOG2K-Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NTM1Ng==", "bodyText": "Why do we need a mock here? Feature and Value do not have any real dependency to be mocked", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458785356", "createdAt": "2020-07-22T13:20:09Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TestUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    static {\n+        random.setSeed(4);\n+    }\n+\n+    public static PredictionProvider getFeaturePassModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, feature.getType(), feature.getValue(),\n+                                           1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getSumSkipModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-but\" + skipFeatureIndex, Type.NUMBER, new Value<>(result), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenFeatureModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                double v = feature.getValue().asNumber();\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, Type.BOOLEAN, new Value<>(v % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenSumModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-even-but\" + skipFeatureIndex, Type.BOOLEAN, new Value<>(((int) result) % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getDummyTextClassifier() {\n+        return new PredictionProvider() {\n+            private final List<String> blackList = Arrays.asList(\"money\", \"$\", \"\u00a3\", \"bitcoin\");\n+\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> outputs = new LinkedList<>();\n+                for (PredictionInput input : inputs) {\n+                    boolean spam = false;\n+                    for (Feature f : input.getFeatures()) {\n+                        if (!spam && Type.TEXT.equals(f.getType())) {\n+                            String s = f.getValue().asString();\n+                            String[] words = s.split(\" \");\n+                            for (String w : words) {\n+                                if (blackList.contains(w)) {\n+                                    spam = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Output output = new Output(\"spam\", Type.BOOLEAN, new Value<>(spam), 1d);\n+                    outputs.add(new PredictionOutput(List.of(output)));\n+                }\n+                return outputs;\n+            }\n+        };\n+    }\n+\n+    public static Feature getMockedNumericFeature() {\n+        return getMockedNumericFeature(1d);\n+    }\n+\n+    public static Feature getMockedTextFeature(String s) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(Type.TEXT);\n+        when(f.getName()).thenReturn(\"f-text\");\n+        Value<String> value = mock(Value.class);\n+        when(value.getUnderlyingObject()).thenReturn(s);\n+        when(value.asNumber()).thenReturn(Double.NaN);\n+        when(value.asString()).thenReturn(s);\n+        when(f.getValue()).thenReturn(value);\n+        return f;\n+    }\n+\n+    public static Feature getMockedNumericFeature(double d) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(Type.NUMBER);\n+        when(f.getName()).thenReturn(\"f-num\");\n+        Value<Double> value = mock(Value.class);\n+        when(value.getUnderlyingObject()).thenReturn(d);\n+        when(value.asNumber()).thenReturn(d);\n+        when(value.asString()).thenReturn(String.valueOf(d));\n+        when(f.getValue()).thenReturn(value);\n+        return f;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1NjA5MA==", "bodyText": "in order to avoid depending on FeatureFactory which may have bugs itself.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459456090", "createdAt": "2020-07-23T13:39:47Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TestUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    static {\n+        random.setSeed(4);\n+    }\n+\n+    public static PredictionProvider getFeaturePassModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, feature.getType(), feature.getValue(),\n+                                           1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getSumSkipModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-but\" + skipFeatureIndex, Type.NUMBER, new Value<>(result), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenFeatureModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                double v = feature.getValue().asNumber();\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, Type.BOOLEAN, new Value<>(v % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenSumModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-even-but\" + skipFeatureIndex, Type.BOOLEAN, new Value<>(((int) result) % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getDummyTextClassifier() {\n+        return new PredictionProvider() {\n+            private final List<String> blackList = Arrays.asList(\"money\", \"$\", \"\u00a3\", \"bitcoin\");\n+\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> outputs = new LinkedList<>();\n+                for (PredictionInput input : inputs) {\n+                    boolean spam = false;\n+                    for (Feature f : input.getFeatures()) {\n+                        if (!spam && Type.TEXT.equals(f.getType())) {\n+                            String s = f.getValue().asString();\n+                            String[] words = s.split(\" \");\n+                            for (String w : words) {\n+                                if (blackList.contains(w)) {\n+                                    spam = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Output output = new Output(\"spam\", Type.BOOLEAN, new Value<>(spam), 1d);\n+                    outputs.add(new PredictionOutput(List.of(output)));\n+                }\n+                return outputs;\n+            }\n+        };\n+    }\n+\n+    public static Feature getMockedNumericFeature() {\n+        return getMockedNumericFeature(1d);\n+    }\n+\n+    public static Feature getMockedTextFeature(String s) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(Type.TEXT);\n+        when(f.getName()).thenReturn(\"f-text\");\n+        Value<String> value = mock(Value.class);\n+        when(value.getUnderlyingObject()).thenReturn(s);\n+        when(value.asNumber()).thenReturn(Double.NaN);\n+        when(value.asString()).thenReturn(s);\n+        when(f.getValue()).thenReturn(value);\n+        return f;\n+    }\n+\n+    public static Feature getMockedNumericFeature(double d) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(Type.NUMBER);\n+        when(f.getName()).thenReturn(\"f-num\");\n+        Value<Double> value = mock(Value.class);\n+        when(value.getUnderlyingObject()).thenReturn(d);\n+        when(value.asNumber()).thenReturn(d);\n+        when(value.asString()).thenReturn(String.valueOf(d));\n+        when(f.getValue()).thenReturn(value);\n+        return f;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NTM1Ng=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA2NDEyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyMjo1MVrOG1iJ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMzo0MToxMlrOG2LCig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NzI5MA==", "bodyText": "why these checks?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458787290", "createdAt": "2020-07-22T13:22:51Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ1NzE2Mg==", "bodyText": "because that particular model simply lets one fixed input feature be passed as the output, all other features should have way low importance, when compared with the top one.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459457162", "createdAt": "2020-07-23T13:41:12Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NzI5MA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA3MjczOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNDo1M1rOG1iPUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNDo1M1rOG1iPUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODY4OA==", "bodyText": "This is false only if an exception is raised. Is this what was intended to be checked?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458788688", "createdAt": "2020-07-22T13:24:53Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA3Mzg5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNTowNlrOG1iP9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNTowNlrOG1iP9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODg1NQ==", "bodyText": "same as above", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458788855", "createdAt": "2020-07-22T13:25:06Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputClassification() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 7));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getEvenFeatureModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertFalse(topFeatures.isEmpty());\n+        assertEquals(features.get(idx).getName(), topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA3NDUzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNToxMlrOG1iQVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNToxMlrOG1iQVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4ODk0OQ==", "bodyText": "same as above", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458788949", "createdAt": "2020-07-22T13:25:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputClassification() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 7));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getEvenFeatureModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertFalse(topFeatures.isEmpty());\n+        assertEquals(features.get(idx).getName(), topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testTextSpamClassification() {\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f1\",\"we go here and there\"));\n+        features.add(FeatureFactory.newTextFeature(\"f2\", \"please give me some money\"));\n+        features.add(FeatureFactory.newTextFeature(\"f3\", \"dear friend, please reply\"));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertEquals(\"money (f2)\", topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA3NTE1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNToyMFrOG1iQtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyNToyMFrOG1iQtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4OTA0NA==", "bodyText": "same as above", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458789044", "createdAt": "2020-07-22T13:25:20Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputClassification() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 7));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getEvenFeatureModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertFalse(topFeatures.isEmpty());\n+        assertEquals(features.get(idx).getName(), topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testTextSpamClassification() {\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f1\",\"we go here and there\"));\n+        features.add(FeatureFactory.newTextFeature(\"f2\", \"please give me some money\"));\n+        features.add(FeatureFactory.newTextFeature(\"f3\", \"dear friend, please reply\"));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertEquals(\"money (f2)\", topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThanOrEqualTo(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureClassification() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\",6));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\",3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\",5));\n+        PredictionProvider model = TestUtils.getEvenSumModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getNegativeFeatures(3);\n+        assertFalse(perFeatureImportance.stream().map(fi -> fi.getFeature().getName()).collect(Collectors.toList()).contains(features.get(idx).getName()));\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getNegativeFeatures(2));\n+        assertThat(v).isGreaterThanOrEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA4Njc1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzoyODowN1rOG1iYEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1MDoxMVrOG2OK3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MDkzMA==", "bodyText": "These POJOs do not have any business logic, is there a specific reason why mock is used?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458790930", "createdAt": "2020-07-22T13:28:07Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testEmptyPrediction() {\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionOutput output = mock(PredictionOutput.class);\n+        PredictionInput input = mock(PredictionInput.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwODQ0Ng==", "bodyText": "to avoid unnecessary boiler plate code as this is a test for an empty prediction.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459508446", "createdAt": "2020-07-23T14:50:11Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testEmptyPrediction() {\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionOutput output = mock(PredictionOutput.class);\n+        PredictionInput input = mock(PredictionInput.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MDkzMA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzA5ODc3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Output.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozMDo1OFrOG1iftw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozMDo1OFrOG1iftw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5Mjg4Nw==", "bodyText": "capital", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458792887", "createdAt": "2020-07-22T13:30:58Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Output.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * A single output/decision value generated by a {@link PredictionProvider} and incorporated in a {@link PredictionOutput}.\n+ */\n+public class Output {\n+\n+    private final Value value;\n+    private final Type type;\n+    private final double score;\n+    private final String name;\n+\n+    public Output(String name, Type type, Value value, double score) {\n+        this.name = name;\n+        this.value = value;\n+        this.type = type;\n+        this.score = score;\n+    }\n+\n+    /**\n+     * get the output name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzExNDE1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozNDo0NVrOG1ipkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1NDo0NlrOG2OYTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NTQxMQ==", "bodyText": "Is it possible to set the seed here so that the test is somehow deterministic? As @jiripetrlik suggested, It might be good to test with different seeds.\nThe same for all the following tests", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458795411", "createdAt": "2020-07-22T13:34:45Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+class DataUtilsTest {\n+\n+    @Test\n+    public void testDataGeneration() {\n+        double mean = 0.5;\n+        double stdDeviation = 0.1;\n+        int size = 100;\n+        double[] data = DataUtils.generateData(mean, stdDeviation, size);\n+        // check the sum of deviations from mean is zero\n+        double sum = 0;\n+        for (double d : data) {\n+            sum += d - mean;\n+        }\n+        assertEquals(0, sum, 1e-4);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMTg4Ng==", "bodyText": "I've opened FAI-237 for this and other tests requiring test with multiple different seeds.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459511886", "createdAt": "2020-07-23T14:54:46Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+class DataUtilsTest {\n+\n+    @Test\n+    public void testDataGeneration() {\n+        double mean = 0.5;\n+        double stdDeviation = 0.1;\n+        int size = 100;\n+        double[] data = DataUtils.generateData(mean, stdDeviation, size);\n+        // check the sum of deviations from mean is zero\n+        double sum = 0;\n+        for (double d : data) {\n+            sum += d - mean;\n+        }\n+        assertEquals(0, sum, 1e-4);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NTQxMQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzEyNzYxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozNzo0NVrOG1iyBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1NjozMlrOG2OeCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzU3Mw==", "bodyText": "Isnt't' always true (if there are no Exceptions)?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458797573", "createdAt": "2020-07-22T13:37:45Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LinearModelTest {\n+\n+    @Test\n+    void testEmptyFitClassificationDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testEmptyFitRegressionDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testRegressionFit() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            double[] x = new double[size];\n+            for (int j = 0; j < size; j++) {\n+                x[j] = (double) i / (1d * j + i);\n+            }\n+            Double y = DoubleStream.of(x).sum();\n+            trainingSet.add(new ImmutablePair<>(x, y));\n+        }\n+        assertThat(linearModel.fit(trainingSet)).isLessThan(1d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMzM1NA==", "bodyText": "nope, this happens also with an empty dataset, and I think it is good to define the expectation here, regardless of the actual implementation internal behaviour.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459513354", "createdAt": "2020-07-23T14:56:32Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LinearModelTest {\n+\n+    @Test\n+    void testEmptyFitClassificationDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testEmptyFitRegressionDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testRegressionFit() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            double[] x = new double[size];\n+            for (int j = 0; j < size; j++) {\n+                x[j] = (double) i / (1d * j + i);\n+            }\n+            Double y = DoubleStream.of(x).sum();\n+            trainingSet.add(new ImmutablePair<>(x, y));\n+        }\n+        assertThat(linearModel.fit(trainingSet)).isLessThan(1d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzU3Mw=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzEyODE1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozNzo1MlrOG1iyYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozNzo1MlrOG1iyYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzY2NQ==", "bodyText": "Isnt't' always true (if there are no Exceptions)?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458797665", "createdAt": "2020-07-22T13:37:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LinearModelTest {\n+\n+    @Test\n+    void testEmptyFitClassificationDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testEmptyFitRegressionDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));\n+    }\n+\n+    @Test\n+    void testRegressionFit() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, false);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            double[] x = new double[size];\n+            for (int j = 0; j < size; j++) {\n+                x[j] = (double) i / (1d * j + i);\n+            }\n+            Double y = DoubleStream.of(x).sum();\n+            trainingSet.add(new ImmutablePair<>(x, y));\n+        }\n+        assertThat(linearModel.fit(trainingSet)).isLessThan(1d);\n+    }\n+\n+    @Test\n+    void testClassificationFit() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        for (int i = 0; i < 100; i++) {\n+            double[] x = new double[size];\n+            for (int j = 0; j < size; j++) {\n+                x[j] = (double) i / (1d * j + i);\n+            }\n+            Double y = i % 2 == 0 ? 1d : 0d;\n+            trainingSet.add(new ImmutablePair<>(x, y));\n+        }\n+        assertThat(linearModel.fit(trainingSet)).isLessThan(1d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzEzNDY2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozOToyNFrOG1i2fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMjo0MTo0NFrOG3guGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5ODcxNw==", "bodyText": "Please declare the modules in the kogito-bom and remove <version>${project.version}</version>", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458798717", "createdAt": "2020-07-22T13:39:24Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-dmn</artifactId>\n+  <name>Kogito :: Explainability Integration Tests DMN</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg2MDk1NQ==", "bodyText": "kiegroup/kogito-runtimes#653", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r460860955", "createdAt": "2020-07-27T12:41:44Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-dmn</artifactId>\n+  <name>Kogito :: Explainability Integration Tests DMN</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5ODcxNw=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzE0MjQyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0MTowN1rOG1i7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMjo0MTozN1rOG3gt0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5OTkyNA==", "bodyText": "move to kogito bom and remove version", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458799924", "createdAt": "2020-07-22T13:41:07Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-opennlp</artifactId>\n+  <name>Kogito :: Explainability Integration Tests OpenNLP</name>\n+\n+  <properties>\n+    <opennlp.version>1.9.2</opennlp.version>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg2MDg4MQ==", "bodyText": "kiegroup/kogito-runtimes#653", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r460860881", "createdAt": "2020-07-27T12:41:37Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-opennlp</artifactId>\n+  <name>Kogito :: Explainability Integration Tests OpenNLP</name>\n+\n+  <properties>\n+    <opennlp.version>1.9.2</opennlp.version>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5OTkyNA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzE0NTk3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0MTo1MlrOG1i9Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMjo0MTozMFrOG3gtlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMDQ3MQ==", "bodyText": "move to kogito bom and remove version", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458800471", "createdAt": "2020-07-22T13:41:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,82 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  \n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg2MDgyMA==", "bodyText": "kiegroup/kogito-runtimes#653", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r460860820", "createdAt": "2020-07-27T12:41:30Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,82 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  \n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwMDQ3MQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzE3MTI2OnYy", "diffSide": "LEFT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0NzoyMlrOG1jNAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNDo1NzowM1rOG2Ofhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNDQ4MA==", "bodyText": "Could you update the parent of explainability/explainability-service/pom.xml with the new one?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458804480", "createdAt": "2020-07-22T13:47:22Z", "author": {"login": "r00ta"}, "path": "pom.xml", "diffHunk": "@@ -71,7 +71,7 @@\n     <module>ui-packages</module>\n     <module>management-console</module>\n     <module>task-console</module>\n-    <module>explainability-service</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMzczNQ==", "bodyText": "sure", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459513735", "createdAt": "2020-07-23T14:57:03Z", "author": {"login": "tteofili"}, "path": "pom.xml", "diffHunk": "@@ -71,7 +71,7 @@\n     <module>ui-packages</module>\n     <module>management-console</module>\n     <module>task-console</module>\n-    <module>explainability-service</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNDQ4MA=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MzE3NDg1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0ODoxMVrOG1jPUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo0ODoxMVrOG1jPUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTA3Mw==", "bodyText": "Add a link to documentation?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458805073", "createdAt": "2020-07-22T13:48:11Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.kie.kogito.explainability.global.GlobalExplanationException;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PartialDependenceGraph;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.PredictionProviderMetadata;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<PartialDependenceGraph>> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PartialDependencePlotExplainer.class);\n+    public static final int DEFAULT_SERIES_LENGTH = 100;\n+\n+    private final int seriesLength;\n+\n+    /**\n+     * Create a PDP provider.\n+     *\n+     * @param seriesLength the no. of data points sampled for each given feature.\n+     */\n+    public PartialDependencePlotExplainer(int seriesLength) {\n+        this.seriesLength = seriesLength;\n+    }\n+\n+    /**\n+     * Create a PDP provider.\n+     *\n+     * Each feature is sampled {@code DEFAULT_SERIES_LENGTH} times.\n+     */\n+    public PartialDependencePlotExplainer() {\n+        this(DEFAULT_SERIES_LENGTH);\n+    }\n+\n+    @Override\n+    public Collection<PartialDependenceGraph> explain(PredictionProvider model, PredictionProviderMetadata metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ2ODU4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNTowMlrOG4BqUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDowOTowN1rOG4F5ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMDY1Ng==", "bodyText": "A comment on the type handling: at the moment in some parts of the pull request there are some logics around the types. All those logics are handled with a switch statement: I think that it would be much much easier to read and expecially maintain if we go for a strategy pattern. If a new type comes in, we just add a class instead of adding a case in all the switches (with the risk of missing some of them).\nSince this pr is big and the refactoring might not be trivial, we might do that in another ticket if you @tteofili @danielezonca @jiripetrlik think it makes sense.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461400656", "createdAt": "2020-07-28T08:15:02Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < targetInput.getFeatures().size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (originalFeature.getType()) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3MDExMA==", "bodyText": "sure, that's what I proposed as well in another comment above, I've created FAI-238 to track that.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461470110", "createdAt": "2020-07-28T10:09:07Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < targetInput.getFeatures().size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (originalFeature.getType()) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMDY1Ng=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ3MTk2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNjowMFrOG4Bscg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNjowMFrOG4Bscg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTIwMg==", "bodyText": "Add default case and handle the unsupported case?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461401202", "createdAt": "2020-07-28T08:16:00Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < targetInput.getFeatures().size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (originalFeature.getType()) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ3NTcxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNzowM1rOG4Bu2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoxNzowM1rOG4Bu2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwMTgxNg==", "bodyText": "move threshold to constant?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461401816", "createdAt": "2020-07-28T08:17:03Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < targetInput.getFeatures().size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (originalFeature.getType()) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+            }\n+        }\n+        return columnData;\n+    }\n+\n+    private static void encodeNumbers(List<PredictionInput> predictionInputs, PredictionInput originalInputs, List<List<Double>> columnData, int t) {\n+        // find maximum and minimum values\n+        double[] doubles = new double[predictionInputs.size() + 1];\n+        int i = 0;\n+        for (PredictionInput pi : predictionInputs) {\n+            Feature feature = pi.getFeatures().get(t);\n+            doubles[i] = feature.getValue().asNumber();\n+            i++;\n+        }\n+        Feature feature = originalInputs.getFeatures().get(t);\n+        double originalValue = feature.getValue().asNumber();\n+        doubles[i] = originalValue;\n+        double min = DoubleStream.of(doubles).min().getAsDouble();\n+        double max = DoubleStream.of(doubles).max().getAsDouble();\n+        // feature scaling + kernel based clustering\n+        double threshold = DataUtils.gaussianKernel((originalValue - min) / (max - min));\n+        List<Double> featureValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min))\n+                .map(d -> Double.isNaN(d) ? 1 : d).boxed().map(DataUtils::gaussianKernel)\n+                .map(d -> (d - threshold < 1e-3) ? 1d : 0d).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ5MDExOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyMTowOFrOG4B3vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyMTowOFrOG4B3vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNDA5NA==", "bodyText": "minor thing: all caps letters?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461404094", "createdAt": "2020-07-28T08:21:08Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ * <p>\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDQ5MzU1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyMjowNFrOG4B58Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoxMToyOFrOG4F_Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNDY1Nw==", "bodyText": "which code block is this comment referring to?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461404657", "createdAt": "2020-07-28T08:22:04Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ * <p>\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * No. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * No. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    /**\n+     * No. of retries while trying to find a (linearly) separable dataset\n+     */\n+    private final int noOfRetries;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations, int noOfRetries) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = noOfRetries;\n+    }\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = 3;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+\n+        if (inputFeatures.size() > 0) {\n+            // in case of composite / nested features, \"linearize\" the features\n+            List<PredictionInput> linearizedInputs = DataUtils.linearizeInputs(List.of(originalInput));\n+            if (linearizedInputs.size() > 0) {\n+                PredictionInput targetInput = linearizedInputs.get(0);\n+                List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+\n+                List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+                int noOfInputFeatures = inputFeatures.size();\n+                int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+                double[] weights = new double[noOfOutputFeatures];\n+\n+                // iterate through the different outputs in the prediction and explain each one separately\n+                for (int o = 0; o < actualOutputs.size(); o++) {\n+                    boolean separableDataset = false;\n+\n+                    List<PredictionInput> trainingInputs = new LinkedList<>();\n+                    List<PredictionOutput> trainingOutputs = new LinkedList<>();\n+\n+                    Output currentOutput = actualOutputs.get(o);\n+                    // do not explain the current output if it is 'null'\n+                    if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                        Map<Double, Long> rawClassesBalance = new HashMap<>();\n+\n+                            /*\n+                            perturb the inputs so that the perturbed dataset contains more than just one output class, otherwise\n+                            it would be impossible to linearly separate it, and hence learn meaningful weights to be used as\n+                            feature importance scores.\n+                             */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3MTU0Ng==", "bodyText": "it refers to: https://github.com/tteofili/kogito-apps/blob/KOGITO-2750/explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java#L123-L157\nI realize there's an indent issue, I'll fix it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461471546", "createdAt": "2020-07-28T10:11:28Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ * <p>\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * No. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * No. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    /**\n+     * No. of retries while trying to find a (linearly) separable dataset\n+     */\n+    private final int noOfRetries;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations, int noOfRetries) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = noOfRetries;\n+    }\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = 3;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+\n+        if (inputFeatures.size() > 0) {\n+            // in case of composite / nested features, \"linearize\" the features\n+            List<PredictionInput> linearizedInputs = DataUtils.linearizeInputs(List.of(originalInput));\n+            if (linearizedInputs.size() > 0) {\n+                PredictionInput targetInput = linearizedInputs.get(0);\n+                List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+\n+                List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+                int noOfInputFeatures = inputFeatures.size();\n+                int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+                double[] weights = new double[noOfOutputFeatures];\n+\n+                // iterate through the different outputs in the prediction and explain each one separately\n+                for (int o = 0; o < actualOutputs.size(); o++) {\n+                    boolean separableDataset = false;\n+\n+                    List<PredictionInput> trainingInputs = new LinkedList<>();\n+                    List<PredictionOutput> trainingOutputs = new LinkedList<>();\n+\n+                    Output currentOutput = actualOutputs.get(o);\n+                    // do not explain the current output if it is 'null'\n+                    if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                        Map<Double, Long> rawClassesBalance = new HashMap<>();\n+\n+                            /*\n+                            perturb the inputs so that the perturbed dataset contains more than just one output class, otherwise\n+                            it would be impossible to linearly separate it, and hence learn meaningful weights to be used as\n+                            feature importance scores.\n+                             */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNDY1Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDUwNDE4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNDo1MlrOG4CAng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNDo1MlrOG4CAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNjM2Ng==", "bodyText": "can you intent/split this line? it's a bit hard to read/understand", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461406366", "createdAt": "2020-07-28T08:24:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ * <p>\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * No. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * No. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    /**\n+     * No. of retries while trying to find a (linearly) separable dataset\n+     */\n+    private final int noOfRetries;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations, int noOfRetries) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = noOfRetries;\n+    }\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = 3;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+\n+        if (inputFeatures.size() > 0) {\n+            // in case of composite / nested features, \"linearize\" the features\n+            List<PredictionInput> linearizedInputs = DataUtils.linearizeInputs(List.of(originalInput));\n+            if (linearizedInputs.size() > 0) {\n+                PredictionInput targetInput = linearizedInputs.get(0);\n+                List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+\n+                List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+                int noOfInputFeatures = inputFeatures.size();\n+                int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+                double[] weights = new double[noOfOutputFeatures];\n+\n+                // iterate through the different outputs in the prediction and explain each one separately\n+                for (int o = 0; o < actualOutputs.size(); o++) {\n+                    boolean separableDataset = false;\n+\n+                    List<PredictionInput> trainingInputs = new LinkedList<>();\n+                    List<PredictionOutput> trainingOutputs = new LinkedList<>();\n+\n+                    Output currentOutput = actualOutputs.get(o);\n+                    // do not explain the current output if it is 'null'\n+                    if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                        Map<Double, Long> rawClassesBalance = new HashMap<>();\n+\n+                            /*\n+                            perturb the inputs so that the perturbed dataset contains more than just one output class, otherwise\n+                            it would be impossible to linearly separate it, and hence learn meaningful weights to be used as\n+                            feature importance scores.\n+                             */\n+\n+                        boolean classification = false;\n+\n+                        // in case of failure in separating the dataset, retry with newly perturbed inputs\n+                        for (int tries = this.noOfRetries; tries > 0; tries--) {\n+                            // perturb the inputs\n+                            List<PredictionInput> perturbedInputs = getPerturbedInputs(originalInput, noOfInputFeatures);\n+\n+                            // perform predictions on the perturbed inputs\n+                            List<PredictionOutput> perturbedOutputs = model.predict(perturbedInputs);\n+\n+                            // calculate the no. of samples belonging to each output class\n+                            Value<?> fv = currentOutput.getValue();\n+                            int finalO = o;\n+                            rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                    .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                    && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                    .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                            logger.debug(\"raw samples per class: {}\", rawClassesBalance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDUwNjUxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNToyN1rOG4CCGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNToyN1rOG4CCGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNjc0Ng==", "bodyText": "move to constant?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461406746", "createdAt": "2020-07-28T08:25:27Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ * <p>\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * No. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * No. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    /**\n+     * No. of retries while trying to find a (linearly) separable dataset\n+     */\n+    private final int noOfRetries;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations, int noOfRetries) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = noOfRetries;\n+    }\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+        this.noOfRetries = 3;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+\n+        if (inputFeatures.size() > 0) {\n+            // in case of composite / nested features, \"linearize\" the features\n+            List<PredictionInput> linearizedInputs = DataUtils.linearizeInputs(List.of(originalInput));\n+            if (linearizedInputs.size() > 0) {\n+                PredictionInput targetInput = linearizedInputs.get(0);\n+                List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+\n+                List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+                int noOfInputFeatures = inputFeatures.size();\n+                int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+                double[] weights = new double[noOfOutputFeatures];\n+\n+                // iterate through the different outputs in the prediction and explain each one separately\n+                for (int o = 0; o < actualOutputs.size(); o++) {\n+                    boolean separableDataset = false;\n+\n+                    List<PredictionInput> trainingInputs = new LinkedList<>();\n+                    List<PredictionOutput> trainingOutputs = new LinkedList<>();\n+\n+                    Output currentOutput = actualOutputs.get(o);\n+                    // do not explain the current output if it is 'null'\n+                    if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                        Map<Double, Long> rawClassesBalance = new HashMap<>();\n+\n+                            /*\n+                            perturb the inputs so that the perturbed dataset contains more than just one output class, otherwise\n+                            it would be impossible to linearly separate it, and hence learn meaningful weights to be used as\n+                            feature importance scores.\n+                             */\n+\n+                        boolean classification = false;\n+\n+                        // in case of failure in separating the dataset, retry with newly perturbed inputs\n+                        for (int tries = this.noOfRetries; tries > 0; tries--) {\n+                            // perturb the inputs\n+                            List<PredictionInput> perturbedInputs = getPerturbedInputs(originalInput, noOfInputFeatures);\n+\n+                            // perform predictions on the perturbed inputs\n+                            List<PredictionOutput> perturbedOutputs = model.predict(perturbedInputs);\n+\n+                            // calculate the no. of samples belonging to each output class\n+                            Value<?> fv = currentOutput.getValue();\n+                            int finalO = o;\n+                            rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                    .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                    && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                    .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                            logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                            // check if the dataset is separable and also if the linear model should fit a regressor or a classifier\n+                            if (rawClassesBalance.size() > 1) {\n+                                Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                                if ((double) max / (double) perturbedInputs.size() < 0.99) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDUxMzIzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNzoyMVrOG4CGWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODoyNzoyMVrOG4CGWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNzgzMg==", "bodyText": "indent/split?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461407832", "createdAt": "2020-07-28T08:27:21Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+/**\n+ * Utility class to generate weights for the LIME encoded training set, given a prediction.\n+ */\n+class SampleWeighter {\n+\n+    private static final double SIGMA = 0.75;\n+\n+    static double[] getSampleWeights(PredictionInput targetInput, Collection<Pair<double[], Double>> training) {\n+        int noOfFeatures = targetInput.getFeatures().size();\n+        double[] x = new double[noOfFeatures];\n+        Arrays.fill(x, 1);\n+\n+        return training.stream().map(Pair::getLeft).map(\n+                d -> DataUtils.euclideanDistance(x, d)).map(d -> DataUtils.exponentialSmoothingKernel(d, SIGMA *\n+                Math.sqrt(noOfFeatures))).mapToDouble(Double::doubleValue).toArray();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU0MDgwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODozNDoyNVrOG4CXZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMjoyMjowNVrOG415iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw==", "bodyText": "Just for my understanding: what is the difference of sampling from a normal distribution and this procedure?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461412197", "createdAt": "2020-07-28T08:34:25Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3ODg0Ng==", "bodyText": "there's no difference, in fact that is used exactly for sampling from a standard normal distribution in https://github.com/tteofili/kogito-apps/blob/KOGITO-2750/explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java#L216", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461478846", "createdAt": "2020-07-28T10:26:01Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMzQwOA==", "bodyText": "Ok, since there is no difference wdyt @tteofili  if we change it to something like\nRandom r = new Random();\ndouble sample = r.nextGaussian()*targetStandardDeviation+targetMean;\n\n?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461503408", "createdAt": "2020-07-28T11:15:11Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0NjE3OQ==", "bodyText": "the current code is slightly more accurate with respect to r.nextGaussian()*targetStandardDeviation+targetMean, not sure why it is the case but there's a difference in precision wrt to desired mean and stdDev of the generated data of 1e-6 (with current code) vs 1e-2 (with r.nextGaussian()*targetStandardDeviation+targetMean).\nSo if it is not a problem, I'd prefer to keep the current code (slightly slower but more precise).", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461546179", "createdAt": "2020-07-28T12:38:18Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcwNjQ1Mg==", "bodyText": "Hi @tteofili , I've called generateData(0, 10, 500) and I've plotted the data, but it does not look a gaussian: it's not symmetric at all.\n\nIf it's important that we sample from a normal distribution maybe it's better to go for  r.nextGaussian()*targetStandardDeviation+targetMean even if the noise is bigger than the other method, because at least we sample from a normal distribution. If the distribution is not that important as the mean and the std deviation, forget my comments.\nbtw, what is the size of the sample you are generating for your comparison?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461706452", "createdAt": "2020-07-28T16:17:19Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1NjUyMQ==", "bodyText": "both are important for the numerical data perturbation procedure, hence I would mix them together, by generating the initial values ofdouble[] with r.nextGaussian()*targetStandardDeviation+targetMean and then adjusting mean and stdDeviation with the current procedure.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462256521", "createdAt": "2020-07-29T12:22:05Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjE5Nw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU1NDM0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODozODowNVrOG4Cftg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMzo1NzowMFrOG4N1mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNDMyNg==", "bodyText": "If I'm not wrong, if stringValue.endswith(' ') == true this piece of code will throw an exception since 1/2 = 0 and random.nextInt(0) will throw an IllegalArgumentException or something. Can you add a test for that if this is correct?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461414326", "createdAt": "2020-07-28T08:38:05Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYwMDE1Mg==", "bodyText": "I think this is guarded by !words.isEmpty(), anyway there're tests for such text features at https://github.com/tteofili/kogito-apps/blob/KOGITO-2750/explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java#L155-L197", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461600152", "createdAt": "2020-07-28T13:57:00Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNDMyNg=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU2MzA5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0MDozMlrOG4ClPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMjo0OTo0OFrOG4K-hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNTc0MA==", "bodyText": "Just for my understanding: this line of code does not ensure that the feature is perturbed right? Should we create a ticket to investigate and improve the perturbation of such types?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461415740", "createdAt": "2020-07-28T08:40:32Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU1MzI4NA==", "bodyText": "yes, agreed, I've created FAI-243 for this.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461553284", "createdAt": "2020-07-28T12:49:48Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNTc0MA=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU3MTMwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0Mjo0MFrOG4CqWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0Mjo0MFrOG4CqWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNzA1MQ==", "bodyText": "Check if the strings have different length?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461417051", "createdAt": "2020-07-28T08:42:40Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                } else {\n+                    f = feature;\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, List<String> names) {\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = names.stream().map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (names.contains(featureName)) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newBooleanFeature(featureName, null);\n+                }\n+                break;\n+            case TIME:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTimeFeature(featureName, null);\n+                }\n+                break;\n+            case DURATION:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newDurationFeature(featureName, null);\n+                }\n+                break;\n+            case CURRENCY:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newCurrencyFeature(featureName, null);\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (names.contains(featureName)) {\n+                    String category = feature.getValue().asString();\n+                    f = FeatureFactory.newCategoricalFeature(featureName, \"\");\n+                }\n+                break;\n+            case BINARY:\n+                if (names.contains(featureName)) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (names.contains(featureName)) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (names.contains(featureName)) {\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        Arrays.fill(values, 0);\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                } else {\n+                    f = FeatureFactory.newObjectFeature(featureName, null);\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        if (x.length != y.length) {\n+            return Double.NaN;\n+        } else {\n+            double h = 0d;\n+            for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+                if (x[i] != y[i]) {\n+                    h++;\n+                }\n+            }\n+            return h;\n+        }\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU3MjE3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0Mjo1NFrOG4Cq5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0Mjo1NFrOG4Cq5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNzE4OQ==", "bodyText": "Math.min not needed anymore", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461417189", "createdAt": "2020-07-28T08:42:54Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                } else {\n+                    f = feature;\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, List<String> names) {\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = names.stream().map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (names.contains(featureName)) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newBooleanFeature(featureName, null);\n+                }\n+                break;\n+            case TIME:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTimeFeature(featureName, null);\n+                }\n+                break;\n+            case DURATION:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newDurationFeature(featureName, null);\n+                }\n+                break;\n+            case CURRENCY:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newCurrencyFeature(featureName, null);\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (names.contains(featureName)) {\n+                    String category = feature.getValue().asString();\n+                    f = FeatureFactory.newCategoricalFeature(featureName, \"\");\n+                }\n+                break;\n+            case BINARY:\n+                if (names.contains(featureName)) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (names.contains(featureName)) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (names.contains(featureName)) {\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        Arrays.fill(values, 0);\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                } else {\n+                    f = FeatureFactory.newObjectFeature(featureName, null);\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        if (x.length != y.length) {\n+            return Double.NaN;\n+        } else {\n+            double h = 0d;\n+            for (int i = 0; i < Math.min(x.length, y.length); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 372}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDU3MzMwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo0MzoxM1rOG4Crkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMjoyNTo1NFrOG4KGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNzM2Mw==", "bodyText": "Same as above for hamming distance?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461417363", "createdAt": "2020-07-28T08:43:13Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                } else {\n+                    f = feature;\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, List<String> names) {\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = names.stream().map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (names.contains(featureName)) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newBooleanFeature(featureName, null);\n+                }\n+                break;\n+            case TIME:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTimeFeature(featureName, null);\n+                }\n+                break;\n+            case DURATION:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newDurationFeature(featureName, null);\n+                }\n+                break;\n+            case CURRENCY:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newCurrencyFeature(featureName, null);\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (names.contains(featureName)) {\n+                    String category = feature.getValue().asString();\n+                    f = FeatureFactory.newCategoricalFeature(featureName, \"\");\n+                }\n+                break;\n+            case BINARY:\n+                if (names.contains(featureName)) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (names.contains(featureName)) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (names.contains(featureName)) {\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        Arrays.fill(values, 0);\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                } else {\n+                    f = FeatureFactory.newObjectFeature(featureName, null);\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        if (x.length != y.length) {\n+            return Double.NaN;\n+        } else {\n+            double h = 0d;\n+            for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+                if (x[i] != y[i]) {\n+                    h++;\n+                }\n+            }\n+            return h;\n+        }\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUzODgzNw==", "bodyText": "sure", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461538837", "createdAt": "2020-07-28T12:25:54Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,470 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void setSeed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbFeatures(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue = \"\";\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        if (!words.isEmpty()) {\n+                            int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                            for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                                int dropIdx = random.nextInt(words.size());\n+                                words.remove(dropIdx);\n+                            }\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    }\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double originalFeatureValue = feature.getValue().asNumber();\n+                boolean intValue = originalFeatureValue % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double normalDistributionSample = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (originalFeatureValue != 0d) {\n+                    normalDistributionSample = normalDistributionSample * originalFeatureValue + originalFeatureValue;\n+                }\n+                if (intValue) {\n+                    normalDistributionSample = (int) normalDistributionSample;\n+                    if (normalDistributionSample == originalFeatureValue) {\n+                        normalDistributionSample = (int) normalDistributionSample * 10d;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, normalDistributionSample);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                LocalTime featureValue = (LocalTime) feature.getValue().getUnderlyingObject();\n+                f = FeatureFactory.newTimeFeature(featureName, featureValue.minusHours(random.nextInt(24)));\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to machine default locale\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));\n+                break;\n+            case CATEGORICAL:\n+                String category = feature.getValue().asString();\n+                if (!\"0\".equals(category)) {\n+                    category = \"0\";\n+                } else {\n+                    category = \"1\";\n+                }\n+                f = FeatureFactory.newCategoricalFeature(featureName, category);\n+                break;\n+            case BINARY:\n+                // set an empty buffer\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                break;\n+            case URI:\n+                // set an empty URI\n+                f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                break;\n+            case VECTOR:\n+                // randomly set a non zero value to zero (or decrease it by 1)\n+                double[] values = feature.getValue().asVector();\n+                if (values.length > 1) {\n+                    int idx = random.nextInt(values.length - 1);\n+                    if (values[idx] != 0) {\n+                        values[idx] = 0;\n+                    } else {\n+                        values[idx]--;\n+                    }\n+                }\n+                f = FeatureFactory.newVectorFeature(featureName, values);\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = perturbFeature((Feature) feature.getValue().getUnderlyingObject(), noOfSamples);\n+                } else {\n+                    f = feature;\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static Feature dropFeature(Feature feature, List<String> names) {\n+        Type type = feature.getType();\n+        Feature f = feature;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    featuresMap.put(cf.getName(), dropFeature(cf, names));\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTextFeature(featureName, \"\");\n+                } else {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        List<String> matchingWords = names.stream().map(n -> n.contains(\" (\") ? n.substring(0, n.indexOf(\" (\")) : \"\").filter(words::contains).collect(Collectors.toList());\n+                        if (words.removeAll(matchingWords)) {\n+                            stringValue = String.join(\" \", words);\n+                        }\n+                    }\n+                    f = FeatureFactory.newTextFeature(featureName, stringValue);\n+                }\n+                break;\n+            case NUMBER:\n+                if (names.contains(featureName)) {\n+                    if (feature.getValue().asNumber() == 0) {\n+                        f = FeatureFactory.newNumericalFeature(featureName, Double.NaN);\n+                    } else {\n+                        f = FeatureFactory.newNumericalFeature(featureName, 0);\n+                    }\n+                }\n+                break;\n+            case BOOLEAN:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newBooleanFeature(featureName, null);\n+                }\n+                break;\n+            case TIME:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newTimeFeature(featureName, null);\n+                }\n+                break;\n+            case DURATION:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newDurationFeature(featureName, null);\n+                }\n+                break;\n+            case CURRENCY:\n+                if (names.contains(featureName)) {\n+                    f = FeatureFactory.newCurrencyFeature(featureName, null);\n+                }\n+                break;\n+            case CATEGORICAL:\n+                if (names.contains(featureName)) {\n+                    String category = feature.getValue().asString();\n+                    f = FeatureFactory.newCategoricalFeature(featureName, \"\");\n+                }\n+                break;\n+            case BINARY:\n+                if (names.contains(featureName)) {\n+                    // set an empty buffer\n+                    ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n+                    f = FeatureFactory.newBinaryFeature(featureName, byteBuffer);\n+                }\n+                break;\n+            case URI:\n+                if (names.contains(featureName)) {\n+                    // set an empty URI\n+                    f = FeatureFactory.newURIFeature(featureName, URI.create(\"\"));\n+                }\n+                break;\n+            case VECTOR:\n+                if (names.contains(featureName)) {\n+                    double[] values = feature.getValue().asVector();\n+                    if (values.length > 0) {\n+                        Arrays.fill(values, 0);\n+                    }\n+                    f = FeatureFactory.newVectorFeature(featureName, values);\n+                }\n+                break;\n+            case UNDEFINED:\n+                if (feature.getValue().getUnderlyingObject() instanceof Feature) {\n+                    f = dropFeature((Feature) feature.getValue().getUnderlyingObject(), names);\n+                } else {\n+                    f = FeatureFactory.newObjectFeature(featureName, null);\n+                }\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + type);\n+        }\n+        return f;\n+    }\n+\n+    public static double hammingDistance(double[] x, double[] y) {\n+        if (x.length != y.length) {\n+            return Double.NaN;\n+        } else {\n+            double h = 0d;\n+            for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+                if (x[i] != y[i]) {\n+                    h++;\n+                }\n+            }\n+            return h;\n+        }\n+    }\n+\n+    public static double hammingDistance(String x, String y) {\n+        double h = 0;\n+        for (int i = 0; i < Math.min(x.length(), y.length()); i++) {\n+            if (x.charAt(i) != y.charAt(i)) {\n+                h++;\n+            }\n+        }\n+        return h + (double) (x.length() - y.length());\n+    }\n+\n+    public static double euclideanDistance(double[] x, double[] y) {\n+        double e = 0;\n+        for (int i = 0; i < Math.min(x.length, y.length); i++) {\n+            e += Math.pow(x[i] - y[i], 2);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxNzM2Mw=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 395}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYwODc0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1MjoyM1rOG4DB_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMzoxOToxNVrOG4MJKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMzEwMg==", "bodyText": "Following the discussion of the previous comment  all other features should have way low importance, when compared with the top one., wouldn't it be better to check the percentage here? In theory these checks might pass if topFeatures.get(1).getScore() == topFeatures.get(0).getScore(), which is not the expected behaviour iiuc", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461423102", "createdAt": "2020-07-28T08:52:23Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU3MjM5Mw==", "bodyText": "hmm, now I realize the check is wrong, thanks for pointing it out, I'll fix it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461572393", "createdAt": "2020-07-28T13:19:15Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyMzEwMg=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYxNjAxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1NDoyMFrOG4DGnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMzoyMzoyMVrOG4MUmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNDI4NA==", "bodyText": "this is always true, isn't it? Same for all the following tests", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461424284", "createdAt": "2020-07-28T08:54:20Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThan(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThan(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU3NTMyMQ==", "bodyText": "no, it can be 0 when dropping features has no effect in the model prediction output.\nIf the impact it's greater than 0 it means that the drop of the top k features caused some change in the output.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461575321", "createdAt": "2020-07-28T13:23:21Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        PredictionProvider model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThan(0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        PredictionProvider model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertThat(v).isGreaterThan(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNDI4NA=="}, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYzMzIxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1ODozN1rOG4DRUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1ODozN1rOG4DRUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNzAyNQ==", "bodyText": "Assertions.assertThrows(LocalExplanationException.class, () -> limeExplainer.explain(prediction, model)); ?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461427025", "createdAt": "2020-07-28T08:58:37Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testEmptyPrediction() {\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionOutput output = mock(PredictionOutput.class);\n+        PredictionInput input = mock(PredictionInput.class);\n+        Prediction prediction = new Prediction(input, output);\n+        PredictionProvider model = mock(PredictionProvider.class);\n+        try {\n+            limeExplainer.explain(prediction, model);\n+            fail(\"explaining an empty prediction should throw an exception\");\n+        } catch (LocalExplanationException e) {\n+            // do nothing\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDYzNjg0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1OTozM1rOG4DTjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwODo1OTozM1rOG4DTjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyNzU5Ng==", "bodyText": "refactor so to remove duplicated code?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r461427596", "createdAt": "2020-07-28T08:59:33Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LimeStabilityTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testStabilityWithNumericData() {\n+        PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n+        List<Feature> featureList = new LinkedList<>();\n+        for (int i = 0; i < 5; i++) {\n+            featureList.add(TestUtils.getMockedNumericFeature(i));\n+        }\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = sumSkipModel.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, predictionOutputs.get(0));\n+        List<Saliency> saliencies = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        for (int i = 0; i < 100; i++) {\n+            Saliency saliency = limeExplainer.explain(prediction, sumSkipModel);\n+            saliencies.add(saliency);\n+        }\n+        List<String> names = new LinkedList<>();\n+        saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+        Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+        boolean topFeature = false;\n+        for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n+            topFeature = entry.getValue() >= 0.9;\n+        }\n+        assertTrue(topFeature);\n+    }\n+\n+    @Test\n+    void testStabilityWithTextData() {\n+        PredictionProvider sumSkipModel = TestUtils.getDummyTextClassifier();\n+        List<Feature> featureList = new LinkedList<>();\n+        for (int i = 0; i < 4; i++) {\n+            featureList.add(TestUtils.getMockedTextFeature(\"foo \"+i));\n+        }\n+        featureList.add(TestUtils.getMockedTextFeature(\"money\"));\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = sumSkipModel.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, predictionOutputs.get(0));\n+        List<Saliency> saliencies = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        for (int i = 0; i < 100; i++) {\n+            Saliency saliency = limeExplainer.explain(prediction, sumSkipModel);\n+            saliencies.add(saliency);\n+        }\n+        List<String> names = new LinkedList<>();\n+        saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+        Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+        boolean topFeature = false;\n+        for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n+            topFeature = entry.getValue() >= 0.9;\n+        }\n+        assertTrue(topFeature);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ab120a13b777f71f58bbebefcfbc12d81d98483"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzIzMzY4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMjozOFrOG5CHZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMDozMFrOG5cd1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NjY3Ng==", "bodyText": "If the two strings have different length then the impact is just 1? Is this correct?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462456676", "createdAt": "2020-07-29T17:12:38Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * Measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        List<String> importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).collect(Collectors.toList());\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0d;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += 0.5 * DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            String x = original.getValue().asString();\n+            String y = modified.getValue().asString();\n+            if (x.length() == y.length()) {\n+                impact += DataUtils.hammingDistance(x, y);\n+            } else {\n+                impact += 1d;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODQwNg==", "bodyText": "I am struggling at finding the original paper where I had found this impact definition, I'll keep digging...\nAnyway the idea is similar to the one described in this paper where the impact is 1 when either the output without the important features is different from the original one or when its score has changed by at least 0.5 (in a 0..1 range), except that instead of having a discrete impact we calculate the distance between the changed/original output values and between changed/original scores, giving more weight to a changed output than to a changed score (hence the 0.5 on score).\nIn case the (hamming) distance cannot be computed (e.g. when their lengths differ) it's just set to 1 if the output value changed.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462888406", "createdAt": "2020-07-30T10:00:30Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * Measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        List<String> importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).collect(Collectors.toList());\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0d;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += 0.5 * DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            String x = original.getValue().asString();\n+            String y = modified.getValue().asString();\n+            if (x.length() == y.length()) {\n+                impact += DataUtils.hammingDistance(x, y);\n+            } else {\n+                impact += 1d;\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NjY3Ng=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzIzNDE3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMjo0NlrOG5CHuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDowMToyOFrOG5cfsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njc2Mw==", "bodyText": "Why 0.5?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462456763", "createdAt": "2020-07-29T17:12:46Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * Measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        List<String> importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).collect(Collectors.toList());\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0d;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += 0.5 * DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODg4MQ==", "bodyText": "see above comment", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462888881", "createdAt": "2020-07-30T10:01:28Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * Measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model       the model to be explained\n+     * @param prediction  a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(PredictionProvider model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        List<String> importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).collect(Collectors.toList());\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0d;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += 0.5 * DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njc2Mw=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI0MzQ1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxNTowOFrOG5CNow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyODozM1rOG5bX1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1ODI3NQ==", "bodyText": "Isnt't better to directly instantiate a Feature object without a mock?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462458275", "createdAt": "2020-07-29T17:15:08Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TestUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    static {\n+        random.setSeed(4);\n+    }\n+\n+    public static PredictionProvider getFeaturePassModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, feature.getType(), feature.getValue(),\n+                                           1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getSumSkipModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-but\" + skipFeatureIndex, Type.NUMBER, new Value<>(result), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenFeatureModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                double v = feature.getValue().asNumber();\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, Type.BOOLEAN, new Value<>(v % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenSumModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-even-but\" + skipFeatureIndex, Type.BOOLEAN, new Value<>(((int) result) % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getDummyTextClassifier() {\n+        return new PredictionProvider() {\n+            private final List<String> blackList = Arrays.asList(\"money\", \"$\", \"\u00a3\", \"bitcoin\");\n+\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> outputs = new LinkedList<>();\n+                for (PredictionInput input : inputs) {\n+                    boolean spam = false;\n+                    for (Feature f : input.getFeatures()) {\n+                        if (!spam && Type.TEXT.equals(f.getType())) {\n+                            String s = f.getValue().asString();\n+                            String[] words = s.split(\" \");\n+                            for (String w : words) {\n+                                if (blackList.contains(w)) {\n+                                    spam = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Output output = new Output(\"spam\", Type.BOOLEAN, new Value<>(spam), 1d);\n+                    outputs.add(new PredictionOutput(List.of(output)));\n+                }\n+                return outputs;\n+            }\n+        };\n+    }\n+\n+    public static Feature getMockedNumericFeature() {\n+        return getMockedNumericFeature(1d);\n+    }\n+\n+    public static Feature getMockedFeature(Type type, Value<?> v) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(type);\n+        when(f.getName()).thenReturn(\"f-\" + type.name());\n+        when(f.getValue()).thenReturn(v);\n+        return f;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDQ4Nw==", "bodyText": "Feature constructor is package local to prevent users to instantiate them themselves while possibly messing up Types  and Values (e.g. Type.BOOLEAN and new Value<Double>(1d)).\nFeature creation is exposed via FeatureFactory however I prefer to not depend on the FeatureFactory impl in the tests, as that might hide some bugs iteself.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462870487", "createdAt": "2020-07-30T09:28:33Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class TestUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    static {\n+        random.setSeed(4);\n+    }\n+\n+    public static PredictionProvider getFeaturePassModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, feature.getType(), feature.getValue(),\n+                                           1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getSumSkipModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-but\" + skipFeatureIndex, Type.NUMBER, new Value<>(result), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenFeatureModel(int featureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                Feature feature = features.get(featureIndex);\n+                double v = feature.getValue().asNumber();\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"feature-\" + featureIndex, Type.BOOLEAN, new Value<>(v % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getEvenSumModel(int skipFeatureIndex) {\n+        return inputs -> {\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+            for (PredictionInput predictionInput : inputs) {\n+                List<Feature> features = predictionInput.getFeatures();\n+                double result = 0;\n+                for (int i = 0; i < features.size(); i++) {\n+                    if (skipFeatureIndex != i) {\n+                        result += features.get(i).getValue().asNumber();\n+                    }\n+                }\n+                PredictionOutput predictionOutput = new PredictionOutput(\n+                        List.of(new Output(\"sum-even-but\" + skipFeatureIndex, Type.BOOLEAN, new Value<>(((int) result) % 2 == 0), 1d)));\n+                predictionOutputs.add(predictionOutput);\n+            }\n+            return predictionOutputs;\n+        };\n+    }\n+\n+    public static PredictionProvider getDummyTextClassifier() {\n+        return new PredictionProvider() {\n+            private final List<String> blackList = Arrays.asList(\"money\", \"$\", \"\u00a3\", \"bitcoin\");\n+\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> outputs = new LinkedList<>();\n+                for (PredictionInput input : inputs) {\n+                    boolean spam = false;\n+                    for (Feature f : input.getFeatures()) {\n+                        if (!spam && Type.TEXT.equals(f.getType())) {\n+                            String s = f.getValue().asString();\n+                            String[] words = s.split(\" \");\n+                            for (String w : words) {\n+                                if (blackList.contains(w)) {\n+                                    spam = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Output output = new Output(\"spam\", Type.BOOLEAN, new Value<>(spam), 1d);\n+                    outputs.add(new PredictionOutput(List.of(output)));\n+                }\n+                return outputs;\n+            }\n+        };\n+    }\n+\n+    public static Feature getMockedNumericFeature() {\n+        return getMockedNumericFeature(1d);\n+    }\n+\n+    public static Feature getMockedFeature(Type type, Value<?> v) {\n+        Feature f = mock(Feature.class);\n+        when(f.getType()).thenReturn(type);\n+        when(f.getName()).thenReturn(\"f-\" + type.name());\n+        when(f.getValue()).thenReturn(v);\n+        return f;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1ODI3NQ=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI5ODY2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoyOTo1MlrOG5CwRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozMjoxNVrOG5bgHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NzE0Mg==", "bodyText": "This is checking that the last entry.getValue() is >= 0.9 right? Isnt't better to rewrite it?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462467142", "createdAt": "2020-07-29T17:29:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LimeStabilityTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testStabilityWithNumericData() {\n+        PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n+        List<Feature> featureList = new LinkedList<>();\n+        for (int i = 0; i < 5; i++) {\n+            featureList.add(TestUtils.getMockedNumericFeature(i));\n+        }\n+        assertStable(sumSkipModel, featureList);\n+    }\n+\n+    private void assertStable(PredictionProvider sumSkipModel, List<Feature> featureList) {\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = sumSkipModel.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, predictionOutputs.get(0));\n+        List<Saliency> saliencies = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        for (int i = 0; i < 100; i++) {\n+            Saliency saliency = limeExplainer.explain(prediction, sumSkipModel);\n+            saliencies.add(saliency);\n+        }\n+        List<String> names = new LinkedList<>();\n+        saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+        Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+        boolean topFeature = false;\n+        for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n+            topFeature = entry.getValue() >= 0.9;\n+        }\n+        assertTrue(topFeature);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MjYwNQ==", "bodyText": "the proper check is that at least one entry matches the condition, hence yes, I'll fix it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462872605", "createdAt": "2020-07-30T09:32:15Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LimeStabilityTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testStabilityWithNumericData() {\n+        PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n+        List<Feature> featureList = new LinkedList<>();\n+        for (int i = 0; i < 5; i++) {\n+            featureList.add(TestUtils.getMockedNumericFeature(i));\n+        }\n+        assertStable(sumSkipModel, featureList);\n+    }\n+\n+    private void assertStable(PredictionProvider sumSkipModel, List<Feature> featureList) {\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = sumSkipModel.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, predictionOutputs.get(0));\n+        List<Saliency> saliencies = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        for (int i = 0; i < 100; i++) {\n+            Saliency saliency = limeExplainer.explain(prediction, sumSkipModel);\n+            saliencies.add(saliency);\n+        }\n+        List<String> names = new LinkedList<>();\n+        saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+        Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+        boolean topFeature = false;\n+        for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n+            topFeature = entry.getValue() >= 0.9;\n+        }\n+        assertTrue(topFeature);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2NzE0Mg=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzMzMTM1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzozODozNVrOG5DEZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzowOTozM1rOG5iQJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjI5NA==", "bodyText": "This is always true unless ExplainabilityMetrics.classificationFidelity throws an exception. If this is the intended check, could you use assertDoesNotThrow?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462472294", "createdAt": "2020-07-29T17:38:35Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NDIyNw==", "bodyText": "the above assertion is meant to check that the value returned by ExplainabilityMetrics.classificationFidelity is in the expected range of values, which I think is correct. If it throws an Exception that would be an unexpected behaviour and the test should go in error instead of failing.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462874227", "createdAt": "2020-07-30T09:35:00Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjI5NA=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyNTk3Nw==", "bodyText": "Hi @tteofili , I'm more referring to the fact that ExplainabilityMetrics.classificationFidelity returns always a number between 0 and 1 by contract, regardless the inputs (could you double check?). Meaning that we can change the implementation of ExplainabilityMetrics.classificationFidelity and this test completely and this test would anyway pass. That's why I was wondering if the real check is assertDoesNotThrow, since this is the only way for this test to fail.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462925977", "createdAt": "2020-07-30T11:17:16Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjI5NA=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk4MzIwNg==", "bodyText": "ok, done ;)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462983206", "createdAt": "2020-07-30T13:09:33Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjI5NA=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzMzMTYxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzozODo0MFrOG5DElQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozNTo0NlrOG5boWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjM0MQ==", "bodyText": "This is always true unless ExplainabilityMetrics.classificationFidelity throws an exception. If this is the intended check, could you use assertDoesNotThrow?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462472341", "createdAt": "2020-07-29T17:38:40Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testFidelityWithEvenSumModel() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getEvenSumModel(1);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f-1\", 1));\n+        features.add(FeatureFactory.newNumericalFeature(\"f-2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f-3\", 3));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NDcxMg==", "bodyText": "same as above.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462874712", "createdAt": "2020-07-30T09:35:46Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+class ExplainabilityMetricsTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.setSeed(4);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanation() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilityNoExplanationWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(0, 0, 1);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertEquals(0, v);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0);\n+        assertFalse(Double.isNaN(v));\n+        assertFalse(Double.isInfinite(v));\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testExplainabilitySameIOChunksWithInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(10, 10, 0.5);\n+        assertEquals(0.2331, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksNoInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0);\n+        assertEquals(0.481, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testExplainabilityDifferentIOChunksInteraction() {\n+        double v = ExplainabilityMetrics.quantifyExplainability(3, 9, 0.5);\n+        assertEquals(0.3145, v, 1e-5);\n+    }\n+\n+    @Test\n+    void testFidelityWithTextClassifier() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getDummyTextClassifier();\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f-0\", \"brown fox\"));\n+        features.add(FeatureFactory.newTextFeature(\"f-1\", \"money\"));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);\n+    }\n+\n+    @Test\n+    void testFidelityWithEvenSumModel() {\n+        List<Pair<Saliency, Prediction>> pairs = new LinkedList<>();\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionProvider model = TestUtils.getEvenSumModel(1);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f-1\", 1));\n+        features.add(FeatureFactory.newNumericalFeature(\"f-2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f-3\", 3));\n+        PredictionInput input = new PredictionInput(features);\n+        Prediction prediction = new Prediction(input, model.predict(List.of(input)).get(0));\n+        pairs.add(Pair.of(limeExplainer.explain(prediction, model), prediction));\n+        double v = ExplainabilityMetrics.classificationFidelity(pairs);\n+        assertThat(v).isBetween(0d, 1d);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MjM0MQ=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzQ5MjA2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODoyMToxOFrOG5EoNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOTozNzoyN1rOG5br2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5Nzg0NQ==", "bodyText": "assertArrayEquals(new double[size], linearModel.getWeights()); or check that all the elements are zero?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462497845", "createdAt": "2020-07-29T18:21:18Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class LinearModelTest {\n+\n+    @Test\n+    void testEmptyFitClassificationDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3NTYwOQ==", "bodyText": "the former, correct, thanks.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r462875609", "createdAt": "2020-07-30T09:37:27Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class LinearModelTest {\n+\n+    @Test\n+    void testEmptyFitClassificationDoesNothing() {\n+        int size = 10;\n+        LinearModel linearModel = new LinearModel(size, true);\n+        Collection<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        linearModel.fit(trainingSet);\n+        assertEquals(Arrays.toString(new double[size]), Arrays.toString(linearModel.getWeights()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5Nzg0NQ=="}, "originalCommit": {"oid": "22658493f480efbdc99adb5b5cc055a1fe3f160f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYyNjkwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNjoxOVrOGx3VPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjozMzoxM1rOGyo0ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzOTk2NA==", "bodyText": "Can you review this pom? the versions of the artifacts should be put in kogito-runtimes/bom as well as properties that are not already present in the parent poms", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454939964", "createdAt": "2020-07-15T10:06:19Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.json</groupId>\n+      <artifactId>json</artifactId>\n+      <version>20190722</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.10</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-api</artifactId>\n+    </dependency>\n+\n+  </dependencies>\n+\n+  <repositories>\n+    <!-- Bootstrap repository to locate the parent pom when the parent pom\n+      has not been build locally. -->\n+    <repository>\n+      <id>jboss-public-repository-group</id>\n+      <name>JBoss Public Repository Group</name>\n+      <url>https://repository.jboss.org/nexus/content/groups/public/</url>\n+      <layout>default</layout>\n+      <releases>\n+        <enabled>true</enabled>\n+        <updatePolicy>never</updatePolicy>\n+      </releases>\n+      <snapshots>\n+        <enabled>true</enabled>\n+        <updatePolicy>daily</updatePolicy>\n+      </snapshots>\n+    </repository>\n+  </repositories>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1MDg0Mg==", "bodyText": "I've removed all the properties, dependencyManagement, repository and build POM portions that are no longer required as inherited by kogito-apps parent.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455750842", "createdAt": "2020-07-16T12:33:13Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.json</groupId>\n+      <artifactId>json</artifactId>\n+      <version>20190722</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.10</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-api</artifactId>\n+    </dependency>\n+\n+  </dependencies>\n+\n+  <repositories>\n+    <!-- Bootstrap repository to locate the parent pom when the parent pom\n+      has not been build locally. -->\n+    <repository>\n+      <id>jboss-public-repository-group</id>\n+      <name>JBoss Public Repository Group</name>\n+      <url>https://repository.jboss.org/nexus/content/groups/public/</url>\n+      <layout>default</layout>\n+      <releases>\n+        <enabled>true</enabled>\n+        <updatePolicy>never</updatePolicy>\n+      </releases>\n+      <snapshots>\n+        <enabled>true</enabled>\n+        <updatePolicy>daily</updatePolicy>\n+      </snapshots>\n+    </repository>\n+  </repositories>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <version>${compiler-plugin.version}</version>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>${surefire-plugin.version}</version>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+    </plugins>\n+  </build>\n+</project>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzOTk2NA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYyNzM4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNjozMFrOGx3VkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNjozMFrOGx3VkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDA0OQ==", "bodyText": "Can you review this pom? the versions of the artifacts should be put in kogito-runtimes/bom as well as properties that are not already present in the parent poms", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454940049", "createdAt": "2020-07-15T10:06:30Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,75 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYyNzkxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNjozOVrOGx3V5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNjozOVrOGx3V5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDEzNA==", "bodyText": "Can you review this pom? the versions of the artifacts should be put in kogito-runtimes/bom as well as properties that are not already present in the parent poms", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454940134", "createdAt": "2020-07-15T10:06:39Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYzMDExOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNzoxOVrOGx3XRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNzoxOVrOGx3XRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDQ4Nw==", "bodyText": "wrong parent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454940487", "createdAt": "2020-07-15T10:07:19Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,77 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYzMTA0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNzozNlrOGx3X4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNzozNlrOGx3X4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDY0Mw==", "bodyText": "wrong parent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454940643", "createdAt": "2020-07-15T10:07:36Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,75 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYzMTgyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowNzo0OVrOGx3YaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODoyNzoxNFrOG1Elyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDc3Ng==", "bodyText": "wrong parent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454940776", "createdAt": "2020-07-15T10:07:49Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjkyMg==", "bodyText": "@tteofili have a look at this please", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458302922", "createdAt": "2020-07-21T18:27:14Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MDc3Ng=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY0NTIzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMTo0NlrOGx3glg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMTo0NlrOGx3glg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Mjg3MA==", "bodyText": "wrong parent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454942870", "createdAt": "2020-07-15T10:11:46Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,148 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY0NTM2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMTo0OVrOGx3gsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMTo0OVrOGx3gsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Mjg5Nw==", "bodyText": "Can you review this pom? the versions of the artifacts should be put in kogito-runtimes/bom as well as properties that are not already present in the parent poms", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454942897", "createdAt": "2020-07-15T10:11:49Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,148 @@\n+<?xml version=\"1.0\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY0NjAzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMjowM1rOGx3hJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMjowM1rOGx3hJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MzAxMg==", "bodyText": "wrong parent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454943012", "createdAt": "2020-07-15T10:12:03Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/pom.xml", "diffHunk": "@@ -0,0 +1,21 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <parent>\n+    <artifactId>kogito-apps</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY1MTY1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMzo1M1rOGx3k7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo1MTowN1rOGypdOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Mzk4MA==", "bodyText": "private static final", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454943980", "createdAt": "2020-07-15T10:13:53Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MTIxMA==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455761210", "createdAt": "2020-07-16T12:51:07Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Mzk4MA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY2NzY3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxODo0MFrOGx3unA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0MDozMlrOGypE3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NjQ2MA==", "bodyText": "Do we need this?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454946460", "createdAt": "2020-07-15T10:18:40Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helper class to connect to a remote endpoint.\n+ */\n+public class HttpHelper {\n+\n+    private static final CloseableHttpClient httpclient = createHttpClient();\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpHelper.class);\n+\n+    private ObjectMapper mapper = new ObjectMapper();\n+\n+    private String baseHost;\n+\n+    public HttpHelper(String baseHost) {\n+        this.baseHost = baseHost;\n+    }\n+\n+    private static CloseableHttpClient createHttpClient() {\n+        int timeout = 60;\n+        RequestConfig config = RequestConfig.custom()\n+                .setConnectTimeout(timeout * 1000)\n+                .setConnectionRequestTimeout(timeout * 1000)\n+                .setSocketTimeout(timeout * 1000).build();\n+        return HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n+    }\n+\n+    public String doGet(String path) throws IOException {\n+        HttpGet request = new HttpGet(baseHost + path);\n+        HttpResponse response = null;\n+        response = httpclient.execute(request);\n+        HttpEntity entity = response.getEntity();\n+        if (entity != null) {\n+            String result = EntityUtils.toString(entity);\n+            LOGGER.debug(\"Get request returned \" + result);\n+            return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    public String doPost(String path, String params) throws IOException {\n+\n+        HttpPost post = new HttpPost(baseHost + path);\n+        LOGGER.debug(\"Going to post to: \" + path + \"\\n with: \" + params);\n+        post.setEntity(new StringEntity(params, ContentType.APPLICATION_JSON));\n+        CloseableHttpResponse response = httpclient.execute(post);\n+        String result = EntityUtils.toString(response.getEntity());\n+        LOGGER.debug(\"I've got \" + result);\n+        return result;\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NDk3Mw==", "bodyText": "I was not 100% sure about whether to bring this and RemoteDMNModel along in kogito-apps as they will most probably be replaced by a proper wiring to a /predict endpoint in kogito.\nI realize it is actually best to have explainability-core to be completely model agnostic (see also other comments wrt other DMN related classes).", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455754973", "createdAt": "2020-07-16T12:40:32Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helper class to connect to a remote endpoint.\n+ */\n+public class HttpHelper {\n+\n+    private static final CloseableHttpClient httpclient = createHttpClient();\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpHelper.class);\n+\n+    private ObjectMapper mapper = new ObjectMapper();\n+\n+    private String baseHost;\n+\n+    public HttpHelper(String baseHost) {\n+        this.baseHost = baseHost;\n+    }\n+\n+    private static CloseableHttpClient createHttpClient() {\n+        int timeout = 60;\n+        RequestConfig config = RequestConfig.custom()\n+                .setConnectTimeout(timeout * 1000)\n+                .setConnectionRequestTimeout(timeout * 1000)\n+                .setSocketTimeout(timeout * 1000).build();\n+        return HttpClientBuilder.create().setDefaultRequestConfig(config).build();\n+    }\n+\n+    public String doGet(String path) throws IOException {\n+        HttpGet request = new HttpGet(baseHost + path);\n+        HttpResponse response = null;\n+        response = httpclient.execute(request);\n+        HttpEntity entity = response.getEntity();\n+        if (entity != null) {\n+            String result = EntityUtils.toString(entity);\n+            LOGGER.debug(\"Get request returned \" + result);\n+            return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    public String doPost(String path, String params) throws IOException {\n+\n+        HttpPost post = new HttpPost(baseHost + path);\n+        LOGGER.debug(\"Going to post to: \" + path + \"\\n with: \" + params);\n+        post.setEntity(new StringEntity(params, ContentType.APPLICATION_JSON));\n+        CloseableHttpResponse response = httpclient.execute(post);\n+        String result = EntityUtils.toString(response.getEntity());\n+        LOGGER.debug(\"I've got \" + result);\n+        return result;\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NjQ2MA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY3NjEyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoyMTowOFrOGx3ztA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0MDo1MFrOGypFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Nzc2NA==", "bodyText": "I think this comes directly from the PoC and might not be what we will do for the stable implementation?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454947764", "createdAt": "2020-07-15T10:21:08Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.HttpHelper;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link BlackBoxModel} implementation of a remote (HTTP/HTTPS) DMN service.\n+ */\n+public class RemoteDMNModel implements BlackBoxModel {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    private final HttpHelper httpHelper;\n+    private final List<TypedData> inputStructure;\n+    private final List<TypedData> outputStructure;\n+    private final String modelName;\n+\n+    public RemoteDMNModel(HttpHelper httpHelper, List<TypedData> inputStructure, List<TypedData> outputStructure, String modelName) {\n+        this.httpHelper = httpHelper;\n+        this.inputStructure = inputStructure;\n+        this.outputStructure = outputStructure;\n+        this.modelName = modelName;\n+    }\n+\n+    private JSONObject toKogitoRequestJson(List<TypedData> inputStructure, List<Feature> features) {\n+        JSONObject json = new JSONObject();\n+        for (TypedData input : inputStructure) {\n+            if (input.value != null) { // is a built in type\n+                Value value = features.stream().filter(x -> x.getName().equals(input.inputName)).findFirst().get().getValue();\n+                json.put(input.inputName, input.typeRef.equals(\"string\") ? value.asString() : value.asNumber());\n+            } else {\n+                json.put(input.inputName, toKogitoRequestJson(input.components, features));\n+            }\n+        }\n+        return json;\n+    }\n+\n+    @Override\n+    public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+        List<PredictionOutput> result = new ArrayList<>();\n+        for (PredictionInput input : inputs) {\n+            String request = toKogitoRequestJson(inputStructure, input.getFeatures()).toString();\n+            String response = null;\n+            try {\n+                response = httpHelper.doPost(\"/\" + modelName + \"?tracing=false\", request);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+            logger.debug(request);\n+            Map<String, Object> outcome = null;\n+            try {\n+                outcome = new ObjectMapper().readValue(response, new HashMap<String, Object>().getClass());\n+            } catch (JsonProcessingException e) {\n+                e.printStackTrace();\n+            }\n+            result.add(new PredictionOutput(flattenDmnResult(outcome, outputStructure.stream().map(x -> x.inputName).collect(Collectors.toList()))));\n+        }\n+        return result;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NTExNg==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455755116", "createdAt": "2020-07-16T12:40:50Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.HttpHelper;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link BlackBoxModel} implementation of a remote (HTTP/HTTPS) DMN service.\n+ */\n+public class RemoteDMNModel implements BlackBoxModel {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    private final HttpHelper httpHelper;\n+    private final List<TypedData> inputStructure;\n+    private final List<TypedData> outputStructure;\n+    private final String modelName;\n+\n+    public RemoteDMNModel(HttpHelper httpHelper, List<TypedData> inputStructure, List<TypedData> outputStructure, String modelName) {\n+        this.httpHelper = httpHelper;\n+        this.inputStructure = inputStructure;\n+        this.outputStructure = outputStructure;\n+        this.modelName = modelName;\n+    }\n+\n+    private JSONObject toKogitoRequestJson(List<TypedData> inputStructure, List<Feature> features) {\n+        JSONObject json = new JSONObject();\n+        for (TypedData input : inputStructure) {\n+            if (input.value != null) { // is a built in type\n+                Value value = features.stream().filter(x -> x.getName().equals(input.inputName)).findFirst().get().getValue();\n+                json.put(input.inputName, input.typeRef.equals(\"string\") ? value.asString() : value.asNumber());\n+            } else {\n+                json.put(input.inputName, toKogitoRequestJson(input.components, features));\n+            }\n+        }\n+        return json;\n+    }\n+\n+    @Override\n+    public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+        List<PredictionOutput> result = new ArrayList<>();\n+        for (PredictionInput input : inputs) {\n+            String request = toKogitoRequestJson(inputStructure, input.getFeatures()).toString();\n+            String response = null;\n+            try {\n+                response = httpHelper.doPost(\"/\" + modelName + \"?tracing=false\", request);\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+            logger.debug(request);\n+            Map<String, Object> outcome = null;\n+            try {\n+                outcome = new ObjectMapper().readValue(response, new HashMap<String, Object>().getClass());\n+            } catch (JsonProcessingException e) {\n+                e.printStackTrace();\n+            }\n+            result.add(new PredictionOutput(flattenDmnResult(outcome, outputStructure.stream().map(x -> x.inputName).collect(Collectors.toList()))));\n+        }\n+        return result;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0Nzc2NA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY4NDgzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoyMzo0MlrOGx35FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0MTowMlrOGypF4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0OTE0MA==", "bodyText": "I personally would remove all the communication between services from this library and delegate it to the service, wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454949140", "createdAt": "2020-07-15T10:23:42Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.HttpHelper;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link BlackBoxModel} implementation of a remote (HTTP/HTTPS) DMN service.\n+ */\n+public class RemoteDMNModel implements BlackBoxModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NTIzMw==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455755233", "createdAt": "2020-07-16T12:41:02Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/RemoteDMNModel.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.HttpHelper;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link BlackBoxModel} implementation of a remote (HTTP/HTTPS) DMN service.\n+ */\n+public class RemoteDMNModel implements BlackBoxModel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0OTE0MA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzcwODk4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMDo0N1rOGx4H0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMDo0N1rOGx4H0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1MjkxNQ==", "bodyText": "I think you should be able to inherit all these information from parent pom and if not we should move these properties there", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454952915", "createdAt": "2020-07-15T10:30:47Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzcwOTc2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMTowMVrOGx4ITQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMTowMVrOGx4ITQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1MzAzNw==", "bodyText": "Same for this", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454953037", "createdAt": "2020-07-15T10:31:01Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzcxNDM4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMjoyMlrOGx4LDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMjoyMlrOGx4LDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1Mzc0Mw==", "bodyText": "Al dependency versions should be managed with DependencyManagement node in root pom (btw I think they are already defined so just try to remove the version as first", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454953743", "createdAt": "2020-07-15T10:32:22Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.json</groupId>\n+      <artifactId>json</artifactId>\n+      <version>20190722</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.10</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzcxODYxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozMzoyNlrOGx4Ngg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo1MDo1NlrOGypcxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1NDM3MA==", "bodyText": "I think debug should be better", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454954370", "createdAt": "2020-07-15T10:33:26Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();\n+        try {\n+            DataDistribution dataDistribution = model.getDataDistribution();\n+            int noOfFeatures = model.getInputShape().getFeatures().size();\n+\n+            List<FeatureDistribution> featureDistributions = dataDistribution.getFeatureDistributions();\n+            for (int featureIndex = 0; featureIndex < noOfFeatures; featureIndex++) {\n+                for (int outputIndex = 0; outputIndex < model.getOutputShape().getOutputs().size(); outputIndex++) {\n+                    double[] featureXSvalues = DataUtils.generateSamples(featureDistributions.get(featureIndex).getMin(),\n+                                                                         featureDistributions.get(featureIndex).getMax(), TABLE_SIZE);\n+\n+                    double[][] trainingData = new double[noOfFeatures][TABLE_SIZE];\n+                    for (int i = 0; i < noOfFeatures; i++) {\n+                        double[] featureData = DataUtils.generateData(featureDistributions.get(i).getMean(),\n+                                                                      featureDistributions.get(i).getStdDev(), TABLE_SIZE);\n+                        trainingData[i] = featureData;\n+                    }\n+\n+                    double[] marginalImpacts = new double[featureXSvalues.length];\n+                    for (int i = 0; i < featureXSvalues.length; i++) {\n+                        List<PredictionInput> predictionInputs = new LinkedList<>();\n+                        double xs = featureXSvalues[i];\n+                        double[] inputs = new double[noOfFeatures];\n+                        inputs[featureIndex] = xs;\n+                        for (int j = 0; j < TABLE_SIZE; j++) {\n+                            for (int f = 0; f < noOfFeatures; f++) {\n+                                if (f != featureIndex) {\n+                                    inputs[f] = trainingData[f][j];\n+                                }\n+                            }\n+                            PredictionInput input = new PredictionInput(DataUtils.doublesToFeatures(inputs));\n+                            predictionInputs.add(input);\n+                        }\n+\n+                        // prediction requests are batched per value of feature 'Xs' under analysis\n+                        for (PredictionOutput predictionOutput : model.predict(predictionInputs)) {\n+                            Output output = predictionOutput.getOutputs().get(outputIndex);\n+                            marginalImpacts[i] += output.getScore() / (double) TABLE_SIZE;\n+                        }\n+                    }\n+                    DataSeries dataSeries = new DataSeries(model.getInputShape().getFeatures().get(featureIndex),\n+                                                           featureXSvalues, marginalImpacts);\n+                    pdps.add(dataSeries);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        long end = System.currentTimeMillis();\n+        logger.info(\"explanation time: {}ms\", (end - start));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MTA5NQ==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455761095", "createdAt": "2020-07-16T12:50:56Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();\n+        try {\n+            DataDistribution dataDistribution = model.getDataDistribution();\n+            int noOfFeatures = model.getInputShape().getFeatures().size();\n+\n+            List<FeatureDistribution> featureDistributions = dataDistribution.getFeatureDistributions();\n+            for (int featureIndex = 0; featureIndex < noOfFeatures; featureIndex++) {\n+                for (int outputIndex = 0; outputIndex < model.getOutputShape().getOutputs().size(); outputIndex++) {\n+                    double[] featureXSvalues = DataUtils.generateSamples(featureDistributions.get(featureIndex).getMin(),\n+                                                                         featureDistributions.get(featureIndex).getMax(), TABLE_SIZE);\n+\n+                    double[][] trainingData = new double[noOfFeatures][TABLE_SIZE];\n+                    for (int i = 0; i < noOfFeatures; i++) {\n+                        double[] featureData = DataUtils.generateData(featureDistributions.get(i).getMean(),\n+                                                                      featureDistributions.get(i).getStdDev(), TABLE_SIZE);\n+                        trainingData[i] = featureData;\n+                    }\n+\n+                    double[] marginalImpacts = new double[featureXSvalues.length];\n+                    for (int i = 0; i < featureXSvalues.length; i++) {\n+                        List<PredictionInput> predictionInputs = new LinkedList<>();\n+                        double xs = featureXSvalues[i];\n+                        double[] inputs = new double[noOfFeatures];\n+                        inputs[featureIndex] = xs;\n+                        for (int j = 0; j < TABLE_SIZE; j++) {\n+                            for (int f = 0; f < noOfFeatures; f++) {\n+                                if (f != featureIndex) {\n+                                    inputs[f] = trainingData[f][j];\n+                                }\n+                            }\n+                            PredictionInput input = new PredictionInput(DataUtils.doublesToFeatures(inputs));\n+                            predictionInputs.add(input);\n+                        }\n+\n+                        // prediction requests are batched per value of feature 'Xs' under analysis\n+                        for (PredictionOutput predictionOutput : model.predict(predictionInputs)) {\n+                            Output output = predictionOutput.getOutputs().get(outputIndex);\n+                            marginalImpacts[i] += output.getScore() / (double) TABLE_SIZE;\n+                        }\n+                    }\n+                    DataSeries dataSeries = new DataSeries(model.getInputShape().getFeatures().get(featureIndex),\n+                                                           featureXSvalues, marginalImpacts);\n+                    pdps.add(dataSeries);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        long end = System.currentTimeMillis();\n+        logger.info(\"explanation time: {}ms\", (end - start));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1NDM3MA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzcyMzQ3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDozNDo1OFrOGx4QjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0MTozM1rOGypHDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1NTE0OQ==", "bodyText": "Why don't add NUMBER to switch block and remove this addition if? Is it needed?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454955149", "createdAt": "2020-07-15T10:34:58Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ *\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            if (!Type.NUMBER.equals(featureTypes.get(t))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NTUzMw==", "bodyText": "good point :) thanks", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455755533", "createdAt": "2020-07-16T12:41:33Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ *\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            if (!Type.NUMBER.equals(featureTypes.get(t))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1NTE0OQ=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODAxMDExOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowNDozNFrOGx6_Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowNDozNFrOGx6_Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5OTg1OQ==", "bodyText": "What does this imply?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454999859", "createdAt": "2020-07-15T12:04:34Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) optimised for tabular data and decision models.\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, BlackBoxModel model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+        PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+        List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+        List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+        int noOfInputFeatures = inputFeatures.size();\n+        int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+        double[] weights = new double[noOfOutputFeatures];\n+\n+        for (int o = 0; o < actualOutputs.size(); o++) {\n+            boolean separableDataset = false;\n+\n+            List<PredictionInput> perturbedInputs = new LinkedList<>();\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+            boolean classification = false;\n+            int tries = 3;\n+            Map<Double, Long> rawClassesBalance = new HashMap<>();\n+            Output currentOutput = actualOutputs.get(o);\n+            while (!separableDataset && tries > 0) {\n+                List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                Object fv = currentOutput != null && currentOutput.getValue() != null ? currentOutput.getValue().getUnderlyingObject() : null;\n+\n+                int finalO = o;\n+                rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                        .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                        && fv == null) || output.getValue().getUnderlyingObject().equals(fv)) ? 1d : 0d))\n+                        .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                if (rawClassesBalance.size() > 1) {\n+                    Long max = rawClassesBalance.values().stream().max(Long::compareTo).get();\n+                    if ((double) max / (double) perturbed.size() < 0.9) {\n+                        separableDataset = true;\n+                        classification = rawClassesBalance.size() == 2;\n+                    } else {\n+                        tries--;\n+                    }\n+                } else {\n+                    tries--;\n+                }\n+                if (tries == 0 || separableDataset) {\n+                    perturbedInputs.addAll(perturbed);\n+                    predictionOutputs.addAll(perturbedOutputs);\n+                }\n+            }\n+            if (!separableDataset) {\n+                logger.warn(\"the perturbed inputs / outputs dataset is not (easily) separable: {}\", rawClassesBalance);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODAxMDgxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowNDo0NlrOGx6_mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowNDo0NlrOGx6_mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5OTk2MQ==", "bodyText": "debug?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r454999961", "createdAt": "2020-07-15T12:04:46Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) optimised for tabular data and decision models.\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, BlackBoxModel model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        PredictionInput originalInput = prediction.getInput();\n+        List<Feature> inputFeatures = originalInput.getFeatures();\n+        PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+        List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+        List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+        int noOfInputFeatures = inputFeatures.size();\n+        int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+        double[] weights = new double[noOfOutputFeatures];\n+\n+        for (int o = 0; o < actualOutputs.size(); o++) {\n+            boolean separableDataset = false;\n+\n+            List<PredictionInput> perturbedInputs = new LinkedList<>();\n+            List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+            boolean classification = false;\n+            int tries = 3;\n+            Map<Double, Long> rawClassesBalance = new HashMap<>();\n+            Output currentOutput = actualOutputs.get(o);\n+            while (!separableDataset && tries > 0) {\n+                List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                Object fv = currentOutput != null && currentOutput.getValue() != null ? currentOutput.getValue().getUnderlyingObject() : null;\n+\n+                int finalO = o;\n+                rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                        .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                        && fv == null) || output.getValue().getUnderlyingObject().equals(fv)) ? 1d : 0d))\n+                        .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                if (rawClassesBalance.size() > 1) {\n+                    Long max = rawClassesBalance.values().stream().max(Long::compareTo).get();\n+                    if ((double) max / (double) perturbed.size() < 0.9) {\n+                        separableDataset = true;\n+                        classification = rawClassesBalance.size() == 2;\n+                    } else {\n+                        tries--;\n+                    }\n+                } else {\n+                    tries--;\n+                }\n+                if (tries == 0 || separableDataset) {\n+                    perturbedInputs.addAll(perturbed);\n+                    predictionOutputs.addAll(perturbedOutputs);\n+                }\n+            }\n+            if (!separableDataset) {\n+                logger.warn(\"the perturbed inputs / outputs dataset is not (easily) separable: {}\", rawClassesBalance);\n+            }\n+            List<Output> predictedOutputs = new LinkedList<>();\n+            for (int i = 0; i < perturbedInputs.size(); i++) {\n+                Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                predictedOutputs.add(output);\n+            }\n+\n+            Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+            DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+            Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+            double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+            LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+            linearModel.fit(trainingSet, sampleWeights);\n+            for (int i = 0; i < weights.length; i++) {\n+                weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();\n+            }\n+            logger.debug(\"weights updated for output {}\", currentOutput);\n+        }\n+        for (int i = 0; i < weights.length; i++) {\n+            FeatureImportance featureImportance = new FeatureImportance(linearizedTargetInputFeatures.get(i), weights[i]);\n+            saliencies.add(featureImportance);\n+        }\n+        long end = System.currentTimeMillis();\n+        logger.info(\"explanation time: {}ms\", (end - start));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEwNDQ0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozMDo1OVrOGx74Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0MjowNVrOGypIKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNDQxOA==", "bodyText": "\ud83e\udd14 Are you sure about this dependency? I do not expect this library to depends on kogito-api. Maybe it is for test?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455014418", "createdAt": "2020-07-15T12:30:59Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.json</groupId>\n+      <artifactId>json</artifactId>\n+      <version>20190722</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.10</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NTgxNg==", "bodyText": "we actually need it only in integration tests, hence moving it into explainability-integrationtests-dmn.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455755816", "createdAt": "2020-07-16T12:42:05Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,124 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <properties>\n+    <compiler-plugin.version>3.8.1</compiler-plugin.version>\n+    <maven.compiler.parameters>true</maven.compiler.parameters>\n+    <maven.compiler.source>11</maven.compiler.source>\n+    <maven.compiler.target>11</maven.compiler.target>\n+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n+    <quarkus-plugin.version>1.4.2.Final</quarkus-plugin.version>\n+    <quarkus.platform.artifact-id>quarkus-universe-bom</quarkus.platform.artifact-id>\n+    <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>\n+    <quarkus.platform.version>1.4.2.Final</quarkus.platform.version>\n+    <surefire-plugin.version>2.22.1</surefire-plugin.version>\n+  </properties>\n+  <dependencyManagement>\n+    <dependencies>\n+      <dependency>\n+        <groupId>${quarkus.platform.group-id}</groupId>\n+        <artifactId>${quarkus.platform.artifact-id}</artifactId>\n+        <version>${quarkus.platform.version}</version>\n+        <type>pom</type>\n+        <scope>import</scope>\n+      </dependency>\n+    </dependencies>\n+  </dependencyManagement>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.json</groupId>\n+      <artifactId>json</artifactId>\n+      <version>20190722</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.httpcomponents</groupId>\n+      <artifactId>httpclient</artifactId>\n+      <version>4.5.10</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-api</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNDQxOA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEwODkzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozMjoxOVrOGx764g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0Mjo0OVrOGypJxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTEzOA==", "bodyText": "Why this? This means that empty string and null are equivalent", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455015138", "createdAt": "2020-07-15T12:32:19Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        if (underlyingObject == null) {\n+            return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NjIzMQ==", "bodyText": "this is wrong, thanks for catching it :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455756231", "createdAt": "2020-07-16T12:42:49Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        if (underlyingObject == null) {\n+            return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTEzOA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODExMzg3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DMNUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozMzozOFrOGx790Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0Mzo1MFrOGypL5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTg4OQ==", "bodyText": "Can you review this class? It is named DMN but it is not using any DMN class at all. Is it maybe a generic data types utils class?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455015889", "createdAt": "2020-07-15T12:33:38Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DMNUtils.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+/**\n+ * Utility class to handle DMN types for input and output.\n+ */\n+public class DMNUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1Njc3NA==", "bodyText": "yes, this is used to convert TypedData into and from PredictionInputs and PredictionOutputs.\nAnyway this stuff belongs to the explanation-service hence dropping it from the current PR.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455756774", "createdAt": "2020-07-16T12:43:50Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DMNUtils.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+\n+/**\n+ * Utility class to handle DMN types for input and output.\n+ */\n+public class DMNUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTg4OQ=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEyMzUwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DecisionModelWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozNjoxMVrOGx8Dog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0NDoyM1rOGypNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNzM3OA==", "bodyText": "What is this class? I do not expect any DMN specific class in this library expect as test", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455017378", "createdAt": "2020-07-15T12:36:11Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DecisionModelWrapper.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNDecisionResult;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.model.api.Decision;\n+import org.kie.kogito.decision.DecisionModel;\n+\n+/**\n+ * {@link BlackBoxModel} implementation based on a Kogito {@link DecisionModel}.\n+ */\n+public class DecisionModelWrapper implements BlackBoxModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NzA1Ng==", "bodyText": "see above, moving it to explainability-integrationtests-dmn.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455757056", "createdAt": "2020-07-16T12:44:23Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/dmn/DecisionModelWrapper.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model.dmn;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.dmn.api.core.DMNContext;\n+import org.kie.dmn.api.core.DMNDecisionResult;\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.DMNType;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.model.api.Decision;\n+import org.kie.kogito.decision.DecisionModel;\n+\n+/**\n+ * {@link BlackBoxModel} implementation based on a Kogito {@link DecisionModel}.\n+ */\n+public class DecisionModelWrapper implements BlackBoxModel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNzM3OA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEzMjEzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozODo0MFrOGx8JCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0NDozM1rOGypNaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxODc2MA==", "bodyText": "This should not be in the core (and in general we can leverage on quarkus features for that)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455018760", "createdAt": "2020-07-15T12:38:40Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helper class to connect to a remote endpoint.\n+ */\n+public class HttpHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1NzE2MQ==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455757161", "createdAt": "2020-07-16T12:44:33Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/HttpHelper.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Helper class to connect to a remote endpoint.\n+ */\n+public class HttpHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxODc2MA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgwOTE5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTowODo0MFrOGyCvZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0OToxNlrOGypYUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyNjg4NQ==", "bodyText": "Is this supposed to be not deterministic?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455126885", "createdAt": "2020-07-15T15:08:40Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.dmn.DecisionModelWrapper;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class LoanEligibilityDmnLimeExplainerTest {\n+\n+    @RepeatedTest(10)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1OTk1NA==", "bodyText": "Such ITs are currently repeated as they used to be the first gate to stability of LIME explanations.\nCurrently we also have other tests covering the stability parts.\nHowever there's some non determinism in how LIME perturb features and hence the repeated test.\nI am fine to move them to single execution tests.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455759954", "createdAt": "2020-07-16T12:49:16Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.dmn.DecisionModelWrapper;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class LoanEligibilityDmnLimeExplainerTest {\n+\n+    @RepeatedTest(10)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyNjg4NQ=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgyMzcxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToxMjoxMlrOGyC4rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0NzoyNFrOGypUUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyOTI2MQ==", "bodyText": "Is there a specific reason why the integration tests are in separated modules? We might put them in the core and service modules and add the maven plugin to run them if they match a specific regex (like we are already doing for the trusty service and the data index) see here \n  \n    \n      kogito-apps/data-index/data-index-service/pom.xml\n    \n    \n         Line 159\n      in\n      8516df2\n    \n    \n    \n    \n\n        \n          \n           <goal>integration-test</goal>", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455129261", "createdAt": "2020-07-15T15:12:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc1ODkzMA==", "bodyText": "the main reason to have them in separate modules is that dependencies needed to run DMN and PMML dependencies within the same JVM are not compatible, in the sense that they use two different and not compatible versions of drools (at least in the current state of kie-pmml-new vs kogito-dmn).", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455758930", "createdAt": "2020-07-16T12:47:24Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/LoanEligibilityDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyOTI2MQ=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgyNzM5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToxMzowNVrOGyC6-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo0OTo0OFrOGypZxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyOTg0OA==", "bodyText": "pdps?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455129848", "createdAt": "2020-07-15T15:13:05Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MDMyNg==", "bodyText": "partial dependency plots.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455760326", "createdAt": "2020-07-16T12:49:48Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyOTg0OA=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgzMDcyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToxMzo1MlrOGyC9Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo1MDozN1rOGypb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzMDM4Nw==", "bodyText": "log?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455130387", "createdAt": "2020-07-15T15:13:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();\n+        try {\n+            DataDistribution dataDistribution = model.getDataDistribution();\n+            int noOfFeatures = model.getInputShape().getFeatures().size();\n+\n+            List<FeatureDistribution> featureDistributions = dataDistribution.getFeatureDistributions();\n+            for (int featureIndex = 0; featureIndex < noOfFeatures; featureIndex++) {\n+                for (int outputIndex = 0; outputIndex < model.getOutputShape().getOutputs().size(); outputIndex++) {\n+                    double[] featureXSvalues = DataUtils.generateSamples(featureDistributions.get(featureIndex).getMin(),\n+                                                                         featureDistributions.get(featureIndex).getMax(), TABLE_SIZE);\n+\n+                    double[][] trainingData = new double[noOfFeatures][TABLE_SIZE];\n+                    for (int i = 0; i < noOfFeatures; i++) {\n+                        double[] featureData = DataUtils.generateData(featureDistributions.get(i).getMean(),\n+                                                                      featureDistributions.get(i).getStdDev(), TABLE_SIZE);\n+                        trainingData[i] = featureData;\n+                    }\n+\n+                    double[] marginalImpacts = new double[featureXSvalues.length];\n+                    for (int i = 0; i < featureXSvalues.length; i++) {\n+                        List<PredictionInput> predictionInputs = new LinkedList<>();\n+                        double xs = featureXSvalues[i];\n+                        double[] inputs = new double[noOfFeatures];\n+                        inputs[featureIndex] = xs;\n+                        for (int j = 0; j < TABLE_SIZE; j++) {\n+                            for (int f = 0; f < noOfFeatures; f++) {\n+                                if (f != featureIndex) {\n+                                    inputs[f] = trainingData[f][j];\n+                                }\n+                            }\n+                            PredictionInput input = new PredictionInput(DataUtils.doublesToFeatures(inputs));\n+                            predictionInputs.add(input);\n+                        }\n+\n+                        // prediction requests are batched per value of feature 'Xs' under analysis\n+                        for (PredictionOutput predictionOutput : model.predict(predictionInputs)) {\n+                            Output output = predictionOutput.getOutputs().get(outputIndex);\n+                            marginalImpacts[i] += output.getScore() / (double) TABLE_SIZE;\n+                        }\n+                    }\n+                    DataSeries dataSeries = new DataSeries(model.getInputShape().getFeatures().get(featureIndex),\n+                                                           featureXSvalues, marginalImpacts);\n+                    pdps.add(dataSeries);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MDg5NQ==", "bodyText": "imho, as per the local case, we need to throw a GlobalExplainabilityException.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455760895", "createdAt": "2020-07-16T12:50:37Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());\n+\n+    @Override\n+    public Collection<DataSeries> explain(BlackBoxModel model) {\n+        long start = System.currentTimeMillis();\n+\n+        Collection<DataSeries> pdps = new LinkedList<>();\n+        try {\n+            DataDistribution dataDistribution = model.getDataDistribution();\n+            int noOfFeatures = model.getInputShape().getFeatures().size();\n+\n+            List<FeatureDistribution> featureDistributions = dataDistribution.getFeatureDistributions();\n+            for (int featureIndex = 0; featureIndex < noOfFeatures; featureIndex++) {\n+                for (int outputIndex = 0; outputIndex < model.getOutputShape().getOutputs().size(); outputIndex++) {\n+                    double[] featureXSvalues = DataUtils.generateSamples(featureDistributions.get(featureIndex).getMin(),\n+                                                                         featureDistributions.get(featureIndex).getMax(), TABLE_SIZE);\n+\n+                    double[][] trainingData = new double[noOfFeatures][TABLE_SIZE];\n+                    for (int i = 0; i < noOfFeatures; i++) {\n+                        double[] featureData = DataUtils.generateData(featureDistributions.get(i).getMean(),\n+                                                                      featureDistributions.get(i).getStdDev(), TABLE_SIZE);\n+                        trainingData[i] = featureData;\n+                    }\n+\n+                    double[] marginalImpacts = new double[featureXSvalues.length];\n+                    for (int i = 0; i < featureXSvalues.length; i++) {\n+                        List<PredictionInput> predictionInputs = new LinkedList<>();\n+                        double xs = featureXSvalues[i];\n+                        double[] inputs = new double[noOfFeatures];\n+                        inputs[featureIndex] = xs;\n+                        for (int j = 0; j < TABLE_SIZE; j++) {\n+                            for (int f = 0; f < noOfFeatures; f++) {\n+                                if (f != featureIndex) {\n+                                    inputs[f] = trainingData[f][j];\n+                                }\n+                            }\n+                            PredictionInput input = new PredictionInput(DataUtils.doublesToFeatures(inputs));\n+                            predictionInputs.add(input);\n+                        }\n+\n+                        // prediction requests are batched per value of feature 'Xs' under analysis\n+                        for (PredictionOutput predictionOutput : model.predict(predictionInputs)) {\n+                            Output output = predictionOutput.getOutputs().get(outputIndex);\n+                            marginalImpacts[i] += output.getScore() / (double) TABLE_SIZE;\n+                        }\n+                    }\n+                    DataSeries dataSeries = new DataSeries(model.getInputShape().getFeatures().get(featureIndex),\n+                                                           featureXSvalues, marginalImpacts);\n+                    pdps.add(dataSeries);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzMDM4Nw=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgzMTQ2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToxNDowOFrOGyC9oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo1MDo0NlrOGypccg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzMDUyOQ==", "bodyText": "private static final?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455130529", "createdAt": "2020-07-15T15:14:08Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MTAxMA==", "bodyText": "+1", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455761010", "createdAt": "2020-07-16T12:50:46Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int TABLE_SIZE = 100;\n+\n+    private final Logger logger = LoggerFactory.getLogger(getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzMDUyOQ=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODg1NTM3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/DataSeries.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToxOToyNVrOGyDMfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMjo1MzozMFrOGypiqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzNDMzMg==", "bodyText": "I don't think assert is a good idea here :/ Throw an illegal argument exception (or my personal preference is anyway to use a factory if an exception can be raised)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455134332", "createdAt": "2020-07-15T15:19:25Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/DataSeries.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+public class DataSeries {\n+\n+    private final double[] x;\n+    private final double[] y;\n+    private final Feature feature;\n+\n+    public DataSeries(Feature feature, double[] x, double[] y) {\n+        assert x.length == y.length : \"x and y lengths do not match\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc2MjYwMQ==", "bodyText": "I do not expect this class to be instantiated by customers / external users hence not having a Factory / Builder with proper checks. The reason for using assert in first place is that it was an internal check I put in place while I was developing the PDP implementation.\nI'm fine to drop it anyway.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455762601", "createdAt": "2020-07-16T12:53:30Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/DataSeries.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+public class DataSeries {\n+\n+    private final double[] x;\n+    private final double[] y;\n+    private final Feature feature;\n+\n+    public DataSeries(Feature feature, double[] x, double[] y) {\n+        assert x.length == y.length : \"x and y lengths do not match\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEzNDMzMg=="}, "originalCommit": {"oid": "92e39d5446821fc262025f9e7c11794be87945ee"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTU1ODY1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/LocalExplanationException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzowODozMVrOGyc9Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDowMTo0MFrOGzUNyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NjQwMw==", "bodyText": "Side note, in general it is better to use runtime exception because checked exceptions don't fit well with lambda/stream. I will let you decide what you prefer, it is just a comment :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455556403", "createdAt": "2020-07-16T07:08:31Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/LocalExplanationException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.kie.kogito.explainability.local;\n+\n+/**\n+ * Exception representing errors happened during the process of generating a local explanation.\n+ */\n+public class LocalExplanationException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MTc3MA==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456461770", "createdAt": "2020-07-17T14:01:40Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/LocalExplanationException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.kie.kogito.explainability.local;\n+\n+/**\n+ * Exception representing errors happened during the process of generating a local explanation.\n+ */\n+public class LocalExplanationException extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NjQwMw=="}, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTU2MzIwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzowOTo1N1rOGyc_-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo1MDoyMlrOGzM1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzExNQ==", "bodyText": "Is there any reason why this class is not public (same question for the constructor and methods)?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455557115", "createdAt": "2020-07-16T07:09:57Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MDc4Nw==", "bodyText": "it is expected to be used by LimeExplainer rather than users, hence the package local constructor and methods, similar to SampleWeighter.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456340787", "createdAt": "2020-07-17T09:50:22Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzExNQ=="}, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTYyODk1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoyOTozOVrOGydnmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo1MDo1MlrOGzM2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2NzI1OQ==", "bodyText": "Please consider to use assertj to replace this and other assertTrue based on simple expressions.\nYou can express condition logic directly in the assertion to obtain better error reporting\nassertThat(v).isPositive();\nassertThat(v).isGreaterThanOrEqualTo(0);", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455567259", "createdAt": "2020-07-16T07:29:39Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    public static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @RepeatedTest(10)\n+    void testMapOneFeatureToOutputRegression() throws Exception {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        BlackBoxModel model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertTrue(v > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MTA0NA==", "bodyText": "thanks for the suggestion, I'll do that.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456341044", "createdAt": "2020-07-17T09:50:52Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    public static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @RepeatedTest(10)\n+    void testMapOneFeatureToOutputRegression() throws Exception {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        BlackBoxModel model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertTrue(v > 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2NzI1OQ=="}, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTY3NjI4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzo0MzoyMlrOGyeEQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo1MToyNFrOGzM3PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU3NDU5Mw==", "bodyText": "This should not be needed any more", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455574593", "createdAt": "2020-07-16T07:43:22Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,90 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explanation-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  <properties>\n+    <org.kie.version>7.40.0-SNAPSHOT</org.kie.version>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.kie.kogito</groupId>\n+          <artifactId>kogito-api</artifactId>\n+        </exclusion>\n+      </exclusions>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MTMwOA==", "bodyText": "correct", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456341308", "createdAt": "2020-07-17T09:51:24Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,90 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explanation-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  <properties>\n+    <org.kie.version>7.40.0-SNAPSHOT</org.kie.version>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.kie.kogito</groupId>\n+          <artifactId>kogito-api</artifactId>\n+        </exclusion>\n+      </exclusions>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU3NDU5Mw=="}, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTgxMTIxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODowNzowNlrOGyfd7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODowNzowNlrOGyfd7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU5NzU1MA==", "bodyText": "Side note, this will be changed to proper kogito-pmml dependencies as soon as https://issues.redhat.com/browse/DROOLS-5491 will be merged. For now it is not a problem especially because they are test dependencies", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455597550", "createdAt": "2020-07-16T08:07:06Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,90 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explanation-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  <properties>\n+    <org.kie.version>7.40.0-SNAPSHOT</org.kie.version>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>org.kie.kogito</groupId>\n+          <artifactId>kogito-api</artifactId>\n+        </exclusion>\n+      </exclusions>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-evaluator-assembler</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-evaluator-core</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-regression-model</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-regression-compiler</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-regression-evaluator</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-drools-common</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-drools-scorecard-model</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-drools-scorecard-compiler</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.kie</groupId>\n+      <artifactId>kie-pmml-models-drools-scorecard-evaluator</artifactId>\n+      <version>${org.kie.version}</version>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba21264f71a85203adaab370cdc4528be4fd67f6"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzMzMDQ3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDozNzo0OFrOGyuGEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwODoyMzoxNVrOGzKC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzIwMg==", "bodyText": "Move the version definition to kogito-runtimes/bom/pom.xml", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455837202", "createdAt": "2020-07-16T14:37:48Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkyMjA4MQ==", "bodyText": "Wait: kogito-bom is for internal (aka kogito-*) dependencies while external dependencies are declared here. Btw this dependency should be already inherited by other bom so try to remove the version", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455922081", "createdAt": "2020-07-16T16:38:51Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzIwMg=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTEyMQ==", "bodyText": "correct, dropping the version just works :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456295121", "createdAt": "2020-07-17T08:23:15Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-jackson</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-openapi</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+      <version>3.9</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzIwMg=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM1MTYwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo0MjozNlrOGyuTdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo0ODo1MFrOGy13Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MDYyOA==", "bodyText": "Don't shoot on me :) I'm not sure about the documentation policy of the project but I'd suggest to start always with capital letter and end the sentence with the dot (also for all the other classes). Do you have more info @jiripetrlik @danielezonca ?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455840628", "createdAt": "2020-07-16T14:42:36Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkyMzQwMA==", "bodyText": "We do not have a proper policy so fine for me both upper or lower case. Usually we use upper case but no strong opinion", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455923400", "createdAt": "2020-07-16T16:40:57Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MDYyOA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2NDQ4Mw==", "bodyText": "Ok thanks Daniele, I would suggest to align all the docs so that the first letter is capital with a final dot", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455964483", "createdAt": "2020-07-16T17:48:50Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MDYyOA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM3MDMzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/BlackBoxModel.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo0NjozM1rOGyue5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMjowOTozOFrOGzQiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MzU1OA==", "bodyText": "I wonder if BlackBoxModel is the most comprehensive name here, since this class is going to be extended by the consumer of the library and implement the mechanism to execute the prediction (in our case, the BlackBoxModelImpl would make http calls to the kogito-runtimes application so it's not just executing the model). For that reason, what about PredictionProvider or something like this?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455843558", "createdAt": "2020-07-16T14:46:33Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/BlackBoxModel.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.List;\n+\n+/**\n+ * A black box model capable of performing predictions.\n+ * This can be using different kinds of underlying functions, like DMN, PMML, or any other machine learning model.\n+ */\n+public interface BlackBoxModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MzgzNA==", "bodyText": "I had dropped the previous much overloaded Model in favor of BlackBoxModel because I wanted to highlight that the library is expected to work with any kind of model, regardless of implementation.\nPredictionProvider sounds good to me to highlight the fact that it is not necessarily a model instance (e.g. loaded in memory from disk), the only thing I am not sure is that, in its current state, it doesn't only provide predictions but also information about feature wise data distribution.\nThis leads to me to think that it might be useful to decouple the prediction API from the data distribution API, also because not all the providers are also able to provide data distribution information.\nSo PredictionProvider will only have the predict API.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456353834", "createdAt": "2020-07-17T10:16:34Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/BlackBoxModel.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.List;\n+\n+/**\n+ * A black box model capable of performing predictions.\n+ * This can be using different kinds of underlying functions, like DMN, PMML, or any other machine learning model.\n+ */\n+public interface BlackBoxModel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MzU1OA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwMTQyNQ==", "bodyText": "Makes sense to me", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456401425", "createdAt": "2020-07-17T12:09:38Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/BlackBoxModel.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.List;\n+\n+/**\n+ * A black box model capable of performing predictions.\n+ * This can be using different kinds of underlying functions, like DMN, PMML, or any other machine learning model.\n+ */\n+public interface BlackBoxModel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MzU1OA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5ODMyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MjoxOFrOGyuv0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNToyNDozNlrOGzXUAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Nzg5MA==", "bodyText": "Is this covering all the possible cases?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455847890", "createdAt": "2020-07-16T14:52:18Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }\n+            }\n+        }\n+        return doubles;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzM1OA==", "bodyText": "not all possible cases yet.\nHere're the ones I see:\n\nwe could have a String representation of a vector, right now it is blindly converted into an arrays of 1s\nwe could have a binary, a ByteBuffer, that could be parsed as a double[]\netc.\nIt probably makes sense to have a VectorValue interface that users should leverage to define how a specific object is encoded/decoded into/from a double[].", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456317358", "createdAt": "2020-07-17T09:04:58Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }\n+            }\n+        }\n+        return doubles;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Nzg5MA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwMjQwMg==", "bodyText": "I'm a bit concerned about that because if the developer is using some dmn models (or whatever :) ) that we do not support, we are not catching the exception that is going to be raised here", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456402402", "createdAt": "2020-07-17T12:11:57Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }\n+            }\n+        }\n+        return doubles;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Nzg5MA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUxMjUxMw==", "bodyText": "as far as I can see, the problem here is that we eventually do not correctly parse a vector feature, or skip parts of it.\nThe right fix here is a more thorough (and pluggable) encoding / decoding mechanism for vector values.\nNote though that this is anyway an edge case where a model holds an entire vector into a single feature, whereas the good practice is to use a feature for each coordinate (value) in a vector (e.g. you have 100 numerical features for a 100-dimensional vector), which we correctly handle already.\nI've created FAI-234 ticket for this purpose.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456512513", "createdAt": "2020-07-17T15:24:36Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }\n+            }\n+        }\n+        return doubles;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Nzg5MA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQwMzcyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MzozMFrOGyuzSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTowNTozMVrOGzLa6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0ODc3OQ==", "bodyText": "I'd remove those comments since the method names are already clear. Keep only force desired XYZ ones", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455848779", "createdAt": "2020-07-16T14:53:30Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        // get the mean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzY3Mg==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456317672", "createdAt": "2020-07-17T09:05:31Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        // get the mean", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0ODc3OQ=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQxNjA3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1NTo1OFrOGyu64g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODoyNjo1MlrOG1ElDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MDcyMg==", "bodyText": "Are the casts (double) needed?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455850722", "createdAt": "2020-07-16T14:55:58Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkyNDQ4Mw==", "bodyText": "It is not needed because 0.333 is already floating point but I prefer to keep the cast to preserve floating point division even if we change 0.333 to 1 or similar", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455924483", "createdAt": "2020-07-16T16:42:45Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MDcyMg=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjczMw==", "bodyText": "@tteofili have a look at this please", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458302733", "createdAt": "2020-07-21T18:26:52Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MDcyMg=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQyMDAxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1Njo1MVrOGyu9ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1Njo1MVrOGyu9ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MTM2NA==", "bodyText": "Check condition directly in the if?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455851364", "createdAt": "2020-07-16T14:56:51Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model      the model to be explained\n+     * @param prediction a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(BlackBoxModel model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());\n+        }\n+        return impact / size;\n+    }\n+\n+    /**\n+     * calculate fidelity of boolean classification outputs using saliency predictor function = sign(sum(saliency.scores))\n+     * see papers:\n+     * - Guidotti Riccardo, et al. \"A survey of methods for explaining black box models.\" ACM computing surveys (2018).\n+     * - Bodria, Francesco, et al. \"Explainability Methods for Natural Language Processing: Applications to Sentiment Analysis (Discussion Paper).\"\n+     *\n+     * @param pairs pairs composed by the saliency and the related prediction\n+     * @return the fidelity accuracy\n+     */\n+    public static double classificationFidelity(List<Pair<Saliency, Prediction>> pairs) {\n+        double acc = 0;\n+        double evals = 0;\n+        for (Pair<Saliency, Prediction> pair : pairs) {\n+            Saliency saliency = pair.getLeft();\n+            Prediction prediction = pair.getRight();\n+            for (Output output : prediction.getOutput().getOutputs()) {\n+                Type type = output.getType();\n+                if (Type.BOOLEAN.equals(type)) {\n+                    double predictorOutput = saliency.getPerFeatureImportance().stream().map(FeatureImportance::getScore).mapToDouble(d -> d).sum();\n+                    double v = output.getValue().asNumber();\n+                    boolean match = (v >= 0 && predictorOutput >= 0) || (v < 0 && predictorOutput < 0);\n+                    if (match) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQzOTU0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMTowMlrOGyvJtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzoyNDo0N1rOG1V_0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDUxNw==", "bodyText": "Is it possible that pairs or prediction.getOutput().getOutputs() are empty? if so, an exception is going to be raised because of return 0/0", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455854517", "createdAt": "2020-07-16T15:01:02Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model      the model to be explained\n+     * @param prediction a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(BlackBoxModel model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());\n+        }\n+        return impact / size;\n+    }\n+\n+    /**\n+     * calculate fidelity of boolean classification outputs using saliency predictor function = sign(sum(saliency.scores))\n+     * see papers:\n+     * - Guidotti Riccardo, et al. \"A survey of methods for explaining black box models.\" ACM computing surveys (2018).\n+     * - Bodria, Francesco, et al. \"Explainability Methods for Natural Language Processing: Applications to Sentiment Analysis (Discussion Paper).\"\n+     *\n+     * @param pairs pairs composed by the saliency and the related prediction\n+     * @return the fidelity accuracy\n+     */\n+    public static double classificationFidelity(List<Pair<Saliency, Prediction>> pairs) {\n+        double acc = 0;\n+        double evals = 0;\n+        for (Pair<Saliency, Prediction> pair : pairs) {\n+            Saliency saliency = pair.getLeft();\n+            Prediction prediction = pair.getRight();\n+            for (Output output : prediction.getOutput().getOutputs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4ODExMg==", "bodyText": "theoretically this is possible, although not really plausible in reality, but nevertheless I think it's worth guarding against possible 0 by 0 division, thanks!", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458588112", "createdAt": "2020-07-22T07:24:47Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/ExplainabilityMetrics.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility class providing different methods to evaluate explainability.\n+ */\n+public class ExplainabilityMetrics {\n+\n+    /**\n+     * measure the explainability of an explanation as per paper \"Towards Quantification of Explainability in Explainable\n+     * Artificial Intelligence Methods\" by Islam et al.\n+     *\n+     * @param inputCognitiveChunks  the no. of cognitive chunks (pieces of information) required to generate the\n+     *                              explanation (e.g. the no. of explanation inputs)\n+     * @param outputCognitiveChunks the no. of cognitive chunks generated within the explanation itself\n+     * @param interactionRatio      the ratio of interaction (between 0 and 1) required by the explanation\n+     * @return the quantitative explainability measure\n+     */\n+    public static double quantifyExplainability(int inputCognitiveChunks, int outputCognitiveChunks, double interactionRatio) {\n+        return inputCognitiveChunks + outputCognitiveChunks > 0 ? 0.333 / (double) inputCognitiveChunks\n+                + 0.333 / (double) outputCognitiveChunks + 0.333 * (1d - interactionRatio) : 0;\n+    }\n+\n+    /**\n+     * Calculate the impact of dropping the most important features (given by {@link Saliency#getTopFeatures(int)} from the input.\n+     * Highly important features would have rather high impact.\n+     *\n+     * @param model      the model to be explained\n+     * @param prediction a prediction\n+     * @param topFeatures the list of important features that should be dropped\n+     * @return the saliency impact\n+     */\n+    public static double saliencyImpact(BlackBoxModel model, Prediction prediction, List<FeatureImportance> topFeatures) {\n+        String[] importantFeatureNames = topFeatures.stream().map(f -> f.getFeature().getName()).toArray(String[]::new);\n+\n+        List<Feature> newFeatures = new LinkedList<>();\n+        for (Feature feature : prediction.getInput().getFeatures()) {\n+            Feature newFeature = DataUtils.dropFeature(feature, importantFeatureNames);\n+            newFeatures.add(newFeature);\n+        }\n+        PredictionInput predictionInput = new PredictionInput(newFeatures);\n+        List<PredictionOutput> predictionOutputs = model.predict(List.of(predictionInput));\n+        PredictionOutput predictionOutput = predictionOutputs.get(0);\n+        double impact = 0;\n+        double size = predictionOutput.getOutputs().size();\n+        for (int i = 0; i < size; i++) {\n+            Output original = prediction.getOutput().getOutputs().get(i);\n+            Output modified = predictionOutput.getOutputs().get(i);\n+            impact += DataUtils.euclideanDistance(new double[]{original.getScore()}, new double[]{modified.getScore()});\n+            impact += DataUtils.hammingDistance(original.getValue().asString(), modified.getValue().asString());\n+        }\n+        return impact / size;\n+    }\n+\n+    /**\n+     * calculate fidelity of boolean classification outputs using saliency predictor function = sign(sum(saliency.scores))\n+     * see papers:\n+     * - Guidotti Riccardo, et al. \"A survey of methods for explaining black box models.\" ACM computing surveys (2018).\n+     * - Bodria, Francesco, et al. \"Explainability Methods for Natural Language Processing: Applications to Sentiment Analysis (Discussion Paper).\"\n+     *\n+     * @param pairs pairs composed by the saliency and the related prediction\n+     * @return the fidelity accuracy\n+     */\n+    public static double classificationFidelity(List<Pair<Saliency, Prediction>> pairs) {\n+        double acc = 0;\n+        double evals = 0;\n+        for (Pair<Saliency, Prediction> pair : pairs) {\n+            Saliency saliency = pair.getLeft();\n+            Prediction prediction = pair.getRight();\n+            for (Output output : prediction.getOutput().getOutputs()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDUxNw=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ0MzA1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMTo0OVrOGyvL7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowMTo0OVrOGyvL7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTA4Nw==", "bodyText": "move constants to property so that it's clear what they are for?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455855087", "createdAt": "2020-07-16T15:01:49Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double floss = 1d;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {\n+            double lr = 0.01;\n+            int e = 0;\n+            while (floss > 0.1 && e < 15) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ1NjE2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNDo1MVrOGyvUKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNDo1MVrOGyvUKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NzE5Mg==", "bodyText": "Even if the seed is fixed and these tests are deterministic, it is impossible to understand what are the features really tested by these tests. wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455857192", "createdAt": "2020-07-16T15:04:51Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/TestUtils.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.apache.commons.lang3.RandomStringUtils;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TestUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    static {\n+        random.setSeed(4);\n+    }\n+\n+    public static BlackBoxModel getFeaturePassModel(int featureIndex) {\n+        return new BlackBoxModel() {\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+                for (PredictionInput predictionInput : inputs) {\n+                    List<Feature> features = predictionInput.getFeatures();\n+                    Feature feature = features.get(featureIndex);\n+                    PredictionOutput predictionOutput = new PredictionOutput(\n+                            List.of(new Output(\"feature-\" + featureIndex, feature.getType(), feature.getValue(),\n+                                               1d)));\n+                    predictionOutputs.add(predictionOutput);\n+                }\n+                return predictionOutputs;\n+            }\n+\n+            @Override\n+            public DataDistribution getDataDistribution() {\n+                return DataUtils.generateRandomDataDistribution(featureIndex + 1);\n+            }\n+\n+            @Override\n+            public PredictionInput getInputShape() {\n+                List<Feature> features = new LinkedList<>();\n+                features.add(FeatureFactory.newNumericalFeature(\"f1\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f2\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f3\", Double.NaN));\n+                return new PredictionInput(features);\n+            }\n+\n+            @Override\n+            public PredictionOutput getOutputShape() {\n+                return new PredictionOutput(List.of(new Output(\"feature-\" + featureIndex, Type.NUMBER, new Value<>(Double.NaN), 1d)));\n+            }\n+        };\n+    }\n+\n+    public static BlackBoxModel getSumSkipModel(int skipFeatureIndex) {\n+        return new BlackBoxModel() {\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+                for (PredictionInput predictionInput : inputs) {\n+                    List<Feature> features = predictionInput.getFeatures();\n+                    double result = 0;\n+                    for (int i = 0; i < features.size(); i++) {\n+                        if (skipFeatureIndex != i) {\n+                            result += features.get(i).getValue().asNumber();\n+                        }\n+                    }\n+                    PredictionOutput predictionOutput = new PredictionOutput(\n+                            List.of(new Output(\"sum-but\" + skipFeatureIndex, Type.NUMBER, new Value<>(result), 1d)));\n+                    predictionOutputs.add(predictionOutput);\n+                }\n+                return predictionOutputs;\n+            }\n+\n+            @Override\n+            public DataDistribution getDataDistribution() {\n+                return DataUtils.generateRandomDataDistribution(skipFeatureIndex + 1);\n+            }\n+\n+            @Override\n+            public PredictionInput getInputShape() {\n+                List<Feature> features = new LinkedList<>();\n+                features.add(FeatureFactory.newNumericalFeature(\"f1\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f2\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f3\", Double.NaN));\n+                return new PredictionInput(features);\n+            }\n+\n+            @Override\n+            public PredictionOutput getOutputShape() {\n+                return new PredictionOutput(List.of(new Output(\"o\", Type.NUMBER, new Value<>(Double.NaN), 1d)));\n+            }\n+        };\n+    }\n+\n+    public static BlackBoxModel getEvenFeatureModel(int featureIndex) {\n+        return new BlackBoxModel() {\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+                for (PredictionInput predictionInput : inputs) {\n+                    List<Feature> features = predictionInput.getFeatures();\n+                    Feature feature = features.get(featureIndex);\n+                    double v = feature.getValue().asNumber();\n+                    PredictionOutput predictionOutput = new PredictionOutput(\n+                            List.of(new Output(\"feature-\" + featureIndex, Type.BOOLEAN, new Value<>(v % 2 == 0), 1d)));\n+                    predictionOutputs.add(predictionOutput);\n+                }\n+                return predictionOutputs;\n+            }\n+\n+            @Override\n+            public DataDistribution getDataDistribution() {\n+                return DataUtils.generateRandomDataDistribution(featureIndex + 1);\n+            }\n+\n+            @Override\n+            public PredictionInput getInputShape() {\n+                List<Feature> features = new LinkedList<>();\n+                features.add(FeatureFactory.newNumericalFeature(\"f1\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f2\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f3\", Double.NaN));\n+                return new PredictionInput(features);\n+            }\n+\n+            @Override\n+            public PredictionOutput getOutputShape() {\n+                return new PredictionOutput(List.of(new Output(\"o\", Type.NUMBER, new Value<>(Double.NaN), 1d)));\n+            }\n+        };\n+    }\n+\n+    public static BlackBoxModel getEvenSumModel(int skipFeatureIndex) {\n+        return new BlackBoxModel() {\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+                for (PredictionInput predictionInput : inputs) {\n+                    List<Feature> features = predictionInput.getFeatures();\n+                    double result = 0;\n+                    for (int i = 0; i < features.size(); i++) {\n+                        if (skipFeatureIndex != i) {\n+                            result += features.get(i).getValue().asNumber();\n+                        }\n+                    }\n+                    PredictionOutput predictionOutput = new PredictionOutput(\n+                            List.of(new Output(\"sum-even-but\" + skipFeatureIndex, Type.BOOLEAN, new Value<>(((int) result) % 2 == 0), 1d)));\n+                    predictionOutputs.add(predictionOutput);\n+                }\n+                return predictionOutputs;\n+            }\n+\n+            @Override\n+            public DataDistribution getDataDistribution() {\n+                return DataUtils.generateRandomDataDistribution(skipFeatureIndex + 1);\n+            }\n+\n+            @Override\n+            public PredictionInput getInputShape() {\n+                List<Feature> features = new LinkedList<>();\n+                features.add(FeatureFactory.newNumericalFeature(\"f1\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f2\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f3\", Double.NaN));\n+                return new PredictionInput(features);\n+            }\n+\n+            @Override\n+            public PredictionOutput getOutputShape() {\n+                return new PredictionOutput(List.of(new Output(\"o\", Type.NUMBER, new Value<>(Double.NaN), 1d)));\n+            }\n+        };\n+    }\n+\n+    public static BlackBoxModel getDummyTextClassifier() {\n+        return new BlackBoxModel() {\n+            private final List<String> blackList = Arrays.asList(\"money\", \"$\", \"\u00a3\", \"bitcoin\");\n+            @Override\n+            public List<PredictionOutput> predict(List<PredictionInput> inputs) {\n+                List<PredictionOutput> outputs = new LinkedList<>();\n+                for (PredictionInput input : inputs) {\n+                    boolean spam = false;\n+                    for (Feature f : input.getFeatures()) {\n+                        if (!spam && Type.TEXT.equals(f.getType())) {\n+                            String s = f.getValue().asString();\n+                            String[] words = s.split(\" \");\n+                            for (String w : words) {\n+                                if (blackList.contains(w)) {\n+                                    spam = true;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Output output = new Output(\"spam-classification\", Type.BOOLEAN, new Value<>(spam), 1d);\n+                    outputs.add(new PredictionOutput(List.of(output)));\n+                }\n+                return outputs;\n+            }\n+\n+            @Override\n+            public DataDistribution getDataDistribution() {\n+                return DataUtils.generateRandomDataDistribution(3);\n+            }\n+\n+            @Override\n+            public PredictionInput getInputShape() {\n+                List<Feature> features = new LinkedList<>();\n+                features.add(FeatureFactory.newNumericalFeature(\"f1\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f2\", Double.NaN));\n+                features.add(FeatureFactory.newNumericalFeature(\"f3\", Double.NaN));\n+                return new PredictionInput(features);\n+            }\n+\n+            @Override\n+            public PredictionOutput getOutputShape() {\n+                return new PredictionOutput(List.of(new Output(\"o\", Type.NUMBER, new Value<>(Double.NaN), 1d)));\n+            }\n+        };\n+    }\n+\n+    public static Feature getRandomFeature() {\n+        Feature f;\n+        int r = random.nextInt(12);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ2NjMzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNjo1M1rOGyvaRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNjo1M1rOGyvaRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1ODc1Ng==", "bodyText": "why?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455858756", "createdAt": "2020-07-16T15:06:53Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainerTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.PrintWriter;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class PartialDependencePlotExplainerTest {\n+\n+    @Test\n+    void testPdpTextClassifier() throws Exception {\n+        PartialDependencePlotExplainer partialDependencePlotProvider = new PartialDependencePlotExplainer();\n+        BlackBoxModel modelInfo = TestUtils.getDummyTextClassifier();\n+        Collection<DataSeries> pdps = partialDependencePlotProvider.explain(modelInfo);\n+        assertNotNull(pdps);\n+        for (DataSeries dataSeries : pdps) {\n+            writeAsciiGraph(dataSeries, new PrintWriter(new File(\"target/pdp\" + dataSeries.getFeature().getName() + \".txt\")));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ3MDc0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DatasetEncoderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNzo0OVrOGyvdIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTowNzo0OVrOGyvdIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1OTQ5MA==", "bodyText": "Unit tests should be deterministic by definition, I would avoid using random", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455859490", "createdAt": "2020-07-16T15:07:49Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DatasetEncoderTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.security.SecureRandom;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DatasetEncoderTest {\n+\n+    private final static SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ4NDk0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDo1MFrOGyvmEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMDo1MFrOGyvmEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTc3OA==", "bodyText": "I would avoid using random in every tests (and all the other classes) even if the seed is set, wdyt?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455861778", "createdAt": "2020-07-16T15:10:50Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testEmptyPrediction() throws Exception {\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionOutput output = mock(PredictionOutput.class);\n+        PredictionInput input = mock(PredictionInput.class);\n+        Prediction prediction = new Prediction(input, output);\n+        BlackBoxModel model = mock(BlackBoxModel.class);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+        assertNotNull(saliency);\n+    }\n+\n+    @Test\n+    void testNonEmptyInput() throws Exception {\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        PredictionOutput output = mock(PredictionOutput.class);\n+        List<Feature> features = new LinkedList<>();\n+        for (int i = 0; i < 4; i++) {\n+            features.add(TestUtils.getRandomFeature());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ5NTUwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMzowOVrOGyvsqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOToxODowOFrOGzL0UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzQ2Nw==", "bodyText": "Can you refactor the entire class so to remove duplicated code? For example moving String name to a property in the class and using a reusable method to do the assertions", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455863467", "createdAt": "2020-07-16T15:13:09Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class FeatureFactoryTest {\n+\n+    @Test\n+    void testTimeFeature() {\n+        String name = \"some-name\";\n+        LocalTime time = LocalTime.now();\n+        Feature feature = FeatureFactory.newTimeFeature(name, time);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.TIME, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(time, feature.getValue().getUnderlyingObject());\n+    }\n+\n+    @Test\n+    void testCategoricalFeature() {\n+        String name = \"some-name\";\n+        String category = \"FIXED-CAT\";\n+        Feature feature = FeatureFactory.newCategoricalFeature(name, category);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.CATEGORICAL, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(category, feature.getValue().getUnderlyingObject());\n+    }\n+\n+    @Test\n+    void testNumberFeature() {\n+        String name = \"some-name\";\n+        Number number = 0.1d;\n+        Feature feature = FeatureFactory.newNumericalFeature(name, number);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.NUMBER, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(number, feature.getValue().getUnderlyingObject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNDE3Nw==", "bodyText": "sure, makes sense.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456324177", "createdAt": "2020-07-17T09:18:08Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class FeatureFactoryTest {\n+\n+    @Test\n+    void testTimeFeature() {\n+        String name = \"some-name\";\n+        LocalTime time = LocalTime.now();\n+        Feature feature = FeatureFactory.newTimeFeature(name, time);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.TIME, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(time, feature.getValue().getUnderlyingObject());\n+    }\n+\n+    @Test\n+    void testCategoricalFeature() {\n+        String name = \"some-name\";\n+        String category = \"FIXED-CAT\";\n+        Feature feature = FeatureFactory.newCategoricalFeature(name, category);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.CATEGORICAL, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(category, feature.getValue().getUnderlyingObject());\n+    }\n+\n+    @Test\n+    void testNumberFeature() {\n+        String name = \"some-name\";\n+        Number number = 0.1d;\n+        Feature feature = FeatureFactory.newNumericalFeature(name, number);\n+        assertNotNull(feature);\n+        assertNotNull(feature.getName());\n+        assertNotNull(feature.getType());\n+        assertEquals(Type.NUMBER, feature.getType());\n+        assertNotNull(feature.getValue());\n+        assertEquals(number, feature.getValue().getUnderlyingObject());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzQ2Nw=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ5NjUwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMzoyMlrOGyvtSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo0NzozOFrOGzMvuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzYyNQ==", "bodyText": "random unit test", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455863625", "createdAt": "2020-07-16T15:13:22Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class DataUtilsTest {\n+\n+    private final static SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMzOTM4Nw==", "bodyText": "good point, I'll remove the randomized parts.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456339387", "createdAt": "2020-07-17T09:47:38Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/DataUtilsTest.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class DataUtilsTest {\n+\n+    private final static SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzYyNQ=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ5NzMxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMzozMVrOGyvtxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo0Nzo0NVrOGzMv7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2Mzc0OA==", "bodyText": "random unit test", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455863748", "createdAt": "2020-07-16T15:13:31Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ExplainabilityMetricsTest {\n+\n+    private static final SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMzOTQzOQ==", "bodyText": "good point, I'll remove the randomized parts.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456339439", "createdAt": "2020-07-17T09:47:45Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/ExplainabilityMetricsTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ExplainabilityMetricsTest {\n+\n+    private static final SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2Mzc0OA=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ5NzcwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMzozOFrOGyvuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo0ODozNFrOGzMxjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzgyMg==", "bodyText": "random unit test", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455863822", "createdAt": "2020-07-16T15:13:38Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LinearModelTest {\n+\n+    private final static SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMzOTg1NA==", "bodyText": "randomization here is needed for a more functional test rather than unit test.\nI'll move that stuff in a different (integration) test.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456339854", "createdAt": "2020-07-17T09:48:34Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/utils/LinearModelTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class LinearModelTest {\n+\n+    private final static SecureRandom random = new SecureRandom();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MzgyMg=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzUwMjQ4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxNDo1NFrOGyvxRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwOTo0ODo0OFrOGzMyAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2NDY0NQ==", "bodyText": "move version to kogito-runtimes/bom", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455864645", "createdAt": "2020-07-16T15:14:54Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,35 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-opennlp</artifactId>\n+  <name>Kogito :: Explainability Integration Tests OpenNLP</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+\n+    <!-- OpenNLP -->\n+    <dependency>\n+      <groupId>org.apache.opennlp</groupId>\n+      <artifactId>opennlp-tools</artifactId>\n+      <version>1.9.2</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkyNTM2Ng==", "bodyText": "This is a really specific dependency used for test. I prefer to keep it declared here but please use a property instead of explicit version.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455925366", "createdAt": "2020-07-16T16:44:17Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,35 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-opennlp</artifactId>\n+  <name>Kogito :: Explainability Integration Tests OpenNLP</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+\n+    <!-- OpenNLP -->\n+    <dependency>\n+      <groupId>org.apache.opennlp</groupId>\n+      <artifactId>opennlp-tools</artifactId>\n+      <version>1.9.2</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2NDY0NQ=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMzOTk3MA==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456339970", "createdAt": "2020-07-17T09:48:48Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-opennlp/pom.xml", "diffHunk": "@@ -0,0 +1,35 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-opennlp</artifactId>\n+  <name>Kogito :: Explainability Integration Tests OpenNLP</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+\n+    <!-- OpenNLP -->\n+    <dependency>\n+      <groupId>org.apache.opennlp</groupId>\n+      <artifactId>opennlp-tools</artifactId>\n+      <version>1.9.2</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2NDY0NQ=="}, "originalCommit": {"oid": "abbfbac86aaf495013f28d4943e8a8118f2f181c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzc5Njk4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/GlobalExplanationException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjoyMjowNVrOGyyptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDowMjowNVrOGzUO1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxMTg2Mg==", "bodyText": "Side note, in general it is better to use runtime exception because checked exceptions don't fit well with lambda/stream. I will let you decide what you prefer, it is just a comment :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455911862", "createdAt": "2020-07-16T16:22:05Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/GlobalExplanationException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global;\n+\n+/**\n+ * Exception representing errors happened during the process of generating a global explanation.\n+ */\n+public class GlobalExplanationException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MjAzNw==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456462037", "createdAt": "2020-07-17T14:02:05Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/GlobalExplanationException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global;\n+\n+/**\n+ * Exception representing errors happened during the process of generating a global explanation.\n+ */\n+public class GlobalExplanationException extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxMTg2Mg=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzgxODQ2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjoyNzoyOVrOGyy20g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDowMzozOVrOGzUSRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxNTIxOA==", "bodyText": "Are you sure about this dependency? This is for scesim file runner so I expect you are looking for kogito-dmn or similar", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455915218", "createdAt": "2020-07-16T16:27:29Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-dmn</artifactId>\n+  <name>Kogito :: Explainability Integration Tests DMN</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN testing -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-scenario-simulation</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MjkxNw==", "bodyText": "correct, kogito-dmn is the right one here.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456462917", "createdAt": "2020-07-17T14:03:39Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-dmn</artifactId>\n+  <name>Kogito :: Explainability Integration Tests DMN</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>explainability-core</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <!-- DMN testing -->\n+    <dependency>\n+      <groupId>org.kie.kogito</groupId>\n+      <artifactId>kogito-scenario-simulation</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxNTIxOA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzg0Mzc5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjozNDoyNVrOGyzG-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDowNzoyMFrOGzUa6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxOTM1Mg==", "bodyText": "In Kogito we use Final external dependencies only. Btw we just updated master to 7.40.0.Final so this property is not needed (use version.org.kie7 https://github.com/kiegroup/kogito-runtimes/blob/master/pom.xml#L143 ).\nWe should only use DependencyManagement but PMML is not ported to Kogito yet so we have no proper dependency to use ( https://issues.redhat.com/browse/DROOLS-5491 ). I'm fine to stay with explicit dependencies in the meanwhile but please change the property as suggested", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r455919352", "createdAt": "2020-07-16T16:34:25Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,90 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  <properties>\n+    <org.kie.version>7.40.0-SNAPSHOT</org.kie.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2NTEyOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456465128", "createdAt": "2020-07-17T14:07:20Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/pom.xml", "diffHunk": "@@ -0,0 +1,90 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability-integrationtests</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+  <artifactId>explainability-integrationtests-pmml</artifactId>\n+  <name>Kogito :: Explainability Integration Tests PMML</name>\n+  <properties>\n+    <org.kie.version>7.40.0-SNAPSHOT</org.kie.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxOTM1Mg=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjczMjkyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozNjo1NVrOGzOMyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDozMjoxNVrOGzVWIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MzIxMQ==", "bodyText": "Can you please describe more what means \"slightly modified\"?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456363211", "createdAt": "2020-07-17T10:36:55Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/README.md", "diffHunk": "@@ -0,0 +1,8 @@\n+# explainability-core project\n+\n+The explainability-core project is a pure Java library for _Explainability_ (aka _XAI_ or _Explainable AI_).\n+\n+It provides implementation of the following algorithms:\n+\n+ * Local Interpretable Model-Agnostic Explanations: a slightly modified version of the [LIME](https://arxiv.org/abs/1602.04938) algorithm (Ribeiro et al., 2016) for local explanations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ3OTMxOA==", "bodyText": "the main differences are highlighted in the javadoc of LimeExplainer.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456479318", "createdAt": "2020-07-17T14:30:31Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/README.md", "diffHunk": "@@ -0,0 +1,8 @@\n+# explainability-core project\n+\n+The explainability-core project is a pure Java library for _Explainability_ (aka _XAI_ or _Explainable AI_).\n+\n+It provides implementation of the following algorithms:\n+\n+ * Local Interpretable Model-Agnostic Explanations: a slightly modified version of the [LIME](https://arxiv.org/abs/1602.04938) algorithm (Ribeiro et al., 2016) for local explanations.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MzIxMQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4MDI4OQ==", "bodyText": "... Also it seems that Sonar cloud test coverage failed. It says \"74.7% Coverage on New Code (is less than 80%)\". As this is mostly the Java library with quite complicated logic implemented inside, I think it would be good if we reach at least requested 80% of test coverage.\n\nagreed, I'll make sure the test coverage is good (and beyond 80%).", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456480289", "createdAt": "2020-07-17T14:32:15Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/README.md", "diffHunk": "@@ -0,0 +1,8 @@\n+# explainability-core project\n+\n+The explainability-core project is a pure Java library for _Explainability_ (aka _XAI_ or _Explainable AI_).\n+\n+It provides implementation of the following algorithms:\n+\n+ * Local Interpretable Model-Agnostic Explanations: a slightly modified version of the [LIME](https://arxiv.org/abs/1602.04938) algorithm (Ribeiro et al., 2016) for local explanations.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MzIxMQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjczNzc1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozODo0M1rOGzOPvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoyOTowN1rOGzVOyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2Mzk2NA==", "bodyText": "Why do we need resteasy if this is a library and not app or addon?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456363964", "createdAt": "2020-07-17T10:38:43Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ3ODQxMA==", "bodyText": "correct, it's not needed.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456478410", "createdAt": "2020-07-17T14:29:07Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>kogito-apps</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2Mzk2NA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjczOTU0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/GlobalExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozOToxOFrOGzOQwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozOToxOFrOGzOQwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NDIyNg==", "bodyText": "Please describe T.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456364226", "createdAt": "2020-07-17T10:39:18Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/GlobalExplainer.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global;\n+\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+\n+/**\n+ * A global explainability method\n+ * @param <T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc0NjAzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo0MTo1MFrOGzOUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoxOTowOFrOGzU2mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NTI1NQ==", "bodyText": "Is it good to hard code series length? Is there any reason to not make this configurable?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456365255", "createdAt": "2020-07-17T10:41:50Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.kie.kogito.explainability.global.GlobalExplanationException;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int SERIES_LENGTH = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ3MjIxOA==", "bodyText": "sure, I think it is ok to make it configurable.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456472218", "createdAt": "2020-07-17T14:19:08Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainer.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.global.GlobalExplainer;\n+import org.kie.kogito.explainability.global.GlobalExplanationException;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generates the partial dependence plot for a given feature.\n+ * While a strict PD implementation would need the whole training set used to train the model, this implementation seeks\n+ * to reproduce an approximate version of the training data by means of data distribution information (min, max, mean,\n+ * stdDev).\n+ */\n+public class PartialDependencePlotExplainer implements GlobalExplainer<Collection<DataSeries>> {\n+\n+    private static final int SERIES_LENGTH = 100;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NTI1NQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc1MDc4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo0MzozMlrOGzOXow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDo0MToxN1rOGzVrgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NTk4Nw==", "bodyText": "Please also make methods of this class public.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456365987", "createdAt": "2020-07-17T10:43:32Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4NTc2MA==", "bodyText": "DatasetEncoder is expected to be used by LimeExplainer only, hence the package level visibility of both class and methods.\nSame as per class and constructor I think it's better not to make stuff public unless needed by consumers, as reducing the surface API is usually more expensive.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456485760", "createdAt": "2020-07-17T14:41:17Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NTk4Nw=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc1MzkyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo0NDozOFrOGzOZcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo0MTo1N1rOG1Wjtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NjQ0OA==", "bodyText": "Shouldn't we throw exception or log something here?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456366448", "createdAt": "2020-07-17T10:44:38Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+                case UNDEFINED:\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjYzNg==", "bodyText": "@tteofili have a look at this please", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458302636", "createdAt": "2020-07-21T18:26:41Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+                case UNDEFINED:\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NjQ0OA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU5NzMwMg==", "bodyText": "after having thought about this I think UNDEFINED should be handled the same way as non text, non numeric features, hence moving it so that it's handled by encodeEquals method.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458597302", "createdAt": "2020-07-22T07:41:57Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * get the input and output predictions transformed into a numerical training set\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+                case UNDEFINED:\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2NjQ0OA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc1NzA2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo0NTozNlrOGzObHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODoyNjo0NFrOG1EkyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2Njg3Ng==", "bodyText": "Please split the line to make this comment more readable.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456366876", "createdAt": "2020-07-17T10:45:36Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) optimised for tabular data and decision models.\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjY2NA==", "bodyText": "@tteofili have a look at this please", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458302664", "createdAt": "2020-07-21T18:26:44Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) optimised for tabular data and decision models.\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2Njg3Ng=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc3MjU2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1MToxOFrOGzOkZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1MToxOFrOGzOkZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2OTI1NA==", "bodyText": "Please remove.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456369254", "createdAt": "2020-07-17T10:51:18Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/global/pdp/PartialDependencePlotExplainerTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.global.pdp;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.PrintWriter;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.DataSeries;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class PartialDependencePlotExplainerTest {\n+\n+    @Test\n+    void testPdpTextClassifier() throws Exception {\n+        PartialDependencePlotExplainer partialDependencePlotProvider = new PartialDependencePlotExplainer();\n+        BlackBoxModel modelInfo = TestUtils.getDummyTextClassifier();\n+        Collection<DataSeries> pdps = partialDependencePlotProvider.explain(modelInfo);\n+        assertNotNull(pdps);\n+        for (DataSeries dataSeries : pdps) {\n+            writeAsciiGraph(dataSeries, new PrintWriter(new File(\"target/pdp\" + dataSeries.getFeature().getName() + \".txt\")));\n+        }\n+    }\n+\n+    private void writeAsciiGraph(DataSeries dataSeries, PrintWriter out) {\n+        double[] outputs = dataSeries.getY();\n+        double max = DoubleStream.of(outputs).max().getAsDouble();\n+        double min = DoubleStream.of(outputs).min().getAsDouble();\n+        outputs = Arrays.stream(outputs).map(d -> d * max / min).toArray();\n+        double curMax = 1 + DoubleStream.of(outputs).max().getAsDouble();\n+        ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc3NTcxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DatasetEncoderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1MjozNlrOGzOmUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoxNjoxMVrOGzUvzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2OTc0Nw==", "bodyText": "Please use public for test methods.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456369747", "createdAt": "2020-07-17T10:52:36Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DatasetEncoderTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.security.SecureRandom;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DatasetEncoderTest {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    @Test\n+    void testEmptyDatasetEncoding() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ3MDQ3Ng==", "bodyText": "this is no longer required since junit5 onwards.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456470476", "createdAt": "2020-07-17T14:16:11Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DatasetEncoderTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.security.SecureRandom;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DatasetEncoderTest {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    @Test\n+    void testEmptyDatasetEncoding() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2OTc0Nw=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc3ODExOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1MzozNlrOGzOn4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1MzozNlrOGzOn4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3MDE0Ng==", "bodyText": "Please remove newlines.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456370146", "createdAt": "2020-07-17T10:53:36Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/DummyModelsLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class DummyModelsLimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputRegression() throws Exception {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 0.1));\n+        PredictionInput input = new PredictionInput(features);\n+        BlackBoxModel model = TestUtils.getFeaturePassModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+        assertEquals(topFeatures.get(0).getFeature().getName(), features.get(idx).getName());\n+        assertTrue(topFeatures.get(1).getScore() < topFeatures.get(0).getScore() * 10);\n+        assertTrue(topFeatures.get(2).getScore() < topFeatures.get(0).getScore() * 10);\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertTrue(v > 0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureRegression() throws Exception {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 100));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 20));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 10));\n+        BlackBoxModel model = TestUtils.getSumSkipModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getPerFeatureImportance();\n+\n+        perFeatureImportance.sort((t1, t2) -> (int) (t2.getScore() - t1.getScore()));\n+        assertTrue(perFeatureImportance.get(0).getScore() > 0);\n+        assertTrue(perFeatureImportance.get(1).getScore() > 0);\n+        assertEquals(features.get(idx).getName(), perFeatureImportance.get(2).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertTrue(v > 0);\n+    }\n+\n+    @Test\n+    void testMapOneFeatureToOutputClassification() throws Exception {\n+        int idx = 1;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\", 3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\", 2));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\", 7));\n+        PredictionInput input = new PredictionInput(features);\n+        BlackBoxModel model = TestUtils.getEvenFeatureModel(idx);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertFalse(topFeatures.isEmpty());\n+        assertEquals(features.get(idx).getName(), topFeatures.get(0).getFeature().getName());\n+    }\n+\n+    @Test\n+    void testTextSpamClassification() throws Exception {\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newTextFeature(\"f1\",\"we go here and there\"));\n+        features.add(FeatureFactory.newTextFeature(\"f2\", \"please give me some money\"));\n+        features.add(FeatureFactory.newTextFeature(\"f3\", \"dear friend, please reply\"));\n+        PredictionInput input = new PredictionInput(features);\n+        BlackBoxModel model = TestUtils.getDummyTextClassifier();\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+\n+        LimeExplainer limeExplainer = new LimeExplainer(1000, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> topFeatures = saliency.getPositiveFeatures(1);\n+        assertEquals(\"money (f2)\", topFeatures.get(0).getFeature().getName());\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getTopFeatures(1));\n+        assertTrue(v > 0);\n+    }\n+\n+    @Test\n+    void testUnusedFeatureClassification() throws Exception {\n+        int idx = 2;\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newNumericalFeature(\"f1\",6));\n+        features.add(FeatureFactory.newNumericalFeature(\"f2\",3));\n+        features.add(FeatureFactory.newNumericalFeature(\"f3\",5));\n+        BlackBoxModel model = TestUtils.getEvenSumModel(idx);\n+        PredictionInput input = new PredictionInput(features);\n+        List<PredictionOutput> outputs = model.predict(List.of(input));\n+        Prediction prediction = new Prediction(input, outputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(100, 1);\n+        Saliency saliency = limeExplainer.explain(prediction, model);\n+\n+        assertNotNull(saliency);\n+        List<FeatureImportance> perFeatureImportance = saliency.getNegativeFeatures(3);\n+        assertFalse(perFeatureImportance.stream().map(fi -> fi.getFeature().getName()).collect(Collectors.toList()).contains(features.get(idx).getName()));\n+        double v = ExplainabilityMetrics.saliencyImpact(model, prediction, saliency.getNegativeFeatures(2));\n+        assertTrue(v >= 0);\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Njc5NTgzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDo1OTo0N1rOGzOyiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTowMzoyMlrOG08XNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3Mjg3NQ==", "bodyText": "As many of tests in this lib are stochastic and results depend on random numbers generator I would suggest to create some logic which allows us to run these tests also with different seed. I mean to have fixed default value, but also possibility to change seed using some env. variable etc. This will allow us to test this lib more robust. I can for example do few runs with with different seed to see whether these methods are really robust or the results are within some tollerance. What do you think?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456372875", "createdAt": "2020-07-17T10:59:47Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQwODYyOA==", "bodyText": "I have a quite strong opinion on using random in unit tests. If internally the library is using random, then I agree with @jiripetrlik that it's good to use different and fixed seeds during the initialization of the tests (and use a test factory to make it more clean from a code perspective). But I really think we should not generate random data upfront for our tests (for example in this class with features.add(TestUtils.getRandomFeature());), even if the seed is fixed because it's really impossible to understand what are the scenarios that are covered by the tests and the tests are not repeatable.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456408628", "createdAt": "2020-07-17T12:25:21Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3Mjg3NQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAzNDQzMg==", "bodyText": "@r00ta Yes, completely agree with you. It is not good to have completely random unit tests. My suggestion was about possibility to simply change the seed for tests and try it also with different  seed if needed.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458034432", "createdAt": "2020-07-21T11:45:08Z", "author": {"login": "jiripetrlik"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3Mjg3NQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2ODExNw==", "bodyText": "I have dropped the randomization in all tests.\nThere's some randomness in the way LIME picks the feature to perturb, that has to be made fixed in tests via setting a random seed.\nAlso in general I agree with you, just note the randomization in tests that work on numeric and text data is sometimes useful in order to capture edge cases (btw that's what Apache Lucene does for example, see [1,2]) and strange combinations (e.g. wrt certain text encoding/locale scenarios) especially while developing a library (you have less control on what the user inputs to it).\n[1] : https://labs.carrotsearch.com/randomizedtesting.html\n[2] : https://www.youtube.com/watch?v=zD57QKzqdCw", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458168117", "createdAt": "2020-07-21T15:03:22Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.explainability.TestUtils;\n+import org.kie.kogito.explainability.model.BlackBoxModel;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+\n+class LimeExplainerTest {\n+\n+    @BeforeAll\n+    static void setUpBefore() {\n+        DataUtils.seed(4);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3Mjg3NQ=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjgwMzQ0OnYy", "diffSide": "LEFT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMTowMjozNVrOGzO3LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNDoxNToxN1rOGzUtXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDA2MA==", "bodyText": "What is the reason to remove word \"service\"?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456374060", "createdAt": "2020-07-17T11:02:35Z", "author": {"login": "jiripetrlik"}, "path": "pom.xml", "diffHunk": "@@ -71,7 +71,7 @@\n     <module>ui-packages</module>\n     <module>management-console</module>\n     <module>task-console</module>\n-    <module>explainability-service</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM4MDk2OQ==", "bodyText": "I think it is for the same reason we did it with trusty module: this module will contain a core library and a service module so it is probably to avoid a explainable-service-service module :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456380969", "createdAt": "2020-07-17T11:19:44Z", "author": {"login": "danielezonca"}, "path": "pom.xml", "diffHunk": "@@ -71,7 +71,7 @@\n     <module>ui-packages</module>\n     <module>management-console</module>\n     <module>task-console</module>\n-    <module>explainability-service</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDA2MA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2OTg1Mg==", "bodyText": "exactly @danielezonca", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r456469852", "createdAt": "2020-07-17T14:15:17Z", "author": {"login": "tteofili"}, "path": "pom.xml", "diffHunk": "@@ -71,7 +71,7 @@\n     <module>ui-packages</module>\n     <module>management-console</module>\n     <module>task-console</module>\n-    <module>explainability-service</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3NDA2MA=="}, "originalCommit": {"oid": "f9b30620f5caf4cceb159693741ebe9903ffe80f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzE1MDU0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMDoyNDozNlrOG0EznA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDozMjowN1rOG064Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI1Nzg4NA==", "bodyText": "If trainingSet.isEmpty() is true this function is going to return 1. Is this the correct behaviour (even if atm the return value is never used)?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r457257884", "createdAt": "2020-07-20T10:24:36Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double floss = 1d;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a65c09909c64ca9acee6d894943f7c4529b354ec"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0Mzc4Mw==", "bodyText": "the initial value should be NaN instead of 1, other than that the return value is used in tests to make sure it converges.\nI'll make sure to use it also inside LimeExplainer as a sanity check that the linear model is a good fit.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458143783", "createdAt": "2020-07-21T14:32:07Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/LinearModel.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.stream.IntStream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A linear model implementation based on perceptron algorithm.\n+ */\n+public class LinearModel {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LinearModel.class);\n+\n+    private final double[] weights;\n+    private final boolean classification;\n+    private double bias;\n+\n+    public LinearModel(int size, boolean classification) {\n+        this.bias = 0;\n+        this.weights = new double[size];\n+        this.classification = classification;\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet) {\n+        double[] sampleWeights = new double[trainingSet.size()];\n+        Arrays.fill(sampleWeights, 1);\n+        return fit(trainingSet, sampleWeights);\n+    }\n+\n+    public double fit(Collection<Pair<double[], Double>> trainingSet, double[] sampleWeights) {\n+        double floss = 1d;\n+        if (trainingSet.isEmpty()) {\n+            logger.warn(\"fitting an empty training set\");\n+        } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI1Nzg4NA=="}, "originalCommit": {"oid": "a65c09909c64ca9acee6d894943f7c4529b354ec"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjA5ODU2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODo0NToxMlrOG1Y1lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjo0OToxNlrOG1g3Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzNDY0Nw==", "bodyText": "Is this needed?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458634647", "createdAt": "2020-07-22T08:45:12Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NjA5OA==", "bodyText": "no, correct. thanks!", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458766098", "createdAt": "2020-07-22T12:49:16Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/pom.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\"?>\n+<project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n+  <parent>\n+    <groupId>org.kie.kogito</groupId>\n+    <artifactId>explainability</artifactId>\n+    <version>8.0.0-SNAPSHOT</version>\n+  </parent>\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <artifactId>explainability-core</artifactId>\n+  <name>Kogito :: Explainability Core</name>\n+  <dependencies>\n+    <dependency>\n+      <groupId>org.slf4j</groupId>\n+      <artifactId>slf4j-api</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.apache.commons</groupId>\n+      <artifactId>commons-lang3</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.junit.jupiter</groupId>\n+      <artifactId>junit-jupiter</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzNDY0Nw=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjE3MjY1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTowNDoxOFrOG1Zi9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNDoxODoyOVrOG1kmiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY0NjI2MQ==", "bodyText": "What about a refactoring like\n    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n        List<List<Double>> columnData = new LinkedList<>();\n\n        for (int t = 0; t < targetInput.getFeatures().size(); t++) {\n            Feature originalFeature = targetInput.getFeatures().get(t);\n            switch (originalFeature.getType()) {\n\nso that we avoid to open a stream and iterate on targetInput", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458646261", "createdAt": "2020-07-22T09:04:18Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyNzQwMA==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458827400", "createdAt": "2020-07-22T14:18:29Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY0NjI2MQ=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjIwOTYxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToxNDoxNlrOG1Z6KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozNzoxMVrOG1iwjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1MjIwMQ==", "bodyText": "What's the gain of sorting and then using a binary search? this thing is going to be O(nlogn) instead of O(n) with a simple linear scan", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458652201", "createdAt": "2020-07-22T09:14:16Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+            }\n+        }\n+        return columnData;\n+    }\n+\n+    private static void encodeNumbers(List<PredictionInput> predictionInputs, PredictionInput originalInputs, List<List<Double>> columnData, int t) {\n+        // find maximum and minimum values\n+        double[] doubles = new double[predictionInputs.size() + 1];\n+        int i = 0;\n+        for (PredictionInput pi : predictionInputs) {\n+            Feature feature = pi.getFeatures().get(t);\n+            doubles[i] = feature.getValue().asNumber();\n+            i++;\n+        }\n+        Feature feature = originalInputs.getFeatures().get(t);\n+        double originalValue = feature.getValue().asNumber();\n+        doubles[i] = originalValue;\n+        double min = DoubleStream.of(doubles).min().getAsDouble();\n+        double max = DoubleStream.of(doubles).max().getAsDouble();\n+        // feature scaling + kernel based clustering\n+        double threshold = DataUtils.gaussianKernel((originalValue - min) / (max - min));\n+        List<Double> featureValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min))\n+                .map(d -> Double.isNaN(d) ? 1 : d).boxed().map(DataUtils::gaussianKernel)\n+                .map(d -> (d - threshold < 1e-3) ? 1d : 0d).collect(Collectors.toList());\n+        columnData.add(featureValues);\n+    }\n+\n+    private static void encodeText(List<PredictionInput> predictionInputs, List<List<Double>> columnData, Feature originalFeature) {\n+        String originalString = originalFeature.getValue().asString();\n+        String[] words = originalString.split(\" \");\n+        for (String word : words) {\n+            List<Double> featureValues = new LinkedList<>();\n+            for (PredictionInput pi : predictionInputs) {\n+                Feature feature = pi.getFeatures().stream().filter(f -> f.getName().equals(originalFeature.getName())).findFirst().orElse(null);\n+                double featureValue;\n+                if (feature != null && feature.getName().equals(originalFeature.getName())) {\n+                    String perturbedString = feature.getValue().asString();\n+                    String[] perturbedWords = perturbedString.split(\" \");\n+                    Arrays.sort(perturbedWords);\n+                    featureValue = Arrays.binarySearch(perturbedWords, word) >= 0 ? 1d : 0d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5NzE5OA==", "bodyText": "agreed", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458797198", "createdAt": "2020-07-22T13:37:11Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/DatasetEncoder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+\n+/**\n+ * Encoder algorithm to transform perturbed inputs and outputs into a training set that the {@link LinearModel} can use.\n+ * The target inputs and output are needed in order to distinguish when the value of a certain feature corresponds or\n+ * is close to the one of the prediction to be explained.\n+ */\n+class DatasetEncoder {\n+\n+    private final List<PredictionInput> perturbedInputs;\n+    private final List<Output> predictedOutputs;\n+    private final PredictionInput targetInput;\n+    private final Output originalOutput;\n+\n+    DatasetEncoder(List<PredictionInput> perturbedInputs, List<Output> perturbedOutputs,\n+                   PredictionInput targetInput, Output targetOutput) {\n+        this.perturbedInputs = perturbedInputs;\n+        this.predictedOutputs = perturbedOutputs;\n+        this.targetInput = targetInput;\n+        this.originalOutput = targetOutput;\n+    }\n+\n+    /**\n+     * Get the input and output predictions transformed into a numerical training set.\n+     *\n+     * @return a numerical training set\n+     */\n+    List<Pair<double[], Double>> getEncodedTrainingSet() {\n+        List<Pair<double[], Double>> trainingSet = new LinkedList<>();\n+        List<List<Double>> columnData;\n+        List<PredictionInput> flatInputs = DataUtils.linearizeInputs(perturbedInputs);\n+        if (!flatInputs.isEmpty() && !predictedOutputs.isEmpty() && !targetInput.getFeatures().isEmpty() && originalOutput != null) {\n+            columnData = getColumnData(flatInputs);\n+\n+            int pi = 0;\n+            for (Output output : predictedOutputs) {\n+                double[] x = new double[columnData.size()];\n+                int i = 0;\n+                for (List<Double> column : columnData) {\n+                    x[i] = column.get(pi);\n+                    i++;\n+                }\n+                double y;\n+                if (Type.NUMBER.equals(originalOutput.getType()) || Type.BOOLEAN.equals(originalOutput.getType())) {\n+                    y = output.getValue().asNumber();\n+                } else {\n+                    Object originalObject = originalOutput.getValue().getUnderlyingObject();\n+                    Object outputObject = output.getValue().getUnderlyingObject();\n+                    if (originalObject == null || outputObject == null) {\n+                        y = originalObject == outputObject ? 1d : 0d;\n+                    } else {\n+                        y = originalObject.equals(outputObject) ? 1d : 0d;\n+                    }\n+                }\n+                Pair<double[], Double> sample = new ImmutablePair<>(x, y);\n+                trainingSet.add(sample);\n+\n+                pi++;\n+            }\n+        }\n+        return trainingSet;\n+    }\n+\n+    private List<List<Double>> getColumnData(List<PredictionInput> perturbedInputs) {\n+        List<Type> featureTypes = targetInput.getFeatures().stream().map(Feature::getType).collect(Collectors.toList());\n+        List<List<Double>> columnData = new LinkedList<>();\n+\n+        for (int t = 0; t < featureTypes.size(); t++) {\n+            Feature originalFeature = targetInput.getFeatures().get(t);\n+            switch (featureTypes.get(t)) {\n+                case NUMBER:\n+                    encodeNumbers(perturbedInputs, targetInput, columnData, t);\n+                    break;\n+                case TEXT:\n+                    encodeText(perturbedInputs, columnData, originalFeature);\n+                    break;\n+                case CATEGORICAL:\n+                case BINARY:\n+                case TIME:\n+                case URI:\n+                case DURATION:\n+                case VECTOR:\n+                case CURRENCY:\n+                case UNDEFINED:\n+                    encodeEquals(perturbedInputs, columnData, t, originalFeature);\n+                    break;\n+                case BOOLEAN:\n+                    // boolean are automatically encoded as 1s or 0s\n+                    List<Double> featureValues = new LinkedList<>();\n+                    for (PredictionInput pi : perturbedInputs) {\n+                        featureValues.add(pi.getFeatures().get(t).getValue().asNumber());\n+                    }\n+                    columnData.add(featureValues);\n+                    break;\n+            }\n+        }\n+        return columnData;\n+    }\n+\n+    private static void encodeNumbers(List<PredictionInput> predictionInputs, PredictionInput originalInputs, List<List<Double>> columnData, int t) {\n+        // find maximum and minimum values\n+        double[] doubles = new double[predictionInputs.size() + 1];\n+        int i = 0;\n+        for (PredictionInput pi : predictionInputs) {\n+            Feature feature = pi.getFeatures().get(t);\n+            doubles[i] = feature.getValue().asNumber();\n+            i++;\n+        }\n+        Feature feature = originalInputs.getFeatures().get(t);\n+        double originalValue = feature.getValue().asNumber();\n+        doubles[i] = originalValue;\n+        double min = DoubleStream.of(doubles).min().getAsDouble();\n+        double max = DoubleStream.of(doubles).max().getAsDouble();\n+        // feature scaling + kernel based clustering\n+        double threshold = DataUtils.gaussianKernel((originalValue - min) / (max - min));\n+        List<Double> featureValues = DoubleStream.of(doubles).map(d -> (d - min) / (max - min))\n+                .map(d -> Double.isNaN(d) ? 1 : d).boxed().map(DataUtils::gaussianKernel)\n+                .map(d -> (d - threshold < 1e-3) ? 1d : 0d).collect(Collectors.toList());\n+        columnData.add(featureValues);\n+    }\n+\n+    private static void encodeText(List<PredictionInput> predictionInputs, List<List<Double>> columnData, Feature originalFeature) {\n+        String originalString = originalFeature.getValue().asString();\n+        String[] words = originalString.split(\" \");\n+        for (String word : words) {\n+            List<Double> featureValues = new LinkedList<>();\n+            for (PredictionInput pi : predictionInputs) {\n+                Feature feature = pi.getFeatures().stream().filter(f -> f.getName().equals(originalFeature.getName())).findFirst().orElse(null);\n+                double featureValue;\n+                if (feature != null && feature.getName().equals(originalFeature.getName())) {\n+                    String perturbedString = feature.getValue().asString();\n+                    String[] perturbedWords = perturbedString.split(\" \");\n+                    Arrays.sort(perturbedWords);\n+                    featureValue = Arrays.binarySearch(perturbedWords, word) >= 0 ? 1d : 0d;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1MjIwMQ=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjIyNDg0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToxODoyN1rOG1aDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzo1NTo0MFrOG1jmRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NDYwMw==", "bodyText": "There might be models without inputs, get(0) without checks on the size is dangerous", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458654603", "createdAt": "2020-07-22T09:18:27Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMDk1MQ==", "bodyText": "there shouldn't be predictions without inputs as well as there shouldn't be inputs without features, that wouldn't make much sense.\nAnyway I'll add some checks to avoid ugly exceptions in case of malformed inputs.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458810951", "createdAt": "2020-07-22T13:55:40Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NDYwMw=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjIzMTY2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyMDowNFrOG1aHsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjozNDoxNFrOG19yQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NTY2Nw==", "bodyText": "This method is pretty big, would it be possible to refactor it with some private methods so that it's clear what are the steps that the algorithm is making? If this does not make sense to you, ignore it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458655667", "createdAt": "2020-07-22T09:20:04Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0MDAwMA==", "bodyText": "I have abstracted the dataset encoding and sample weighting responsibilities in different classes exactly because of that, let me see if I can refactor more portions of the method body in private methods or separate classes.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459240000", "createdAt": "2020-07-23T06:34:14Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NTY2Nw=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI0MzkzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyMzowNFrOG1aO9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNDoyMjowMVrOG1kwqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NzUyNg==", "bodyText": "make this configurable?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458657526", "createdAt": "2020-07-22T09:23:04Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyOTk5Mw==", "bodyText": "in general, why not, my only concern is trying not letting users shoot in their own feet by giving them too much flexibility in the configuration :) anyway I think a reasonable default would work, so yes.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458829993", "createdAt": "2020-07-22T14:22:01Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NzUyNg=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI2MzkxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyODozMlrOG1abkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyNTowMlrOG1nqFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDc1NA==", "bodyText": "Why linkedlist?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458660754", "createdAt": "2020-07-22T09:28:32Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3NzQ2MA==", "bodyText": "because prior to linearizing the inputs/features we don't know how many items the List will contain and hence using e.g. an ArrayList with a fixed size constructor is not possible.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458877460", "createdAt": "2020-07-22T15:25:02Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDc1NA=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjYyOTEzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxNzoxOFrOG1d8Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNToyMjoxM1rOG1nhwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxODMwMg==", "bodyText": "why do we add the perturbed inputs/outputs if tries == 0? at the end if separableDataset is false this operation is without effects", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458718302", "createdAt": "2020-07-22T11:17:18Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3NTMyOA==", "bodyText": "prior to throwing an Exception, when the dataset is not easily separable the impl used to try to train linear classifier anyway. I'll fix it.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458875328", "createdAt": "2020-07-22T15:22:13Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxODMwMg=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjYzNDQ0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxOTowOFrOG1d_oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjo0MToyNVrOG198Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxOTEzNg==", "bodyText": "what about a refactoring like\n                    for (int tries = MAX_RETRY; tries > 0; tries--){\n                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n\n                        Value<?> fv = currentOutput.getValue();\n\n                        int finalO = o;\n                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n\n                        if (rawClassesBalance.size() > 1) {\n                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n                            if ((double) max / (double) perturbed.size() < 0.99) {\n                                separableDataset = true;\n                                classification = rawClassesBalance.size() == 2;\n                                perturbedInputs.addAll(perturbed);\n                                predictionOutputs.addAll(perturbedOutputs);\n                            } \n                        } \n                    }\n``` ?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458719136", "createdAt": "2020-07-22T11:19:08Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0MjU1NQ==", "bodyText": "sounds good, I'd only add a break statement in the \"succeeding\" block to avoid always running the whole cycle three times.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459242555", "createdAt": "2020-07-23T06:41:25Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxOTEzNg=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY0NTM2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToyMjo1NFrOG1eGTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToyMjo1NFrOG1eGTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMDg0NQ==", "bodyText": "cast not needed", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458720845", "createdAt": "2020-07-22T11:22:54Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }\n+                    if (!separableDataset) {\n+                        throw new DatasetNotSeparableException(currentOutput, rawClassesBalance);\n+                    }\n+                    List<Output> predictedOutputs = new LinkedList<>();\n+                    for (int i = 0; i < perturbedInputs.size(); i++) {\n+                        Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                        predictedOutputs.add(output);\n+                    }\n+\n+                    Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+                    DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+                    Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+                    double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+                    LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+                    double loss = linearModel.fit(trainingSet, sampleWeights);\n+                    if (!Double.isNaN(loss)) {\n+                        for (int i = 0; i < weights.length; i++) {\n+                            weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY1MDkwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToyNDo0NlrOG1eJyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjo0NDo1OFrOG1-BfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMTczNw==", "bodyText": "weights = Arrays.stream(linearModel.getWeights()).map(x -> x / actualOutputs.size()).toArray();?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458721737", "createdAt": "2020-07-22T11:24:46Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }\n+                    if (!separableDataset) {\n+                        throw new DatasetNotSeparableException(currentOutput, rawClassesBalance);\n+                    }\n+                    List<Output> predictedOutputs = new LinkedList<>();\n+                    for (int i = 0; i < perturbedInputs.size(); i++) {\n+                        Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                        predictedOutputs.add(output);\n+                    }\n+\n+                    Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+                    DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+                    Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+                    double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+                    LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+                    double loss = linearModel.fit(trainingSet, sampleWeights);\n+                    if (!Double.isNaN(loss)) {\n+                        for (int i = 0; i < weights.length; i++) {\n+                            weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0MzkwMA==", "bodyText": "sounds good", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459243900", "createdAt": "2020-07-23T06:44:58Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }\n+                    if (!separableDataset) {\n+                        throw new DatasetNotSeparableException(currentOutput, rawClassesBalance);\n+                    }\n+                    List<Output> predictedOutputs = new LinkedList<>();\n+                    for (int i = 0; i < perturbedInputs.size(); i++) {\n+                        Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                        predictedOutputs.add(output);\n+                    }\n+\n+                    Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+                    DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+                    Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+                    double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+                    LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+                    double loss = linearModel.fit(trainingSet, sampleWeights);\n+                    if (!Double.isNaN(loss)) {\n+                        for (int i = 0; i < weights.length; i++) {\n+                            weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMTczNw=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY1ODg2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToyNzoyNlrOG1eOqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTozNDozNFrOG2DGjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMjk4Ng==", "bodyText": "I don't 100% like big try/catch(Exception) 'cause it means we don't really control what is going on there, is there a specify reason why we have to catch everything?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458722986", "createdAt": "2020-07-22T11:27:26Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }\n+                    if (!separableDataset) {\n+                        throw new DatasetNotSeparableException(currentOutput, rawClassesBalance);\n+                    }\n+                    List<Output> predictedOutputs = new LinkedList<>();\n+                    for (int i = 0; i < perturbedInputs.size(); i++) {\n+                        Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                        predictedOutputs.add(output);\n+                    }\n+\n+                    Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+                    DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+                    Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+                    double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+                    LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+                    double loss = linearModel.fit(trainingSet, sampleWeights);\n+                    if (!Double.isNaN(loss)) {\n+                        for (int i = 0; i < weights.length; i++) {\n+                            weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();\n+                        }\n+                        logger.debug(\"weights updated for output {}\", currentOutput);\n+                    }\n+                } else {\n+                    logger.debug(\"skipping explanation of empty output {}\", currentOutput);\n+                }\n+            }\n+            for (int i = 0; i < weights.length; i++) {\n+                FeatureImportance featureImportance = new FeatureImportance(linearizedTargetInputFeatures.get(i), weights[i]);\n+                saliencies.add(featureImportance);\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNzExNg==", "bodyText": "apart personal taste I think it's good to carefully consider expected failures only, I'll drop the generic try/catch(Exception) block.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459327116", "createdAt": "2020-07-23T09:34:34Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.local.LocalExplainer;\n+import org.kie.kogito.explainability.local.LocalExplanationException;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Output;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.model.Type;\n+import org.kie.kogito.explainability.model.Value;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+import org.kie.kogito.explainability.utils.LinearModel;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An implementation of LIME algorithm (Ribeiro et al., 2016) that handles tabular data, text data, complex hierarchically\n+ * organized data, etc. seamlessly.\n+ *\n+ * Differences with respect to the original (python) implementation:\n+ * - the linear (interpretable) model is based on a perceptron algorithm instead of Lasso + Ridge regression\n+ * - perturbing numerical features is done by sampling from a normal distribution centered around the value of the feature value associated with the prediction to be explained\n+ * - numerical features are max-min scaled and clustered via a gaussian kernel\n+ */\n+public class LimeExplainer implements LocalExplainer<Saliency> {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LimeExplainer.class);\n+\n+    /**\n+     * no. of samples to be generated for the local linear model training\n+     */\n+    private final int noOfSamples;\n+\n+    /**\n+     * no. of perturbations to perform on a prediction\n+     */\n+    private final int noOfPerturbations;\n+\n+    public LimeExplainer(int noOfSamples, int noOfPerturbations) {\n+        this.noOfSamples = noOfSamples;\n+        this.noOfPerturbations = noOfPerturbations;\n+    }\n+\n+    @Override\n+    public Saliency explain(Prediction prediction, PredictionProvider model) {\n+\n+        long start = System.currentTimeMillis();\n+\n+        List<FeatureImportance> saliencies = new LinkedList<>();\n+        try {\n+            PredictionInput originalInput = prediction.getInput();\n+            List<Feature> inputFeatures = originalInput.getFeatures();\n+            PredictionInput targetInput = DataUtils.linearizeInputs(List.of(originalInput)).get(0);\n+            List<Feature> linearizedTargetInputFeatures = targetInput.getFeatures();\n+            List<Output> actualOutputs = prediction.getOutput().getOutputs();\n+            int noOfInputFeatures = inputFeatures.size();\n+            int noOfOutputFeatures = linearizedTargetInputFeatures.size();\n+            double[] weights = new double[noOfOutputFeatures];\n+\n+            for (int o = 0; o < actualOutputs.size(); o++) {\n+                boolean separableDataset = false;\n+\n+                List<PredictionInput> perturbedInputs = new LinkedList<>();\n+                List<PredictionOutput> predictionOutputs = new LinkedList<>();\n+\n+                boolean classification = false;\n+                Output currentOutput = actualOutputs.get(o);\n+                if (currentOutput.getValue() != null && currentOutput.getValue().getUnderlyingObject() != null) {\n+                    Map<Double, Long> rawClassesBalance = new HashMap<>();\n+                    int tries = 3;\n+                    while (!separableDataset && tries > 0) {\n+                        List<PredictionInput> perturbed = getPerturbedInputs(originalInput, noOfInputFeatures, noOfSamples);\n+                        List<PredictionOutput> perturbedOutputs = model.predict(perturbed);\n+\n+                        Value<?> fv = currentOutput.getValue();\n+\n+                        int finalO = o;\n+                        rawClassesBalance = perturbedOutputs.stream().map(p -> p.getOutputs().get(finalO)).map(output -> (Type.NUMBER\n+                                .equals(output.getType())) ? output.getValue().asNumber() : (((output.getValue().getUnderlyingObject() == null\n+                                && fv.getUnderlyingObject() == null) || (output.getValue().getUnderlyingObject() != null && output.getValue().asString().equals(fv.asString()))) ? 1d : 0d))\n+                                .collect(Collectors.groupingBy(Double::doubleValue, Collectors.counting()));\n+                        logger.debug(\"raw samples per class: {}\", rawClassesBalance);\n+\n+                        if (rawClassesBalance.size() > 1) {\n+                            Long max = rawClassesBalance.values().stream().max(Long::compareTo).orElse(1L);\n+                            if ((double) max / (double) perturbed.size() < 0.99) {\n+                                separableDataset = true;\n+                                classification = rawClassesBalance.size() == 2;\n+                            } else {\n+                                tries--;\n+                            }\n+                        } else {\n+                            tries--;\n+                        }\n+                        if (tries == 0 || separableDataset) {\n+                            perturbedInputs.addAll(perturbed);\n+                            predictionOutputs.addAll(perturbedOutputs);\n+                        }\n+                    }\n+                    if (!separableDataset) {\n+                        throw new DatasetNotSeparableException(currentOutput, rawClassesBalance);\n+                    }\n+                    List<Output> predictedOutputs = new LinkedList<>();\n+                    for (int i = 0; i < perturbedInputs.size(); i++) {\n+                        Output output = predictionOutputs.get(i).getOutputs().get(o);\n+                        predictedOutputs.add(output);\n+                    }\n+\n+                    Output originalOutput = prediction.getOutput().getOutputs().get(o);\n+\n+                    DatasetEncoder datasetEncoder = new DatasetEncoder(perturbedInputs, predictedOutputs, targetInput, originalOutput);\n+                    Collection<Pair<double[], Double>> trainingSet = datasetEncoder.getEncodedTrainingSet();\n+\n+                    double[] sampleWeights = SampleWeighter.getSampleWeights(targetInput, trainingSet);\n+\n+                    LinearModel linearModel = new LinearModel(linearizedTargetInputFeatures.size(), classification);\n+                    double loss = linearModel.fit(trainingSet, sampleWeights);\n+                    if (!Double.isNaN(loss)) {\n+                        for (int i = 0; i < weights.length; i++) {\n+                            weights[i] += linearModel.getWeights()[i] / (double) actualOutputs.size();\n+                        }\n+                        logger.debug(\"weights updated for output {}\", currentOutput);\n+                    }\n+                } else {\n+                    logger.debug(\"skipping explanation of empty output {}\", currentOutput);\n+                }\n+            }\n+            for (int i = 0; i < weights.length; i++) {\n+                FeatureImportance featureImportance = new FeatureImportance(linearizedTargetInputFeatures.get(i), weights[i]);\n+                saliencies.add(featureImportance);\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMjk4Ng=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY2ODAyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozMDoyOFrOG1eUMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNjo0NTozNlrOG1-CeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyNDQwMQ==", "bodyText": "Move to constant?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458724401", "createdAt": "2020-07-22T11:30:28Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+/**\n+ * Utility class to generate weights for the LIME encoded training set, given a prediction.\n+ */\n+class SampleWeighter {\n+\n+    static double[] getSampleWeights(PredictionInput targetInput, Collection<Pair<double[], Double>> training) {\n+        int noOfFeatures = targetInput.getFeatures().size();\n+        double[] x = new double[noOfFeatures];\n+        Arrays.fill(x, 1);\n+\n+        return training.stream().map(Pair::getLeft).map(\n+                d -> DataUtils.euclideanDistance(x, d)).map(d -> DataUtils.exponentialSmoothingKernel(d, 0.75 *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0NDE1Mw==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459244153", "createdAt": "2020-07-23T06:45:36Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/SampleWeighter.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.utils.DataUtils;\n+\n+/**\n+ * Utility class to generate weights for the LIME encoded training set, given a prediction.\n+ */\n+class SampleWeighter {\n+\n+    static double[] getSampleWeights(PredictionInput targetInput, Collection<Pair<double[], Double>> training) {\n+        int noOfFeatures = targetInput.getFeatures().size();\n+        double[] x = new double[noOfFeatures];\n+        Arrays.fill(x, 1);\n+\n+        return training.stream().map(Pair::getLeft).map(\n+                d -> DataUtils.euclideanDistance(x, d)).map(d -> DataUtils.exponentialSmoothingKernel(d, 0.75 *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyNDQwMQ=="}, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY2OTU1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Feature.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozMDo1NVrOG1eVGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozMDo1NVrOG1eVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyNDYzNA==", "bodyText": "Capital (and in the following methods) : )", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458724634", "createdAt": "2020-07-22T11:30:55Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Feature.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * A feature represents fixed portions of an input, having a name, a {@link Type} and an associated {@link Value}.\n+ */\n+public class Feature {\n+\n+    private final String name;\n+    private final Type type;\n+    private final Value value;\n+\n+    Feature(String name, Type type, Value value) {\n+        this.name = name;\n+        this.type = type;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * the name of the feature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY3MDcwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureDistribution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozMToyMlrOG1eV3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozMToyMlrOG1eV3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyNDgzMA==", "bodyText": "Capital", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458724830", "createdAt": "2020-07-22T11:31:22Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureDistribution.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * The data distribution for a given feature.\n+ */\n+public class FeatureDistribution {\n+\n+    private final double min;\n+    private final double max;\n+    private final double mean;\n+    private final double stdDev;\n+\n+    public FeatureDistribution(double min, double max, double mean, double stdDev) {\n+        this.min = min;\n+        this.max = max;\n+        this.mean = mean;\n+        this.stdDev = stdDev;\n+    }\n+\n+    /**\n+     * get minimum value for this feature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27bacc8c139c607a3cc2ccdf31d4efa1eb0ad44"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjY5NDEyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTozODo0OFrOG1ekIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwNzoyODowMFrOG1_Ftg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyODQ4MQ==", "bodyText": "Could you add a test for complex nested (more than 1 level) structures created with newCompositeFeature?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458728481", "createdAt": "2020-07-22T11:38:48Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class FeatureFactoryTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI2MTM2Ng==", "bodyText": "sure :)", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459261366", "createdAt": "2020-07-23T07:28:00Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/model/FeatureFactoryTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class FeatureFactoryTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyODQ4MQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjcwMzM5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/PredictionProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0MTozNFrOG1eptA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0MTozNFrOG1eptA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyOTkwOA==", "bodyText": "capital", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458729908", "createdAt": "2020-07-22T11:41:34Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/PredictionProvider.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.List;\n+\n+/**\n+ * A provider of predictions.\n+ * This can be any model, service or function, like (local / remote) DMN, PMML services or any other ML model.\n+ */\n+public interface PredictionProvider {\n+\n+    /**\n+     * perform a batch of predictions, given a batch of inputs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjcwNjk2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/PredictionProviderMetadata.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0MjozMVrOG1erug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0MjozMVrOG1erug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMDQyNg==", "bodyText": "capital", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458730426", "createdAt": "2020-07-22T11:42:31Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/PredictionProviderMetadata.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * Metadata about a given {@link PredictionProvider}.\n+ */\n+public interface PredictionProviderMetadata {\n+\n+    /**\n+     * fetch the data distribution associated to this model", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjcyMzE1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0NzoyM1rOG1e1Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwOTozOTo0NFrOG2DRTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMjg3MQ==", "bodyText": "Are these the build types we support atm right? I know the explainability applies to all the models, but we also have to consider that we have to target DMN and its types to properly perturb the inputs.\nafaik there are a couple of fancy build in types like \"years and months duration\" that we will have to support as well. I'm not saying we should support all of them now in this PR, but it might be good to create a ticket for that to keep track. wdyt? cc @danielezonca", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458732871", "createdAt": "2020-07-22T11:47:23Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * Allowed data types.\n+ */\n+public enum Type {\n+\n+    TEXT(\"text\"),\n+\n+    CATEGORICAL(\"categorical\"),\n+\n+    BINARY(\"binary\"),\n+\n+    NUMBER(\"number\"),\n+\n+    BOOLEAN(\"boolean\"),\n+\n+    URI(\"uri\"),\n+\n+    TIME(\"time\"),\n+\n+    DURATION(\"duration\"),\n+\n+    VECTOR(\"vector\"),\n+\n+    UNDEFINED(\"undefined\"),\n+\n+    COMPOSITE(\"composite\"),\n+\n+    CURRENCY(\"currency\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI0OTMwMA==", "bodyText": "Here the idea is simplify the integration of an external \"engine\" with explainable-service: instead of just accept plain array of double and ask to do all the conversion on engine side we will support a richer set of data types.\nI am not sure about how far we want to go with this and we need to find a tradeoff: it is always possible to add a new type or manually convert the value.\nIn general I agree we should try to support all builtin DMN types so feel free to create a ticket to track missing types", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459249300", "createdAt": "2020-07-23T06:58:59Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * Allowed data types.\n+ */\n+public enum Type {\n+\n+    TEXT(\"text\"),\n+\n+    CATEGORICAL(\"categorical\"),\n+\n+    BINARY(\"binary\"),\n+\n+    NUMBER(\"number\"),\n+\n+    BOOLEAN(\"boolean\"),\n+\n+    URI(\"uri\"),\n+\n+    TIME(\"time\"),\n+\n+    DURATION(\"duration\"),\n+\n+    VECTOR(\"vector\"),\n+\n+    UNDEFINED(\"undefined\"),\n+\n+    COMPOSITE(\"composite\"),\n+\n+    CURRENCY(\"currency\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMjg3MQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyOTg2OA==", "bodyText": "when coming with this initial set of types to support I have looked at some DMN models as well as trying to think what generally makes sense or is commonly used in ML models in terms of features. Any possible enrichment to the supported data types is welcome I'd say.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459329868", "createdAt": "2020-07-23T09:39:44Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+/**\n+ * Allowed data types.\n+ */\n+public enum Type {\n+\n+    TEXT(\"text\"),\n+\n+    CATEGORICAL(\"categorical\"),\n+\n+    BINARY(\"binary\"),\n+\n+    NUMBER(\"number\"),\n+\n+    BOOLEAN(\"boolean\"),\n+\n+    URI(\"uri\"),\n+\n+    TIME(\"time\"),\n+\n+    DURATION(\"duration\"),\n+\n+    VECTOR(\"vector\"),\n+\n+    UNDEFINED(\"undefined\"),\n+\n+    COMPOSITE(\"composite\"),\n+\n+    CURRENCY(\"currency\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMjg3MQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc1MjcwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1NjozOFrOG1fHpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1NjozOFrOG1fHpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczNzU3Mw==", "bodyText": "why not using underlyingObject  instanceof double[] ?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458737573", "createdAt": "2020-07-22T11:56:38Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc1NjU4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1Nzo1OFrOG1fKJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDowMTozNVrOG2D-kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODIxNQ==", "bodyText": "why can it fail with an Exception?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458738215", "createdAt": "2020-07-22T11:57:58Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM0MTQ1OQ==", "bodyText": "because asNumber throws a NumberFormatException if the underlyingObject cannot be parsed as a number. Maybe a good idea is to make asNumber return NaN in such cases and avoid throwing NFE.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459341459", "createdAt": "2020-07-23T10:01:35Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Value.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.model;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Wrapper class for any kind of value part of a prediction input or output.\n+ * @param <S>\n+ */\n+public class Value<S> {\n+\n+    private final S underlyingObject;\n+\n+    public Value(S underlyingObject) {\n+        this.underlyingObject = underlyingObject;\n+    }\n+\n+    public String asString() {\n+        return String.valueOf(underlyingObject);\n+    }\n+\n+    public double asNumber() {\n+        if (underlyingObject != null) {\n+            return underlyingObject instanceof Boolean ? (Boolean) underlyingObject ? 1d : 0d : Double.parseDouble(asString());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    public S getUnderlyingObject() {\n+        return underlyingObject;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Value{\" + underlyingObject + '}';\n+    }\n+\n+    public double[] asVector() {\n+        double[] doubles;\n+        try {\n+            doubles = (double[]) underlyingObject;\n+        } catch (ClassCastException cce) {\n+            if (underlyingObject instanceof String) {\n+                int noOfWords = ((String) underlyingObject).split(\" \").length;\n+                doubles = new double[noOfWords];\n+                Arrays.fill(doubles, 1);\n+            } else {\n+                try {\n+                    double v = asNumber();\n+                    doubles = new double[1];\n+                    doubles[0] = v;\n+                } catch (Exception e) {\n+                    doubles = new double[0];\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODIxNQ=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc1ODUzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1ODo0MVrOG1fLhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1ODo0MVrOG1fLhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODU2NA==", "bodyText": "rename to setSeed?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458738564", "createdAt": "2020-07-22T11:58:41Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc2MTEzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1OToyNVrOG1fNEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMDo0OTo0NFrOG2FZdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODk2Mg==", "bodyText": "why is it bounded to 10?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458738962", "createdAt": "2020-07-22T11:59:25Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2NDcyNA==", "bodyText": "to generate data less prune to underflow, 100 or 1000 would be fine as well though.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459364724", "createdAt": "2020-07-23T10:49:44Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODk2Mg=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc2MjU4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1OTo0OVrOG1fN7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo1OTo0OVrOG1fN7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczOTE4MQ==", "bodyText": "cast not needed", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458739181", "createdAt": "2020-07-22T11:59:49Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2Mjc3NzE3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNDoxNlrOG1fWvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNDoxNlrOG1fWvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTQzNg==", "bodyText": "Initialize to \"\" so that you can skip the assignments at lines 186 and 189?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458741436", "createdAt": "2020-07-22T12:04:16Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgwNDA5OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxMjozOVrOG1fnPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMToxNjo0NlrOG2GIyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTY2Mg==", "bodyText": "This is going to remove at max 2 words, is this intended?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458745662", "createdAt": "2020-07-22T12:12:39Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2ODQ0Mw==", "bodyText": "this is one of those very sensitive parameters in LIME, I think it's worth opening an investigation issue to assess a good default; this setting was the result of my experiments with our models, but it's worth investigating a bit more.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459368443", "createdAt": "2020-07-23T10:57:49Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTY2Mg=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3Njg0MA==", "bodyText": "I've created FAI-236 to handle this.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459376840", "createdAt": "2020-07-23T11:16:46Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NTY2Mg=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgxMjQ3OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxNDo1OFrOG1fsNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNDozNVrOG2GnNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NjkzMw==", "bodyText": "If stringValue ends with \" \", an exception is going to be raised by random.nextInt(0) at line 179. Could you fix it and add a test?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458746933", "createdAt": "2020-07-22T12:14:58Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDYzMQ==", "bodyText": "ok", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459384631", "createdAt": "2020-07-23T11:34:35Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NjkzMw=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgxNTk1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxNjowNFrOG1fubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxNjowNFrOG1fubw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NzUwMw==", "bodyText": "can you rename v?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458747503", "createdAt": "2020-07-22T12:16:04Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgxNjc0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxNjoxOFrOG1fu7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxNjoxOFrOG1fu7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0NzYzMQ==", "bodyText": "rename ov?", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458747631", "createdAt": "2020-07-22T12:16:18Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjgyNTgzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoxOTowN1rOG1f0mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMTozNzoxNFrOG2Gr9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0OTA4Mw==", "bodyText": "Not sure if it's the comment that is not aligned with the actual implementation, but Locale.getDefault is not going to return always EUR", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r458749083", "createdAt": "2020-07-22T12:19:07Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NTg0Ng==", "bodyText": "yes, the comment is wrong, as that depends on the machine the code is running actually.", "url": "https://github.com/kiegroup/kogito-apps/pull/324#discussion_r459385846", "createdAt": "2020-07-23T11:37:14Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/utils/DataUtils.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.utils;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.LocalTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Currency;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import org.kie.kogito.explainability.model.DataDistribution;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureDistribution;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.Type;\n+\n+/**\n+ * Utility methods to handle and manipulate data.\n+ */\n+public class DataUtils {\n+\n+    private final static SecureRandom random = new SecureRandom();\n+\n+    public static void seed(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * Generate a dataset of a certain size, given mean and standard deviation.\n+     * Samples are generated randomly, actual mean {@code m} and standard deviation {@code d} are calculated.\n+     * Then all numbers are multiplied by the same number so that the standard deviation also gets\n+     * multiplied by the same number, hence we multiply each random number by {@code stdDeviation / d}.\n+     * The resultant set has standard deviation {@code stdDeviation} and mean {@code m1=m*stdDeviation/d}.\n+     * If a same number is added to all values the mean also changes by the same number so we add {@code mean - m1} to\n+     * all numbers.\n+     *\n+     * @param mean         desired mean\n+     * @param stdDeviation desired standard deviation\n+     * @param size         size of the array\n+     * @return the generated data\n+     */\n+    public static double[] generateData(double mean, double stdDeviation, int size) {\n+        double[] data = new double[size];\n+        // generate random data\n+        for (int i = 0; i < size; i++) {\n+            double g = 1d / (1d + random.nextInt(10));\n+            data[i] = g;\n+        }\n+\n+        double m = getMean(data);\n+        double d = getStdDev(data, m);\n+\n+        // force desired standard deviation\n+        double d1 = stdDeviation / d;\n+        for (int i = 0; i < size; i++) {\n+            data[i] *= d1;\n+        }\n+\n+        // get the new mean\n+        double m1 = m * stdDeviation / d;\n+\n+        // force desired mean\n+        for (int i = 0; i < size; i++) {\n+            data[i] += mean - m1;\n+        }\n+\n+        return data;\n+    }\n+\n+    private static double getMean(double[] data) {\n+        double m = 0;\n+        for (double datum : data) {\n+            m += datum;\n+        }\n+        m = m / (double) data.length;\n+        return m;\n+    }\n+\n+    private static double getStdDev(double[] data, double mean) {\n+        double d = 0;\n+        for (double datum : data) {\n+            d += Math.pow(datum - mean, 2);\n+        }\n+        d /= data.length;\n+        d = Math.sqrt(d);\n+        return d;\n+    }\n+\n+    /**\n+     * Generate equally {@code size} sampled values between {@code min} and {@code max}.\n+     *\n+     * @param min  minimum value\n+     * @param max  maximum value\n+     * @param size dataset size\n+     * @return the generated data\n+     */\n+    public static double[] generateSamples(double min, double max, int size) {\n+        double[] data = new double[size];\n+        double val = min;\n+        double sum = max / size;\n+        for (int i = 0; i < size; i++) {\n+            data[i] = val;\n+            val += sum;\n+        }\n+        return data;\n+    }\n+\n+    public static List<Feature> doublesToFeatures(double[] inputs) {\n+        return DoubleStream.of(inputs).mapToObj(DataUtils::doubleToFeature).collect(Collectors.toList());\n+    }\n+\n+    public static Feature doubleToFeature(double d) {\n+        return FeatureFactory.newNumericalFeature(String.valueOf(d), d);\n+    }\n+\n+    public static PredictionInput perturbDrop(PredictionInput input, int noOfSamples, int noOfPerturbations) {\n+        List<Feature> originalFeatures = input.getFeatures();\n+        List<Feature> newFeatures = new ArrayList<>(originalFeatures);\n+        PredictionInput perturbedInput = new PredictionInput(newFeatures);\n+        int perturbationSize = Math.min(noOfPerturbations, originalFeatures.size());\n+        int[] indexesToBePerturbed = random.ints(0, perturbedInput.getFeatures().size()).distinct().limit(perturbationSize).toArray();\n+        // TODO : perturbing a composite / nested feature must be done by considering to only perturb #noOfPerturbations features\n+        for (int value : indexesToBePerturbed) {\n+            perturbedInput.getFeatures().set(value, perturbFeature(\n+                    perturbedInput.getFeatures().get(value), noOfSamples));\n+        }\n+        return perturbedInput;\n+    }\n+\n+    private static Feature perturbFeature(Feature feature, int noOfSamples) {\n+        Type type = feature.getType();\n+        Feature f;\n+        String featureName = feature.getName();\n+        switch (type) {\n+            case COMPOSITE:\n+                List<Feature> composite = (List<Feature>) feature.getValue().getUnderlyingObject();\n+                Map<String, Object> featuresMap = new HashMap<>();\n+                for (Feature cf : composite) {\n+                    if (random.nextBoolean()) {\n+                        featuresMap.put(cf.getName(), perturbFeature(cf, noOfSamples));\n+                    } else {\n+                        featuresMap.put(cf.getName(), cf);\n+                    }\n+                }\n+                f = FeatureFactory.newCompositeFeature(featureName, featuresMap);\n+                break;\n+            case TEXT:\n+                String newStringValue;\n+                // randomly drop entire string or parts of it\n+                if (random.nextBoolean()) {\n+                    String stringValue = feature.getValue().asString();\n+                    if (stringValue.indexOf(' ') != -1) {\n+                        List<String> words = new ArrayList<>(Arrays.asList(stringValue.split(\" \")));\n+                        int featuresToDrop = random.nextInt(Math.min(2, words.size() / 2));\n+                        for (int i = 0; i < 1 + featuresToDrop; i++) {\n+                            int dropIdx = random.nextInt(words.size());\n+                            words.remove(dropIdx);\n+                        }\n+                        newStringValue = String.join(\" \", words);\n+                    } else {\n+                        newStringValue = \"\";\n+                    }\n+                } else {\n+                    newStringValue = \"\";\n+                }\n+                f = FeatureFactory.newTextFeature(featureName, newStringValue);\n+                break;\n+            case NUMBER:\n+                double ov = feature.getValue().asNumber();\n+                boolean intValue = ov % 1 == 0;\n+\n+                // sample from normal distribution and center around feature value\n+                int pickIdx = random.nextInt(noOfSamples - 1);\n+                double v = DataUtils.generateData(0, 1, noOfSamples)[pickIdx];\n+                if (ov != 0d) {\n+                    v = v * ov + ov;\n+                }\n+                if (intValue) {\n+                    v = (int) v;\n+                    if (v == ov) {\n+                        v = (int) v * 10;\n+                    }\n+                }\n+                f = FeatureFactory.newNumericalFeature(featureName, v);\n+                break;\n+            case BOOLEAN:\n+                // flip the boolean value\n+                f = FeatureFactory.newBooleanFeature(featureName, !Boolean.getBoolean(feature.getValue().asString()));\n+                break;\n+            case TIME:\n+                // set to midnight\n+                f = FeatureFactory.newTimeFeature(featureName, LocalTime.MIDNIGHT);\n+                break;\n+            case DURATION:\n+                // set the duration to 0\n+                f = FeatureFactory.newDurationFeature(featureName, Duration.of(0, ChronoUnit.SECONDS));\n+                break;\n+            case CURRENCY:\n+                // set the currency to EUR\n+                f = FeatureFactory.newCurrencyFeature(featureName, Currency.getInstance(Locale.getDefault()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0OTA4Mw=="}, "originalCommit": {"oid": "88868b312f67fe6762462735aa1b95dcaf144c69"}, "originalPosition": 225}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 816, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}