{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NTE3NjM4", "number": 392, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNjo1ODowNlrOEY6enA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNjo1ODowNlrOEY6enA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTU5Mzg4OnYy", "diffSide": "RIGHT", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/TrustyServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNjo1ODowNlrOHBb3Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTozNjoxM1rOHBt8ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2NzEzOQ==", "bodyText": "Can you please better explain the original problem?\nI don't like that now we are loading the entire storage in a list before applying the offset.", "url": "https://github.com/kiegroup/kogito-apps/pull/392#discussion_r471267139", "createdAt": "2020-08-17T06:58:06Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/TrustyServiceImpl.java", "diffHunk": "@@ -56,13 +61,23 @@ public TrustyServiceImpl(TrustyStorageService storageService) {\n     }\n \n     @Override\n-    public List<Execution> getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n+    public MatchedExecutionHeaders getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n         Storage<String, Decision> storage = storageService.getDecisionsStorage();\n         List<AttributeFilter<?>> filters = new ArrayList<>();\n         filters.add(QueryFilterFactory.like(Execution.EXECUTION_ID_FIELD, prefix + \"*\"));\n         filters.add(QueryFilterFactory.greaterThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, from.toInstant().toEpochMilli()));\n         filters.add(QueryFilterFactory.lessThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, to.toInstant().toEpochMilli()));\n-        return new ArrayList<>(storage.query().limit(limit).offset(offset).filter(filters).execute());\n+        ArrayList result = new ArrayList<>(storage.query()\n+                                                   .sort(asList(orderBy(Execution.EXECUTION_TIMESTAMP_FIELD, DESC)))\n+                                                   .filter(filters)\n+                                                   .execute()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9095517905e6b899a771685dc07698206776556"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2Mjk5NQ==", "bodyText": "Ok I had a look to Query in persistence-commons and count is not supported so we should implement it to properly fix the bug", "url": "https://github.com/kiegroup/kogito-apps/pull/392#discussion_r471462995", "createdAt": "2020-08-17T13:02:55Z", "author": {"login": "danielezonca"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/TrustyServiceImpl.java", "diffHunk": "@@ -56,13 +61,23 @@ public TrustyServiceImpl(TrustyStorageService storageService) {\n     }\n \n     @Override\n-    public List<Execution> getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n+    public MatchedExecutionHeaders getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n         Storage<String, Decision> storage = storageService.getDecisionsStorage();\n         List<AttributeFilter<?>> filters = new ArrayList<>();\n         filters.add(QueryFilterFactory.like(Execution.EXECUTION_ID_FIELD, prefix + \"*\"));\n         filters.add(QueryFilterFactory.greaterThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, from.toInstant().toEpochMilli()));\n         filters.add(QueryFilterFactory.lessThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, to.toInstant().toEpochMilli()));\n-        return new ArrayList<>(storage.query().limit(limit).offset(offset).filter(filters).execute());\n+        ArrayList result = new ArrayList<>(storage.query()\n+                                                   .sort(asList(orderBy(Execution.EXECUTION_TIMESTAMP_FIELD, DESC)))\n+                                                   .filter(filters)\n+                                                   .execute()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2NzEzOQ=="}, "originalCommit": {"oid": "e9095517905e6b899a771685dc07698206776556"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MzQyMg==", "bodyText": "Hi @danielezonca ,\nwe have two options:\n\nwe load all the executions from that timestamp and then apply the offset/return the count of the results\nwe run two queries: one to extract the number of matched executions and one to extract only the results from offset to offset+total.\n\nThis PR implements the first option and adds some tests to check that the contract with the UI is not broken in terms of pagination. We can move forward with this and then create another ticket to implement the second option, or directly implement that. let me know what you think", "url": "https://github.com/kiegroup/kogito-apps/pull/392#discussion_r471563422", "createdAt": "2020-08-17T15:36:13Z", "author": {"login": "r00ta"}, "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/TrustyServiceImpl.java", "diffHunk": "@@ -56,13 +61,23 @@ public TrustyServiceImpl(TrustyStorageService storageService) {\n     }\n \n     @Override\n-    public List<Execution> getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n+    public MatchedExecutionHeaders getExecutionHeaders(OffsetDateTime from, OffsetDateTime to, int limit, int offset, String prefix) {\n         Storage<String, Decision> storage = storageService.getDecisionsStorage();\n         List<AttributeFilter<?>> filters = new ArrayList<>();\n         filters.add(QueryFilterFactory.like(Execution.EXECUTION_ID_FIELD, prefix + \"*\"));\n         filters.add(QueryFilterFactory.greaterThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, from.toInstant().toEpochMilli()));\n         filters.add(QueryFilterFactory.lessThanEqual(Execution.EXECUTION_TIMESTAMP_FIELD, to.toInstant().toEpochMilli()));\n-        return new ArrayList<>(storage.query().limit(limit).offset(offset).filter(filters).execute());\n+        ArrayList result = new ArrayList<>(storage.query()\n+                                                   .sort(asList(orderBy(Execution.EXECUTION_TIMESTAMP_FIELD, DESC)))\n+                                                   .filter(filters)\n+                                                   .execute()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2NzEzOQ=="}, "originalCommit": {"oid": "e9095517905e6b899a771685dc07698206776556"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 624, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}