{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NjA0MjU0", "number": 529, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0MDoyM1rOE24OJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzo0ODowMFrOE8jo2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTc5Njg0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0MDoyM1rOHv6JHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMDoyNzo0M1rOHx0THA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5NzcyNw==", "bodyText": "Now we have a single param but this might change in the future so what about create a generic ExplainerParams/ExplainerContext/ExplainerDescr (and use it in the constructor of course)?\nIf you think this parameter is Lime-specific fine for me to have a LimeExplainer*, up to you :)\nPlease create also a public static final DEFAULT field in this class with default values like this example", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r519997727", "createdAt": "2020-11-09T17:40:23Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -77,6 +77,11 @@\n      */\n     private final PerturbationContext perturbationContext;\n \n+    /**\n+     * Whether the explainer should adapt the variance in the generated (perturbed) data when it's not separable.\n+     */\n+    private final boolean adaptDatasetVariance;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MTcwOQ==", "bodyText": "Ok, it makes perfect sense to have a config / params class for LimeExplainer.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r520061709", "createdAt": "2020-11-09T19:20:46Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -77,6 +77,11 @@\n      */\n     private final PerturbationContext perturbationContext;\n \n+    /**\n+     * Whether the explainer should adapt the variance in the generated (perturbed) data when it's not separable.\n+     */\n+    private final boolean adaptDatasetVariance;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5NzcyNw=="}, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTEzMg==", "bodyText": "I've added now a LimeConfig object.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r521999132", "createdAt": "2020-11-12T10:27:43Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -77,6 +77,11 @@\n      */\n     private final PerturbationContext perturbationContext;\n \n+    /**\n+     * Whether the explainer should adapt the variance in the generated (perturbed) data when it's not separable.\n+     */\n+    private final boolean adaptDatasetVariance;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5NzcyNw=="}, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTgyMzU4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0Njo1NlrOHv6ZZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo0Mjo1NFrOHx7TAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMTg5Mw==", "bodyText": "Are you sure of this code? As far as I can see this code will double the size of samples as soon as a DatasetNotSeparableException is thrown (regardless if it is the first attempt or similar) and again and again until the generated dataset is separable or that noOfRetries will be 0.\nIs it the logic you want? Do you expect it is never (or almost never) possible that a new sample of the same size will produce a separated dataset?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r520001893", "createdAt": "2020-11-09T17:46:56Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -154,7 +157,19 @@ public int getNoOfRetries() {\n                         return completedFuture(getSaliencies(targetInput, linearizedTargetInputFeatures, actualOutputs, limeInputsList));\n                     } catch (DatasetNotSeparableException e) {\n                         if (noOfRetries > 0) {\n-                            return explainRetryCycle(model, originalInput, targetInput, linearizedTargetInputFeatures, actualOutputs, noOfRetries - 1);\n+                            PerturbationContext newPerturbationContext;\n+                            int newNoOfSamples;\n+                            if (adaptDatasetVariance) {\n+                                newPerturbationContext = new PerturbationContext(perturbationContext.getRandom(),\n+                                                                                 perturbationContext.getNoOfPerturbations() + 1);\n+                                newNoOfSamples = noOfSamples * 2;\n+                            } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEwOTM1Mg==", "bodyText": "Yes, this is the intent. It might still happen that re-generating a new dataset will produce a separable dataset on a second run. I was however thinking in terms of the cost of this retry mechanism in terms of resources, therefore I was thinking that perhaps it's better to \"spend\" resources (generating perturbed data + computing outputs for each) when you have a higher likelihood of succeeding in the task of getting a separable dataset. That's why I set to do both increased sampling and increased perturbation size.\nBut maybe we can make a compromise and not just double the sample size, but rather increase it by n/100 on each retry where n is the configured number of retries (so that you end up with a doubled dataset size on the final retry, rather than with a n times bigger dataset).\nSame goes for the number of perturbations we can increase it more \"slowly\" and get it at half the no. of features by the last retry.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r520109352", "createdAt": "2020-11-09T20:46:19Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -154,7 +157,19 @@ public int getNoOfRetries() {\n                         return completedFuture(getSaliencies(targetInput, linearizedTargetInputFeatures, actualOutputs, limeInputsList));\n                     } catch (DatasetNotSeparableException e) {\n                         if (noOfRetries > 0) {\n-                            return explainRetryCycle(model, originalInput, targetInput, linearizedTargetInputFeatures, actualOutputs, noOfRetries - 1);\n+                            PerturbationContext newPerturbationContext;\n+                            int newNoOfSamples;\n+                            if (adaptDatasetVariance) {\n+                                newPerturbationContext = new PerturbationContext(perturbationContext.getRandom(),\n+                                                                                 perturbationContext.getNoOfPerturbations() + 1);\n+                                newNoOfSamples = noOfSamples * 2;\n+                            } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMTg5Mw=="}, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjExMzc5Mg==", "bodyText": "I think I have addressed the above comment in the subsequent commits.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r522113792", "createdAt": "2020-11-12T13:42:54Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -154,7 +157,19 @@ public int getNoOfRetries() {\n                         return completedFuture(getSaliencies(targetInput, linearizedTargetInputFeatures, actualOutputs, limeInputsList));\n                     } catch (DatasetNotSeparableException e) {\n                         if (noOfRetries > 0) {\n-                            return explainRetryCycle(model, originalInput, targetInput, linearizedTargetInputFeatures, actualOutputs, noOfRetries - 1);\n+                            PerturbationContext newPerturbationContext;\n+                            int newNoOfSamples;\n+                            if (adaptDatasetVariance) {\n+                                newPerturbationContext = new PerturbationContext(perturbationContext.getRandom(),\n+                                                                                 perturbationContext.getNoOfPerturbations() + 1);\n+                                newNoOfSamples = noOfSamples * 2;\n+                            } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMTg5Mw=="}, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1OTgzMDYyOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0ODo0OFrOHv6dtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDo0ODoyOFrOHwBBUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMjk5Nw==", "bodyText": "Does it make sense to check also if all positive features are stable?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r520002997", "createdAt": "2020-11-09T17:48:48Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "diffHunk": "@@ -42,70 +44,97 @@\n \n     @Test\n     void testStabilityWithNumericData() throws Exception {\n-        PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n-        List<Feature> featureList = new LinkedList<>();\n-        for (int i = 0; i < 5; i++) {\n-            featureList.add(TestUtils.getMockedNumericFeature(i));\n+        Random random = new Random();\n+        for (int seed = 0; seed < 5; seed++) {\n+            random.setSeed(seed);\n+            PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n+            List<Feature> featureList = new LinkedList<>();\n+            for (int i = 0; i < 5; i++) {\n+                featureList.add(TestUtils.getMockedNumericFeature(i));\n+            }\n+            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n+            assertStable(limeExplainer, sumSkipModel, featureList);\n         }\n-        assertStable(sumSkipModel, featureList);\n     }\n \n     @Test\n     void testStabilityWithTextData() throws Exception {\n-        PredictionProvider sumSkipModel = TestUtils.getDummyTextClassifier();\n-        List<Feature> featureList = new LinkedList<>();\n-        for (int i = 0; i < 4; i++) {\n-            featureList.add(TestUtils.getMockedTextFeature(\"foo \" + i));\n+        Random random = new Random();\n+        for (int seed = 0; seed < 5; seed++) {\n+            random.setSeed(seed);\n+            PredictionProvider sumSkipModel = TestUtils.getDummyTextClassifier();\n+            List<Feature> featureList = new LinkedList<>();\n+            for (int i = 0; i < 4; i++) {\n+                featureList.add(TestUtils.getMockedTextFeature(\"foo \" + i));\n+            }\n+            featureList.add(TestUtils.getMockedTextFeature(\"money\"));\n+            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n+            assertStable(limeExplainer, sumSkipModel, featureList);\n         }\n-        featureList.add(TestUtils.getMockedTextFeature(\"money\"));\n-        assertStable(sumSkipModel, featureList);\n     }\n \n-    private void assertStable(PredictionProvider model, List<Feature> featureList) throws Exception {\n+    @Test\n+    void testAdaptiveVariance() throws Exception {\n         Random random = new Random();\n         for (int seed = 0; seed < 5; seed++) {\n             random.setSeed(seed);\n-            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n-            PredictionInput input = new PredictionInput(featureList);\n-            List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n-                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n-            for (PredictionOutput predictionOutput : predictionOutputs) {\n-                Prediction prediction = new Prediction(input, predictionOutput);\n-                List<Saliency> saliencies = new LinkedList<>();\n-                for (int i = 0; i < 100; i++) {\n-                    Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n-                            .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n-                    saliencies.addAll(saliencyMap.values());\n-                }\n-                // check that the topmost important feature is stable\n-                List<String> names = new LinkedList<>();\n-                saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n-                Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n-                boolean topFeature = false;\n-                for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n-                    if (entry.getValue() >= TOP_FEATURE_THRESHOLD) {\n-                        topFeature = true;\n-                        break;\n-                    }\n-                }\n-                assertTrue(topFeature);\n+            PerturbationContext perturbationContext = new PerturbationContext(random, 1);\n \n-                // check that the impact is stable\n-                List<Double> impacts = new ArrayList<>(saliencies.size());\n-                for (Saliency saliency : saliencies) {\n-                    double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(2));\n-                    impacts.add(v);\n+            int samples = 1;\n+            int retries = 4;\n+\n+            LimeExplainer adaptiveVarianceLE = new LimeExplainer(samples, perturbationContext,\n+                                                            retries, true);\n+\n+            List<Feature> features = new LinkedList<>();\n+            for (int i = 0; i < 4; i++) {\n+                features.add(FeatureFactory.newNumericalFeature(\"f-\"+i,2));\n+            }\n+            PredictionProvider model = TestUtils.getEvenSumModel(0);\n+            assertStable(adaptiveVarianceLE, model, features);\n+        }\n+    }\n+\n+    private void assertStable(LimeExplainer limeExplainer, PredictionProvider model, List<Feature> featureList) throws Exception {\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (PredictionOutput predictionOutput : predictionOutputs) {\n+            Prediction prediction = new Prediction(input, predictionOutput);\n+            List<Saliency> saliencies = new LinkedList<>();\n+            for (int i = 0; i < 100; i++) {\n+                Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+                saliencies.addAll(saliencyMap.values());\n+            }\n+            // check that the topmost important feature is stable\n+            List<String> names = new LinkedList<>();\n+            saliencies.stream().map(s -> s.getPositiveFeatures(1)).filter(f -> !f.isEmpty()).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+            Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDExMDQxNg==", "bodyText": "this is better implemented in #530 where the depth at which the stability is checked is made configurable.\nSo I would leave it as it is for now, and then switch to that metric within #530.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r520110416", "createdAt": "2020-11-09T20:48:28Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/test/java/org/kie/kogito/explainability/local/lime/LimeStabilityTest.java", "diffHunk": "@@ -42,70 +44,97 @@\n \n     @Test\n     void testStabilityWithNumericData() throws Exception {\n-        PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n-        List<Feature> featureList = new LinkedList<>();\n-        for (int i = 0; i < 5; i++) {\n-            featureList.add(TestUtils.getMockedNumericFeature(i));\n+        Random random = new Random();\n+        for (int seed = 0; seed < 5; seed++) {\n+            random.setSeed(seed);\n+            PredictionProvider sumSkipModel = TestUtils.getSumSkipModel(0);\n+            List<Feature> featureList = new LinkedList<>();\n+            for (int i = 0; i < 5; i++) {\n+                featureList.add(TestUtils.getMockedNumericFeature(i));\n+            }\n+            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n+            assertStable(limeExplainer, sumSkipModel, featureList);\n         }\n-        assertStable(sumSkipModel, featureList);\n     }\n \n     @Test\n     void testStabilityWithTextData() throws Exception {\n-        PredictionProvider sumSkipModel = TestUtils.getDummyTextClassifier();\n-        List<Feature> featureList = new LinkedList<>();\n-        for (int i = 0; i < 4; i++) {\n-            featureList.add(TestUtils.getMockedTextFeature(\"foo \" + i));\n+        Random random = new Random();\n+        for (int seed = 0; seed < 5; seed++) {\n+            random.setSeed(seed);\n+            PredictionProvider sumSkipModel = TestUtils.getDummyTextClassifier();\n+            List<Feature> featureList = new LinkedList<>();\n+            for (int i = 0; i < 4; i++) {\n+                featureList.add(TestUtils.getMockedTextFeature(\"foo \" + i));\n+            }\n+            featureList.add(TestUtils.getMockedTextFeature(\"money\"));\n+            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n+            assertStable(limeExplainer, sumSkipModel, featureList);\n         }\n-        featureList.add(TestUtils.getMockedTextFeature(\"money\"));\n-        assertStable(sumSkipModel, featureList);\n     }\n \n-    private void assertStable(PredictionProvider model, List<Feature> featureList) throws Exception {\n+    @Test\n+    void testAdaptiveVariance() throws Exception {\n         Random random = new Random();\n         for (int seed = 0; seed < 5; seed++) {\n             random.setSeed(seed);\n-            LimeExplainer limeExplainer = new LimeExplainer(10, 1, random);\n-            PredictionInput input = new PredictionInput(featureList);\n-            List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n-                    .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n-            for (PredictionOutput predictionOutput : predictionOutputs) {\n-                Prediction prediction = new Prediction(input, predictionOutput);\n-                List<Saliency> saliencies = new LinkedList<>();\n-                for (int i = 0; i < 100; i++) {\n-                    Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n-                            .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n-                    saliencies.addAll(saliencyMap.values());\n-                }\n-                // check that the topmost important feature is stable\n-                List<String> names = new LinkedList<>();\n-                saliencies.stream().map(s -> s.getPositiveFeatures(1)).forEach(f -> names.add(f.get(0).getFeature().getName()));\n-                Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n-                boolean topFeature = false;\n-                for (Map.Entry<String, Long> entry : frequencyMap.entrySet()) {\n-                    if (entry.getValue() >= TOP_FEATURE_THRESHOLD) {\n-                        topFeature = true;\n-                        break;\n-                    }\n-                }\n-                assertTrue(topFeature);\n+            PerturbationContext perturbationContext = new PerturbationContext(random, 1);\n \n-                // check that the impact is stable\n-                List<Double> impacts = new ArrayList<>(saliencies.size());\n-                for (Saliency saliency : saliencies) {\n-                    double v = ExplainabilityMetrics.impactScore(model, prediction, saliency.getTopFeatures(2));\n-                    impacts.add(v);\n+            int samples = 1;\n+            int retries = 4;\n+\n+            LimeExplainer adaptiveVarianceLE = new LimeExplainer(samples, perturbationContext,\n+                                                            retries, true);\n+\n+            List<Feature> features = new LinkedList<>();\n+            for (int i = 0; i < 4; i++) {\n+                features.add(FeatureFactory.newNumericalFeature(\"f-\"+i,2));\n+            }\n+            PredictionProvider model = TestUtils.getEvenSumModel(0);\n+            assertStable(adaptiveVarianceLE, model, features);\n+        }\n+    }\n+\n+    private void assertStable(LimeExplainer limeExplainer, PredictionProvider model, List<Feature> featureList) throws Exception {\n+        PredictionInput input = new PredictionInput(featureList);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(input))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (PredictionOutput predictionOutput : predictionOutputs) {\n+            Prediction prediction = new Prediction(input, predictionOutput);\n+            List<Saliency> saliencies = new LinkedList<>();\n+            for (int i = 0; i < 100; i++) {\n+                Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+                saliencies.addAll(saliencyMap.values());\n+            }\n+            // check that the topmost important feature is stable\n+            List<String> names = new LinkedList<>();\n+            saliencies.stream().map(s -> s.getPositiveFeatures(1)).filter(f -> !f.isEmpty()).forEach(f -> names.add(f.get(0).getFeature().getName()));\n+            Map<String, Long> frequencyMap = names.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMjk5Nw=="}, "originalCommit": {"oid": "25b6ab01d9ef0f19869a5f0890252cba8c852d84"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY3Mzk1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMTo1NFrOHx-5HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMTo1NFrOHx-5HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MjcwMA==", "bodyText": "Do we really want to have a default static instance of PerturbationContext? I think this could be better to do the new directly on perturbationContext field at instance level (so two different LimeConfig instances will not share it)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final PerturbationContext DEFAULT_PERTURBATION_CONTEXT = new PerturbationContext(new SecureRandom(), 1);\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * No. of samples to be generated for the local linear model training\n          \n          \n            \n                 */\n          \n          \n            \n                private int noOfSamples = DEFAULT_NO_OF_SAMPLES;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * No. of retries while trying to find a (linearly) separable dataset\n          \n          \n            \n                 */\n          \n          \n            \n                private int noOfRetries = DEFAULT_NO_OF_RETRIES;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Context object for perturbing features\n          \n          \n            \n                 */\n          \n          \n            \n                private PerturbationContext perturbationContext = DEFAULT_PERTURBATION_CONTEXT;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * No. of samples to be generated for the local linear model training\n          \n          \n            \n                 */\n          \n          \n            \n                private int noOfSamples = DEFAULT_NO_OF_SAMPLES;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * No. of retries while trying to find a (linearly) separable dataset\n          \n          \n            \n                 */\n          \n          \n            \n                private int noOfRetries = DEFAULT_NO_OF_RETRIES;\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Context object for perturbing features\n          \n          \n            \n                 */\n          \n          \n            \n                private PerturbationContext perturbationContext = new PerturbationContext(new SecureRandom(), 1);", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r522172700", "createdAt": "2020-11-12T15:01:54Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeConfig.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.local.lime;\n+\n+import java.security.SecureRandom;\n+\n+import org.kie.kogito.explainability.model.PerturbationContext;\n+\n+/**\n+ * Lime explainer configuration parameters.\n+ */\n+public class LimeConfig {\n+\n+    private static final int DEFAULT_NO_OF_SAMPLES = 300;\n+    public static final int DEFAULT_NO_OF_RETRIES = 3;\n+    private static final boolean DEFAULT_ADAPT_DATASET_VARIANCE = false;\n+    private static final PerturbationContext DEFAULT_PERTURBATION_CONTEXT = new PerturbationContext(new SecureRandom(), 1);\n+\n+    /**\n+     * No. of samples to be generated for the local linear model training\n+     */\n+    private int noOfSamples = DEFAULT_NO_OF_SAMPLES;\n+\n+    /**\n+     * No. of retries while trying to find a (linearly) separable dataset\n+     */\n+    private int noOfRetries = DEFAULT_NO_OF_RETRIES;\n+\n+    /**\n+     * Context object for perturbing features\n+     */\n+    private PerturbationContext perturbationContext = DEFAULT_PERTURBATION_CONTEXT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab8f5ebbb3bb79b71549bb13864ddd6fdb29ff7"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY3ODg4OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMjo1OVrOHx-8PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMjo1OVrOHx-8PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MzUwMA==", "bodyText": "Please fix formatting", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r522173500", "createdAt": "2020-11-12T15:02:59Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -142,9 +106,9 @@ public int getNoOfRetries() {\n             PredictionInput targetInput,\n             List<Feature> linearizedTargetInputFeatures,\n             List<Output> actualOutputs,\n-            int noOfRetries) {\n+            int noOfRetries, int noOfSamples, PerturbationContext perturbationContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab8f5ebbb3bb79b71549bb13864ddd6fdb29ff7"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDY0NzIwOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzowOToyMlrOH2o5TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzozODoxOFrOH2qF3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NTE4MQ==", "bodyText": "What about move this to LimeConfig too? Or do you prefer to have this hardcoded?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r527055181", "createdAt": "2020-11-19T17:09:22Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -58,59 +56,21 @@\n  */\n public class LimeExplainer implements LocalExplainer<Map<String, Saliency>> {\n \n-    public static final int DEFAULT_NO_OF_RETRIES = 3;\n     public static final double SEPARABLE_DATASET_RATIO = 0.99;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adf6fe6cb4848329f3fafb85717fda61495cef73"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NDc4MA==", "bodyText": "sounds good \ud83d\udc4d", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r527074780", "createdAt": "2020-11-19T17:38:18Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/local/lime/LimeExplainer.java", "diffHunk": "@@ -58,59 +56,21 @@\n  */\n public class LimeExplainer implements LocalExplainer<Map<String, Saliency>> {\n \n-    public static final int DEFAULT_NO_OF_RETRIES = 3;\n     public static final double SEPARABLE_DATASET_RATIO = 0.99;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA1NTE4MQ=="}, "originalCommit": {"oid": "adf6fe6cb4848329f3fafb85717fda61495cef73"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTMzNzQxOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzo0NzoyNlrOH4vsPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwODo0NDoyMFrOH6RFcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzY3Ng==", "bodyText": "Is SecureRandom() going to make this test non deterministic?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r529263676", "createdAt": "2020-11-24T07:47:26Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -107,7 +113,10 @@ void testPMMLRegressionCategorical() throws Exception {\n         features.add(FeatureFactory.newCategoricalFeature(\"mapY\", \"classB\"));\n         PredictionInput input = new PredictionInput(features);\n \n-        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(10)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg1OTM3OQ==", "bodyText": "correct, I've set it back to use Random with a fixed seed.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r530859379", "createdAt": "2020-11-26T08:44:20Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -107,7 +113,10 @@ void testPMMLRegressionCategorical() throws Exception {\n         features.add(FeatureFactory.newCategoricalFeature(\"mapY\", \"classB\"));\n         PredictionInput input = new PredictionInput(features);\n \n-        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(10)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzY3Ng=="}, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTMzNzg2OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzo0NzozMlrOH4vseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwODo0NDoyOFrOH6RFzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzczNw==", "bodyText": "Is SecureRandom() going to make this test non deterministic?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r529263737", "createdAt": "2020-11-24T07:47:32Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -141,7 +150,10 @@ void testPMMLScorecardCategorical() throws Exception {\n         features.add(FeatureFactory.newCategoricalFeature(\"input2\", \"classB\"));\n         PredictionInput input = new PredictionInput(features);\n \n-        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(10)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg1OTQ3MA==", "bodyText": "correct, I've set it back to use Random with a fixed seed.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r530859470", "createdAt": "2020-11-26T08:44:28Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-pmml/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/pmml/PmmlLimeExplainerTest.java", "diffHunk": "@@ -141,7 +150,10 @@ void testPMMLScorecardCategorical() throws Exception {\n         features.add(FeatureFactory.newCategoricalFeature(\"input2\", \"classB\"));\n         PredictionInput input = new PredictionInput(features);\n \n-        LimeExplainer limeExplainer = new LimeExplainer(10, 1);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(10)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzczNw=="}, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTMzOTE0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzo0ODowMFrOH4vtPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwODo0NTo0M1rOH6RI0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzkzNA==", "bodyText": "Is SecureRandom() going to make this test non deterministic?", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r529263934", "createdAt": "2020-11-24T07:48:00Z", "author": {"login": "r00ta"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -77,7 +80,10 @@ void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedExce\n         List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n                 .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n         Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n-        LimeExplainer limeExplainer = new LimeExplainer(100, 5);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(100)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 5));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg2MDI0MA==", "bodyText": "correct, I've set it back to use Random with a fixed seed.", "url": "https://github.com/kiegroup/kogito-apps/pull/529#discussion_r530860240", "createdAt": "2020-11-26T08:45:43Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -77,7 +80,10 @@ void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedExce\n         List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n                 .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n         Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n-        LimeExplainer limeExplainer = new LimeExplainer(100, 5);\n+        LimeConfig limeConfig = new LimeConfig()\n+                .withSamples(100)\n+                .withPerturbationContext(new PerturbationContext(new SecureRandom(), 5));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI2MzkzNA=="}, "originalCommit": {"oid": "ddfc44fec8084566ed19a8f37bc019d1e8dca071"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1197, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}