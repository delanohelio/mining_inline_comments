{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyNDU4NjUy", "number": 467, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NTozNlrOEoC26w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1MDowNFrOEqQ2lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDI1MzIzOnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo1NTozNlrOHY6Scw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozMjoyNlrOHabOcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4Mjg2Nw==", "bodyText": "Can you please explain when this else should happen? It seems to me just a way to ignore the actual value and replace it with a empty one", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r495882867", "createdAt": "2020-09-28T11:55:36Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -86,8 +88,21 @@\n \n         @Override\n         public Value<?> perturb(Value<?> value, PerturbationContext perturbationContext) {\n-            ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n-            return new Value<>(byteBuffer);\n+            if (value.getUnderlyingObject() instanceof ByteBuffer) {\n+                ByteBuffer currentBuffer = (ByteBuffer) value.getUnderlyingObject();\n+                byte[] copy = new byte[currentBuffer.array().length];\n+                int maxPerturbationSize = Math.min(copy.length, Math.max((int) (copy.length * 0.5), perturbationContext.getNoOfPerturbations()));\n+                System.arraycopy(currentBuffer.array(), 0, copy, 0, currentBuffer.array().length);\n+                int[] indexes = perturbationContext.getRandom().ints(0, copy.length)\n+                        .limit(maxPerturbationSize).toArray();\n+                for (int i = 0; i < indexes.length; i++) {\n+                    copy[i] = 0;\n+                }\n+                return new Value<>(ByteBuffer.wrap(copy));\n+            } else {\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec816a9cbe4347da51dacc844b16ecb0bd443afd"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3MTA4OQ==", "bodyText": "this is handling the \"unexpected\" case of the underlying object not being a ByteBuffer.", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r497471089", "createdAt": "2020-09-30T12:32:26Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -86,8 +88,21 @@\n \n         @Override\n         public Value<?> perturb(Value<?> value, PerturbationContext perturbationContext) {\n-            ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n-            return new Value<>(byteBuffer);\n+            if (value.getUnderlyingObject() instanceof ByteBuffer) {\n+                ByteBuffer currentBuffer = (ByteBuffer) value.getUnderlyingObject();\n+                byte[] copy = new byte[currentBuffer.array().length];\n+                int maxPerturbationSize = Math.min(copy.length, Math.max((int) (copy.length * 0.5), perturbationContext.getNoOfPerturbations()));\n+                System.arraycopy(currentBuffer.array(), 0, copy, 0, currentBuffer.array().length);\n+                int[] indexes = perturbationContext.getRandom().ints(0, copy.length)\n+                        .limit(maxPerturbationSize).toArray();\n+                for (int i = 0; i < indexes.length; i++) {\n+                    copy[i] = 0;\n+                }\n+                return new Value<>(ByteBuffer.wrap(copy));\n+            } else {\n+                ByteBuffer byteBuffer = ByteBuffer.allocate(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4Mjg2Nw=="}, "originalCommit": {"oid": "ec816a9cbe4347da51dacc844b16ecb0bd443afd"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTE0MDE1OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMTo0Njo1OFrOHZpO6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjozNToyNlrOHabVfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MjAxMA==", "bodyText": "Are you sure about this code? I think you should iterate over indexes with a for each instead of the current code.\nIn other words: let assume that copy contains 5 elements and maxPerturbationSize is 2, then indexes could be [2, 4] but the for loop will set to 0 the first and the second entries.\nAm I wrong?", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r496652010", "createdAt": "2020-09-29T11:46:58Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -86,8 +88,21 @@\n \n         @Override\n         public Value<?> perturb(Value<?> value, PerturbationContext perturbationContext) {\n-            ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n-            return new Value<>(byteBuffer);\n+            if (value.getUnderlyingObject() instanceof ByteBuffer) {\n+                ByteBuffer currentBuffer = (ByteBuffer) value.getUnderlyingObject();\n+                byte[] copy = new byte[currentBuffer.array().length];\n+                int maxPerturbationSize = Math.min(copy.length, Math.max((int) (copy.length * 0.5), perturbationContext.getNoOfPerturbations()));\n+                System.arraycopy(currentBuffer.array(), 0, copy, 0, currentBuffer.array().length);\n+                int[] indexes = perturbationContext.getRandom().ints(0, copy.length)\n+                        .limit(maxPerturbationSize).toArray();\n+                for (int i = 0; i < indexes.length; i++) {\n+                    copy[i] = 0;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec816a9cbe4347da51dacc844b16ecb0bd443afd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3Mjg5Mw==", "bodyText": "yes, of course that should iterate over the indexes, thanks for spotting it.", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r497472893", "createdAt": "2020-09-30T12:35:26Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -86,8 +88,21 @@\n \n         @Override\n         public Value<?> perturb(Value<?> value, PerturbationContext perturbationContext) {\n-            ByteBuffer byteBuffer = ByteBuffer.allocate(0);\n-            return new Value<>(byteBuffer);\n+            if (value.getUnderlyingObject() instanceof ByteBuffer) {\n+                ByteBuffer currentBuffer = (ByteBuffer) value.getUnderlyingObject();\n+                byte[] copy = new byte[currentBuffer.array().length];\n+                int maxPerturbationSize = Math.min(copy.length, Math.max((int) (copy.length * 0.5), perturbationContext.getNoOfPerturbations()));\n+                System.arraycopy(currentBuffer.array(), 0, copy, 0, currentBuffer.array().length);\n+                int[] indexes = perturbationContext.getRandom().ints(0, copy.length)\n+                        .limit(maxPerturbationSize).toArray();\n+                for (int i = 0; i < indexes.length; i++) {\n+                    copy[i] = 0;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MjAxMA=="}, "originalCommit": {"oid": "ec816a9cbe4347da51dacc844b16ecb0bd443afd"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUxNzY0OnYy", "diffSide": "RIGHT", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1MDowNVrOHcXm7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToyMjo1OVrOHcYoiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwODk3NA==", "bodyText": "What about use PerturbationContext instead of Random? In this way we can better decouple and be more \"futureproof\": for example we will probably add data distribution (or sort of) in the future to PerturbationContext so that the generation will be guided.", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r499508974", "createdAt": "2020-10-05T10:50:05Z", "author": {"login": "danielezonca"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -416,4 +556,16 @@ public String toString() {\n      * @return a list of vectors\n      */\n     public abstract List<double[]> encode(Value<?> target, Value<?>... values);\n+\n+    /**\n+     * Generate a random {@code Value} (depending on the underlying {@code Type}).\n+     *\n+     * @param random random instance\n+     * @return a random Value\n+     */\n+    public abstract Value<?> randomValue(Random random);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2db6174130a1bfa565ce0171b060d5ecce88f34"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyNTc2OA==", "bodyText": "sounds good, thx", "url": "https://github.com/kiegroup/kogito-apps/pull/467#discussion_r499525768", "createdAt": "2020-10-05T11:22:59Z", "author": {"login": "tteofili"}, "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/Type.java", "diffHunk": "@@ -416,4 +556,16 @@ public String toString() {\n      * @return a list of vectors\n      */\n     public abstract List<double[]> encode(Value<?> target, Value<?>... values);\n+\n+    /**\n+     * Generate a random {@code Value} (depending on the underlying {@code Type}).\n+     *\n+     * @param random random instance\n+     * @return a random Value\n+     */\n+    public abstract Value<?> randomValue(Random random);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwODk3NA=="}, "originalCommit": {"oid": "d2db6174130a1bfa565ce0171b060d5ecce88f34"}, "originalPosition": 340}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 731, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}