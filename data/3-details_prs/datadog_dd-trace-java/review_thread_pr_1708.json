{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1ODgyMDc1", "number": 1708, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0ODoyM1rOETUPFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNzo1OTo1MFrOETknZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4Njg5OTQwOnYy", "diffSide": "RIGHT", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNTo0ODoyM1rOG4-0UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwOTo1MzowOFrOG6zXlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjY0MQ==", "bodyText": "Java uses int as index of array and we can't create array more than Integer.MAX_VALUE .\nI don't understand why we are using long as offset in this interface and then we have to convert it to int anyway in  many places in implementation:\nhttps://github.com/DataDog/dd-trace-java/pull/1708/files#diff-d12c79eb0010a77cc4ca68b1b31d4225R43", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462402641", "createdAt": "2020-07-29T15:48:23Z", "author": {"login": "lpriima"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+public interface LEB128Writer {\n+  int EXT_BIT = 0x80;\n+  long COMPRESSED_INT_MASK = -EXT_BIT;\n+\n+  /**\n+   * Get a default {@linkplain LEB128Writer} instance\n+   *\n+   * @return a new instance of {@linkplain LEB128Writer}\n+   */\n+  static LEB128Writer getInstance() {\n+    return new LEB128ByteBufferWriter();\n+  }\n+\n+  /** Reset the writer. Discard any collected data and set position to 0. */\n+  void reset();\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding\n+   *\n+   * @param data the data\n+   * @return the writer instance for chaining\n+   */\n+  LEB128Writer writeChar(char data);\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding at the given offset\n+   *\n+   * @param offset the offset from which to start writing the data\n+   * @param data the data\n+   * @return the writer position after the data has been written\n+   */\n+  long writeChar(long offset, char data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMTYwMA==", "bodyText": "This started with using mmapped file as the backing storage in mind. Hence 'long' index. But I agree that for our current (and any foreseeable future) usage an 'int' offset would be sufficient.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462821600", "createdAt": "2020-07-30T08:04:21Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+public interface LEB128Writer {\n+  int EXT_BIT = 0x80;\n+  long COMPRESSED_INT_MASK = -EXT_BIT;\n+\n+  /**\n+   * Get a default {@linkplain LEB128Writer} instance\n+   *\n+   * @return a new instance of {@linkplain LEB128Writer}\n+   */\n+  static LEB128Writer getInstance() {\n+    return new LEB128ByteBufferWriter();\n+  }\n+\n+  /** Reset the writer. Discard any collected data and set position to 0. */\n+  void reset();\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding\n+   *\n+   * @param data the data\n+   * @return the writer instance for chaining\n+   */\n+  LEB128Writer writeChar(char data);\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding at the given offset\n+   *\n+   * @param offset the offset from which to start writing the data\n+   * @param data the data\n+   * @return the writer position after the data has been written\n+   */\n+  long writeChar(long offset, char data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjY0MQ=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMjIxNQ==", "bodyText": "Refactored to int offset values.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r464312215", "createdAt": "2020-08-03T09:53:08Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+public interface LEB128Writer {\n+  int EXT_BIT = 0x80;\n+  long COMPRESSED_INT_MASK = -EXT_BIT;\n+\n+  /**\n+   * Get a default {@linkplain LEB128Writer} instance\n+   *\n+   * @return a new instance of {@linkplain LEB128Writer}\n+   */\n+  static LEB128Writer getInstance() {\n+    return new LEB128ByteBufferWriter();\n+  }\n+\n+  /** Reset the writer. Discard any collected data and set position to 0. */\n+  void reset();\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding\n+   *\n+   * @param data the data\n+   * @return the writer instance for chaining\n+   */\n+  LEB128Writer writeChar(char data);\n+\n+  /**\n+   * Write {@linkplain Character} data in LEB128 encoding at the given offset\n+   *\n+   * @param offset the offset from which to start writing the data\n+   * @param data the data\n+   * @return the writer position after the data has been written\n+   */\n+  long writeChar(long offset, char data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQwMjY0MQ=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzAxMDY4OnYy", "diffSide": "RIGHT", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTChunkCollector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjoxNDowOVrOG4_6nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwOTo1Mjo0NVrOG6zWxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDYzOQ==", "bodyText": "Do we need dd. prefix and/or ENV var support, Config and etc ... for this one ?", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462420639", "createdAt": "2020-07-29T16:14:09Z", "author": {"login": "lpriima"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTChunkCollector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntIterator;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import lombok.Getter;\n+\n+public abstract class MLTChunkCollector implements IMLTChunk {\n+  /*\n+   * TODO seems like subtree compression is worse than plain full-tree deduplication\n+   *  when the subtree compression is finally removed this flag should go as well + subtree support in FrameSequence\n+   */\n+  private static final boolean USE_SUBTREE_COMPRESSION =\n+      Boolean.getBoolean(\"mlt.subtree_compression\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjI4OA==", "bodyText": "This should be gone - the subtree compression proved to be suboptimal for the data we are collecting for MLT. The flag as well as all the related functionality can safely be removed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462822288", "createdAt": "2020-07-30T08:05:37Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTChunkCollector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntIterator;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import lombok.Getter;\n+\n+public abstract class MLTChunkCollector implements IMLTChunk {\n+  /*\n+   * TODO seems like subtree compression is worse than plain full-tree deduplication\n+   *  when the subtree compression is finally removed this flag should go as well + subtree support in FrameSequence\n+   */\n+  private static final boolean USE_SUBTREE_COMPRESSION =\n+      Boolean.getBoolean(\"mlt.subtree_compression\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDYzOQ=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMjAwNQ==", "bodyText": "Subtree compression removed. No need for the config any more.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r464312005", "createdAt": "2020-08-03T09:52:45Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTChunkCollector.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntIterator;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import lombok.Getter;\n+\n+public abstract class MLTChunkCollector implements IMLTChunk {\n+  /*\n+   * TODO seems like subtree compression is worse than plain full-tree deduplication\n+   *  when the subtree compression is finally removed this flag should go as well + subtree support in FrameSequence\n+   */\n+  private static final boolean USE_SUBTREE_COMPRESSION =\n+      Boolean.getBoolean(\"mlt.subtree_compression\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDYzOQ=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzU3NzY3OnYy", "diffSide": "RIGHT", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODo0NToyMVrOG5FeNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoxMToyM1rOG5YoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTY3MQ==", "bodyText": "class without state? Should we mark all methods as static and add private constructor ?", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462511671", "createdAt": "2020-07-29T18:45:21Z", "author": {"login": "lpriima"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTReader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.datadog.mlt.io;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** The MLT binary format reader */\n+public final class MLTReader {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyNTUwOA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462825508", "createdAt": "2020-07-30T08:11:23Z", "author": {"login": "bantonsson"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTReader.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.datadog.mlt.io;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** The MLT binary format reader */\n+public final class MLTReader {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTY3MQ=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzU3ODAyOnYy", "diffSide": "RIGHT", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxODo0NToyOVrOG5FeeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwOTo1MToxNlrOG6zUHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTczNw==", "bodyText": "class without state? Should we mark all methods as static and add private constructor ?", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462511737", "createdAt": "2020-07-29T18:45:29Z", "author": {"login": "lpriima"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+/** The MLT binary format writer */\n+public final class MLTWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMzI1Mg==", "bodyText": "The eternal question whether to have all-static singletons or instance singletons :)\nI have no strong opinion either way - only that mocking would be impossible for all-static one.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462823252", "createdAt": "2020-07-30T08:07:19Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+/** The MLT binary format writer */\n+public final class MLTWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTczNw=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyNjE2NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462826165", "createdAt": "2020-07-30T08:12:32Z", "author": {"login": "bantonsson"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+/** The MLT binary format writer */\n+public final class MLTWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTczNw=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA4MzcxMw==", "bodyText": "you don't have to mock something which doesn't have state :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r463083713", "createdAt": "2020-07-30T15:31:30Z", "author": {"login": "lpriima"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+/** The MLT binary format writer */\n+public final class MLTWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTczNw=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMTMyNg==", "bodyText": "Ok, all-static now.\nIn theory, you still can mock no-state class - eg. a factory impl which will return mock instanes in turn. But it is not the case here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r464311326", "createdAt": "2020-08-03T09:51:16Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;\n+import it.unimi.dsi.fastutil.ints.IntSet;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+/** The MLT binary format writer */\n+public final class MLTWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxMTczNw=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTU4MzA4OnYy", "diffSide": "RIGHT", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/ConstantPool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNzo1OTo1MFrOG5YPxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwOTo0OTo0M1rOG6zQwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxOTI3MA==", "bodyText": "So since this is not the full code, I couldn't figure out exactly how this is used, but I think that it would be good to mention that this data structure is not thread safe, to set expectations and avoid misuse.", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r462819270", "createdAt": "2020-07-30T07:59:50Z", "author": {"login": "bantonsson"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/ConstantPool.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+\n+/**\n+ * A generic constant pool implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMDQ2Ng==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1708#discussion_r464310466", "createdAt": "2020-08-03T09:49:43Z", "author": {"login": "jbachorik"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/ConstantPool.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.datadog.mlt.io;\n+\n+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;\n+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+\n+/**\n+ * A generic constant pool implementation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxOTI3MA=="}, "originalCommit": {"oid": "4ce4edac18053d5070d1474469b7fe4bc0c825ea"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4952, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}