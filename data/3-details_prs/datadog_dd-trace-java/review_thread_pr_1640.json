{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNTI0MzE2", "number": 1640, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNzoyMToxM1rOEKZKjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDoyODo1M1rOEKdHWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzMzNTE4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNzoyMToxM1rOGrZ2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDowMDowOVrOGrfUtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2NTYyNQ==", "bodyText": "Like for MLT we may have an issue regarding initializing or using JMX to early no?", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448165625", "createdAt": "2020-07-01T07:21:13Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzNDAwMQ==", "bodyText": "\ud83d\ude2d Yeah. Possible. Although all our smoke tests are passing - this class is touched only when a recording is being started and at that moment everything else is up. But I know we were protecting against a very improbable event that there happen to be a JVM doing eager load of class constants (not that I know of any in real life). Let me try put it in the right place so we don't crash in that hypothetical case.", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448234001", "createdAt": "2020-07-01T09:22:44Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2NTYyNQ=="}, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI1NTE1OQ==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448255159", "createdAt": "2020-07-01T10:00:09Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2NTYyNQ=="}, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzM1MjQyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNzoyNjoxNFrOGraBiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwOTozMjozMlrOGreXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2ODMzMQ==", "bodyText": "could we at least store the Thread Ids for this event, it could be sufficient for correlating and identifying deadlocked threads, no?", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448168331", "createdAt": "2020-07-01T07:26:14Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());\n+  }\n+\n+  final List<? extends Event> collectEvents() {\n+    if (!isDeadlockEventEnabled()) {\n+      return Collections.emptyList();\n+    }\n+\n+    long[] locked = threadMXBean.findDeadlockedThreads();\n+    if (locked == null) {\n+      return Collections.emptyList();\n+    }\n+    long id = deadlockCounter.getAndIncrement();\n+\n+    List<Event> events = new ArrayList<>();\n+    DeadlockEvent event = new DeadlockEvent(id, locked.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzNTA4Ng==", "bodyText": "I was trying to explain this in the description - we are severely limited by not being able to have array/collection attributes. There is no good way to store thread IDs short of putting them to a comma delimited string which is kind of off-putting ... That's why there is the 'deadlock ID' concept so we can emit events per deadlocked thread and relate them back to the primary event.", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448235086", "createdAt": "2020-07-01T09:24:43Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());\n+  }\n+\n+  final List<? extends Event> collectEvents() {\n+    if (!isDeadlockEventEnabled()) {\n+      return Collections.emptyList();\n+    }\n+\n+    long[] locked = threadMXBean.findDeadlockedThreads();\n+    if (locked == null) {\n+      return Collections.emptyList();\n+    }\n+    long id = deadlockCounter.getAndIncrement();\n+\n+    List<Event> events = new ArrayList<>();\n+    DeadlockEvent event = new DeadlockEvent(id, locked.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2ODMzMQ=="}, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzOTQ3MA==", "bodyText": "right, I overlooked the description :)\nlet's keep it that way for now, we will see if it's wirth to improve with the list of thread ids encoded.", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448239470", "createdAt": "2020-07-01T09:32:32Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/events/DeadlockEventFactory.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.datadog.profiling.controller.openjdk.events;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.Event;\n+import jdk.jfr.FlightRecorder;\n+\n+public class DeadlockEventFactory {\n+  private static final DeadlockEvent DEADLOCK_EVENT = new DeadlockEvent();\n+  private static final DeadlockedThreadEvent DEADLOCKED_THREAD_EVENT = new DeadlockedThreadEvent();\n+\n+  private final ThreadMXBean threadMXBean;\n+  private final AtomicLong deadlockCounter = new AtomicLong();\n+\n+  public static void registerEvents() {\n+    FlightRecorder.addPeriodicEvent(DeadlockEvent.class, DeadlockEvent::emit);\n+  }\n+\n+  DeadlockEventFactory(ThreadMXBean threadMXBean) {\n+    this.threadMXBean = threadMXBean;\n+  }\n+\n+  DeadlockEventFactory() {\n+    this(ManagementFactory.getThreadMXBean());\n+  }\n+\n+  final List<? extends Event> collectEvents() {\n+    if (!isDeadlockEventEnabled()) {\n+      return Collections.emptyList();\n+    }\n+\n+    long[] locked = threadMXBean.findDeadlockedThreads();\n+    if (locked == null) {\n+      return Collections.emptyList();\n+    }\n+    long id = deadlockCounter.getAndIncrement();\n+\n+    List<Event> events = new ArrayList<>();\n+    DeadlockEvent event = new DeadlockEvent(id, locked.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2ODMzMQ=="}, "originalCommit": {"oid": "a5e068845279a6d1cecb1094779e907bbedc86fa"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5Mzk4MjMzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDoyODo1M1rOGrgOgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMDozODowNVrOGrggCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2OTk1NQ==", "bodyText": "are you sure about this change?\nit seems to desynchronize later access to AGENT_CLASSLOADER in this method", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448269955", "createdAt": "2020-07-01T10:28:53Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -264,12 +264,27 @@ private static synchronized void installDatadogTracer() {\n   private static synchronized void startJmx(final URL bootstrapURL) {\n     startJmxFetch(bootstrapURL);\n     initializeJmxThreadCpuTimeProvider();\n+    registerDeadlockDetectionEvent(bootstrapURL);\n+  }\n+\n+  private static synchronized void registerDeadlockDetectionEvent(URL bootstrapUrl) {\n+    log.info(\"Initializing JMX thread deadlock detector\");\n+    try {\n+      ClassLoader classLoader = getProfilingClassloader(bootstrapUrl);\n+      final Class<?> deadlockFactoryClass =\n+          classLoader.loadClass(\n+              \"com.datadog.profiling.controller.openjdk.events.DeadlockEventFactory\");\n+      final Method registerMethod = deadlockFactoryClass.getMethod(\"registerEvents\");\n+      registerMethod.invoke(null);\n+    } catch (final Throwable ex) {\n+      log.error(\"Throwable thrown while initializing JMX thread deadlock detector\", ex);\n+    }\n   }\n \n   /** Enable JMX based thread CPU time provider once it is safe to touch JMX */\n   private static synchronized void initializeJmxThreadCpuTimeProvider() {\n     log.info(\"Initializing JMX thread CPU time provider\");\n-    if (AGENT_CLASSLOADER == null) {\n+    if (PROFILING_CLASSLOADER == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a017d77f0101e4f2658e83cfd2be89bbd446707f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NDQ0Mg==", "bodyText": "\ud83d\udca9 this is totally wrong. thanks for catching it. somehow I messed up while renaming ...", "url": "https://github.com/DataDog/dd-trace-java/pull/1640#discussion_r448274442", "createdAt": "2020-07-01T10:38:05Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -264,12 +264,27 @@ private static synchronized void installDatadogTracer() {\n   private static synchronized void startJmx(final URL bootstrapURL) {\n     startJmxFetch(bootstrapURL);\n     initializeJmxThreadCpuTimeProvider();\n+    registerDeadlockDetectionEvent(bootstrapURL);\n+  }\n+\n+  private static synchronized void registerDeadlockDetectionEvent(URL bootstrapUrl) {\n+    log.info(\"Initializing JMX thread deadlock detector\");\n+    try {\n+      ClassLoader classLoader = getProfilingClassloader(bootstrapUrl);\n+      final Class<?> deadlockFactoryClass =\n+          classLoader.loadClass(\n+              \"com.datadog.profiling.controller.openjdk.events.DeadlockEventFactory\");\n+      final Method registerMethod = deadlockFactoryClass.getMethod(\"registerEvents\");\n+      registerMethod.invoke(null);\n+    } catch (final Throwable ex) {\n+      log.error(\"Throwable thrown while initializing JMX thread deadlock detector\", ex);\n+    }\n   }\n \n   /** Enable JMX based thread CPU time provider once it is safe to touch JMX */\n   private static synchronized void initializeJmxThreadCpuTimeProvider() {\n     log.info(\"Initializing JMX thread CPU time provider\");\n-    if (AGENT_CLASSLOADER == null) {\n+    if (PROFILING_CLASSLOADER == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2OTk1NQ=="}, "originalCommit": {"oid": "a017d77f0101e4f2658e83cfd2be89bbd446707f"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 104, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}