{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MDg1NzU2", "number": 1755, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoyMzo1NlrOEV5pIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoyODowMFrOEV5u2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzk5OTcxOnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/mlt/Invocation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoyMzo1NlrOG866kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODo1MTo1N1rOG9R9Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMzAwOQ==", "bodyText": "It seems that's incorrect, it will return null, no?", "url": "https://github.com/DataDog/dd-trace-java/pull/1755#discussion_r466533009", "createdAt": "2020-08-06T16:23:56Z", "author": {"login": "jpbempel"}, "path": "internal-api/src/main/java/datadog/trace/mlt/Invocation.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package datadog.trace.mlt;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.List;\n+import java.util.Objects;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class Invocation {\n+  static final int INVOCATION_OFFSET = 3;\n+\n+  /**\n+   * A simple data class representing an invocation caller. Provides the caller class and method\n+   * name.\n+   */\n+  public static final class Caller {\n+    public final String className;\n+    public final String methodName;\n+\n+    Caller(String className, String methodName) {\n+      this.className = className;\n+      this.methodName = methodName;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Caller caller = (Caller) o;\n+      return className.equals(caller.className) && Objects.equals(methodName, caller.methodName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(className, methodName);\n+    }\n+  }\n+\n+  /**\n+   * Invocation caller detection can use StackWalker API which available in Java 9+ only. Therefore\n+   * abstracting the common interface which can be implemented by the default (pre Java 9)\n+   * implementation and the post Java 9 one as well.\n+   */\n+  public interface Impl {\n+    @NonNull\n+    Caller getCaller(int offset);\n+\n+    @NonNull\n+    List<Caller> getCallers();\n+  }\n+\n+  private static final Invocation.Impl impl;\n+\n+  static {\n+    Invocation.Impl rtImpl = new InvocationImplDefault();\n+    try {\n+      Runtime.class.getMethod(\"version\");\n+      Constructor<?> constructor =\n+          Class.forName(Invocation.class.getPackage().getName() + \".InvocationImpl9\")\n+              .getDeclaredConstructor();\n+      constructor.setAccessible(true);\n+      rtImpl = (Invocation.Impl) constructor.newInstance();\n+    } catch (NoSuchMethodException ignored) {\n+      // running on pre-9 Java; silently ignore and use the default impl\n+    } catch (Throwable t) {\n+      log.info(\n+          \"Unable to instantiate StackWalker API based invocation caller impl. Using the default one.\",\n+          t);\n+    }\n+\n+    impl = rtImpl;\n+  }\n+\n+  /**\n+   * Get the method {@linkplain Caller} adjusted by offset. An offset of 0 will return the immediate\n+   * caller.\n+   *\n+   * @param offset the offset to adjust the caller stackframe by\n+   * @return the {@linkplain Caller} located {@literal offset} stackframes above the called method;\n+   *     if the offset is bigger than the current stack depth the callstack root will be returned\n+   *     instead", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efa9d48e8a490f72534260a33374080cb6868b06"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxMDUxOA==", "bodyText": "Yes, good catch. Fixed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1755#discussion_r466910518", "createdAt": "2020-08-07T08:51:57Z", "author": {"login": "jbachorik"}, "path": "internal-api/src/main/java/datadog/trace/mlt/Invocation.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package datadog.trace.mlt;\n+\n+import java.lang.reflect.Constructor;\n+import java.util.List;\n+import java.util.Objects;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class Invocation {\n+  static final int INVOCATION_OFFSET = 3;\n+\n+  /**\n+   * A simple data class representing an invocation caller. Provides the caller class and method\n+   * name.\n+   */\n+  public static final class Caller {\n+    public final String className;\n+    public final String methodName;\n+\n+    Caller(String className, String methodName) {\n+      this.className = className;\n+      this.methodName = methodName;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Caller caller = (Caller) o;\n+      return className.equals(caller.className) && Objects.equals(methodName, caller.methodName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(className, methodName);\n+    }\n+  }\n+\n+  /**\n+   * Invocation caller detection can use StackWalker API which available in Java 9+ only. Therefore\n+   * abstracting the common interface which can be implemented by the default (pre Java 9)\n+   * implementation and the post Java 9 one as well.\n+   */\n+  public interface Impl {\n+    @NonNull\n+    Caller getCaller(int offset);\n+\n+    @NonNull\n+    List<Caller> getCallers();\n+  }\n+\n+  private static final Invocation.Impl impl;\n+\n+  static {\n+    Invocation.Impl rtImpl = new InvocationImplDefault();\n+    try {\n+      Runtime.class.getMethod(\"version\");\n+      Constructor<?> constructor =\n+          Class.forName(Invocation.class.getPackage().getName() + \".InvocationImpl9\")\n+              .getDeclaredConstructor();\n+      constructor.setAccessible(true);\n+      rtImpl = (Invocation.Impl) constructor.newInstance();\n+    } catch (NoSuchMethodException ignored) {\n+      // running on pre-9 Java; silently ignore and use the default impl\n+    } catch (Throwable t) {\n+      log.info(\n+          \"Unable to instantiate StackWalker API based invocation caller impl. Using the default one.\",\n+          t);\n+    }\n+\n+    impl = rtImpl;\n+  }\n+\n+  /**\n+   * Get the method {@linkplain Caller} adjusted by offset. An offset of 0 will return the immediate\n+   * caller.\n+   *\n+   * @param offset the offset to adjust the caller stackframe by\n+   * @return the {@linkplain Caller} located {@literal offset} stackframes above the called method;\n+   *     if the offset is bigger than the current stack depth the callstack root will be returned\n+   *     instead", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMzAwOQ=="}, "originalCommit": {"oid": "efa9d48e8a490f72534260a33374080cb6868b06"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDAxNDM0OnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/mlt/InvocationImplDefault.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoyODowMFrOG87D3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODo1MjozNVrOG9R-VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNTM5MA==", "bodyText": "nit: why not directly creating an ArrayList with the right capacity (based on callerLength) and add Callers inside the list and returning it directly?", "url": "https://github.com/DataDog/dd-trace-java/pull/1755#discussion_r466535390", "createdAt": "2020-08-06T16:28:00Z", "author": {"login": "jpbempel"}, "path": "internal-api/src/main/java/datadog/trace/mlt/InvocationImplDefault.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package datadog.trace.mlt;\n+\n+import static datadog.trace.mlt.Invocation.INVOCATION_OFFSET;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Default implementation of the invocation caller detection. Works for all Java versions from 7\n+ * till the latest current one. The downside is a slight performance hit and the inability to report\n+ * the caller method name.\n+ */\n+@Slf4j\n+final class InvocationImplDefault implements Invocation.Impl {\n+  private static final class WhoCalledSM extends SecurityManager {\n+    @Override\n+    public Class<?>[] getClassContext() {\n+      return super.getClassContext();\n+    }\n+  }\n+\n+  private static final WhoCalledSM ACCESSOR = new WhoCalledSM();\n+\n+  @Override\n+  @NonNull\n+  public Invocation.Caller getCaller(int offset) {\n+    if (offset < 0) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    offset += INVOCATION_OFFSET;\n+\n+    Class<?>[] list = ACCESSOR.getClassContext();\n+\n+    if (list.length <= offset) {\n+      return null;\n+    }\n+\n+    return new Invocation.Caller(list[offset].getName(), null);\n+  }\n+\n+  @Override\n+  @NonNull\n+  public List<Invocation.Caller> getCallers() {\n+    Class<?>[] list = ACCESSOR.getClassContext();\n+    int callerLength = Math.max(list.length - INVOCATION_OFFSET, 0);\n+    Invocation.Caller[] callers = new Invocation.Caller[callerLength];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efa9d48e8a490f72534260a33374080cb6868b06"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxMDgwNA==", "bodyText": "Hm, I don't know :) it makes sense to do it the simplest way - done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1755#discussion_r466910804", "createdAt": "2020-08-07T08:52:35Z", "author": {"login": "jbachorik"}, "path": "internal-api/src/main/java/datadog/trace/mlt/InvocationImplDefault.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package datadog.trace.mlt;\n+\n+import static datadog.trace.mlt.Invocation.INVOCATION_OFFSET;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Default implementation of the invocation caller detection. Works for all Java versions from 7\n+ * till the latest current one. The downside is a slight performance hit and the inability to report\n+ * the caller method name.\n+ */\n+@Slf4j\n+final class InvocationImplDefault implements Invocation.Impl {\n+  private static final class WhoCalledSM extends SecurityManager {\n+    @Override\n+    public Class<?>[] getClassContext() {\n+      return super.getClassContext();\n+    }\n+  }\n+\n+  private static final WhoCalledSM ACCESSOR = new WhoCalledSM();\n+\n+  @Override\n+  @NonNull\n+  public Invocation.Caller getCaller(int offset) {\n+    if (offset < 0) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    offset += INVOCATION_OFFSET;\n+\n+    Class<?>[] list = ACCESSOR.getClassContext();\n+\n+    if (list.length <= offset) {\n+      return null;\n+    }\n+\n+    return new Invocation.Caller(list[offset].getName(), null);\n+  }\n+\n+  @Override\n+  @NonNull\n+  public List<Invocation.Caller> getCallers() {\n+    Class<?>[] list = ACCESSOR.getClassContext();\n+    int callerLength = Math.max(list.length - INVOCATION_OFFSET, 0);\n+    Invocation.Caller[] callers = new Invocation.Caller[callerLength];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNTM5MA=="}, "originalCommit": {"oid": "efa9d48e8a490f72534260a33374080cb6868b06"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 0, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}