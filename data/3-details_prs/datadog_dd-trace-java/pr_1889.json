{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NTY1MTcw", "number": 1889, "title": "ScopeListener and ScopeManager fixes", "bodyText": "Problem:\nThis fixes various problems with ScopeListener and ScopeManager\n\nScopeListener.afterScopeActivated() was only called for new scopes and not previous scopes being activated (starting with 0.52.0)\nScope depth was incorrectly tracked with out-of-order scope closing\nTraces with scopes meeting the following conditions were never reported:\n\na) resulting from Continuation activations\nb) closed out of order\n\n\nScopeListener.afterScopeClosed() wasn't called for Scopes closed out of order until the ScopeStack was modified again\nSome closed scopes were never GC'd until a call to activeScope() or similar (you could have an entire stack of closed scopes with the right .close() ordering)\nThe internal array in scope stack was almost always resized to 0.  Leading to a lot of churn and array copying.\nScopes with multiple activations didn't trigger strict mode when closed out of order\n\nImplementation:\nThe main change is that the stack is cleaned up when a scope is closed rather than on calls to top().  This simplifies things greatly.\nReviewing:\nPlease check the tests first.  Part of the issue before is we had tests that were wrong and we only tracked counts instead of ordering", "createdAt": "2020-09-18T22:18:58Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1889", "merged": true, "mergeCommit": {"oid": "e564130543fc27e46d8e2fbb9a0fc50d1c9ab4ce"}, "closed": true, "closedAt": "2020-09-21T15:23:30Z", "author": {"login": "randomanderson"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdKLtMkAH2gAyNDg5NTY1MTcwOjBlMjMxODdkNjZiN2M4MTRiYzE0NDAyMTRkMTQ0OGJmZDRkMjI3Yzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLGp6qgFqTQ5Mjc0NDE3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e23187d66b7c814bc1440214d1448bfd4d227c7", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0e23187d66b7c814bc1440214d1448bfd4d227c7", "committedDate": "2020-09-18T20:34:48Z", "message": "Some failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4", "committedDate": "2020-09-18T22:12:07Z", "message": "Fix issues with ContinuableScopeManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d8ea2d0e183464b34aca0b777007f86751c96a2", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9d8ea2d0e183464b34aca0b777007f86751c96a2", "committedDate": "2020-09-18T22:12:56Z", "message": "This check is no longer necessary and probably causes problems"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6876b8a0a7a09bd54344694bb4590576ac5cae62", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6876b8a0a7a09bd54344694bb4590576ac5cae62", "committedDate": "2020-09-18T22:50:31Z", "message": "Fix tests in OT project"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxODIyNDc5", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#pullrequestreview-491822479", "createdAt": "2020-09-18T22:52:48Z", "commit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1Mjo0OFrOHUeFtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1Mjo0OFrOHUeFtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA==", "bodyText": "Can you clarify the difference between topPos starting at 0, with element 0 maintained to be always null, and topPos starting at -1 and returning null whenever topPos is -1?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491226548", "createdAt": "2020-09-18T22:52:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b18e63f1110930218df2b97a0f60a274c2b5dbab", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b18e63f1110930218df2b97a0f60a274c2b5dbab", "committedDate": "2020-09-18T23:17:10Z", "message": "anchor toppos at 0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6076473dc811133379059311510fc474395b3f1e", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6076473dc811133379059311510fc474395b3f1e", "committedDate": "2020-09-18T23:41:41Z", "message": "Fix some comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b6985538d4d8f485557af5c2a2374128487db093", "committedDate": "2020-09-19T00:01:30Z", "message": "Fix out of order + multiple activations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMzE5MTA2", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#pullrequestreview-492319106", "createdAt": "2020-09-21T06:59:13Z", "commit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNDQyNTEz", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#pullrequestreview-492442513", "createdAt": "2020-09-21T09:59:37Z", "commit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzQ0MTc3", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#pullrequestreview-492744177", "createdAt": "2020-09-21T15:38:57Z", "commit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTozODo1N1rOHVXDMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MDowOFrOHVXhZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1OTc5NA==", "bodyText": "If the first one fails, the second one is going to get run. Perhaps these should have their own try blocks?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492159794", "createdAt": "2020-09-21T15:38:57Z", "author": {"login": "arkban"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/log/LogContextScopeListener.java", "diffHunk": "@@ -45,10 +43,6 @@ public void afterScopeActivated() {\n \n   @Override\n   public void afterScopeClosed() {\n-    if (activeSpan() != null) {\n-      afterScopeActivated();\n-      return;\n-    }\n     try {\n       removeMethod.invoke(null, CorrelationIdentifier.getTraceIdKey());\n       removeMethod.invoke(null, CorrelationIdentifier.getSpanIdKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg==", "bodyText": "Why remove the \"Ignoring!\" phrase? That was a useful canary to check if things went sideways.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492160816", "createdAt": "2020-09-21T15:40:28Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -148,24 +148,15 @@ protected ScopeStack scopeStack() {\n \n     @Override\n     public void close() {\n-      ScopeStack scopeStack = scopeManager.scopeStack();\n-\n-      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n-      // first round of out-of-order handling.\n-      // When reference counts are being used, we don't check the stack top --\n-      // so potentially we undercount errors\n-      // Also we don't report closed until the reference count == 0 which seems\n-      // incorrect given the OpenTracing semantics\n-      // Both these issues should be corrected at a later date\n+      final ScopeStack scopeStack = scopeManager.scopeStack();\n \n-      boolean alive = decrementReferences();\n-      if (alive) return;\n+      final boolean alive = decrementReferences();\n \n-      boolean onTop = scopeStack.checkTop(this);\n+      final boolean onTop = scopeStack.checkTop(this);\n       if (!onTop) {\n         if (log.isDebugEnabled()) {\n-          // Using noFixupTop because I don't want to have code with side effects in logging code\n-          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+          log.debug(\n+              \"Tried to close {} scope when not on top.  Current top: {}\", this, scopeStack.top());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MTQzNA==", "bodyText": "Is it possible for cancelFromContinuedScopeClose() to throw and prevent this from being reached?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492161434", "createdAt": "2020-09-21T15:41:23Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -177,19 +168,17 @@ public void close() {\n             throw new RuntimeException(\"Tried to close scope when not on top\");\n           }\n         }\n+      }\n \n+      if (alive) {\n         return;\n       }\n \n       if (null != continuation) {\n-        span.context().getTrace().cancelContinuation(continuation);\n+        continuation.cancelFromContinuedScopeClose();\n       }\n-      scopeStack.blindPop();\n \n-      // DQH - As covered above, I feel our close notification semantics are incorrect with\n-      // especially where reference counting is concerned.  Unfortunately, sorting out the\n-      // semantics will also require sorting out the tests which have codified the ill-behavior.\n-      onProperClose();\n+      scopeStack.cleanup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NTUwNg==", "bodyText": "Does this mean that topPos is 1-indexed? I'm asking because it says here 0 if empty, yet all the calls like stack[topPos] seem to use topPos as if it was 0-indexed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492165506", "createdAt": "2020-09-21T15:47:14Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEyNw==", "bodyText": "Should this be private? Seems like internal state.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492166127", "createdAt": "2020-09-21T15:48:12Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg==", "bodyText": "Why not use an ArrayList? You might do better off with that and calling ArrayList.trimToSize() when it's capacity grows beyond what you want.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492167526", "createdAt": "2020-09-21T15:50:08Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty\n     int topPos = 0;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    /** top - accesses the top of the ScopeStack */\n     final ContinuableScope top() {\n-      int priorTopPos = this.topPos;\n-      if (priorTopPos == 0) {\n-        return null;\n-      }\n+      return stack[topPos];\n+    }\n \n+    void cleanup() {\n       // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n       // only bothering to do this here because of the loop below\n-      ContinuableScope[] stack = this.stack;\n-      priorTopPos = Math.min(priorTopPos, stack.length);\n-\n-      // Peel first iteration\n-      ContinuableScope topScope = stack[priorTopPos];\n-      if (topScope.alive()) {\n-        return topScope;\n-      }\n+      final ContinuableScope[] stack = this.stack;\n+      topPos = Math.min(topPos, stack.length);\n \n-      // null out top position, it is no longer alive\n-      stack[topPos] = null;\n-\n-      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n-        ContinuableScope curScope = stack[curPos];\n+      boolean changedTop = false;\n+      while (topPos > 0) {\n+        final ContinuableScope curScope = stack[topPos];\n         if (curScope.alive()) {\n-          // save the position for next time\n-          topPos = curPos;\n-\n-          if (topPos < stack.length / 4) {\n-            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          if (changedTop) {\n+            curScope.afterActivated();\n           }\n-\n-          return curScope;\n+          break;\n         }\n \n         // no longer alive -- trigger listener & null out\n         curScope.onProperClose();\n-        stack[curPos] = null;\n+        stack[topPos] = null;\n+        --topPos;\n+        changedTop = true;\n       }\n \n-      // empty stack -- save topPos for next time\n-      topPos = 0;\n-      return null;\n-    }\n-\n-    /**\n-     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n-     * useful in logging to avoid side effects, but could be used in other places with caution.\n-     */\n-    final ContinuableScope noFixupTop() {\n-      return stack[topPos];\n+      if (topPos < stack.length / 4 && stack.length > MIN_STACK_LENGTH * 4) {\n+        this.stack = Arrays.copyOf(stack, stack.length / 2);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3138, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}