{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDgzMzk4", "number": 2215, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1NTo0NVrOFGb5PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowMDoyMlrOFQidKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjkyNzk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1NTo0NVrOIHcz2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwOTo0MzoxN1rOIHtAGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ==", "bodyText": "tableswitches are generally not faster than array accesses unless the targets are very predictable.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544682969", "createdAt": "2020-12-16T22:55:45Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NDQ1Ng==", "bodyText": "tableswitch is only used for initial allocation, and in this case the targets are predictable - actual lookup at runtime from the advice is done directly as field lookup for the fast-path, with array for the slow path:\nhttps://github.com/DataDog/dd-trace-java/pull/2215/files#diff-47bea262caab8af75c9bf136265015eed9352d1f2d3349eb859abe07a6550a09R137", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544684456", "createdAt": "2020-12-16T22:58:38Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4OTE5OA==", "bodyText": "ok makes sense.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544689198", "createdAt": "2020-12-16T23:08:50Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMDk0Ng==", "bodyText": "As I understand it, the first 8 context stores will do static final field accesses which will allow for constant folding and make this basically free, and the others will call this method with a constant parameter which will index into the array\nFieldBackedContextStore store = getContextStore(N);\nbut because the array and its contents can't be trusted not to change, the access won't be completely optimised away, and there will be a small difference in access time. So I would be tempted to create a lot more of these, maybe 32 or even 64 of them, since it's a fixed cost. What do you think?", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544700946", "createdAt": "2020-12-16T23:36:44Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMTI4Nw==", "bodyText": "Do you think it would be possible to generate the class with the right number of static fields once the number of context stores is known, so only the fast path exists?", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544701287", "createdAt": "2020-12-16T23:37:34Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0ODI1MA==", "bodyText": "Yes, eventually I'd like to have a build plugin scan for uses of InstrumentationContext.get and generate the table class. It could even rewrite the advice at build time to replace InstrumentationContext.get  with field access which would avoid having to do the transformation at runtime.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544948250", "createdAt": "2020-12-17T09:43:17Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzEzMDA4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNDozM1rOIHekog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNDozM1rOIHekog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMTg0Mg==", "bodyText": "An important improvement here is that the instanceof check will only be done once, because it's here rather than having been generated in the accessors, this also makes implementing new methods such as getAndSet much easier to do.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544711842", "createdAt": "2020-12-17T00:04:33Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStore.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package datadog.trace.bootstrap;\n+\n+/**\n+ * {@link ContextStore} that attempts to store context in its keys by using bytecode-injected\n+ * fields. Delegates to a lazy {@link WeakMap} for keys that don't have a field for this store.\n+ */\n+public final class FieldBackedContextStore implements ContextStore<Object, Object> {\n+  final int storeId;\n+\n+  FieldBackedContextStore(final int storeId) {\n+    this.storeId = storeId;\n+  }\n+\n+  @Override\n+  public Object get(final Object key) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      return ((FieldBackedContextAccessor) key).get$__datadogContext$(storeId);\n+    } else {\n+      return weakStore().get(key);\n+    }\n+  }\n+\n+  @Override\n+  public void put(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      ((FieldBackedContextAccessor) key).put$__datadogContext$(storeId, context);\n+    } else {\n+      weakStore().put(key, context);\n+    }\n+  }\n+\n+  @Override\n+  public Object putIfAbsent(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE2Njg5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNzo0MVrOIHe4fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNjoxNzowN1rOIRcyFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA==", "bodyText": "If access to the map is concurrent, the BitSet can't be updated safely, unless processing of each type is guaranteed to be on the same thread. There is no JMM support for updating fields narrower than a byte, and this will lead to word tearing, though it would work with a  wrapper around a boolean[] emulating the relevant parts of BitSet's API (with the right memory barriers in place).", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544716924", "createdAt": "2020-12-17T00:17:41Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -21,6 +28,20 @@\n   private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n       new ConcurrentHashMap<>();\n \n+  private static final Class<?> FIELD_INJECTED_MARKER =\n+      Config.get().isLegacyContextFieldInjection()\n+          ? FieldBackedContextStoreAppliedMarker.class\n+          : FieldBackedContextAccessor.class;\n+\n+  private static final boolean TRACK_EXCLUDED_CONTEXT_STORES =\n+      !Config.get().isLegacyContextFieldInjection();\n+\n+  // this map will contain entries for any root type that we wanted to field-inject\n+  // but were not able to - either because it was explicitly excluded, or because we\n+  // failed to field-inject as the type was already loaded\n+  private static final ConcurrentHashMap<String, BitSet> EXCLUDED_STORE_IDS_BY_TYPE =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0NDkzMg==", "bodyText": "yes, access can be concurrent - I'll replace this with a concurrent version", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544944932", "createdAt": "2020-12-17T09:38:29Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -21,6 +28,20 @@\n   private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n       new ConcurrentHashMap<>();\n \n+  private static final Class<?> FIELD_INJECTED_MARKER =\n+      Config.get().isLegacyContextFieldInjection()\n+          ? FieldBackedContextStoreAppliedMarker.class\n+          : FieldBackedContextAccessor.class;\n+\n+  private static final boolean TRACK_EXCLUDED_CONTEXT_STORES =\n+      !Config.get().isLegacyContextFieldInjection();\n+\n+  // this map will contain entries for any root type that we wanted to field-inject\n+  // but were not able to - either because it was explicitly excluded, or because we\n+  // failed to field-inject as the type was already loaded\n+  private static final ConcurrentHashMap<String, BitSet> EXCLUDED_STORE_IDS_BY_TYPE =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2ODI3OQ==", "bodyText": "As mentioned elsewhere it turns out that each BitSet has low contention because they are only updated and read by excluded types and their sub-classes - and only during transform. Adding a simple synchronized block is enough for this use-case: 8c9fd16", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555168279", "createdAt": "2021-01-11T16:17:07Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -21,6 +28,20 @@\n   private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n       new ConcurrentHashMap<>();\n \n+  private static final Class<?> FIELD_INJECTED_MARKER =\n+      Config.get().isLegacyContextFieldInjection()\n+          ? FieldBackedContextStoreAppliedMarker.class\n+          : FieldBackedContextAccessor.class;\n+\n+  private static final boolean TRACK_EXCLUDED_CONTEXT_STORES =\n+      !Config.get().isLegacyContextFieldInjection();\n+\n+  // this map will contain entries for any root type that we wanted to field-inject\n+  // but were not able to - either because it was explicitly excluded, or because we\n+  // failed to field-inject as the type was already loaded\n+  private static final ConcurrentHashMap<String, BitSet> EXCLUDED_STORE_IDS_BY_TYPE =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE3MTk5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxOTozNlrOIHe7Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNjoxNzo0OVrOIRcz0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw==", "bodyText": "This seems to be explicitly catering for concurrency (matchedType was missing, but using putIfAbsent in case another thread added it) but the update to the BitSet isn't safe, and updates from competing threads will overwrite each other. See the comment about word tearing.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544717627", "createdAt": "2020-12-17T00:19:36Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxODI4Mw==", "bodyText": "In fact, the comment directly below indicates that this is designed to handle concurrent updates.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544718283", "createdAt": "2020-12-17T00:21:20Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0NTI0MQ==", "bodyText": "yes, I'll replace this with a concurrent version", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544945241", "createdAt": "2020-12-17T09:38:58Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2ODcyMA==", "bodyText": "as above, adding a synchronized block is acceptable for this particular use-case: 8c9fd16", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555168720", "createdAt": "2021-01-11T16:17:49Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTE4Nzk5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNzowNDoxOFrOIRe0ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNzowNDoxOFrOIRe0ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIwMTYzNw==", "bodyText": "interesting... \ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555201637", "createdAt": "2021-01-11T17:04:18Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "diffHunk": "@@ -72,11 +74,16 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     addByteBuddyRawSetting();\n \n-    FieldBackedProvider.resetContextMatchers();\n+    if (Config.get().isLegacyContextFieldInjection()) {\n+      FieldBackedProvider.resetContextMatchers();\n+    } else {\n+      FieldBackedContextProvider.resetContextMatchers();\n+    }\n \n     AgentBuilder.Ignored ignoredAgentBuilder =\n         new AgentBuilder.Default()\n             .disableClassFormatChanges()\n+            .assureReadEdgeTo(INSTRUMENTATION, FieldBackedContextAccessor.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTQ0ODM5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODowODoxOFrOIRhS9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0Nzo0NlrOIVlzYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA==", "bodyText": "I don't think this is thread safe with concurrent updates since extraStores is volatile, and two threads could get inside the block at the same time, and the second one to expand the array can read the updated length, so quadruple the size. The second updater could also overwrite the result of extraStores[arrayIndex] = store; below. It's probably worth making this synchronized on a private lock.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555242230", "createdAt": "2021-01-11T18:08:18Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0Nzk2NA==", "bodyText": "this method is only called inside a synchronized block on STORES_BY_NAME", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555247964", "createdAt": "2021-01-11T18:18:29Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MDQ2NA==", "bodyText": "This needs a comment for maintainability", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555260464", "createdAt": "2021-01-11T18:40:50Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDM2OQ==", "bodyText": "done as part of 4de2aa4", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510369", "createdAt": "2021-01-18T11:47:46Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTQ2MTc2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxMjowN1rOIRhbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0NjoyNVrOIVlwSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDMwNw==", "bodyText": "Since this method is used for looking up the weak stores (is this a correct reading?), I would suggest removing the large switch statement and putting the 32 stores into the extraStores  array  and replace this with an array lookup to reduce the bytecode weight of the method when the fallback is required. It also just simplifies the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555244307", "createdAt": "2021-01-11T18:12:07Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwOTU3OQ==", "bodyText": "4de2aa4", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559509579", "createdAt": "2021-01-18T11:46:25Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDMwNw=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTQ3Mjk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/WeakMapContextStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNTowOFrOIRhh2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0Njo0NlrOIVlxDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjA0Mg==", "bodyText": "Can you add a comment that making it clear that this class should be instantiated lazily (it is lazily instantiated in FieldBackedContextStore) because it triggers background cleanup work?", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555246042", "createdAt": "2021-01-11T18:15:08Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/WeakMapContextStore.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package datadog.trace.bootstrap;\n+\n+final class WeakMapContextStore implements ContextStore<Object, Object> {\n+  private static final int MAX_SIZE = 50_000;\n+\n+  private final WeakMap<Object, Object> map = WeakMap.Provider.newWeakMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwOTc3NQ==", "bodyText": "98ec83f", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559509775", "createdAt": "2021-01-18T11:46:46Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/WeakMapContextStore.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package datadog.trace.bootstrap;\n+\n+final class WeakMapContextStore implements ContextStore<Object, Object> {\n+  private static final int MAX_SIZE = 50_000;\n+\n+  private final WeakMap<Object, Object> map = WeakMap.Provider.newWeakMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjA0Mg=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTQ4MjAyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/FieldBackedContextStoresTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNzoyOFrOIRhnMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0NzowNlrOIVlxvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NzQwOA==", "bodyText": "I would be tempted to add another test to go a little way beyond 64 since the store ids are stored in a bitset, to make sure more than the first word is used, and run the test concurrently", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555247408", "createdAt": "2021-01-11T18:17:28Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/FieldBackedContextStoresTest.groovy", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.trace.bootstrap\n+\n+import datadog.trace.test.util.DDSpecification\n+\n+class FieldBackedContextStoresTest extends DDSpecification {\n+\n+  def \"test FieldBackedContextStore id allocation (#storeId)\"() {\n+    setup:\n+      int allocatedId = FieldBackedContextStores.getContextStoreId(\"key${storeId}\", \"value${storeId}\")\n+\n+    expect:\n+      storeId == allocatedId\n+      storeId == FieldBackedContextStores.getContextStore(storeId).storeId\n+\n+    where:\n+      storeId << (0..64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwOTk0OA==", "bodyText": "4de2aa4", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559509948", "createdAt": "2021-01-18T11:47:06Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/FieldBackedContextStoresTest.groovy", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.trace.bootstrap\n+\n+import datadog.trace.test.util.DDSpecification\n+\n+class FieldBackedContextStoresTest extends DDSpecification {\n+\n+  def \"test FieldBackedContextStore id allocation (#storeId)\"() {\n+    setup:\n+      int allocatedId = FieldBackedContextStores.getContextStoreId(\"key${storeId}\", \"value${storeId}\")\n+\n+    expect:\n+      storeId == allocatedId\n+      storeId == FieldBackedContextStores.getContextStore(storeId).storeId\n+\n+    where:\n+      storeId << (0..64)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NzQwOA=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTU2OTcyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODo0MjoyMVrOIRidcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxMjo0NDo0M1rOIWM4Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng==", "bodyText": "I'm wary of trusting that equality will have been implemented properly for ElementMatcher", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555261296", "createdAt": "2021-01-11T18:42:21Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.safeHasSuperType;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.unpackContextStore;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.wrapVisitor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.Instrumenter.Default;\n+import datadog.trace.api.Config;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * InstrumentationContextProvider which stores context in a field that is injected into a class and\n+ * falls back to tracking the context association in a global weak-map if the field wasn't injected.\n+ *\n+ * <p>This is accomplished by\n+ *\n+ * <ol>\n+ *   <li>Rewriting calls to {@link InstrumentationContext} to access stores based on numeric ids\n+ *   <li>Injecting fields in the earliest holder class that matches the context key\n+ *   <li>Injecting a getter and setter that retrieves context stored in the injected fields\n+ *   <li>Delegating to the superclass getter and setter if a superclass is also a context holder\n+ *   <li>Delegating to weak-map if neither this class or superclass have a field for the context\n+ * </ol>\n+ */\n+@Slf4j\n+public final class FieldBackedContextProvider implements InstrumentationContextProvider {\n+\n+  /*\n+   * Mapping from the instrumentations contextClassLoaderMatcher to a set of pairs (context holder, context class)\n+   * for which we have matchers installed. We use this to make sure we do not install matchers repeatedly for cases\n+   * when same context class is used by multiple instrumentations.\n+   */\n+  private static final HashMap<ElementMatcher<ClassLoader>, Set<Map.Entry<String, String>>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI4NDA5NQ==", "bodyText": "this comes from the original code: https://github.com/DataDog/dd-trace-java/blob/master/dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java#L45 - that's not to say this doesn't warrant further investigation, just that if there is an issue then it affects both old and new approaches", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555284095", "createdAt": "2021-01-11T19:24:15Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.safeHasSuperType;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.unpackContextStore;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.wrapVisitor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.Instrumenter.Default;\n+import datadog.trace.api.Config;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * InstrumentationContextProvider which stores context in a field that is injected into a class and\n+ * falls back to tracking the context association in a global weak-map if the field wasn't injected.\n+ *\n+ * <p>This is accomplished by\n+ *\n+ * <ol>\n+ *   <li>Rewriting calls to {@link InstrumentationContext} to access stores based on numeric ids\n+ *   <li>Injecting fields in the earliest holder class that matches the context key\n+ *   <li>Injecting a getter and setter that retrieves context stored in the injected fields\n+ *   <li>Delegating to the superclass getter and setter if a superclass is also a context holder\n+ *   <li>Delegating to weak-map if neither this class or superclass have a field for the context\n+ * </ol>\n+ */\n+@Slf4j\n+public final class FieldBackedContextProvider implements InstrumentationContextProvider {\n+\n+  /*\n+   * Mapping from the instrumentations contextClassLoaderMatcher to a set of pairs (context holder, context class)\n+   * for which we have matchers installed. We use this to make sure we do not install matchers repeatedly for cases\n+   * when same context class is used by multiple instrumentations.\n+   */\n+  private static final HashMap<ElementMatcher<ClassLoader>, Set<Map.Entry<String, String>>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDE1MDYxOQ==", "bodyText": "I agree, leave it in place. But this assumes unequal matchers don't match the same classes, which isn't true, and wouldn't be a good strategy even if equals and hashCode were always implemented properly, since two unequal matchers can match the same classes - e.g.\nnamedOneOf(\"foo.bar.ClassLoader\", \"bar.foo.ClassLoader\")\nand\nnamed(\"foo.bar.ClassLoader\").or(named(\"bar.foo.ClassLoader\"))\nmatch the same types but are unequal objects. So this isn't just a case of implementing equals and hashCode.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r560150619", "createdAt": "2021-01-19T12:44:43Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.safeHasSuperType;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.unpackContextStore;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.wrapVisitor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.Instrumenter.Default;\n+import datadog.trace.api.Config;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * InstrumentationContextProvider which stores context in a field that is injected into a class and\n+ * falls back to tracking the context association in a global weak-map if the field wasn't injected.\n+ *\n+ * <p>This is accomplished by\n+ *\n+ * <ol>\n+ *   <li>Rewriting calls to {@link InstrumentationContext} to access stores based on numeric ids\n+ *   <li>Injecting fields in the earliest holder class that matches the context key\n+ *   <li>Injecting a getter and setter that retrieves context stored in the injected fields\n+ *   <li>Delegating to the superclass getter and setter if a superclass is also a context holder\n+ *   <li>Delegating to weak-map if neither this class or superclass have a field for the context\n+ * </ol>\n+ */\n+@Slf4j\n+public final class FieldBackedContextProvider implements InstrumentationContextProvider {\n+\n+  /*\n+   * Mapping from the instrumentations contextClassLoaderMatcher to a set of pairs (context holder, context class)\n+   * for which we have matchers installed. We use this to make sure we do not install matchers repeatedly for cases\n+   * when same context class is used by multiple instrumentations.\n+   */\n+  private static final HashMap<ElementMatcher<ClassLoader>, Set<Map.Entry<String, String>>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjAyNTQxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextRequestRewriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMDo1Njo0N1rOIRmy9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0ODozN1rOIVl1XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMjM0Mw==", "bodyText": "Please add a class comment explaining what this does.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555332343", "createdAt": "2021-01-11T20:56:47Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextRequestRewriter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextRequestRewriter implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDg3Ng==", "bodyText": "9584661", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510876", "createdAt": "2021-01-18T11:48:37Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextRequestRewriter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextRequestRewriter implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMjM0Mw=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjAzMzM5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/testing/src/test/groovy/context/FieldInjectionLegacyForkedTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMDo1ODoyN1rOIRm3eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0OTowMVrOIVl2Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMzQ5Ng==", "bodyText": "We try to avoid * imports. You should have a config set in your IDE to increase the threshold.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555333496", "createdAt": "2021-01-11T20:58:27Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/test/groovy/context/FieldInjectionLegacyForkedTest.groovy", "diffHunk": "@@ -19,20 +18,14 @@ import java.lang.reflect.Method\n import java.lang.reflect.Modifier\n import java.util.concurrent.atomic.AtomicReference\n \n-import static context.ContextTestInstrumentation.DisabledKeyClass\n-import static context.ContextTestInstrumentation.IncorrectCallUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectContextClassUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectKeyClassUsageKeyClass\n-import static context.ContextTestInstrumentation.InvalidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.InvalidSerializableKeyClass\n-import static context.ContextTestInstrumentation.KeyClass\n-import static context.ContextTestInstrumentation.UntransformableKeyClass\n-import static context.ContextTestInstrumentation.ValidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.ValidSerializableKeyClass\n-import static datadog.trace.bootstrap.config.provider.SystemPropertiesConfigSource.PREFIX\n+import static context.FieldInjectionTestInstrumentation.*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMTEwNg==", "bodyText": "d4980e5", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559511106", "createdAt": "2021-01-18T11:49:01Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/testing/src/test/groovy/context/FieldInjectionLegacyForkedTest.groovy", "diffHunk": "@@ -19,20 +18,14 @@ import java.lang.reflect.Method\n import java.lang.reflect.Modifier\n import java.util.concurrent.atomic.AtomicReference\n \n-import static context.ContextTestInstrumentation.DisabledKeyClass\n-import static context.ContextTestInstrumentation.IncorrectCallUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectContextClassUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectKeyClassUsageKeyClass\n-import static context.ContextTestInstrumentation.InvalidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.InvalidSerializableKeyClass\n-import static context.ContextTestInstrumentation.KeyClass\n-import static context.ContextTestInstrumentation.UntransformableKeyClass\n-import static context.ContextTestInstrumentation.ValidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.ValidSerializableKeyClass\n-import static datadog.trace.bootstrap.config.provider.SystemPropertiesConfigSource.PREFIX\n+import static context.FieldInjectionTestInstrumentation.*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMzQ5Ng=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjA2MjQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextInjector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTowMzo0OVrOIRnJOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOFQxMTo0ODo0MlrOIVl1ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzODA0Mg==", "bodyText": "Class doc please.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555338042", "createdAt": "2021-01-11T21:03:49Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextInjector.java", "diffHunk": "@@ -0,0 +1,505 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.context.ShouldInjectFieldsMatcher.hasInjectedField;\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.FieldBackedContextAccessor;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.ClassFileVersion;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.FieldVisitor;\n+import net.bytebuddy.jar.asm.Label;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextInjector implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDk0Mg==", "bodyText": "9584661", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510942", "createdAt": "2021-01-18T11:48:42Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextInjector.java", "diffHunk": "@@ -0,0 +1,505 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.context.ShouldInjectFieldsMatcher.hasInjectedField;\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.FieldBackedContextAccessor;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.ClassFileVersion;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.FieldVisitor;\n+import net.bytebuddy.jar.asm.Label;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextInjector implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzODA0Mg=="}, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyODg2MDU4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowMDoyMlrOIWc3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowMDoyMlrOIWc3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMjYxNQ==", "bodyText": "An example of code that wouldn't need to exist if we dropped java 7.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r560412615", "createdAt": "2021-01-19T19:00:22Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** Allocates {@link ContextStore} ids and keeps track of allocated stores. */\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  // these fields will be accessed directly from field-injected instrumentation\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // keep track of all allocated stores so far\n+  private static volatile FieldBackedContextStore[] stores = {\n+    contextStore0,\n+    contextStore1,\n+    contextStore2,\n+    contextStore3,\n+    contextStore4,\n+    contextStore5,\n+    contextStore6,\n+    contextStore7,\n+    contextStore8,\n+    contextStore9,\n+    contextStore10,\n+    contextStore11,\n+    contextStore12,\n+    contextStore13,\n+    contextStore14,\n+    contextStore15,\n+    contextStore16,\n+    contextStore17,\n+    contextStore18,\n+    contextStore19,\n+    contextStore20,\n+    contextStore21,\n+    contextStore22,\n+    contextStore23,\n+    contextStore24,\n+    contextStore25,\n+    contextStore26,\n+    contextStore27,\n+    contextStore28,\n+    contextStore29,\n+    contextStore30,\n+    contextStore31\n+  };\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    return stores[storeId]; // createStore ensures array is big enough for allocated storeIds\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4557, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}