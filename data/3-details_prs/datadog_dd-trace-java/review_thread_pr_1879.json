{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4Mjg0OTQ4", "number": 1879, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTozNTowOFrOEksisA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTozNTowOFrOEksisA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTEzOTY4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-webmvc-3.1/src/main/java/datadog/trace/instrumentation/springweb/BeanFactoryInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTozNTowOFrOHTygsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo0NDo0NVrOHT2mgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMjU2MA==", "bodyText": "Is this something we need to replicate for other Spring instrumentation & bean types?\nI'm fine with us doing a targeted fix first.\nI'm just wondering if there's a bigger change that we need as well.", "url": "https://github.com/DataDog/dd-trace-java/pull/1879#discussion_r490512560", "createdAt": "2020-09-17T19:35:08Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-webmvc-3.1/src/main/java/datadog/trace/instrumentation/springweb/BeanFactoryInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.springweb;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.springframework.beans.factory.support.RootBeanDefinition;\n+\n+/**\n+ * Bean Factories can be set with a \"beanClassloader\" that is different from the injected\n+ * classloader. This leads to a ClassNotFoundException at runtime.\n+ *\n+ * <p>This instrumentation ensures class lookups for the HandlerMappingResourceNameFilter don't fail\n+ * by manually setting the class on the bean definition\n+ *\n+ * <p>This can't be done at BeanDefinition construction time because Spring heavy use of clone()\n+ * which sometimes only copies the classname\n+ */\n+@AutoService(Instrumenter.class)\n+public class BeanFactoryInstrumentation extends Instrumenter.Default {\n+  public BeanFactoryInstrumentation() {\n+    super(\"spring-web\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.springframework.beans.factory.support.AbstractBeanFactory\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"org.springframework.beans.factory.support.AbstractBeanFactory\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".SpringWebHttpServerDecorator\",\n+      packageName + \".SpringWebHttpServerDecorator$1\",\n+      packageName + \".ServletRequestURIAdapter\",\n+      packageName + \".HandlerMappingResourceNameFilter\",\n+      packageName + \".HandlerMappingResourceNameFilter$BeanDefinition\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"resolveBeanClass\"))\n+            .and(\n+                takesArgument(\n+                    0, named(\"org.springframework.beans.factory.support.RootBeanDefinition\"))),\n+        BeanFactoryInstrumentation.class.getName() + \"$BeanResolvingAdvice\");\n+  }\n+\n+  public static class BeanResolvingAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void onEnter(@Advice.Argument(0) final RootBeanDefinition beanDefinition) {\n+      if (!beanDefinition.hasBeanClass()\n+          && HandlerMappingResourceNameFilter.class\n+              .getName()\n+              .equals(beanDefinition.getBeanClassName())) {\n+\n+        beanDefinition.setBeanClass(HandlerMappingResourceNameFilter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170d40cddede911fba5d38497ab8dbf4ad218fad"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3OTU4NA==", "bodyText": "HandlerMappingResourceNameFilter is the only bean that we register so no other changes are required", "url": "https://github.com/DataDog/dd-trace-java/pull/1879#discussion_r490579584", "createdAt": "2020-09-17T21:44:45Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/spring-webmvc-3.1/src/main/java/datadog/trace/instrumentation/springweb/BeanFactoryInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.springweb;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.extendsClass;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.springframework.beans.factory.support.RootBeanDefinition;\n+\n+/**\n+ * Bean Factories can be set with a \"beanClassloader\" that is different from the injected\n+ * classloader. This leads to a ClassNotFoundException at runtime.\n+ *\n+ * <p>This instrumentation ensures class lookups for the HandlerMappingResourceNameFilter don't fail\n+ * by manually setting the class on the bean definition\n+ *\n+ * <p>This can't be done at BeanDefinition construction time because Spring heavy use of clone()\n+ * which sometimes only copies the classname\n+ */\n+@AutoService(Instrumenter.class)\n+public class BeanFactoryInstrumentation extends Instrumenter.Default {\n+  public BeanFactoryInstrumentation() {\n+    super(\"spring-web\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.springframework.beans.factory.support.AbstractBeanFactory\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return extendsClass(named(\"org.springframework.beans.factory.support.AbstractBeanFactory\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".SpringWebHttpServerDecorator\",\n+      packageName + \".SpringWebHttpServerDecorator$1\",\n+      packageName + \".ServletRequestURIAdapter\",\n+      packageName + \".HandlerMappingResourceNameFilter\",\n+      packageName + \".HandlerMappingResourceNameFilter$BeanDefinition\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"resolveBeanClass\"))\n+            .and(\n+                takesArgument(\n+                    0, named(\"org.springframework.beans.factory.support.RootBeanDefinition\"))),\n+        BeanFactoryInstrumentation.class.getName() + \"$BeanResolvingAdvice\");\n+  }\n+\n+  public static class BeanResolvingAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void onEnter(@Advice.Argument(0) final RootBeanDefinition beanDefinition) {\n+      if (!beanDefinition.hasBeanClass()\n+          && HandlerMappingResourceNameFilter.class\n+              .getName()\n+              .equals(beanDefinition.getBeanClassName())) {\n+\n+        beanDefinition.setBeanClass(HandlerMappingResourceNameFilter.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxMjU2MA=="}, "originalCommit": {"oid": "170d40cddede911fba5d38497ab8dbf4ad218fad"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4828, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}