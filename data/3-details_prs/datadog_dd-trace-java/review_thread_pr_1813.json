{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NjY2ODIx", "number": 1813, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozMzo1OFrOEeT17Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOToxNDoxMVrOEe0FOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE3ODM3OnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigConverter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozMzo1OFrOHJ5D4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozMzo1OFrOHJ5D4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDExNQ==", "bodyText": "I wonder if type specific converters would be better than many static methods, but this is fine.", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480134115", "createdAt": "2020-08-31T13:33:58Z", "author": {"login": "dougqh"}, "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigConverter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package datadog.trace.bootstrap.config.provider;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class ConfigConverter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a2c6b936ba7bb3d605ccf149bf68c502fa8f90"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE4MzY4OnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigConverter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozNToxMVrOHJ5G8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMTozM1rOHKHm8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDg5Ng==", "bodyText": "I think this should by error.  I also think this should fail immediately with an Exception or Error in tests.", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480134896", "createdAt": "2020-08-31T13:35:11Z", "author": {"login": "dougqh"}, "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigConverter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package datadog.trace.bootstrap.config.provider;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class ConfigConverter {\n+  private static final ValueOfLookup LOOKUP = new ValueOfLookup();\n+\n+  /**\n+   * @param value to parse by tClass::valueOf\n+   * @param tClass should contain static parsing method \"T valueOf(String)\"\n+   * @param <T>\n+   * @return value == null || value.trim().isEmpty() ? defaultValue : tClass.valueOf(value)\n+   * @throws NumberFormatException\n+   */\n+  static <T> T valueOf(final String value, @NonNull final Class<T> tClass) {\n+    if (value == null || value.trim().isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return (T) LOOKUP.get(tClass).invoke(value);\n+    } catch (final NumberFormatException e) {\n+      throw e;\n+    } catch (final Throwable e) {\n+      log.debug(\"Can't parse: \", e);\n+      throw new NumberFormatException(e.toString());\n+    }\n+  }\n+\n+  @NonNull\n+  static List<String> parseList(final String str) {\n+    if (str == null || str.trim().isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    final String[] tokens = str.split(\",\", -1);\n+    // Remove whitespace from each item.\n+    for (int i = 0; i < tokens.length; i++) {\n+      tokens[i] = tokens[i].trim();\n+    }\n+    return Collections.unmodifiableList(Arrays.asList(tokens));\n+  }\n+\n+  @NonNull\n+  static Map<String, String> parseMap(final String str, final String settingName) {\n+    // If we ever want to have default values besides an empty map, this will need to change.\n+    if (str == null || str.trim().isEmpty()) {\n+      return Collections.emptyMap();\n+    }\n+    if (!str.matches(\"(([^,:]+:[^,:]*,)*([^,:]+:[^,:]*),?)?\")) {\n+      log.warn(\n+          \"Invalid config for {}: '{}'. Must match 'key1:value1,key2:value2'.\", settingName, str);\n+      return Collections.emptyMap();\n+    }\n+\n+    final String[] tokens = str.split(\",\", -1);\n+    final Map<String, String> map = newHashMap(tokens.length);\n+\n+    for (final String token : tokens) {\n+      final String[] keyValue = token.split(\":\", -1);\n+      if (keyValue.length == 2) {\n+        final String key = keyValue[0].trim();\n+        final String value = keyValue[1].trim();\n+        if (value.length() <= 0) {\n+          log.warn(\"Ignoring empty value for key '{}' in config for {}\", key, settingName);\n+          continue;\n+        }\n+        map.put(key, value);\n+      }\n+    }\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  @NonNull\n+  private static Map<String, String> newHashMap(final int size) {\n+    return new HashMap<>(size + 1, 1f);\n+  }\n+\n+  @NonNull\n+  static BitSet parseIntegerRangeSet(@NonNull String str, final String settingName)\n+      throws NumberFormatException {\n+    str = str.replaceAll(\"\\\\s\", \"\");\n+    if (!str.matches(\"\\\\d{3}(?:-\\\\d{3})?(?:,\\\\d{3}(?:-\\\\d{3})?)*\")) {\n+      log.warn(\n+          \"Invalid config for {}: '{}'. Must be formatted like '400-403,405,410-499'.\",\n+          settingName,\n+          str);\n+      throw new NumberFormatException();\n+    }\n+\n+    final int lastSeparator = Math.max(str.lastIndexOf(','), str.lastIndexOf('-'));\n+    final int maxValue = Integer.parseInt(str.substring(lastSeparator + 1));\n+    final BitSet set = new BitSet(maxValue);\n+    final String[] tokens = str.split(\",\", -1);\n+    for (final String token : tokens) {\n+      final int separator = token.indexOf('-');\n+      if (separator == -1) {\n+        set.set(Integer.parseInt(token));\n+      } else if (separator > 0) {\n+        final int left = Integer.parseInt(token.substring(0, separator));\n+        final int right = Integer.parseInt(token.substring(separator + 1));\n+        final int min = Math.min(left, right);\n+        final int max = Math.max(left, right);\n+        set.set(min, max + 1);\n+      }\n+    }\n+    return set;\n+  }\n+\n+  private static class ValueOfLookup extends ClassValue<MethodHandle> {\n+    private static final MethodHandles.Lookup PUBLIC_LOOKUP = MethodHandles.publicLookup();\n+\n+    @SneakyThrows\n+    @Override\n+    protected MethodHandle computeValue(Class<?> type) {\n+      try {\n+        return PUBLIC_LOOKUP.findStatic(type, \"valueOf\", MethodType.methodType(type, String.class));\n+      } catch (final NoSuchMethodException | IllegalAccessException e) {\n+        log.debug(\"Can't invoke or access 'valueOf': \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a2c6b936ba7bb3d605ccf149bf68c502fa8f90"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MjQ2NQ==", "bodyText": "I can add an assert in ConfigProvider where the exception is being caught and ignored.", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480372465", "createdAt": "2020-08-31T20:11:33Z", "author": {"login": "tylerbenson"}, "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigConverter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package datadog.trace.bootstrap.config.provider;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.NonNull;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class ConfigConverter {\n+  private static final ValueOfLookup LOOKUP = new ValueOfLookup();\n+\n+  /**\n+   * @param value to parse by tClass::valueOf\n+   * @param tClass should contain static parsing method \"T valueOf(String)\"\n+   * @param <T>\n+   * @return value == null || value.trim().isEmpty() ? defaultValue : tClass.valueOf(value)\n+   * @throws NumberFormatException\n+   */\n+  static <T> T valueOf(final String value, @NonNull final Class<T> tClass) {\n+    if (value == null || value.trim().isEmpty()) {\n+      return null;\n+    }\n+    try {\n+      return (T) LOOKUP.get(tClass).invoke(value);\n+    } catch (final NumberFormatException e) {\n+      throw e;\n+    } catch (final Throwable e) {\n+      log.debug(\"Can't parse: \", e);\n+      throw new NumberFormatException(e.toString());\n+    }\n+  }\n+\n+  @NonNull\n+  static List<String> parseList(final String str) {\n+    if (str == null || str.trim().isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    final String[] tokens = str.split(\",\", -1);\n+    // Remove whitespace from each item.\n+    for (int i = 0; i < tokens.length; i++) {\n+      tokens[i] = tokens[i].trim();\n+    }\n+    return Collections.unmodifiableList(Arrays.asList(tokens));\n+  }\n+\n+  @NonNull\n+  static Map<String, String> parseMap(final String str, final String settingName) {\n+    // If we ever want to have default values besides an empty map, this will need to change.\n+    if (str == null || str.trim().isEmpty()) {\n+      return Collections.emptyMap();\n+    }\n+    if (!str.matches(\"(([^,:]+:[^,:]*,)*([^,:]+:[^,:]*),?)?\")) {\n+      log.warn(\n+          \"Invalid config for {}: '{}'. Must match 'key1:value1,key2:value2'.\", settingName, str);\n+      return Collections.emptyMap();\n+    }\n+\n+    final String[] tokens = str.split(\",\", -1);\n+    final Map<String, String> map = newHashMap(tokens.length);\n+\n+    for (final String token : tokens) {\n+      final String[] keyValue = token.split(\":\", -1);\n+      if (keyValue.length == 2) {\n+        final String key = keyValue[0].trim();\n+        final String value = keyValue[1].trim();\n+        if (value.length() <= 0) {\n+          log.warn(\"Ignoring empty value for key '{}' in config for {}\", key, settingName);\n+          continue;\n+        }\n+        map.put(key, value);\n+      }\n+    }\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  @NonNull\n+  private static Map<String, String> newHashMap(final int size) {\n+    return new HashMap<>(size + 1, 1f);\n+  }\n+\n+  @NonNull\n+  static BitSet parseIntegerRangeSet(@NonNull String str, final String settingName)\n+      throws NumberFormatException {\n+    str = str.replaceAll(\"\\\\s\", \"\");\n+    if (!str.matches(\"\\\\d{3}(?:-\\\\d{3})?(?:,\\\\d{3}(?:-\\\\d{3})?)*\")) {\n+      log.warn(\n+          \"Invalid config for {}: '{}'. Must be formatted like '400-403,405,410-499'.\",\n+          settingName,\n+          str);\n+      throw new NumberFormatException();\n+    }\n+\n+    final int lastSeparator = Math.max(str.lastIndexOf(','), str.lastIndexOf('-'));\n+    final int maxValue = Integer.parseInt(str.substring(lastSeparator + 1));\n+    final BitSet set = new BitSet(maxValue);\n+    final String[] tokens = str.split(\",\", -1);\n+    for (final String token : tokens) {\n+      final int separator = token.indexOf('-');\n+      if (separator == -1) {\n+        set.set(Integer.parseInt(token));\n+      } else if (separator > 0) {\n+        final int left = Integer.parseInt(token.substring(0, separator));\n+        final int right = Integer.parseInt(token.substring(separator + 1));\n+        final int min = Math.min(left, right);\n+        final int max = Math.max(left, right);\n+        set.set(min, max + 1);\n+      }\n+    }\n+    return set;\n+  }\n+\n+  private static class ValueOfLookup extends ClassValue<MethodHandle> {\n+    private static final MethodHandles.Lookup PUBLIC_LOOKUP = MethodHandles.publicLookup();\n+\n+    @SneakyThrows\n+    @Override\n+    protected MethodHandle computeValue(Class<?> type) {\n+      try {\n+        return PUBLIC_LOOKUP.findStatic(type, \"valueOf\", MethodType.methodType(type, String.class));\n+      } catch (final NoSuchMethodException | IllegalAccessException e) {\n+        log.debug(\"Can't invoke or access 'valueOf': \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDg5Ng=="}, "originalCommit": {"oid": "33a2c6b936ba7bb3d605ccf149bf68c502fa8f90"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjE4NzM0OnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMzozNjoxMFrOHJ5JFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoxMzowOVrOHKHp5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNTQ0NQ==", "bodyText": "If ConfigProvider was a Composite of its own type rather than Sources, then this code would have less duplication.", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480135445", "createdAt": "2020-08-31T13:36:10Z", "author": {"login": "dougqh"}, "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigProvider.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package datadog.trace.bootstrap.config.provider;\n+\n+import static datadog.trace.api.config.GeneralConfig.CONFIGURATION_FILE;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.BitSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConfigProvider {\n+  protected final ConfigProvider.Source[] sources;\n+\n+  private ConfigProvider(ConfigProvider.Source... sources) {\n+    this.sources = sources;\n+  }\n+\n+  public final String getString(String key) {\n+    return getString(key, null);\n+  }\n+\n+  public final String getString(String key, String defaultValue, String... aliases) {\n+    for (ConfigProvider.Source source : sources) {\n+      String value = source.get(key, aliases);\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final String getStringBypassSysProps(String key, String defaultValue) {\n+    for (ConfigProvider.Source source : sources) {\n+      if (source instanceof SystemPropertiesConfigSource) {\n+        continue;\n+      }\n+      String value = source.get(key);\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final Boolean getBoolean(String key) {\n+    return get(key, null, Boolean.class);\n+  }\n+\n+  public final boolean getBoolean(String key, boolean defaultValue) {\n+    return get(key, defaultValue, Boolean.class);\n+  }\n+\n+  public final Integer getInteger(String key) {\n+    return get(key, null, Integer.class);\n+  }\n+\n+  public final int getInteger(String key, int defaultValue, String... aliases) {\n+    return get(key, defaultValue, Integer.class, aliases);\n+  }\n+\n+  public final Float getFloat(String key) {\n+    return get(key, null, Float.class);\n+  }\n+\n+  public final float getFloat(String key, float defaultValue) {\n+    return get(key, defaultValue, Float.class);\n+  }\n+\n+  public final Double getDouble(String key) {\n+    return get(key, null, Double.class);\n+  }\n+\n+  public final double getDouble(String key, double defaultValue) {\n+    return get(key, defaultValue, Double.class);\n+  }\n+\n+  private <T> T get(String key, T defaultValue, Class<T> type, String... aliases) {\n+    for (ConfigProvider.Source source : sources) {\n+      T value;\n+      try {\n+        value = ConfigConverter.valueOf(source.get(key, aliases), type);\n+      } catch (NumberFormatException ex) {\n+        continue;\n+      }\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final List<String> getList(String key) {\n+    return ConfigConverter.parseList(getString(key));\n+  }\n+\n+  public final Map<String, String> getMergedMap(String key) {\n+    Map<String, String> merged = new HashMap<>();\n+    // reverse iterate to allow overrides\n+    for (int i = sources.length - 1; 0 <= i; i--) {\n+      String value = sources[i].get(key);\n+      merged.putAll(ConfigConverter.parseMap(value, key));\n+    }\n+    return merged;\n+  }\n+\n+  public BitSet getIntegerRange(final String key, final BitSet defaultValue) {\n+    final String value = getString(key);\n+    try {\n+      return value == null ? defaultValue : ConfigConverter.parseIntegerRangeSet(value, key);\n+    } catch (final NumberFormatException e) {\n+      log.warn(\"Invalid configuration for \" + key, e);\n+      return defaultValue;\n+    }\n+  }\n+\n+  public static ConfigProvider createDefault() {\n+    Properties configProperties =\n+        loadConfigurationFile(\n+            new ConfigProvider(new SystemPropertiesConfigSource(), new EnvironmentConfigSource()));\n+    if (configProperties.isEmpty()) {\n+      return new ConfigProvider(\n+          new SystemPropertiesConfigSource(),\n+          new EnvironmentConfigSource(),\n+          new CapturedEnvironmentConfigSource());\n+    } else {\n+      return new ConfigProvider(\n+          new SystemPropertiesConfigSource(),\n+          new EnvironmentConfigSource(),\n+          new PropertiesConfigSource(configProperties, true),\n+          new CapturedEnvironmentConfigSource());\n+    }\n+  }\n+\n+  public static ConfigProvider withPropertiesOverride(Properties properties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33a2c6b936ba7bb3d605ccf149bf68c502fa8f90"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MzIyMA==", "bodyText": "I don't understand what you mean here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480373220", "createdAt": "2020-08-31T20:13:09Z", "author": {"login": "tylerbenson"}, "path": "internal-api/src/main/java/datadog/trace/bootstrap/config/provider/ConfigProvider.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package datadog.trace.bootstrap.config.provider;\n+\n+import static datadog.trace.api.config.GeneralConfig.CONFIGURATION_FILE;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.BitSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConfigProvider {\n+  protected final ConfigProvider.Source[] sources;\n+\n+  private ConfigProvider(ConfigProvider.Source... sources) {\n+    this.sources = sources;\n+  }\n+\n+  public final String getString(String key) {\n+    return getString(key, null);\n+  }\n+\n+  public final String getString(String key, String defaultValue, String... aliases) {\n+    for (ConfigProvider.Source source : sources) {\n+      String value = source.get(key, aliases);\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final String getStringBypassSysProps(String key, String defaultValue) {\n+    for (ConfigProvider.Source source : sources) {\n+      if (source instanceof SystemPropertiesConfigSource) {\n+        continue;\n+      }\n+      String value = source.get(key);\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final Boolean getBoolean(String key) {\n+    return get(key, null, Boolean.class);\n+  }\n+\n+  public final boolean getBoolean(String key, boolean defaultValue) {\n+    return get(key, defaultValue, Boolean.class);\n+  }\n+\n+  public final Integer getInteger(String key) {\n+    return get(key, null, Integer.class);\n+  }\n+\n+  public final int getInteger(String key, int defaultValue, String... aliases) {\n+    return get(key, defaultValue, Integer.class, aliases);\n+  }\n+\n+  public final Float getFloat(String key) {\n+    return get(key, null, Float.class);\n+  }\n+\n+  public final float getFloat(String key, float defaultValue) {\n+    return get(key, defaultValue, Float.class);\n+  }\n+\n+  public final Double getDouble(String key) {\n+    return get(key, null, Double.class);\n+  }\n+\n+  public final double getDouble(String key, double defaultValue) {\n+    return get(key, defaultValue, Double.class);\n+  }\n+\n+  private <T> T get(String key, T defaultValue, Class<T> type, String... aliases) {\n+    for (ConfigProvider.Source source : sources) {\n+      T value;\n+      try {\n+        value = ConfigConverter.valueOf(source.get(key, aliases), type);\n+      } catch (NumberFormatException ex) {\n+        continue;\n+      }\n+      if (value != null) {\n+        return value;\n+      }\n+    }\n+    return defaultValue;\n+  }\n+\n+  public final List<String> getList(String key) {\n+    return ConfigConverter.parseList(getString(key));\n+  }\n+\n+  public final Map<String, String> getMergedMap(String key) {\n+    Map<String, String> merged = new HashMap<>();\n+    // reverse iterate to allow overrides\n+    for (int i = sources.length - 1; 0 <= i; i--) {\n+      String value = sources[i].get(key);\n+      merged.putAll(ConfigConverter.parseMap(value, key));\n+    }\n+    return merged;\n+  }\n+\n+  public BitSet getIntegerRange(final String key, final BitSet defaultValue) {\n+    final String value = getString(key);\n+    try {\n+      return value == null ? defaultValue : ConfigConverter.parseIntegerRangeSet(value, key);\n+    } catch (final NumberFormatException e) {\n+      log.warn(\"Invalid configuration for \" + key, e);\n+      return defaultValue;\n+    }\n+  }\n+\n+  public static ConfigProvider createDefault() {\n+    Properties configProperties =\n+        loadConfigurationFile(\n+            new ConfigProvider(new SystemPropertiesConfigSource(), new EnvironmentConfigSource()));\n+    if (configProperties.isEmpty()) {\n+      return new ConfigProvider(\n+          new SystemPropertiesConfigSource(),\n+          new EnvironmentConfigSource(),\n+          new CapturedEnvironmentConfigSource());\n+    } else {\n+      return new ConfigProvider(\n+          new SystemPropertiesConfigSource(),\n+          new EnvironmentConfigSource(),\n+          new PropertiesConfigSource(configProperties, true),\n+          new CapturedEnvironmentConfigSource());\n+    }\n+  }\n+\n+  public static ConfigProvider withPropertiesOverride(Properties properties) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNTQ0NQ=="}, "originalCommit": {"oid": "33a2c6b936ba7bb3d605ccf149bf68c502fa8f90"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzQ2MDQxOnYy", "diffSide": "LEFT", "path": "internal-api/src/main/java/datadog/trace/api/Config.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOToxNDoxMVrOHKtYBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOToxNDoxMVrOHKtYBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk5MTIzNg==", "bodyText": "So much red... \ud83e\udd29", "url": "https://github.com/DataDog/dd-trace-java/pull/1813#discussion_r480991236", "createdAt": "2020-09-01T09:14:11Z", "author": {"login": "bantonsson"}, "path": "internal-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -640,230 +609,6 @@ private Config(final String runtimeId) {\n     log.debug(\"New instance: {}\", this);\n   }\n \n-  // Read order: Properties -> Parent\n-  private Config(final Properties properties, final Config parent) {\n-    runtimeId = parent.runtimeId;\n-\n-    configFile = parent.configFile;\n-\n-    apiKey = properties.getProperty(API_KEY, parent.apiKey);\n-    site = properties.getProperty(SITE, parent.site);\n-    serviceName =\n-        properties.getProperty(SERVICE, properties.getProperty(SERVICE_NAME, parent.serviceName));\n-\n-    traceEnabled = getPropertyBooleanValue(properties, TRACE_ENABLED, parent.traceEnabled);\n-    integrationsEnabled =\n-        getPropertyBooleanValue(properties, INTEGRATIONS_ENABLED, parent.integrationsEnabled);\n-    writerType = properties.getProperty(WRITER_TYPE, parent.writerType);\n-    agentHost = properties.getProperty(AGENT_HOST, parent.agentHost);\n-    agentPort =\n-        getPropertyIntegerValue(\n-            properties,\n-            TRACE_AGENT_PORT,\n-            getPropertyIntegerValue(properties, AGENT_PORT_LEGACY, parent.agentPort));\n-    agentUnixDomainSocket =\n-        properties.getProperty(AGENT_UNIX_DOMAIN_SOCKET, parent.agentUnixDomainSocket);\n-    agentConfiguredUsingDefault =\n-        !properties.containsKey(AGENT_HOST)\n-            && !properties.containsKey(AGENT_UNIX_DOMAIN_SOCKET)\n-            && !properties.containsKey(TRACE_AGENT_PORT)\n-            && !properties.containsKey(AGENT_PORT_LEGACY)\n-            && parent.agentConfiguredUsingDefault;\n-    agentTimeout = getPropertyIntegerValue(properties, AGENT_TIMEOUT, parent.agentTimeout);\n-    prioritySamplingEnabled =\n-        getPropertyBooleanValue(properties, PRIORITY_SAMPLING, parent.prioritySamplingEnabled);\n-    traceResolverEnabled =\n-        getPropertyBooleanValue(properties, TRACE_RESOLVER_ENABLED, parent.traceResolverEnabled);\n-    serviceMapping = getPropertyMapValue(properties, SERVICE_MAPPING, parent.serviceMapping);\n-\n-    {\n-      final Map<String, String> preTags =\n-          new HashMap<>(\n-              getPropertyMapValue(properties, GLOBAL_TAGS, Collections.<String, String>emptyMap()));\n-      preTags.putAll(getPropertyMapValue(properties, TAGS, parent.tags));\n-      tags = overwriteKeysFromProperties(preTags, properties, ENV, VERSION);\n-    }\n-    spanTags = getPropertyMapValue(properties, SPAN_TAGS, parent.spanTags);\n-    jmxTags = getPropertyMapValue(properties, JMX_TAGS, parent.jmxTags);\n-    excludedClasses =\n-        getPropertyListValue(properties, TRACE_CLASSES_EXCLUDE, parent.excludedClasses);\n-    headerTags = getPropertyMapValue(properties, HEADER_TAGS, parent.headerTags);\n-\n-    httpServerErrorStatuses =\n-        getPropertyIntegerRangeValue(\n-            properties, HTTP_SERVER_ERROR_STATUSES, parent.httpServerErrorStatuses);\n-\n-    httpClientErrorStatuses =\n-        getPropertyIntegerRangeValue(\n-            properties, HTTP_CLIENT_ERROR_STATUSES, parent.httpClientErrorStatuses);\n-\n-    httpServerTagQueryString =\n-        getPropertyBooleanValue(\n-            properties, HTTP_SERVER_TAG_QUERY_STRING, parent.httpServerTagQueryString);\n-\n-    httpClientTagQueryString =\n-        getPropertyBooleanValue(\n-            properties, HTTP_CLIENT_TAG_QUERY_STRING, parent.httpClientTagQueryString);\n-\n-    httpClientSplitByDomain =\n-        getPropertyBooleanValue(\n-            properties, HTTP_CLIENT_HOST_SPLIT_BY_DOMAIN, parent.httpClientSplitByDomain);\n-\n-    dbClientSplitByInstance =\n-        getPropertyBooleanValue(\n-            properties, DB_CLIENT_HOST_SPLIT_BY_INSTANCE, parent.dbClientSplitByInstance);\n-\n-    splitByTags =\n-        Collections.unmodifiableSet(\n-            new LinkedHashSet<>(\n-                getPropertyListValue(\n-                    properties, SPLIT_BY_TAGS, new ArrayList<>(parent.splitByTags))));\n-\n-    scopeDepthLimit =\n-        getPropertyIntegerValue(properties, SCOPE_DEPTH_LIMIT, parent.scopeDepthLimit);\n-\n-    scopeStrictMode =\n-        getPropertyBooleanValue(properties, SCOPE_STRICT_MODE, parent.scopeStrictMode);\n-\n-    partialFlushMinSpans =\n-        getPropertyIntegerValue(properties, PARTIAL_FLUSH_MIN_SPANS, parent.partialFlushMinSpans);\n-\n-    runtimeContextFieldInjection =\n-        getPropertyBooleanValue(\n-            properties, RUNTIME_CONTEXT_FIELD_INJECTION, parent.runtimeContextFieldInjection);\n-\n-    final Set<PropagationStyle> parsedPropagationStylesToExtract =\n-        getPropagationStyleSetFromPropertyValue(properties, PROPAGATION_STYLE_EXTRACT);\n-    propagationStylesToExtract =\n-        parsedPropagationStylesToExtract == null\n-            ? parent.propagationStylesToExtract\n-            : parsedPropagationStylesToExtract;\n-    final Set<PropagationStyle> parsedPropagationStylesToInject =\n-        getPropagationStyleSetFromPropertyValue(properties, PROPAGATION_STYLE_INJECT);\n-    propagationStylesToInject =\n-        parsedPropagationStylesToInject == null\n-            ? parent.propagationStylesToInject\n-            : parsedPropagationStylesToInject;\n-\n-    jmxFetchEnabled =\n-        getPropertyBooleanValue(properties, JMX_FETCH_ENABLED, parent.jmxFetchEnabled);\n-    jmxFetchConfigDir = properties.getProperty(JMX_FETCH_CONFIG_DIR, parent.jmxFetchConfigDir);\n-    jmxFetchConfigs = getPropertyListValue(properties, JMX_FETCH_CONFIG, parent.jmxFetchConfigs);\n-    jmxFetchMetricsConfigs =\n-        getPropertyListValue(properties, JMX_FETCH_METRICS_CONFIGS, parent.jmxFetchMetricsConfigs);\n-    jmxFetchCheckPeriod =\n-        getPropertyIntegerValue(properties, JMX_FETCH_CHECK_PERIOD, parent.jmxFetchCheckPeriod);\n-    jmxFetchRefreshBeansPeriod =\n-        getPropertyIntegerValue(\n-            properties, JMX_FETCH_REFRESH_BEANS_PERIOD, parent.jmxFetchRefreshBeansPeriod);\n-    jmxFetchStatsdHost = properties.getProperty(JMX_FETCH_STATSD_HOST, parent.jmxFetchStatsdHost);\n-    jmxFetchStatsdPort =\n-        getPropertyIntegerValue(properties, JMX_FETCH_STATSD_PORT, parent.jmxFetchStatsdPort);\n-\n-    healthMetricsEnabled =\n-        getPropertyBooleanValue(properties, HEALTH_METRICS_ENABLED, DEFAULT_METRICS_ENABLED);\n-    healthMetricsStatsdHost =\n-        properties.getProperty(HEALTH_METRICS_STATSD_HOST, parent.healthMetricsStatsdHost);\n-    healthMetricsStatsdPort =\n-        getPropertyIntegerValue(\n-            properties, HEALTH_METRICS_STATSD_PORT, parent.healthMetricsStatsdPort);\n-\n-    logsInjectionEnabled =\n-        getBooleanSettingFromEnvironment(LOGS_INJECTION_ENABLED, DEFAULT_LOGS_INJECTION_ENABLED);\n-    logsMDCTagsInjectionEnabled =\n-        getBooleanSettingFromEnvironment(\n-            LOGS_MDC_TAGS_INJECTION_ENABLED, parent.logsMDCTagsInjectionEnabled);\n-    reportHostName =\n-        getPropertyBooleanValue(properties, TRACE_REPORT_HOSTNAME, parent.reportHostName);\n-\n-    traceAgentV05Enabled =\n-        getBooleanSettingFromEnvironment(ENABLE_TRACE_AGENT_V05, parent.traceAgentV05Enabled);\n-\n-    traceAnnotations = properties.getProperty(TRACE_ANNOTATIONS, parent.traceAnnotations);\n-\n-    traceMethods = properties.getProperty(TRACE_METHODS, parent.traceMethods);\n-\n-    traceExecutorsAll =\n-        getPropertyBooleanValue(properties, TRACE_EXECUTORS_ALL, parent.traceExecutorsAll);\n-    traceExecutors = getPropertyListValue(properties, TRACE_EXECUTORS, parent.traceExecutors);\n-\n-    traceAnalyticsEnabled =\n-        getPropertyBooleanValue(properties, TRACE_ANALYTICS_ENABLED, parent.traceAnalyticsEnabled);\n-\n-    traceSamplingServiceRules =\n-        getPropertyMapValue(\n-            properties, TRACE_SAMPLING_SERVICE_RULES, parent.traceSamplingServiceRules);\n-    traceSamplingOperationRules =\n-        getPropertyMapValue(\n-            properties, TRACE_SAMPLING_OPERATION_RULES, parent.traceSamplingOperationRules);\n-    traceSampleRate = getPropertyDoubleValue(properties, TRACE_SAMPLE_RATE, parent.traceSampleRate);\n-    traceRateLimit = getPropertyDoubleValue(properties, TRACE_RATE_LIMIT, parent.traceRateLimit);\n-\n-    profilingEnabled =\n-        getPropertyBooleanValue(properties, PROFILING_ENABLED, parent.profilingEnabled);\n-    profilingUrl = properties.getProperty(PROFILING_URL, parent.profilingUrl);\n-    profilingTags = getPropertyMapValue(properties, PROFILING_TAGS, parent.profilingTags);\n-    profilingStartDelay =\n-        getPropertyIntegerValue(properties, PROFILING_START_DELAY, parent.profilingStartDelay);\n-    profilingStartForceFirst =\n-        getPropertyBooleanValue(\n-            properties, PROFILING_START_FORCE_FIRST, parent.profilingStartForceFirst);\n-    profilingUploadPeriod =\n-        getPropertyIntegerValue(properties, PROFILING_UPLOAD_PERIOD, parent.profilingUploadPeriod);\n-    profilingTemplateOverrideFile =\n-        properties.getProperty(\n-            PROFILING_TEMPLATE_OVERRIDE_FILE, parent.profilingTemplateOverrideFile);\n-    profilingUploadTimeout =\n-        getPropertyIntegerValue(\n-            properties, PROFILING_UPLOAD_TIMEOUT, parent.profilingUploadTimeout);\n-    profilingUploadCompression =\n-        properties.getProperty(PROFILING_UPLOAD_COMPRESSION, parent.profilingUploadCompression);\n-    profilingProxyHost = properties.getProperty(PROFILING_PROXY_HOST, parent.profilingProxyHost);\n-    profilingProxyPort =\n-        getPropertyIntegerValue(properties, PROFILING_PROXY_PORT, parent.profilingProxyPort);\n-    profilingProxyUsername =\n-        properties.getProperty(PROFILING_PROXY_USERNAME, parent.profilingProxyUsername);\n-    profilingProxyPassword =\n-        properties.getProperty(PROFILING_PROXY_PASSWORD, parent.profilingProxyPassword);\n-\n-    profilingExceptionSampleLimit =\n-        getPropertyIntegerValue(\n-            properties, PROFILING_EXCEPTION_SAMPLE_LIMIT, parent.profilingExceptionSampleLimit);\n-\n-    profilingExceptionHistogramTopItems =\n-        getPropertyIntegerValue(\n-            properties,\n-            PROFILING_EXCEPTION_HISTOGRAM_TOP_ITEMS,\n-            parent.profilingExceptionHistogramTopItems);\n-    profilingExceptionHistogramMaxCollectionSize =\n-        getPropertyIntegerValue(\n-            properties,\n-            PROFILING_EXCEPTION_HISTOGRAM_MAX_COLLECTION_SIZE,\n-            parent.profilingExceptionHistogramMaxCollectionSize);\n-\n-    kafkaClientPropagationEnabled =\n-        getPropertyBooleanValue(\n-            properties, KAFKA_CLIENT_PROPAGATION_ENABLED, parent.kafkaClientPropagationEnabled);\n-\n-    hystrixTagsEnabled =\n-        getBooleanSettingFromEnvironment(\n-            TraceInstrumentationConfig.HYSTRIX_TAGS_ENABLED, parent.hystrixTagsEnabled);\n-\n-    servletPrincipalEnabled =\n-        getBooleanSettingFromEnvironment(\n-            TraceInstrumentationConfig.SERVLET_PRINCIPAL_ENABLED, parent.servletPrincipalEnabled);\n-\n-    debugEnabled = parent.debugEnabled || isDebugMode();\n-\n-    kafkaClientBase64DecodingEnabled =\n-        getPropertyBooleanValue(\n-            properties,\n-            KAFKA_CLIENT_BASE64_DECODING_ENABLED,\n-            parent.kafkaClientBase64DecodingEnabled);\n-\n-    log.debug(\"New instance: {}\", this);\n-  }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17b1bca600f735f7eb140121f85c3b5f03dc08a"}, "originalPosition": 623}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4914, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}