{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMjk0NzM4", "number": 2156, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTozMzoxOFrOE_0YPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjowMToyMFrOE_0_kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzUzOTE3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/TracingSession.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTozMzoxOFrOH9vBOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTozOToyMlrOH9vOCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTU0NQ==", "bodyText": "Should this span be the active span at this time? If so, this lambda wouldn't need to capture here.", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534495545", "createdAt": "2020-12-02T21:33:18Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/TracingSession.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.datastax.cassandra.CassandraClientDecorator.CASSANDRA_EXECUTE;\n+import static datadog.trace.instrumentation.datastax.cassandra.CassandraClientDecorator.DECORATE;\n+import static datadog.trace.util.AgentThreadFactory.AgentThread.TRACE_CASSANDRA_ASYNC_SESSION;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.BoundStatement;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.cql.SimpleStatement;\n+import com.datastax.oss.driver.api.core.cql.Statement;\n+import com.datastax.oss.driver.api.core.session.Request;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import com.datastax.oss.driver.api.core.type.reflect.GenericType;\n+import com.datastax.oss.driver.internal.core.session.SessionWrapper;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.util.AgentThreadFactory;\n+import edu.umd.cs.findbugs.annotations.NonNull;\n+import edu.umd.cs.findbugs.annotations.Nullable;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class TracingSession extends SessionWrapper implements CqlSession {\n+  private static final ExecutorService EXECUTOR_SERVICE =\n+      Executors.newCachedThreadPool(new AgentThreadFactory(TRACE_CASSANDRA_ASYNC_SESSION));\n+\n+  public TracingSession(final Session session) {\n+    super(session);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public <RequestT extends Request, ResultT> ResultT execute(\n+      @NonNull RequestT request, @NonNull GenericType<ResultT> resultType) {\n+\n+    if (request instanceof Statement && resultType.equals(Statement.SYNC)) {\n+      return (ResultT) wrapSyncRequest((Statement) request);\n+    } else if (request instanceof Statement && resultType.equals(Statement.ASYNC)) {\n+      return (ResultT) wrapAsyncRequest((Statement) request);\n+    } else {\n+      // PrepareRequest or unknown request: just forward to delegate\n+      return getDelegate().execute(request, resultType);\n+    }\n+  }\n+\n+  private ResultSet wrapSyncRequest(Statement request) {\n+    AgentSpan span = startSpan(CASSANDRA_EXECUTE);\n+\n+    DECORATE.afterStart(span);\n+    DECORATE.onConnection(span, getDelegate());\n+    DECORATE.onStatement(span, getQuery(request));\n+\n+    try (AgentScope scope = activateSpan(span)) {\n+      ResultSet resultSet = getDelegate().execute(request, Statement.SYNC);\n+      DECORATE.onResponse(span, resultSet);\n+      DECORATE.beforeFinish(span);\n+\n+      return resultSet;\n+    } catch (Exception e) {\n+      DECORATE.onError(span, e);\n+      DECORATE.beforeFinish(span);\n+\n+      throw e;\n+    } finally {\n+      span.finish();\n+    }\n+  }\n+\n+  private CompletionStage<AsyncResultSet> wrapAsyncRequest(Statement request) {\n+    AgentSpan span = startSpan(CASSANDRA_EXECUTE);\n+\n+    DECORATE.afterStart(span);\n+    DECORATE.onConnection(span, getDelegate());\n+    DECORATE.onStatement(span, getQuery(request));\n+\n+    try (AgentScope scope = activateSpan(span)) {\n+      CompletionStage<AsyncResultSet> completionStage =\n+          getDelegate().execute(request, Statement.ASYNC);\n+\n+      return completionStage.whenComplete(\n+          (result, throwable) -> {\n+            if (result != null) {\n+              DECORATE.onResponse(span, result);\n+            }\n+\n+            if (throwable instanceof CompletionException) {\n+              throwable = throwable.getCause();\n+            }\n+            DECORATE.onError(span, throwable);\n+            span.finish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5ODgyNQ==", "bodyText": "It seems unfortunate that we go to such lengths and quite some cost to propagate context into completable futures, when all we really need to do is capture the span in a closure, but we're doing both here, the CompletableFuture instrumentation should be making sure this would be the active span at the time.", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534498825", "createdAt": "2020-12-02T21:39:22Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/TracingSession.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.datastax.cassandra.CassandraClientDecorator.CASSANDRA_EXECUTE;\n+import static datadog.trace.instrumentation.datastax.cassandra.CassandraClientDecorator.DECORATE;\n+import static datadog.trace.util.AgentThreadFactory.AgentThread.TRACE_CASSANDRA_ASYNC_SESSION;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.BoundStatement;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.cql.SimpleStatement;\n+import com.datastax.oss.driver.api.core.cql.Statement;\n+import com.datastax.oss.driver.api.core.session.Request;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import com.datastax.oss.driver.api.core.type.reflect.GenericType;\n+import com.datastax.oss.driver.internal.core.session.SessionWrapper;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.util.AgentThreadFactory;\n+import edu.umd.cs.findbugs.annotations.NonNull;\n+import edu.umd.cs.findbugs.annotations.Nullable;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class TracingSession extends SessionWrapper implements CqlSession {\n+  private static final ExecutorService EXECUTOR_SERVICE =\n+      Executors.newCachedThreadPool(new AgentThreadFactory(TRACE_CASSANDRA_ASYNC_SESSION));\n+\n+  public TracingSession(final Session session) {\n+    super(session);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public <RequestT extends Request, ResultT> ResultT execute(\n+      @NonNull RequestT request, @NonNull GenericType<ResultT> resultType) {\n+\n+    if (request instanceof Statement && resultType.equals(Statement.SYNC)) {\n+      return (ResultT) wrapSyncRequest((Statement) request);\n+    } else if (request instanceof Statement && resultType.equals(Statement.ASYNC)) {\n+      return (ResultT) wrapAsyncRequest((Statement) request);\n+    } else {\n+      // PrepareRequest or unknown request: just forward to delegate\n+      return getDelegate().execute(request, resultType);\n+    }\n+  }\n+\n+  private ResultSet wrapSyncRequest(Statement request) {\n+    AgentSpan span = startSpan(CASSANDRA_EXECUTE);\n+\n+    DECORATE.afterStart(span);\n+    DECORATE.onConnection(span, getDelegate());\n+    DECORATE.onStatement(span, getQuery(request));\n+\n+    try (AgentScope scope = activateSpan(span)) {\n+      ResultSet resultSet = getDelegate().execute(request, Statement.SYNC);\n+      DECORATE.onResponse(span, resultSet);\n+      DECORATE.beforeFinish(span);\n+\n+      return resultSet;\n+    } catch (Exception e) {\n+      DECORATE.onError(span, e);\n+      DECORATE.beforeFinish(span);\n+\n+      throw e;\n+    } finally {\n+      span.finish();\n+    }\n+  }\n+\n+  private CompletionStage<AsyncResultSet> wrapAsyncRequest(Statement request) {\n+    AgentSpan span = startSpan(CASSANDRA_EXECUTE);\n+\n+    DECORATE.afterStart(span);\n+    DECORATE.onConnection(span, getDelegate());\n+    DECORATE.onStatement(span, getQuery(request));\n+\n+    try (AgentScope scope = activateSpan(span)) {\n+      CompletionStage<AsyncResultSet> completionStage =\n+          getDelegate().execute(request, Statement.ASYNC);\n+\n+      return completionStage.whenComplete(\n+          (result, throwable) -> {\n+            if (result != null) {\n+              DECORATE.onResponse(span, result);\n+            }\n+\n+            if (throwable instanceof CompletionException) {\n+              throwable = throwable.getCause();\n+            }\n+            DECORATE.onError(span, throwable);\n+            span.finish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTU0NQ=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzU0NTE1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/CassandraClientDecorator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTozNTowNVrOH9vE6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNzozMzozMlrOH-orpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjQ5MQ==", "bodyText": "may or may not be worth it, but this will autobox, RadixTreeCache.PORTS.get(((InetSocketAddress) address).getPort()) works around this.", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534496491", "createdAt": "2020-12-02T21:35:05Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/CassandraClientDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.metadata.Node;\n+import com.datastax.oss.driver.api.core.servererrors.CoordinatorException;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.InternalSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Objects;\n+\n+public class CassandraClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Session> {\n+\n+  public static final CharSequence CASSANDRA_EXECUTE =\n+      UTF8BytesString.createConstant(\"cassandra.execute\");\n+  public static final CharSequence JAVA_CASSANDRA =\n+      UTF8BytesString.createConstant(\"java-cassandra\");\n+\n+  public static final CassandraClientDecorator DECORATE = new CassandraClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"cassandra\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return JAVA_CASSANDRA;\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return InternalSpanTypes.CASSANDRA;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Session session) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Session session) {\n+    return session.getKeyspace().map(Objects::toString).orElse(null);\n+  }\n+\n+  @Override\n+  protected String dbHostname(Session session) {\n+    return null;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final ResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final AsyncResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  @Override\n+  public AgentSpan onError(final AgentSpan span, final Throwable throwable) {\n+    super.onError(span, throwable);\n+\n+    if (throwable instanceof CoordinatorException) {\n+      onResponse(span, ((CoordinatorException) throwable).getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  private AgentSpan onResponse(AgentSpan span, Node coordinator) {\n+    if (coordinator != null) {\n+      SocketAddress address = coordinator.getEndPoint().resolve();\n+      if (address instanceof InetSocketAddress) {\n+        span.setTag(Tags.PEER_PORT, ((InetSocketAddress) address).getPort());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMzg1NA==", "bodyText": "@richardstartin would it be worth adding special logic for this in the setTag(String,int) method?", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534513854", "createdAt": "2020-12-02T22:06:44Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/CassandraClientDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.metadata.Node;\n+import com.datastax.oss.driver.api.core.servererrors.CoordinatorException;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.InternalSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Objects;\n+\n+public class CassandraClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Session> {\n+\n+  public static final CharSequence CASSANDRA_EXECUTE =\n+      UTF8BytesString.createConstant(\"cassandra.execute\");\n+  public static final CharSequence JAVA_CASSANDRA =\n+      UTF8BytesString.createConstant(\"java-cassandra\");\n+\n+  public static final CassandraClientDecorator DECORATE = new CassandraClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"cassandra\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return JAVA_CASSANDRA;\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return InternalSpanTypes.CASSANDRA;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Session session) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Session session) {\n+    return session.getKeyspace().map(Objects::toString).orElse(null);\n+  }\n+\n+  @Override\n+  protected String dbHostname(Session session) {\n+    return null;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final ResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final AsyncResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  @Override\n+  public AgentSpan onError(final AgentSpan span, final Throwable throwable) {\n+    super.onError(span, throwable);\n+\n+    if (throwable instanceof CoordinatorException) {\n+      onResponse(span, ((CoordinatorException) throwable).getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  private AgentSpan onResponse(AgentSpan span, Node coordinator) {\n+    if (coordinator != null) {\n+      SocketAddress address = coordinator.getEndPoint().resolve();\n+      if (address instanceof InetSocketAddress) {\n+        span.setTag(Tags.PEER_PORT, ((InetSocketAddress) address).getPort());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjQ5MQ=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNzYwMg==", "bodyText": "That seems dangerous to me. Here, we know it's a port, and that it only has 16 bits, that it isn't negative, so can reason about worst cases. Elsewhere, it could be any integer.", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534527602", "createdAt": "2020-12-02T22:34:27Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/CassandraClientDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.metadata.Node;\n+import com.datastax.oss.driver.api.core.servererrors.CoordinatorException;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.InternalSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Objects;\n+\n+public class CassandraClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Session> {\n+\n+  public static final CharSequence CASSANDRA_EXECUTE =\n+      UTF8BytesString.createConstant(\"cassandra.execute\");\n+  public static final CharSequence JAVA_CASSANDRA =\n+      UTF8BytesString.createConstant(\"java-cassandra\");\n+\n+  public static final CassandraClientDecorator DECORATE = new CassandraClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"cassandra\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return JAVA_CASSANDRA;\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return InternalSpanTypes.CASSANDRA;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Session session) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Session session) {\n+    return session.getKeyspace().map(Objects::toString).orElse(null);\n+  }\n+\n+  @Override\n+  protected String dbHostname(Session session) {\n+    return null;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final ResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final AsyncResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  @Override\n+  public AgentSpan onError(final AgentSpan span, final Throwable throwable) {\n+    super.onError(span, throwable);\n+\n+    if (throwable instanceof CoordinatorException) {\n+      onResponse(span, ((CoordinatorException) throwable).getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  private AgentSpan onResponse(AgentSpan span, Node coordinator) {\n+    if (coordinator != null) {\n+      SocketAddress address = coordinator.getEndPoint().resolve();\n+      if (address instanceof InetSocketAddress) {\n+        span.setTag(Tags.PEER_PORT, ((InetSocketAddress) address).getPort());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjQ5MQ=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0MDI5NA==", "bodyText": "I changed the code to just call the other version BaseDecorator.onPeerConnection().  I'll update that in a separate PR", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r535440294", "createdAt": "2020-12-03T17:33:32Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java8/datadog/trace/instrumentation/datastax/cassandra/CassandraClientDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import com.datastax.oss.driver.api.core.cql.AsyncResultSet;\n+import com.datastax.oss.driver.api.core.cql.ResultSet;\n+import com.datastax.oss.driver.api.core.metadata.Node;\n+import com.datastax.oss.driver.api.core.servererrors.CoordinatorException;\n+import com.datastax.oss.driver.api.core.session.Session;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.InternalSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.Objects;\n+\n+public class CassandraClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Session> {\n+\n+  public static final CharSequence CASSANDRA_EXECUTE =\n+      UTF8BytesString.createConstant(\"cassandra.execute\");\n+  public static final CharSequence JAVA_CASSANDRA =\n+      UTF8BytesString.createConstant(\"java-cassandra\");\n+\n+  public static final CassandraClientDecorator DECORATE = new CassandraClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"cassandra\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return JAVA_CASSANDRA;\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return InternalSpanTypes.CASSANDRA;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"cassandra\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Session session) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Session session) {\n+    return session.getKeyspace().map(Objects::toString).orElse(null);\n+  }\n+\n+  @Override\n+  protected String dbHostname(Session session) {\n+    return null;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final ResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  public AgentSpan onResponse(final AgentSpan span, final AsyncResultSet result) {\n+    if (result != null) {\n+      return onResponse(span, result.getExecutionInfo().getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  @Override\n+  public AgentSpan onError(final AgentSpan span, final Throwable throwable) {\n+    super.onError(span, throwable);\n+\n+    if (throwable instanceof CoordinatorException) {\n+      onResponse(span, ((CoordinatorException) throwable).getCoordinator());\n+    }\n+\n+    return span;\n+  }\n+\n+  private AgentSpan onResponse(AgentSpan span, Node coordinator) {\n+    if (coordinator != null) {\n+      SocketAddress address = coordinator.getEndPoint().resolve();\n+      if (address instanceof InetSocketAddress) {\n+        span.setTag(Tags.PEER_PORT, ((InetSocketAddress) address).getPort());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NjQ5MQ=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzYyNjI1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1Nzo1M1rOH9v1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1Nzo1M1rOH9v1Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwODg5OQ==", "bodyText": "Do we want to add a secondary name to distinguish 3 from 4?", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534508899", "createdAt": "2020-12-02T21:57:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class CassandraClientInstrumentation extends Instrumenter.Default {\n+\n+  public CassandraClientInstrumentation() {\n+    super(\"cassandra\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzYzMzE3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1OToyMFrOH9v5iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjoyODo0MFrOH9wynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTk2MA==", "bodyText": "Ideally the package name should distinguish to avoid potential naming conflicts with 3. (Maybe update the 3.x package too?)", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534509960", "createdAt": "2020-12-02T21:59:20Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.datastax.cassandra;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNDU3Mw==", "bodyText": "ah, yes.  I've been bitten by this quirk before", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534524573", "createdAt": "2020-12-02T22:28:40Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.datastax.cassandra;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTk2MA=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzYzOTg3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjowMToyMFrOH9v9og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjozMTozMlrOH9w4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMTAxMA==", "bodyText": "Since your advice is focused on the return type instead of arguments, consider a return type matcher (perhaps instead of the argument matcher).", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534511010", "createdAt": "2020-12-02T22:01:20Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class CassandraClientInstrumentation extends Instrumenter.Default {\n+\n+  public CassandraClientInstrumentation() {\n+    super(\"cassandra\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.datastax.oss.driver.internal.core.session.DefaultSession\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".CassandraClientDecorator\", packageName + \".TracingSession\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod().and(named(\"init\")).and(isStatic()).and(takesArguments(3)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUyNjAwNg==", "bodyText": "I'll add a return type matcher for defensive programming but there are 2 init methods with the same return type so the argument matcher needs to stay", "url": "https://github.com/DataDog/dd-trace-java/pull/2156#discussion_r534526006", "createdAt": "2020-12-02T22:31:32Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/datastax-cassandra-4/src/main/java/datadog/trace/instrumentation/datastax/cassandra/CassandraClientInstrumentation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.datastax.cassandra;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class CassandraClientInstrumentation extends Instrumenter.Default {\n+\n+  public CassandraClientInstrumentation() {\n+    super(\"cassandra\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.datastax.oss.driver.internal.core.session.DefaultSession\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".CassandraClientDecorator\", packageName + \".TracingSession\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod().and(named(\"init\")).and(isStatic()).and(takesArguments(3)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMTAxMA=="}, "originalCommit": {"oid": "b2b674f3eea416f36bde632dcea1234da5d929f2"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4669, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}