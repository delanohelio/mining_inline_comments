{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyODEyODQ5", "number": 1366, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoxMToxMFrODxXv1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoyOToxMlrODxYHmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDk1ODk0OnYy", "diffSide": "RIGHT", "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoxMToxMFrOGEzjRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowNjoxNVrOGE1VLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MjEwMA==", "bodyText": "This should be private.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407692100", "createdAt": "2020-04-13T20:11:10Z", "author": {"login": "tylerbenson"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTI2MA==", "bodyText": "fixed", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407721260", "createdAt": "2020-04-13T21:06:15Z", "author": {"login": "mar-kolya"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5MjEwMA=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDk3MTQ0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Cleaner.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoxNTowOFrOGEzrRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozNTo0NlrOGE2NWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5NDE1MQ==", "bodyText": "Should we remove this class and have WeakMap use the CommonTaskExecutor directly?  Seems like the extra abstraction is unnecessary now.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407694151", "createdAt": "2020-04-13T20:15:08Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Cleaner.java", "diffHunk": "@@ -12,47 +10,25 @@\n \n   <T> void scheduleCleaning(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMzEzNw==", "bodyText": "There's also some tests in CleanerTest that would make sense to migrate to the common class that exercise this canceling logic.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407703137", "createdAt": "2020-04-13T20:31:49Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Cleaner.java", "diffHunk": "@@ -12,47 +10,25 @@\n \n   <T> void scheduleCleaning(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5NDE1MQ=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTY0MA==", "bodyText": "should be addressed now", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407735640", "createdAt": "2020-04-13T21:35:46Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Cleaner.java", "diffHunk": "@@ -12,47 +10,25 @@\n \n   <T> void scheduleCleaning(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5NDE1MQ=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDk4MzE2OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoxODo0N1rOGEzyyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo0MTo1NFrOGE2YDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5NjA3NQ==", "bodyText": "Consider removing SpanCleaner and have this accept the list of pendingTraces instead. (Implement the run logic above directly.)", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407696075", "createdAt": "2020-04-13T20:18:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/PendingTrace.java", "diffHunk": "@@ -312,4 +319,17 @@ public void close() {\n       run();\n     }\n   }\n+\n+  /*\n+   * Important to use explicit class to avoid implicit hard references to cleaners from within executor.\n+   */\n+  private static class SpanCleanerTask implements Task<SpanCleaner> {\n+\n+    static final SpanCleanerTask INSTANCE = new SpanCleanerTask();\n+\n+    @Override\n+    public void run(final SpanCleaner target) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODM4MA==", "bodyText": "if (cleaner != null) {\n      cleaner.close();\n    }\n\n\nthis makes things somewhat more interesting since we cannot hold reference to pending traces inside the task.\n\nWould it be ok if I add a fixme for now here - this seems less trivial change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407738380", "createdAt": "2020-04-13T21:41:54Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/PendingTrace.java", "diffHunk": "@@ -312,4 +319,17 @@ public void close() {\n       run();\n     }\n   }\n+\n+  /*\n+   * Important to use explicit class to avoid implicit hard references to cleaners from within executor.\n+   */\n+  private static class SpanCleanerTask implements Task<SpanCleaner> {\n+\n+    static final SpanCleanerTask INSTANCE = new SpanCleanerTask();\n+\n+    @Override\n+    public void run(final SpanCleaner target) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5NjA3NQ=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDk5NzMxOnYy", "diffSide": "RIGHT", "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoyMjo1N1rOGEz7dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowNjowNVrOGE1U3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5ODI5Mw==", "bodyText": "Add a comment explaining why we're returning this, though I think it might be better to explicitly return after each case instead of at the bottom.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407698293", "createdAt": "2020-04-13T20:22:57Z", "author": {"login": "tylerbenson"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -25,9 +28,48 @@ private CommonTaskExecutor() {\n     }\n   }\n \n-  public ScheduledFuture<?> scheduleAtFixedRate(\n-      final Runnable command, final long initialDelay, final long period, final TimeUnit unit) {\n-    return executorService.scheduleAtFixedRate(command, initialDelay, period, unit);\n+  /**\n+   * Run {@code task} periodically providing it with {@code target}\n+   *\n+   * <p>Important implementation detail here is that internally we do not hold any strong references\n+   * to {@code target} which means it can be GCed even while periodic task is still scheduled.\n+   *\n+   * <p>If {@code target} is GCed periodic task is canceled.\n+   *\n+   * @param task task to run. Important: must not hold any strong references to target (or anything\n+   *     else non static)\n+   * @param target target object to pass to task\n+   * @param initialDelay initialDelay, see {@link\n+   *     ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)}\n+   * @param period period, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long,\n+   *     long, TimeUnit)}\n+   * @param unit unit, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long,\n+   *     TimeUnit)}\n+   * @param name name to use in logs when task cannot be scheduled\n+   * @return future that can be canceled\n+   */\n+  public <T> ScheduledFuture<?> scheduleAtFixedRate(\n+      final Task<T> task,\n+      final T target,\n+      final long initialDelay,\n+      final long period,\n+      final TimeUnit unit,\n+      final String name) {\n+    if (CommonTaskExecutor.INSTANCE.isShutdown()) {\n+      log.warn(\"Periodic task scheduler is shutdown. Will not run: {}\", name);\n+    } else {\n+      try {\n+        final PeriodicTask<T> periodicTask = new PeriodicTask<>(task, target);\n+        final ScheduledFuture<?> future =\n+            executorService.scheduleAtFixedRate(\n+                new PeriodicTask<>(task, target), initialDelay, period, unit);\n+        periodicTask.setFuture(future);\n+        return future;\n+      } catch (final RejectedExecutionException e) {\n+        log.warn(\"Cleaning task rejected. Will not run: {}\", name);\n+      }\n+    }\n+    return new UnscheduledFuture(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTE4MQ==", "bodyText": "I've added comments, not sure returning at each case would make things much more readable though :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407721181", "createdAt": "2020-04-13T21:06:05Z", "author": {"login": "mar-kolya"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -25,9 +28,48 @@ private CommonTaskExecutor() {\n     }\n   }\n \n-  public ScheduledFuture<?> scheduleAtFixedRate(\n-      final Runnable command, final long initialDelay, final long period, final TimeUnit unit) {\n-    return executorService.scheduleAtFixedRate(command, initialDelay, period, unit);\n+  /**\n+   * Run {@code task} periodically providing it with {@code target}\n+   *\n+   * <p>Important implementation detail here is that internally we do not hold any strong references\n+   * to {@code target} which means it can be GCed even while periodic task is still scheduled.\n+   *\n+   * <p>If {@code target} is GCed periodic task is canceled.\n+   *\n+   * @param task task to run. Important: must not hold any strong references to target (or anything\n+   *     else non static)\n+   * @param target target object to pass to task\n+   * @param initialDelay initialDelay, see {@link\n+   *     ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)}\n+   * @param period period, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long,\n+   *     long, TimeUnit)}\n+   * @param unit unit, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long,\n+   *     TimeUnit)}\n+   * @param name name to use in logs when task cannot be scheduled\n+   * @return future that can be canceled\n+   */\n+  public <T> ScheduledFuture<?> scheduleAtFixedRate(\n+      final Task<T> task,\n+      final T target,\n+      final long initialDelay,\n+      final long period,\n+      final TimeUnit unit,\n+      final String name) {\n+    if (CommonTaskExecutor.INSTANCE.isShutdown()) {\n+      log.warn(\"Periodic task scheduler is shutdown. Will not run: {}\", name);\n+    } else {\n+      try {\n+        final PeriodicTask<T> periodicTask = new PeriodicTask<>(task, target);\n+        final ScheduledFuture<?> future =\n+            executorService.scheduleAtFixedRate(\n+                new PeriodicTask<>(task, target), initialDelay, period, unit);\n+        periodicTask.setFuture(future);\n+        return future;\n+      } catch (final RejectedExecutionException e) {\n+        log.warn(\"Cleaning task rejected. Will not run: {}\", name);\n+      }\n+    }\n+    return new UnscheduledFuture(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5ODI5Mw=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDk5OTczOnYy", "diffSide": "RIGHT", "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoyMzozMlrOGEz8zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowNzowNVrOGE1W0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5ODYzNw==", "bodyText": "No longer just Cleaning task.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407698637", "createdAt": "2020-04-13T20:23:32Z", "author": {"login": "tylerbenson"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -25,9 +28,48 @@ private CommonTaskExecutor() {\n     }\n   }\n \n-  public ScheduledFuture<?> scheduleAtFixedRate(\n-      final Runnable command, final long initialDelay, final long period, final TimeUnit unit) {\n-    return executorService.scheduleAtFixedRate(command, initialDelay, period, unit);\n+  /**\n+   * Run {@code task} periodically providing it with {@code target}\n+   *\n+   * <p>Important implementation detail here is that internally we do not hold any strong references\n+   * to {@code target} which means it can be GCed even while periodic task is still scheduled.\n+   *\n+   * <p>If {@code target} is GCed periodic task is canceled.\n+   *\n+   * @param task task to run. Important: must not hold any strong references to target (or anything\n+   *     else non static)\n+   * @param target target object to pass to task\n+   * @param initialDelay initialDelay, see {@link\n+   *     ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)}\n+   * @param period period, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long,\n+   *     long, TimeUnit)}\n+   * @param unit unit, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long,\n+   *     TimeUnit)}\n+   * @param name name to use in logs when task cannot be scheduled\n+   * @return future that can be canceled\n+   */\n+  public <T> ScheduledFuture<?> scheduleAtFixedRate(\n+      final Task<T> task,\n+      final T target,\n+      final long initialDelay,\n+      final long period,\n+      final TimeUnit unit,\n+      final String name) {\n+    if (CommonTaskExecutor.INSTANCE.isShutdown()) {\n+      log.warn(\"Periodic task scheduler is shutdown. Will not run: {}\", name);\n+    } else {\n+      try {\n+        final PeriodicTask<T> periodicTask = new PeriodicTask<>(task, target);\n+        final ScheduledFuture<?> future =\n+            executorService.scheduleAtFixedRate(\n+                new PeriodicTask<>(task, target), initialDelay, period, unit);\n+        periodicTask.setFuture(future);\n+        return future;\n+      } catch (final RejectedExecutionException e) {\n+        log.warn(\"Cleaning task rejected. Will not run: {}\", name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTY4MA==", "bodyText": "Fixed", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407721680", "createdAt": "2020-04-13T21:07:05Z", "author": {"login": "mar-kolya"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -25,9 +28,48 @@ private CommonTaskExecutor() {\n     }\n   }\n \n-  public ScheduledFuture<?> scheduleAtFixedRate(\n-      final Runnable command, final long initialDelay, final long period, final TimeUnit unit) {\n-    return executorService.scheduleAtFixedRate(command, initialDelay, period, unit);\n+  /**\n+   * Run {@code task} periodically providing it with {@code target}\n+   *\n+   * <p>Important implementation detail here is that internally we do not hold any strong references\n+   * to {@code target} which means it can be GCed even while periodic task is still scheduled.\n+   *\n+   * <p>If {@code target} is GCed periodic task is canceled.\n+   *\n+   * @param task task to run. Important: must not hold any strong references to target (or anything\n+   *     else non static)\n+   * @param target target object to pass to task\n+   * @param initialDelay initialDelay, see {@link\n+   *     ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)}\n+   * @param period period, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long,\n+   *     long, TimeUnit)}\n+   * @param unit unit, see {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long,\n+   *     TimeUnit)}\n+   * @param name name to use in logs when task cannot be scheduled\n+   * @return future that can be canceled\n+   */\n+  public <T> ScheduledFuture<?> scheduleAtFixedRate(\n+      final Task<T> task,\n+      final T target,\n+      final long initialDelay,\n+      final long period,\n+      final TimeUnit unit,\n+      final String name) {\n+    if (CommonTaskExecutor.INSTANCE.isShutdown()) {\n+      log.warn(\"Periodic task scheduler is shutdown. Will not run: {}\", name);\n+    } else {\n+      try {\n+        final PeriodicTask<T> periodicTask = new PeriodicTask<>(task, target);\n+        final ScheduledFuture<?> future =\n+            executorService.scheduleAtFixedRate(\n+                new PeriodicTask<>(task, target), initialDelay, period, unit);\n+        periodicTask.setFuture(future);\n+        return future;\n+      } catch (final RejectedExecutionException e) {\n+        log.warn(\"Cleaning task rejected. Will not run: {}\", name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5ODYzNw=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTAwMjQxOnYy", "diffSide": "RIGHT", "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoyNDoxM1rOGEz-Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowNjo0NlrOGE1WGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5OTAyNw==", "bodyText": "not really...", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407699027", "createdAt": "2020-04-13T20:24:13Z", "author": {"login": "tylerbenson"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {\n+    private final WeakReference<T> target;\n+    private final Task<T> task;\n+    private volatile ScheduledFuture<?> future = null;\n+\n+    private PeriodicTask(final Task<T> task, final T target) {\n+      this.target = new WeakReference<>(target);\n+      this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+      final T t = target.get();\n+      if (t != null) {\n+        task.run(t);\n+      } else if (future != null) {\n+        future.cancel(false);\n+      }\n+    }\n+\n+    public void setFuture(final ScheduledFuture<?> future) {\n+      this.future = future;\n+    }\n+  }\n+\n+  // Unscheduled future\n+  @Slf4j\n+  public static class UnscheduledFuture implements ScheduledFuture<Object> {\n+    private final String name;\n+\n+    public UnscheduledFuture(final String name) {\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public long getDelay(final TimeUnit unit) {\n+      return 0;\n+    }\n+\n+    @Override\n+    public int compareTo(final Delayed o) {\n+      return 0;\n+    }\n+\n+    @Override\n+    public boolean cancel(final boolean mayInterruptIfRunning) {\n+      log.debug(\"Cancelling future for: {}\", name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMTQ5OQ==", "bodyText": "Kind of made it cleaner, hopfully :).\nLet me know if you have preferred wording.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407721499", "createdAt": "2020-04-13T21:06:46Z", "author": {"login": "mar-kolya"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {\n+    private final WeakReference<T> target;\n+    private final Task<T> task;\n+    private volatile ScheduledFuture<?> future = null;\n+\n+    private PeriodicTask(final Task<T> task, final T target) {\n+      this.target = new WeakReference<>(target);\n+      this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+      final T t = target.get();\n+      if (t != null) {\n+        task.run(t);\n+      } else if (future != null) {\n+        future.cancel(false);\n+      }\n+    }\n+\n+    public void setFuture(final ScheduledFuture<?> future) {\n+      this.future = future;\n+    }\n+  }\n+\n+  // Unscheduled future\n+  @Slf4j\n+  public static class UnscheduledFuture implements ScheduledFuture<Object> {\n+    private final String name;\n+\n+    public UnscheduledFuture(final String name) {\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public long getDelay(final TimeUnit unit) {\n+      return 0;\n+    }\n+\n+    @Override\n+    public int compareTo(final Delayed o) {\n+      return 0;\n+    }\n+\n+    @Override\n+    public boolean cancel(final boolean mayInterruptIfRunning) {\n+      log.debug(\"Cancelling future for: {}\", name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY5OTAyNw=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTAxOTc4OnYy", "diffSide": "RIGHT", "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDoyOToxMlrOGE0Iyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTowMDoxN1rOGE1JKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMTcwNg==", "bodyText": "Also private...", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407701706", "createdAt": "2020-04-13T20:29:12Z", "author": {"login": "tylerbenson"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {\n+    private final WeakReference<T> target;\n+    private final Task<T> task;\n+    private volatile ScheduledFuture<?> future = null;\n+\n+    private PeriodicTask(final Task<T> task, final T target) {\n+      this.target = new WeakReference<>(target);\n+      this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+      final T t = target.get();\n+      if (t != null) {\n+        task.run(t);\n+      } else if (future != null) {\n+        future.cancel(false);\n+      }\n+    }\n+\n+    public void setFuture(final ScheduledFuture<?> future) {\n+      this.future = future;\n+    }\n+  }\n+\n+  // Unscheduled future\n+  @Slf4j\n+  public static class UnscheduledFuture implements ScheduledFuture<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODE4NA==", "bodyText": "I was thinking about this and my thoughts were: it is possible to have a usecase when caller would want to know if things have been scheduled... this is why I'm returning this to begin with... But maybe it is too convoluted for now.", "url": "https://github.com/DataDog/dd-trace-java/pull/1366#discussion_r407718184", "createdAt": "2020-04-13T21:00:17Z", "author": {"login": "mar-kolya"}, "path": "utils/thread-utils/src/main/java/datadog/common/exec/CommonTaskExecutor.java", "diffHunk": "@@ -82,4 +124,79 @@ public void run() {\n       }\n     }\n   }\n+\n+  public interface Task<T> {\n+    void run(T target);\n+  }\n+\n+  public static class PeriodicTask<T> implements Runnable {\n+    private final WeakReference<T> target;\n+    private final Task<T> task;\n+    private volatile ScheduledFuture<?> future = null;\n+\n+    private PeriodicTask(final Task<T> task, final T target) {\n+      this.target = new WeakReference<>(target);\n+      this.task = task;\n+    }\n+\n+    @Override\n+    public void run() {\n+      final T t = target.get();\n+      if (t != null) {\n+        task.run(t);\n+      } else if (future != null) {\n+        future.cancel(false);\n+      }\n+    }\n+\n+    public void setFuture(final ScheduledFuture<?> future) {\n+      this.future = future;\n+    }\n+  }\n+\n+  // Unscheduled future\n+  @Slf4j\n+  public static class UnscheduledFuture implements ScheduledFuture<Object> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMTcwNg=="}, "originalCommit": {"oid": "1fb844ab5fe930ab66731bbc3b30afa62fbb99f7"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 247, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}