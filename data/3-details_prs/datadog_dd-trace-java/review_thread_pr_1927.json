{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0NzYxMDc2", "number": 1927, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjowMToxN1rOEog_Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoxODozM1rOEokuHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTE4OTE5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjowMToxN1rOHZpsTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjowMToxN1rOHZpsTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1OTUzMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1927#discussion_r496659533", "createdAt": "2020-09-29T12:01:17Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "diffHunk": "@@ -58,11 +59,14 @@ public ConnectionInstrumentation() {\n     @Advice.OnMethodExit(suppress = Throwable.class)\n     public static void addDBInfo(\n         @Advice.Argument(0) final String sql, @Advice.Return final PreparedStatement statement) {\n-      // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n-      // check if we have seen this String before\n-      UTF8BytesString utf8Sql = JDBCMaps.preparedStatementsSql.computeIfAbsent(sql, UTF8_ENCODE);\n-      InstrumentationContext.get(PreparedStatement.class, UTF8BytesString.class)\n-          .put(statement, utf8Sql);\n+      ContextStore<PreparedStatement, UTF8BytesString> contextStore =\n+          InstrumentationContext.get(PreparedStatement.class, UTF8BytesString.class);\n+      if (null == contextStore.get(statement)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "712525a93ef614f8f27c863a9a654181e1456b69"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTgwMTI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoxODozM1rOHZvlWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0NToyNVrOHZw64Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc1NjA1OQ==", "bodyText": "Should we add a computeIfAbsent to contextStore instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1927#discussion_r496756059", "createdAt": "2020-09-29T14:18:33Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "diffHunk": "@@ -57,14 +60,14 @@ public ConnectionInstrumentation() {\n     @Advice.OnMethodExit(suppress = Throwable.class)\n     public static void addDBInfo(\n         @Advice.Argument(0) final String sql, @Advice.Return final PreparedStatement statement) {\n-      // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n-      // check if we have seen this String before\n-      UTF8BytesString utf8Sql = JDBCMaps.preparedStatementsSql.get(sql);\n-      if (utf8Sql == null) {\n-        utf8Sql = UTF8BytesString.createWeak(sql);\n-        JDBCMaps.preparedStatementsSql.put(sql, utf8Sql);\n+      ContextStore<PreparedStatement, UTF8BytesString> contextStore =\n+          InstrumentationContext.get(PreparedStatement.class, UTF8BytesString.class);\n+      if (null == contextStore.get(statement)) {\n+        // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n+        // check if we have seen this String before\n+        UTF8BytesString utf8Sql = PREPARED_STATEMENTS_SQL.computeIfAbsent(sql, UTF8_ENCODE);\n+        contextStore.putIfAbsent(statement, utf8Sql);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3baf8b84b0a60b26c618d56954939cfb2ae9ace5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDI1Mw==", "bodyText": "Yes I think that's a good idea. We should also look at the way the synchronization works there because we could improve it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1927#discussion_r496774253", "createdAt": "2020-09-29T14:40:49Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "diffHunk": "@@ -57,14 +60,14 @@ public ConnectionInstrumentation() {\n     @Advice.OnMethodExit(suppress = Throwable.class)\n     public static void addDBInfo(\n         @Advice.Argument(0) final String sql, @Advice.Return final PreparedStatement statement) {\n-      // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n-      // check if we have seen this String before\n-      UTF8BytesString utf8Sql = JDBCMaps.preparedStatementsSql.get(sql);\n-      if (utf8Sql == null) {\n-        utf8Sql = UTF8BytesString.createWeak(sql);\n-        JDBCMaps.preparedStatementsSql.put(sql, utf8Sql);\n+      ContextStore<PreparedStatement, UTF8BytesString> contextStore =\n+          InstrumentationContext.get(PreparedStatement.class, UTF8BytesString.class);\n+      if (null == contextStore.get(statement)) {\n+        // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n+        // check if we have seen this String before\n+        UTF8BytesString utf8Sql = PREPARED_STATEMENTS_SQL.computeIfAbsent(sql, UTF8_ENCODE);\n+        contextStore.putIfAbsent(statement, utf8Sql);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc1NjA1OQ=="}, "originalCommit": {"oid": "3baf8b84b0a60b26c618d56954939cfb2ae9ace5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3Nzk1Mw==", "bodyText": "Yeah, I think that the field version could do away with synchronized and use atomics instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1927#discussion_r496777953", "createdAt": "2020-09-29T14:45:25Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/jdbc/src/main/java/datadog/trace/instrumentation/jdbc/ConnectionInstrumentation.java", "diffHunk": "@@ -57,14 +60,14 @@ public ConnectionInstrumentation() {\n     @Advice.OnMethodExit(suppress = Throwable.class)\n     public static void addDBInfo(\n         @Advice.Argument(0) final String sql, @Advice.Return final PreparedStatement statement) {\n-      // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n-      // check if we have seen this String before\n-      UTF8BytesString utf8Sql = JDBCMaps.preparedStatementsSql.get(sql);\n-      if (utf8Sql == null) {\n-        utf8Sql = UTF8BytesString.createWeak(sql);\n-        JDBCMaps.preparedStatementsSql.put(sql, utf8Sql);\n+      ContextStore<PreparedStatement, UTF8BytesString> contextStore =\n+          InstrumentationContext.get(PreparedStatement.class, UTF8BytesString.class);\n+      if (null == contextStore.get(statement)) {\n+        // Sometimes the prepared statement is not reused, but the underlying String is reused, so\n+        // check if we have seen this String before\n+        UTF8BytesString utf8Sql = PREPARED_STATEMENTS_SQL.computeIfAbsent(sql, UTF8_ENCODE);\n+        contextStore.putIfAbsent(statement, utf8Sql);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc1NjA1OQ=="}, "originalCommit": {"oid": "3baf8b84b0a60b26c618d56954939cfb2ae9ace5"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4866, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}