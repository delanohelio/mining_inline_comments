{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMDIwMTQy", "number": 1798, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowNzoxOFrOEcI82w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0MjozNVrOEceagg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTQyMjM1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowNzoxOFrOHGfQpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOToxNjo1MVrOHGmQAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ==", "bodyText": "I think naming this as capacity is a bit misleading...", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476565671", "createdAt": "2020-08-25T16:07:18Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MTE5MQ==", "bodyText": "Agreed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476591191", "createdAt": "2020-08-25T16:46:59Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNzQ1Nw==", "bodyText": "Well, what is it then? It's the capacity of the map's table immediately after construction, and unless there is irresponsible/unjustified usage and the map needs to be resized, it will remain the capacity of the map's table.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476607457", "createdAt": "2020-08-25T17:13:42Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyNzYyNg==", "bodyText": "initialCapacity?", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476627626", "createdAt": "2020-08-25T17:42:53Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyOTAzMA==", "bodyText": "Simply calling it capacity suggests there is a limit.  I'd suggest either Brian's proposal or expectedSize.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476629030", "createdAt": "2020-08-25T17:45:22Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0MTY2MQ==", "bodyText": "Calling it capacity suggests it has a capacity, but I think Brian's suggestion is a good one.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476641661", "createdAt": "2020-08-25T18:07:06Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4MDE5NQ==", "bodyText": "I changed the name and added javadoc to the factory methods.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476680195", "createdAt": "2020-08-25T19:16:51Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/CHMCache.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package datadog.trace.bootstrap.instrumentation.cache;\n+\n+import datadog.trace.bootstrap.instrumentation.api.Function;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+final class CHMCache<K, V> implements DDCache<K, V> {\n+\n+  private final ConcurrentHashMap<K, V> chm;\n+\n+  public CHMCache(final int capacity) {\n+    this.chm = new ConcurrentHashMap<>(capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NTY3MQ=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTQ1NTI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/QualifiedClassNameCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoxNToxOFrOHGfk-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODozMzoyNlrOHHBr9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3MDg3Mg==", "bodyText": "Why unbounded?  Seems a bit scary.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476570872", "createdAt": "2020-08-25T16:15:18Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/QualifiedClassNameCache.java", "diffHunk": "@@ -42,15 +45,15 @@ protected Leaf computeValue(Class<?> type) {\n \n     private final CharSequence name;\n \n-    private final FixedSizeCache<CharSequence, CharSequence> cache;\n+    private final DDCache<CharSequence, CharSequence> cache;\n     private final Function<CharSequence, CharSequence> joiner;\n \n     private Leaf(\n         CharSequence name,\n         TwoArgFunction<CharSequence, CharSequence, CharSequence> joiner,\n         int leafSize) {\n       this.name = name;\n-      this.cache = new FixedSizeCache<>(leafSize);\n+      this.cache = DDCaches.newUnboundedCache(leafSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MTA5MA==", "bodyText": "I think there are implicit bounds in many cases, like the methods on a class. In those cases I think it's fine not to enforce a bound.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r476591090", "createdAt": "2020-08-25T16:46:50Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/QualifiedClassNameCache.java", "diffHunk": "@@ -42,15 +45,15 @@ protected Leaf computeValue(Class<?> type) {\n \n     private final CharSequence name;\n \n-    private final FixedSizeCache<CharSequence, CharSequence> cache;\n+    private final DDCache<CharSequence, CharSequence> cache;\n     private final Function<CharSequence, CharSequence> joiner;\n \n     private Leaf(\n         CharSequence name,\n         TwoArgFunction<CharSequence, CharSequence, CharSequence> joiner,\n         int leafSize) {\n       this.name = name;\n-      this.cache = new FixedSizeCache<>(leafSize);\n+      this.cache = DDCaches.newUnboundedCache(leafSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3MDg3Mg=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEyOTcxOQ==", "bodyText": "I agree with that it's fine with unbounded here since there is a natural bound. Would be nice with a comment about the reasoning, i.e. that QualifiedClassNameCache is per Class and the number of methods are bounded.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r477129719", "createdAt": "2020-08-26T08:33:26Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/QualifiedClassNameCache.java", "diffHunk": "@@ -42,15 +45,15 @@ protected Leaf computeValue(Class<?> type) {\n \n     private final CharSequence name;\n \n-    private final FixedSizeCache<CharSequence, CharSequence> cache;\n+    private final DDCache<CharSequence, CharSequence> cache;\n     private final Function<CharSequence, CharSequence> joiner;\n \n     private Leaf(\n         CharSequence name,\n         TwoArgFunction<CharSequence, CharSequence, CharSequence> joiner,\n         int leafSize) {\n       this.name = name;\n-      this.cache = new FixedSizeCache<>(leafSize);\n+      this.cache = DDCaches.newUnboundedCache(leafSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3MDg3Mg=="}, "originalCommit": {"oid": "a015ddc8c1900a3c3a52b8df8039a9b09a558f92"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjgzNzE2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODoxNzo0NVrOHHBEMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODoxNzo0NVrOHHBEMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExOTUzOQ==", "bodyText": "Yup, that was covered below...", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r477119539", "createdAt": "2020-08-26T08:17:45Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCache.java", "diffHunk": "@@ -65,16 +67,17 @@ public FixedSizeCache(int capacity) {\n    * @param creator how to create a cached value base on the key if the lookup fails\n    * @return the cached or created and stored value\n    */\n+  @Override\n   public V computeIfAbsent(K key, Function<K, ? extends V> creator) {\n     if (key == null) {\n       return null;\n     }\n \n     int h = key.hashCode();\n     int firstPos = h & mask;\n-    V value = null;\n+    V value;\n     // try to find a slot or a match 3 times\n-    for (int i = 1; i <= 3; i++) {\n+    for (int i = 1; true; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "255d88fd4544b47a3c122d583c5a5ac22f1e5ec3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjkyMDI4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCacheTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODozNzo1MVrOHHB3AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODozNzo1MVrOHHB3AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzMjU0NA==", "bodyText": "There is no chain of hashes in the unbounded one.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r477132544", "createdAt": "2020-08-26T08:37:51Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCacheTest.groovy", "diffHunk": "@@ -32,20 +33,48 @@ class FixedSizeCacheTest extends DDSpecification {\n     new TKey(1, 10, \"foo\")    | \"ten_value\"    | 3     // used the cached tk10\n     new TKey(6, 6, \"foo\")     | \"six_value\"    | 3     // used the cached tk6\n     new TKey(1, 11, \"eleven\") | \"eleven_value\" | 4     // create new value in an occupied slot\n-    new TKey(4, 4, \"four\" )   | \"four_value\"   | 4     // create new value in empty slot\n+    new TKey(4, 4, \"four\")    | \"four_value\"   | 4     // create new value in empty slot\n     null                      | null           | 3     // do nothing\n   }\n \n+  def \"chm cache should store and retrieve values\"() {\n+    setup:\n+    def fsCache = DDCaches.newUnboundedCache(15)\n+    def creationCount = new AtomicInteger(0)\n+    def tvc = new TVC(creationCount)\n+    def tk1 = new TKey(1, 1, \"one\")\n+    def tk6 = new TKey(6, 6, \"six\")\n+    def tk10 = new TKey(10, 10, \"ten\")\n+    // insert some values that happen to be the chain of hashes 1 -> 6 -> 10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "255d88fd4544b47a3c122d583c5a5ac22f1e5ec3"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MjkzODkwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCacheTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0MjozNVrOHHCCiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwODo0MjozNVrOHHCCiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEzNTQ5Nw==", "bodyText": "So the reason for the difference in counts here is that we insert a new thing with hash 1 equals 6 in the unbounded cache, and that will of course create a new item, since the only thing we have with hash 1 has equals 1. In the fixed size cache, we try to insert it at hash 1 and collide, do a rehash ending up on hash 6 and find equals 6 there, which is a match.", "url": "https://github.com/DataDog/dd-trace-java/pull/1798#discussion_r477135497", "createdAt": "2020-08-26T08:42:35Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/instrumentation/cache/FixedSizeCacheTest.groovy", "diffHunk": "@@ -32,20 +33,48 @@ class FixedSizeCacheTest extends DDSpecification {\n     new TKey(1, 10, \"foo\")    | \"ten_value\"    | 3     // used the cached tk10\n     new TKey(6, 6, \"foo\")     | \"six_value\"    | 3     // used the cached tk6\n     new TKey(1, 11, \"eleven\") | \"eleven_value\" | 4     // create new value in an occupied slot\n-    new TKey(4, 4, \"four\" )   | \"four_value\"   | 4     // create new value in empty slot\n+    new TKey(4, 4, \"four\")    | \"four_value\"   | 4     // create new value in empty slot\n     null                      | null           | 3     // do nothing\n   }\n \n+  def \"chm cache should store and retrieve values\"() {\n+    setup:\n+    def fsCache = DDCaches.newUnboundedCache(15)\n+    def creationCount = new AtomicInteger(0)\n+    def tvc = new TVC(creationCount)\n+    def tk1 = new TKey(1, 1, \"one\")\n+    def tk6 = new TKey(6, 6, \"six\")\n+    def tk10 = new TKey(10, 10, \"ten\")\n+    // insert some values that happen to be the chain of hashes 1 -> 6 -> 10\n+    fsCache.computeIfAbsent(tk1, tvc)\n+    fsCache.computeIfAbsent(tk6, tvc)\n+    fsCache.computeIfAbsent(tk10, tvc)\n+\n+    expect:\n+    fsCache.computeIfAbsent(tk, tvc) == value\n+    creationCount.get() == count\n+\n+    where:\n+    tk                        | value          | count\n+    new TKey(1, 1, \"foo\")     | \"one_value\"    | 3\n+    new TKey(1, 6, \"foo\")     | \"foo_value\"    | 4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "255d88fd4544b47a3c122d583c5a5ac22f1e5ec3"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4891, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}