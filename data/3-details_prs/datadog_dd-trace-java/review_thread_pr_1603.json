{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NTgwMzAz", "number": 1603, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNTo1OTo1NlrOEG0LNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjowNDo0OFrOEG0SmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTgxNzQ5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/util/FixedSizeCacheTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNTo1OTo1NlrOGl1_Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTowNToxMFrOGm7_jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMzNTAyMw==", "bodyText": "I think a data structure of this complexity needs a different testing strategy - PBT or similar.", "url": "https://github.com/DataDog/dd-trace-java/pull/1603#discussion_r442335023", "createdAt": "2020-06-18T15:59:56Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/util/FixedSizeCacheTest.groovy", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.util\n+\n+import datadog.trace.util.test.DDSpecification\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+class FixedSizeCacheTest extends DDSpecification {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd20e4cffadcf300d010996b9d41b6cab5663de"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MTk5Nw==", "bodyText": "I added a concurrent usage test below that has 5 threads inserting 100000 random elements each and assert that they get back the correct thing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1603#discussion_r443481997", "createdAt": "2020-06-22T11:05:10Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/util/FixedSizeCacheTest.groovy", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.util\n+\n+import datadog.trace.util.test.DDSpecification\n+\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+class FixedSizeCacheTest extends DDSpecification {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMzNTAyMw=="}, "originalCommit": {"oid": "3fd20e4cffadcf300d010996b9d41b6cab5663de"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTgzNjQwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/util/FixedSizeCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjowNDo0OFrOGl2Llw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjowNDo0OFrOGl2Llw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMzODE5OQ==", "bodyText": "Agreed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1603#discussion_r442338199", "createdAt": "2020-06-18T16:04:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/FixedSizeCache.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package datadog.trace.core.util;\n+\n+/**\n+ * This is a fixed size cache that only has one operation <code>computeIfAbsent</code>, that is used\n+ * to retrieve, or store and compute the cached value.\n+ *\n+ * <p>If there is a hash collision, the cache uses double hashing two more times to try to find a\n+ * match or an unused slot.\n+ *\n+ * <p>The cache is thread safe, and assumes that the <code>Creator</code> passed into <code>\n+ * computeIfAbsent</code> is idempotent or otherwise you might not get back the value you expect\n+ * from a cache lookup.\n+ *\n+ * @param <K> key type\n+ * @param <V> value type\n+ */\n+public class FixedSizeCache<K, V> {\n+\n+  public interface Creator<K, V> {\n+    V create(K key);\n+  }\n+\n+  static final int MAXIMUM_CAPACITY = 1 << 30;\n+\n+  private static final class Node<K, V> {\n+    private final K key;\n+    private final V value;\n+\n+    private Node(K key, V value) {\n+      this.key = key;\n+      this.value = value;\n+    }\n+  }\n+\n+  private final int mask;\n+  // This is a cache, so there is no need for volatile, atomics or synchronized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd20e4cffadcf300d010996b9d41b6cab5663de"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 82, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}