{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxOTU2NjI5", "number": 2083, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDozNTo1NVrOE59CUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0MzozMlrOE7HbOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MjA0MzA0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datanucleus-4/src/main/java/datadog/trace/instrumentation/datanucleus/ExecutionContextInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDozNTo1NVrOH0ukbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzo0NToxMFrOH2qXiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1MDk5MA==", "bodyText": "Couldn't we use BaseDecorator.className(cls) here instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/2083#discussion_r525050990", "createdAt": "2020-11-17T10:35:55Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/datanucleus-4/src/main/java/datadog/trace/instrumentation/datanucleus/ExecutionContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package datadog.trace.instrumentation.datanucleus;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.datanucleus.DatanucleusDecorator.DATANUCLEUS_FIND_OBJECT;\n+import static datadog.trace.instrumentation.datanucleus.DatanucleusDecorator.DECORATE;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.datanucleus.ExecutionContext;\n+\n+@AutoService(Instrumenter.class)\n+public class ExecutionContextInstrumentation extends Instrumenter.Default {\n+  public ExecutionContextInstrumentation() {\n+    super(\"datanucleus\");\n+  }\n+\n+  private final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER =\n+      hasClassesNamed(\"org.datanucleus.ExecutionContext\");\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    return CLASS_LOADER_MATCHER;\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.datanucleus.ExecutionContext\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".DatanucleusDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod().and(namedOneOf(\"persistObject\", \"deleteObject\", \"refreshObject\")),\n+        ExecutionContextInstrumentation.class.getName() + \"$SingleObjectActionAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(namedOneOf(\"refreshAllObjects\", \"persistObjects\", \"deleteObjects\", \"findObjects\")),\n+        ExecutionContextInstrumentation.class.getName() + \"$MultiObjectActionAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"findObject\"))\n+            .and(takesArguments(4))\n+            .and(takesArgument(3, String.class)),\n+        ExecutionContextInstrumentation.class.getName() + \"$FindWithStringClassnameAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"findObject\"))\n+            .and(takesArguments(4))\n+            .and(takesArgument(2, Class.class)),\n+        ExecutionContextInstrumentation.class.getName() + \"$FindWithClassAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class MultiObjectActionAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod(\n+        @Advice.This final ExecutionContext executionContext,\n+        @Advice.Origin(\"datanucleus.#m\") final String operationName) {\n+\n+      final AgentSpan span = startSpan(operationName);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope, @Advice.Thrown final Throwable throwable) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.onError(span, throwable);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class SingleObjectActionAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod(\n+        @Advice.Origin(\"datanucleus.#m\") final String operationName,\n+        @Advice.Argument(0) Object entity) {\n+\n+      if (entity == null) {\n+        return null;\n+      }\n+\n+      final AgentSpan span = startSpan(operationName);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object entity) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.onError(span, throwable);\n+      DECORATE.onOperation(span, entity);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class FindWithStringClassnameAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod() {\n+\n+      final AgentSpan span = startSpan(DATANUCLEUS_FIND_OBJECT);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object id,\n+        @Advice.Argument(3) String objectClassName) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.setResourceFromIdOrClass(span, id, objectClassName);\n+      DECORATE.onError(span, throwable);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class FindWithClassAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod() {\n+\n+      final AgentSpan span = startSpan(DATANUCLEUS_FIND_OBJECT);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object id,\n+        @Advice.Argument(2) Class cls) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.setResourceFromIdOrClass(span, id, cls == null ? null : cls.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba51b34fd4215f8c98ebafb90c5a2fe4c01800cc"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3OTMwNQ==", "bodyText": "No because sometimes we have the \"id object\", sometimes we have the class, sometimes we only have the classname", "url": "https://github.com/DataDog/dd-trace-java/pull/2083#discussion_r527079305", "createdAt": "2020-11-19T17:45:10Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/datanucleus-4/src/main/java/datadog/trace/instrumentation/datanucleus/ExecutionContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,208 @@\n+package datadog.trace.instrumentation.datanucleus;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.datanucleus.DatanucleusDecorator.DATANUCLEUS_FIND_OBJECT;\n+import static datadog.trace.instrumentation.datanucleus.DatanucleusDecorator.DECORATE;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.datanucleus.ExecutionContext;\n+\n+@AutoService(Instrumenter.class)\n+public class ExecutionContextInstrumentation extends Instrumenter.Default {\n+  public ExecutionContextInstrumentation() {\n+    super(\"datanucleus\");\n+  }\n+\n+  private final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER =\n+      hasClassesNamed(\"org.datanucleus.ExecutionContext\");\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    return CLASS_LOADER_MATCHER;\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.datanucleus.ExecutionContext\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".DatanucleusDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+\n+    transformers.put(\n+        isMethod().and(namedOneOf(\"persistObject\", \"deleteObject\", \"refreshObject\")),\n+        ExecutionContextInstrumentation.class.getName() + \"$SingleObjectActionAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(namedOneOf(\"refreshAllObjects\", \"persistObjects\", \"deleteObjects\", \"findObjects\")),\n+        ExecutionContextInstrumentation.class.getName() + \"$MultiObjectActionAdvice\");\n+\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"findObject\"))\n+            .and(takesArguments(4))\n+            .and(takesArgument(3, String.class)),\n+        ExecutionContextInstrumentation.class.getName() + \"$FindWithStringClassnameAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"findObject\"))\n+            .and(takesArguments(4))\n+            .and(takesArgument(2, Class.class)),\n+        ExecutionContextInstrumentation.class.getName() + \"$FindWithClassAdvice\");\n+\n+    return transformers;\n+  }\n+\n+  public static class MultiObjectActionAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod(\n+        @Advice.This final ExecutionContext executionContext,\n+        @Advice.Origin(\"datanucleus.#m\") final String operationName) {\n+\n+      final AgentSpan span = startSpan(operationName);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope, @Advice.Thrown final Throwable throwable) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.onError(span, throwable);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class SingleObjectActionAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod(\n+        @Advice.Origin(\"datanucleus.#m\") final String operationName,\n+        @Advice.Argument(0) Object entity) {\n+\n+      if (entity == null) {\n+        return null;\n+      }\n+\n+      final AgentSpan span = startSpan(operationName);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object entity) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.onError(span, throwable);\n+      DECORATE.onOperation(span, entity);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class FindWithStringClassnameAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod() {\n+\n+      final AgentSpan span = startSpan(DATANUCLEUS_FIND_OBJECT);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object id,\n+        @Advice.Argument(3) String objectClassName) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.setResourceFromIdOrClass(span, id, objectClassName);\n+      DECORATE.onError(span, throwable);\n+      DECORATE.beforeFinish(span);\n+\n+      span.finish();\n+      scope.close();\n+    }\n+  }\n+\n+  public static class FindWithClassAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope startMethod() {\n+\n+      final AgentSpan span = startSpan(DATANUCLEUS_FIND_OBJECT);\n+      DECORATE.afterStart(span);\n+\n+      return activateSpan(span);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void endMethod(\n+        @Advice.Enter final AgentScope scope,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Argument(0) Object id,\n+        @Advice.Argument(2) Class cls) {\n+\n+      if (scope == null) {\n+        return;\n+      }\n+\n+      AgentSpan span = scope.span();\n+      DECORATE.setResourceFromIdOrClass(span, id, cls == null ? null : cls.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1MDk5MA=="}, "originalCommit": {"oid": "ba51b34fd4215f8c98ebafb90c5a2fe4c01800cc"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNDIzMDk2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/datanucleus-4/datanucleus-4.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0MzozMlrOH2k1_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0MzozMlrOH2k1_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk4ODc5Nw==", "bodyText": "Is there no direct dependency between the two?", "url": "https://github.com/DataDog/dd-trace-java/pull/2083#discussion_r526988797", "createdAt": "2020-11-19T15:43:32Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/datanucleus-4/datanucleus-4.gradle", "diffHunk": "@@ -0,0 +1,82 @@\n+import org.datanucleus.enhancer.DataNucleusEnhancer\n+\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+buildscript {\n+  repositories {\n+    mavenCentral()\n+  }\n+\n+  dependencies {\n+    classpath group: 'org.datanucleus', name: 'datanucleus-core', version: '4.0.5'\n+    classpath group: 'org.datanucleus', name: 'datanucleus-api-jdo', version: '4.0.5'\n+    classpath group: 'org.datanucleus', name: 'javax.jdo', version: '3.2.0-m1'\n+  }\n+}\n+\n+muzzle {\n+  // 2 libraries are instrumented.\n+  // Muzzle is tested by keeping one version fixed and modifying the other\n+  // Ideally, muzzle would handle this directly and keep both versions in lockstep", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba51b34fd4215f8c98ebafb90c5a2fe4c01800cc"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4598, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}