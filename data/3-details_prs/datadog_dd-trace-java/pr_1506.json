{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTM1OTUx", "number": 1506, "title": "Switch Trace and Span id from BigInteger to DDId", "bodyText": "This PR introduces a new id type DDId that wraps a long representing the unsigned 64 bit id. It supersedes #1476, and all comments there have been adressed.\nIt roughly cuts down memory usage on pet-clinic with roughly 20% on Java 8, mostly by caching hex strings and not creating BigIntegers.\nThe PR is split in a code and a test commit to make it easier to review.\nComparison against StringCachingBigInteger and raw long:\npackage datadog.trace.api;\n\nimport datadog.trace.core.StringCachingBigInteger;\nimport java.math.BigInteger;\nimport java.util.concurrent.ThreadLocalRandom;\nimport org.openjdk.jmh.annotations.*;\nimport org.openjdk.jmh.infra.Blackhole;\n\n@State(Scope.Benchmark)\npublic class BigIntegerVsLongVsDDId {\n\n  @Param(\"2048\")\n  int count;\n\n  private String[] strings;\n  private String[] hexs;\n  private long[] longs;\n  private BigInteger[] bigIntegers;\n\n  @Setup(Level.Trial)\n  public void init() {\n    longs = new long[count];\n    bigIntegers = new BigInteger[count];\n    strings = new String[count];\n    hexs = new String[count];\n    for (int i = 0; i < count; ++i) {\n      long value = ThreadLocalRandom.current().nextLong();\n      BigInteger bigInteger = BigInteger.valueOf(value);\n      longs[i] = value;\n      bigIntegers[i] = bigInteger;\n      strings[i] = Long.toUnsignedString(value);\n      hexs[i] = Long.toHexString(value);\n    }\n  }\n\n  @Benchmark\n  public void stringCachingBigIntegersFromLong(Blackhole bh) {\n    for (long value : longs) {\n      bh.consume(StringCachingBigInteger.valueOf(value));\n    }\n  }\n\n  @Benchmark\n  public void ddIdsFromLong(Blackhole bh) {\n    for (long value : longs) {\n      bh.consume(DDId.from(value));\n    }\n  }\n\n  @Benchmark\n  public void longsToUnsignedString(Blackhole bh) {\n    for (long value : longs) {\n      bh.consume(Long.toUnsignedString(value));\n    }\n  }\n\n  @Benchmark\n  public void stringCachingBigIntegersToString(Blackhole bh) {\n    for (BigInteger value : bigIntegers) {\n      bh.consume(value.toString());\n    }\n  }\n\n  @Benchmark\n  public void ddIdsToUnsignedString(Blackhole bh) {\n    for (long value: longs) {\n      bh.consume(DDId.toUnsignedString(value));\n    }\n  }\n\n  @Benchmark\n  public void longsParseUnsigned(Blackhole bh) {\n    for (String value : strings) {\n      bh.consume(Long.parseUnsignedLong(value));\n    }\n  }\n\n  @Benchmark\n  public void stringCachingBigIntegersFromString(Blackhole bh) {\n    for (String value : strings) {\n      bh.consume(new StringCachingBigInteger(value));\n    }\n  }\n\n  @Benchmark\n  public void ddIdsFromString(Blackhole bh) {\n    for (String value : strings) {\n      bh.consume(DDId.from(value));\n    }\n  }\n\n  @Benchmark\n  public void ddIdsParseUnsignedLong(Blackhole bh) {\n    for (String value : strings) {\n      bh.consume(DDId.parseUnsignedLong(value));\n    }\n  }\n\n  @Benchmark\n  public void longsParseUnsignedLongHex(Blackhole bh) {\n    for (String value : hexs) {\n      bh.consume(Long.parseUnsignedLong(value, 16));\n    }\n  }\n\n  @Benchmark\n  public void stringCachingBigIntegersFromHex(Blackhole bh) {\n    for (String value : strings) {\n      bh.consume(new StringCachingBigInteger(value, 16));\n    }\n  }\n\n  @Benchmark\n  public void ddIdsFromHex(Blackhole bh) {\n    for (String value : hexs) {\n      bh.consume(DDId.fromHex(value));\n    }\n  }\n\n  @Benchmark\n  public void ddIdsParseUnsignedLongHex(Blackhole bh) {\n    for (String value : hexs) {\n      bh.consume(DDId.parseUnsignedLongHex(value));\n    }\n  }\n}\n\nGives the following results:\nBenchmark                                                 (count)   Mode  Cnt       Score     Error   Units\nBigIntegerVsLongVsDDId.ddIdsFromHex                          2048  thrpt    5   35367.130 \u00b1 111.292  ops/ms\nBigIntegerVsLongVsDDId.ddIdsFromLong                         2048  thrpt    5  106431.517 \u00b1 276.364  ops/ms\nBigIntegerVsLongVsDDId.ddIdsFromString                       2048  thrpt    5   36130.065 \u00b1  93.296  ops/ms\nBigIntegerVsLongVsDDId.ddIdsParseUnsignedLong                2048  thrpt    5   37689.861 \u00b1 140.999  ops/ms\nBigIntegerVsLongVsDDId.ddIdsParseUnsignedLongHex             2048  thrpt    5   53085.074 \u00b1  14.896  ops/ms\nBigIntegerVsLongVsDDId.ddIdsToUnsignedString                 2048  thrpt    5   20957.315 \u00b1  82.129  ops/ms\nBigIntegerVsLongVsDDId.longsParseUnsigned                    2048  thrpt    5   25967.738 \u00b1  97.130  ops/ms\nBigIntegerVsLongVsDDId.longsParseUnsignedLongHex             2048  thrpt    5   36216.422 \u00b1  70.460  ops/ms\nBigIntegerVsLongVsDDId.longsToUnsignedString                 2048  thrpt    5   21121.608 \u00b1 257.754  ops/ms\nBigIntegerVsLongVsDDId.stringCachingBigIntegersFromHex       2048  thrpt    5    9245.045 \u00b1  38.751  ops/ms\nBigIntegerVsLongVsDDId.stringCachingBigIntegersFromLong      2048  thrpt    5   74079.332 \u00b1 851.652  ops/ms\nBigIntegerVsLongVsDDId.stringCachingBigIntegersFromString    2048  thrpt    5    9169.314 \u00b1  71.257  ops/ms\nBigIntegerVsLongVsDDId.stringCachingBigIntegersToString      2048  thrpt    5    4045.854 \u00b1   9.499  ops/ms\n\nA DDId is roughly 32 bytes, and all operations perform better than BigInteger and Long, except unsigned string creation where Long is slightly faster.", "createdAt": "2020-05-28T14:41:12Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1506", "merged": true, "mergeCommit": {"oid": "550995a477175a4606b36a1cf5c715663b989193"}, "closed": true, "closedAt": "2020-06-01T10:10:23Z", "author": {"login": "bantonsson"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclvHahgFqTQyMDE4ODgyOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcm7RrpgBqjMzOTE5MDc1OTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMTg4ODI5", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420188829", "createdAt": "2020-05-28T14:47:10Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0NzoxMFrOGb40Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo1MDozMlrOGb4-_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg==", "bodyText": "Since this is used for tests, can we make it package private or private instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431895622", "createdAt": "2020-05-28T14:47:10Z", "author": {"login": "devinsba"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw==", "bodyText": "I think the 2 argument nextLong would be correct here. We do support negative signed longs", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431898367", "createdAt": "2020-05-28T14:50:32Z", "author": {"login": "devinsba"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjM2Mjc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420236276", "createdAt": "2020-05-28T15:34:11Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozNDoxMlrOGb680w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozNDoxMlrOGb680w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ==", "bodyText": "Do we really need this? It will be extremely rare to overflow, can't we just materialise when (if) we do", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431930579", "createdAt": "2020-05-28T15:34:12Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQxNTUw", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420241550", "createdAt": "2020-05-28T15:39:16Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOToxNlrOGb7K6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOToxNlrOGb7K6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDE4Nw==", "bodyText": "The cast is unnecessary here, >>> will shift zero into the high bits", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934187", "createdAt": "2020-05-28T15:39:16Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQyMzcz", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420242373", "createdAt": "2020-05-28T15:40:05Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDowNVrOGb7NHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDowNVrOGb7NHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDc1MA==", "bodyText": "Could just mask with 0xFFFFFFFFL to isolate the low bits.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934750", "createdAt": "2020-05-28T15:40:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQyNzg5", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420242789", "createdAt": "2020-05-28T15:40:31Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDozMVrOGb7OOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDozMVrOGb7OOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTAzNQ==", "bodyText": "mask unnecessary here if cast above is removed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935035", "createdAt": "2020-05-28T15:40:31Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQzMjgy", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420243282", "createdAt": "2020-05-28T15:41:01Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MTowMlrOGb7Pqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MTowMlrOGb7Pqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTQwMg==", "bodyText": "mask unnecessary if just shifted right above without casting on line 200", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935402", "createdAt": "2020-05-28T15:41:02Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 203}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQ0NDMw", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420244430", "createdAt": "2020-05-28T15:42:11Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MjoxMlrOGb7S3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MjoxMlrOGb7S3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA==", "bodyText": "I wonder should we be shifting the high bits right and xoring?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936220", "createdAt": "2020-05-28T15:42:12Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 218}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQ1MDEy", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420245012", "createdAt": "2020-05-28T15:42:46Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0Mjo0N1rOGb7Ucw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0Mjo0N1rOGb7Ucw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjYyNw==", "bodyText": "maybe add a comment that the race condition is benign", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936627", "createdAt": "2020-05-28T15:42:47Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQ1Njc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420245676", "createdAt": "2020-05-28T15:43:27Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MzoyN1rOGb7Wdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MzoyN1rOGb7Wdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw==", "bodyText": "I don't think we will ever need this except at the last possible moment when we serialise", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937143", "createdAt": "2020-05-28T15:43:27Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjQ5NTUx", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420249551", "createdAt": "2020-05-28T15:47:26Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0NzoyNlrOGb7hLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0NzoyNlrOGb7hLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ==", "bodyText": "can we take this off the critical path by marking it in a bitmask and checking the bitmask against zero (meaning valid) at the end?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431939885", "createdAt": "2020-05-28T15:47:26Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjU2NDMz", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420256433", "createdAt": "2020-05-28T15:54:14Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NDoxNFrOGb7zpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NDoxNFrOGb7zpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDYxMg==", "bodyText": "Can this be implemented the same way as JDK8 Long.compareUnsigned(i.e. add Long.MIN_VALUE to each side?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431944612", "createdAt": "2020-05-28T15:54:14Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java", "diffHunk": "@@ -35,7 +35,12 @@ public boolean sample(final DDSpan span) {\n     } else if (rate == 0) {\n       sampled = false;\n     } else {\n-      sampled = span.getTraceId().multiply(KNUTH_FACTOR).mod(MODULUS).compareTo(cutoff) < 0;\n+      long mod = span.getTraceId().toLong() * KNUTH_FACTOR;\n+      if (cutoff >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMjU3NzQ2", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420257746", "createdAt": "2020-05-28T15:55:30Z", "commit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NTozMFrOGb73Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NTozMFrOGb73Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTUzMQ==", "bodyText": "I believe this is the only time DDId.toBigInteger is called.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431945531", "createdAt": "2020-05-28T15:55:30Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/JsonFormatWriter.java", "diffHunk": "@@ -97,7 +98,17 @@ public void writeDouble(final byte[] key, final double value, final JsonWriter d\n   }\n \n   @Override\n-  public void writeBigInteger(\n+  public void writeId(byte[] key, DDId id, JsonWriter destination) throws IOException {\n+    // This is to keep the id output compatible with the BigInteger id for tests\n+    long l = id.toLong();\n+    if (l >= 0) {\n+      writeLong(key, l, destination);\n+    } else {\n+      writeBigInteger(key, id.toBigInteger(), destination);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzQ4ODEy", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420348812", "createdAt": "2020-05-28T17:45:10Z", "commit": {"oid": "b443e579d678d3e37b66b0cf187c085f7c451733"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo0NToxMFrOGcAA8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo1MDoxOVrOGcAL5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU1Mw==", "bodyText": "Same comment here about the race condition.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432013553", "createdAt": "2020-05-28T17:45:10Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b443e579d678d3e37b66b0cf187c085f7c451733"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxNjM1Ng==", "bodyText": "Should we submit a PR for packUnsignedLong?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432016356", "createdAt": "2020-05-28T17:50:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwODQwMTk2", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-420840196", "createdAt": "2020-05-29T10:38:04Z", "commit": {"oid": "af57fc6682a7c11ecfac642896354f75c111a0ba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af57fc6682a7c11ecfac642896354f75c111a0ba", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/af57fc6682a7c11ecfac642896354f75c111a0ba", "committedDate": "2020-05-29T09:48:10Z", "message": "DDId changes based on review comments"}, "afterCommit": {"oid": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7903d8a724b0ec14124255da4b1e4bddb3a766ca", "committedDate": "2020-05-29T12:13:56Z", "message": "DDId changes based on review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7903d8a724b0ec14124255da4b1e4bddb3a766ca", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7903d8a724b0ec14124255da4b1e4bddb3a766ca", "committedDate": "2020-05-29T12:13:56Z", "message": "DDId changes based on review comments"}, "afterCommit": {"oid": "15707dd317c91a78d145762569e14468e1554e2a", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/15707dd317c91a78d145762569e14468e1554e2a", "committedDate": "2020-05-29T13:26:56Z", "message": "DDId changes based on review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15707dd317c91a78d145762569e14468e1554e2a", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/15707dd317c91a78d145762569e14468e1554e2a", "committedDate": "2020-05-29T13:26:56Z", "message": "DDId changes based on review comments"}, "afterCommit": {"oid": "dd8034b4127b1632735e9bbe043e2f66be2fbf92", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dd8034b4127b1632735e9bbe043e2f66be2fbf92", "committedDate": "2020-05-29T13:59:53Z", "message": "DDId changes based on review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dd8034b4127b1632735e9bbe043e2f66be2fbf92", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dd8034b4127b1632735e9bbe043e2f66be2fbf92", "committedDate": "2020-05-29T13:59:53Z", "message": "DDId changes based on review comments"}, "afterCommit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fc20abc1a2938f53cd08963568ccd399f733d07f", "committedDate": "2020-05-29T15:27:37Z", "message": "DDId changes based on review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTA5NTEz", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-421109513", "createdAt": "2020-05-29T16:32:59Z", "commit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozMjo1OVrOGcj6Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozMjo1OVrOGcj6Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTY0Nw==", "bodyText": "Why is this line important?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432601647", "createdAt": "2020-05-29T16:32:59Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -215,43 +215,53 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return (int) this.id;\n+    long id = this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTI0MzYz", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#pullrequestreview-421124363", "createdAt": "2020-05-29T16:54:46Z", "commit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07bbf3dac87d70bcf5df12dc8d82b87b74ad1445", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/07bbf3dac87d70bcf5df12dc8d82b87b74ad1445", "committedDate": "2020-06-01T07:38:45Z", "message": "Switch Trace and Span id from BigInteger to DDId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4db5dcaa30e10ba6b5d1fafcdac868083bca693", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b4db5dcaa30e10ba6b5d1fafcdac868083bca693", "committedDate": "2020-06-01T07:38:45Z", "message": "Update all tests to DDId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67e404592f9712e3f95d775190933341fc3fe024", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/67e404592f9712e3f95d775190933341fc3fe024", "committedDate": "2020-06-01T07:38:45Z", "message": "DDId changes based on review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fc20abc1a2938f53cd08963568ccd399f733d07f", "committedDate": "2020-05-29T15:27:37Z", "message": "DDId changes based on review comments"}, "afterCommit": {"oid": "67e404592f9712e3f95d775190933341fc3fe024", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/67e404592f9712e3f95d775190933341fc3fe024", "committedDate": "2020-06-01T07:38:45Z", "message": "DDId changes based on review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2311, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}