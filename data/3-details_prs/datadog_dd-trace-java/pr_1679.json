{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4ODE5ODM3", "number": 1679, "title": "trace agent v0.5", "bodyText": "Implements discovery of the format made available here DataDog/datadog-agent#5965\nThis has been verified to work with a manual integration test, but I have not updated the tests yet because they are \"not very nice\" to modify.\nTODO\n\nadd v0.5 integration test once agent changes are finalised and released", "createdAt": "2020-07-14T11:25:27Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1679", "merged": true, "mergeCommit": {"oid": "8314fa76d5170ed5fafefc61da1fbd10d48125e8"}, "closed": true, "closedAt": "2020-08-04T10:06:07Z", "author": {"login": "richardstartin"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc00TaugBqjM1NDM3MzExMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7jRpbABqjM2MTk0MDIxODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "524fa6be820ad61739a2a6de5d4527681b062d59", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/524fa6be820ad61739a2a6de5d4527681b062d59", "committedDate": "2020-07-14T11:21:39Z", "message": "add trace format discovery mechanism"}, "afterCommit": {"oid": "caa73b783716155776283bbd36ac5df4734a9cd3", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/caa73b783716155776283bbd36ac5df4734a9cd3", "committedDate": "2020-07-14T11:26:13Z", "message": "add trace format discovery mechanism"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "caa73b783716155776283bbd36ac5df4734a9cd3", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/caa73b783716155776283bbd36ac5df4734a9cd3", "committedDate": "2020-07-14T11:26:13Z", "message": "add trace format discovery mechanism"}, "afterCommit": {"oid": "28442dabab42e76bdbf3b84e5edf415f5e078233", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/28442dabab42e76bdbf3b84e5edf415f5e078233", "committedDate": "2020-07-14T11:34:07Z", "message": "add trace format discovery mechanism"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6cedf47b529f0814bec320a8f0e045559b41322a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6cedf47b529f0814bec320a8f0e045559b41322a", "committedDate": "2020-07-14T20:25:29Z", "message": "improve agent api tests for v0.5"}, "afterCommit": {"oid": "eced5621e52cac6b924b226c48e1c6d462c00650", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/eced5621e52cac6b924b226c48e1c6d462c00650", "committedDate": "2020-07-14T20:36:37Z", "message": "improve agent api tests for v0.5"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d135dc248ea8a3017693abc12ef6ab9224158f5e", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d135dc248ea8a3017693abc12ef6ab9224158f5e", "committedDate": "2020-07-14T21:04:40Z", "message": "nasty hack to keep CoreTracerTest happy"}, "afterCommit": {"oid": "9d7dfc4e60292b2aeace5d4583344593fd044060", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9d7dfc4e60292b2aeace5d4583344593fd044060", "committedDate": "2020-07-14T21:30:13Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09e9bbf7e1e12f325ae67627621c43341cda382b", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/09e9bbf7e1e12f325ae67627621c43341cda382b", "committedDate": "2020-07-15T09:06:45Z", "message": "select trace mapper lazily in case the agent is unavailable or slow during application startup"}, "afterCommit": {"oid": "6a572a45bc42b861722a7a6d3134aef3099fb434", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6a572a45bc42b861722a7a6d3134aef3099fb434", "committedDate": "2020-07-15T09:07:39Z", "message": "select trace mapper lazily in case the agent is unavailable or slow during application startup"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffd99bcb919fe8dfb6865ad21c6ecffc8a1ea39a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ffd99bcb919fe8dfb6865ad21c6ecffc8a1ea39a", "committedDate": "2020-07-15T11:11:20Z", "message": "make smoke tests 404 on agent v0.5 endpoint"}, "afterCommit": {"oid": "11df138e446ad2bce8eacf0dd4ee13f337b65891", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/11df138e446ad2bce8eacf0dd4ee13f337b65891", "committedDate": "2020-07-15T11:24:45Z", "message": "make smoke tests 404 on agent v0.5 endpoint"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fe42d3f1a9ad2fefadc90d6e82cb08d55585c89", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2fe42d3f1a9ad2fefadc90d6e82cb08d55585c89", "committedDate": "2020-07-16T21:16:20Z", "message": "don't trigger agent connection until at least one trace has been published"}, "afterCommit": {"oid": "3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "committedDate": "2020-07-16T21:34:51Z", "message": "don't trigger agent connection until at least one trace has been published"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "committedDate": "2020-07-16T21:34:51Z", "message": "don't trigger agent connection until at least one trace has been published"}, "afterCommit": {"oid": "2c009aa409abb8d919c0a87bf2b65162edb8968d", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2c009aa409abb8d919c0a87bf2b65162edb8968d", "committedDate": "2020-07-20T14:58:00Z", "message": "remove unused DDAgentWriter from Monitor methods which avoids unsafe publication of"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2535e06d067d8d147063a84f58c31bc22b55c435", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2535e06d067d8d147063a84f58c31bc22b55c435", "committedDate": "2020-07-21T09:35:53Z", "message": "efficiency improvement for tags"}, "afterCommit": {"oid": "6b36a3766a5218e8c567a53fab8dfea45dff695a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6b36a3766a5218e8c567a53fab8dfea45dff695a", "committedDate": "2020-07-21T09:38:25Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6d19194f8209ad1748e54a45cd52b128c984e4a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f6d19194f8209ad1748e54a45cd52b128c984e4a", "committedDate": "2020-07-21T09:58:00Z", "message": "unpeel encodingcache calls, static final dictionary full signal"}, "afterCommit": {"oid": "d939a2f04c546615185363dd0d2ba604c1d2fd50", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d939a2f04c546615185363dd0d2ba604c1d2fd50", "committedDate": "2020-07-21T10:00:27Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d939a2f04c546615185363dd0d2ba604c1d2fd50", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d939a2f04c546615185363dd0d2ba604c1d2fd50", "committedDate": "2020-07-21T10:00:27Z", "message": "revapi"}, "afterCommit": {"oid": "7855b8ce3660be2fd2e1559acfec4e49c6277178", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7855b8ce3660be2fd2e1559acfec4e49c6277178", "committedDate": "2020-07-21T10:05:39Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "542a04d4533a8814ea847e2dea8c254d184e0a29", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/542a04d4533a8814ea847e2dea8c254d184e0a29", "committedDate": "2020-07-21T10:15:37Z", "message": "make CoreTracerTest happy"}, "afterCommit": {"oid": "e421c3a32512a68c716bd2a59c9170b1288b6609", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e421c3a32512a68c716bd2a59c9170b1288b6609", "committedDate": "2020-07-21T10:48:38Z", "message": "make CoreTracerTest happy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85d8bd28894b912ce005ca7bacb69f6ee65e4dc4", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/85d8bd28894b912ce005ca7bacb69f6ee65e4dc4", "committedDate": "2020-07-21T17:09:58Z", "message": "get rid of trace wrapper"}, "afterCommit": {"oid": "b43511383be141761375333f71f0f129830ead4d", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b43511383be141761375333f71f0f129830ead4d", "committedDate": "2020-07-21T17:39:07Z", "message": "get rid of trace wrapper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyODQxMTcx", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-452841171", "createdAt": "2020-07-21T21:25:58Z", "commit": {"oid": "b43511383be141761375333f71f0f129830ead4d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMToyNTo1OVrOG1KXmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMToyNTo1OVrOG1KXmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NzU5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // TODO once this version if the agent is released\n          \n          \n            \n                  //  and it becomes the common case we should think about\n          \n          \n            \n                  //  bumping this\n          \n          \n            \n                  prefix(\"/v0.5/traces\") {\n          \n          \n            \n                    traceRequests.add(request)\n          \n          \n            \n                    response.status(404).send()\n          \n          \n            \n                  }\n          \n          \n            \n                  all {\n          \n          \n            \n                    response.status(200).send()\n          \n          \n            \n                  }\n          \n          \n            \n                  all {\n          \n          \n            \n                    response.status(404).send()\n          \n          \n            \n                  }", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r458397594", "createdAt": "2020-07-21T21:25:59Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "diffHunk": "@@ -52,6 +52,13 @@ abstract class AbstractSmokeTest extends Specification {\n         traceRequests.add(request)\n         response.status(200).send()\n       }\n+      // TODO once this version if the agent is released\n+      //  and it becomes the common case we should think about\n+      //  bumping this\n+      prefix(\"/v0.5/traces\") {\n+        traceRequests.add(request)\n+        response.status(404).send()\n+      }\n       all {\n         response.status(200).send()\n       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b43511383be141761375333f71f0f129830ead4d"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "677b66daba682a0b8c3a26f6c609171b4f978326", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/677b66daba682a0b8c3a26f6c609171b4f978326", "committedDate": "2020-07-23T10:37:16Z", "message": "improve encapsulation of endpoint specific payload logic"}, "afterCommit": {"oid": "bfd5f69a54a078b1211a564fd38021ab723027d3", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/bfd5f69a54a078b1211a564fd38021ab723027d3", "committedDate": "2020-07-23T11:14:26Z", "message": "improve encapsulation of endpoint specific payload logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4530a7dc407c6fd28c95af61a9c8594b5387076", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a4530a7dc407c6fd28c95af61a9c8594b5387076", "committedDate": "2020-07-23T14:32:49Z", "message": "revert to original format which is more efficient"}, "afterCommit": {"oid": "9807b6df52e4f6fd3c631c4f52c214a589914a3a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9807b6df52e4f6fd3c631c4f52c214a589914a3a", "committedDate": "2020-07-30T08:16:01Z", "message": "dictionary encode trace messages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9807b6df52e4f6fd3c631c4f52c214a589914a3a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9807b6df52e4f6fd3c631c4f52c214a589914a3a", "committedDate": "2020-07-30T08:16:01Z", "message": "dictionary encode trace messages"}, "afterCommit": {"oid": "ef1b866f7252ba4c84a1a3656cee98d076910148", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ef1b866f7252ba4c84a1a3656cee98d076910148", "committedDate": "2020-07-30T08:18:54Z", "message": "dictionary encode trace messages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MTkyMzcy", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458192372", "createdAt": "2020-07-30T08:30:01Z", "commit": {"oid": "ef1b866f7252ba4c84a1a3656cee98d076910148"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODozMDowMlrOG5ZSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODozMDowMlrOG5ZSQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNjI5MQ==", "bodyText": "This one seems to be unused and shadowed by the method parameter in writeLongAsString", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r462836291", "createdAt": "2020-07-30T08:30:02Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+public class Util {\n+\n+  private static final byte[] DIGIT_TENS = {\n+    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n+    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n+    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n+    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n+    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n+    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n+    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n+    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n+    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n+    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n+  };\n+\n+  private static final byte[] DIGIT_ONES = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+  };\n+\n+  private final byte[] numberByteArray = new byte[20]; // this is max long digits and sign", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1b866f7252ba4c84a1a3656cee98d076910148"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef1b866f7252ba4c84a1a3656cee98d076910148", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ef1b866f7252ba4c84a1a3656cee98d076910148", "committedDate": "2020-07-30T08:18:54Z", "message": "dictionary encode trace messages"}, "afterCommit": {"oid": "4fdd8908b6c951932be72e2a742d876a165df7f1", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4fdd8908b6c951932be72e2a742d876a165df7f1", "committedDate": "2020-07-30T08:35:30Z", "message": "dictionary encode trace messages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b739353a38e7a39bcdf8c9ab88fe23532c63b50b", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b739353a38e7a39bcdf8c9ab88fe23532c63b50b", "committedDate": "2020-07-30T08:51:42Z", "message": "port baggage overlap to v0.5"}, "afterCommit": {"oid": "b472bcfe3f8e076950ce096300335c983365eab3", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b472bcfe3f8e076950ce096300335c983365eab3", "committedDate": "2020-07-30T09:21:53Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96102bacd3ae225ff494c72ac9785453c2158b32", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/96102bacd3ae225ff494c72ac9785453c2158b32", "committedDate": "2020-07-30T14:23:41Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}, "afterCommit": {"oid": "95c69821949f35bd0876b9f468b85953f4356e67", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/95c69821949f35bd0876b9f468b85953f4356e67", "committedDate": "2020-07-30T16:31:37Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95c69821949f35bd0876b9f468b85953f4356e67", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/95c69821949f35bd0876b9f468b85953f4356e67", "committedDate": "2020-07-30T16:31:37Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}, "afterCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "committedDate": "2020-07-30T17:50:12Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjMxNzc3", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458631777", "createdAt": "2020-07-30T17:57:34Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1NzozNFrOG5t26Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1NzozNFrOG5t26Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3MzM1Mw==", "bodyText": "@dougqh here's the fallback mechanism (i.e. pick the latest one this deployment knows about).", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463173353", "createdAt": "2020-07-30T17:57:34Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -36,9 +38,10 @@\n   private static final String DATADOG_META_TRACER_VERSION = \"Datadog-Meta-Tracer-Version\";\n   private static final String DATADOG_CONTAINER_ID = \"Datadog-Container-ID\";\n   private static final String X_DATADOG_TRACE_COUNT = \"X-Datadog-Trace-Count\";\n-\n-  private static final String TRACES_ENDPOINT_V3 = \"v0.3/traces\";\n-  private static final String TRACES_ENDPOINT_V4 = \"v0.4/traces\";\n+  private static final String V3_ENDPOINT = \"v0.3/traces\";\n+  private static final String V4_ENDPOINT = \"v0.4/traces\";\n+  private static final String V5_ENDPOINT = \"v0.5/traces\";\n+  private static final String[] ENDPOINTS = new String[] {V5_ENDPOINT, V4_ENDPOINT, V3_ENDPOINT};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjMyMjAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458632200", "createdAt": "2020-07-30T17:58:10Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1ODoxMVrOG5t4Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1ODoxMVrOG5t4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3MzY4Mw==", "bodyText": "@dougqh discovery/fallback mechanism", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463173683", "createdAt": "2020-07-30T17:58:11Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -305,16 +335,44 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n-  void detectEndpointAndBuildClient() {\n+  String detectEndpointAndBuildClient() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjMzNDEx", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458633411", "createdAt": "2020-07-30T17:59:48Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1OTo0OFrOG5t70g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo1OTo0OFrOG5t70g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NDYxMA==", "bodyText": "@dougqh this is the V5 mapper", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463174610", "createdAt": "2020-07-30T17:59:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjMzOTAx", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458633901", "createdAt": "2020-07-30T18:00:27Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowMDoyN1rOG5t9pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowMDoyN1rOG5t9pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NTA3OQ==", "bodyText": "@dougqh this ensures that null values are dictionary encoded as the empty string \u00af_(\u30c4)_/\u00af", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463175079", "createdAt": "2020-07-30T18:00:27Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM1MDkz", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458635093", "createdAt": "2020-07-30T18:02:12Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowMjoxMlrOG5uBXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowMjoxMlrOG5uBXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NjAzMQ==", "bodyText": "this is a quite hacky workaround for the Packer's API releasing a slice of the buffer to a consumer, it gets published into the first slot of this array.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463176031", "createdAt": "2020-07-30T18:02:12Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM2NjUz", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458636653", "createdAt": "2020-07-30T18:04:22Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNDoyMlrOG5uGMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNDoyMlrOG5uGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NzI2Ng==", "bodyText": "This happens when the dictionary fills up before the traces do, and we need some way to signal to the Packer packing the traces themselves that the dictionary is full. There are probably other ways of doing this and we can/should refactor this to be cleaner later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463177266", "createdAt": "2020-07-30T18:04:22Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM3MjA5", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458637209", "createdAt": "2020-07-30T18:05:08Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNTowOVrOG5uH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNTowOVrOG5uH-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NzcyMQ==", "bodyText": "This is responsible for mapping the deduplicated strings to msgpack strings.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463177721", "createdAt": "2020-07-30T18:05:09Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];\n+  }\n+\n+  @Override\n+  public void reset() {\n+    dictionaryWriter.reset();\n+    code = 0;\n+    dictionary[0] = null;\n+    encoding.clear();\n+  }\n+\n+  private static class DictionaryMapper implements Mapper<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM3NjYw", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458637660", "createdAt": "2020-07-30T18:05:53Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNTo1M1rOG5uJcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNTo1M1rOG5uJcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3ODA5OQ==", "bodyText": "The WritableByteChannel comes from the HTTP API. Need to write an array of the dictionary and the body (traces) into the channel.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463178099", "createdAt": "2020-07-30T18:05:53Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];\n+  }\n+\n+  @Override\n+  public void reset() {\n+    dictionaryWriter.reset();\n+    code = 0;\n+    dictionary[0] = null;\n+    encoding.clear();\n+  }\n+\n+  private static class DictionaryMapper implements Mapper<Object> {\n+\n+    private final byte[] numberByteArray = new byte[20]; // this is max long digits and sign\n+\n+    @Override\n+    public void map(Object data, Writable packer) {\n+      if (data instanceof UTF8BytesString) {\n+        packer.writeUTF8(((UTF8BytesString) data).getUtf8Bytes());\n+      } else if (data instanceof Long || data instanceof Integer) {\n+        writeLongAsString(((Number) data).longValue(), packer, numberByteArray);\n+      } else {\n+        assert null != data : \"enclosing mapper should not provide null values\";\n+        String string = String.valueOf(data);\n+        byte[] utf8 = StringTables.getKeyBytesUTF8(string);\n+        if (null == utf8) {\n+          utf8 = StringTables.getTagBytesUTF8(string);\n+          if (null == utf8) {\n+            packer.writeString(string, NO_CACHING);\n+            return;\n+          }\n+        }\n+        packer.writeUTF8(utf8);\n+      }\n+    }\n+  }\n+\n+  private static class PayloadV0_5 extends Payload {\n+\n+    // msgpack array header with 2 elements (FIXARRAY | 2)\n+    private final ByteBuffer header = ByteBuffer.allocate(1).put(0, (byte) 0x92);\n+    private final ByteBuffer dictionary;\n+\n+    private PayloadV0_5(ByteBuffer dictionary) {\n+      this.dictionary = dictionary;\n+    }\n+\n+    @Override\n+    int sizeInBytes() {\n+      return sizeInBytes(header) + sizeInBytes(dictionary) + sizeInBytes(body);\n+    }\n+\n+    @Override\n+    public void writeTo(WritableByteChannel channel) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM4NTYy", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458638562", "createdAt": "2020-07-30T18:07:10Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNzoxMFrOG5uMGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowNzoxMFrOG5uMGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3ODc3Nw==", "bodyText": "mediates between DDAgentApi and TraceProcessingDisruptor - discovers the endpoint, which mapper should be used etc.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463178777", "createdAt": "2020-07-30T18:07:10Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/PayloadDispatcher.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class PayloadDispatcher implements ByteBufferConsumer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjM5MzEw", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458639310", "createdAt": "2020-07-30T18:08:13Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowODoxM1rOG5uOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowODoxM1rOG5uOXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3OTM1Nw==", "bodyText": "this interface was extracted because it's so very difficult to create DDSpan without creating a CoreTracer and PendingTrace, and it can't be done without violating access constraints.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463179357", "createdAt": "2020-07-30T18:08:13Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanData.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package datadog.trace.core;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjQwNTE2", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458640516", "createdAt": "2020-07-30T18:09:55Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowOTo1NVrOG5uSLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODowOTo1NVrOG5uSLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MDMzMg==", "bodyText": "this allows this class to be reused for writing the dictionary, where the dictionary packer can be reset manually after the dictionary packer and the traces packer is flushed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463180332", "createdAt": "2020-07-30T18:09:55Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Packer.java", "diffHunk": "@@ -98,17 +108,29 @@ private void initBuffer() {\n       //    overflow into the now reset buffer, doing the serialisation work again.\n       buffer.mark();\n       ++messageCount;\n+      return true;\n     } catch (BufferOverflowException e) {\n       // go back to the last successfully written message\n       buffer.reset();\n-      if (buffer.position() == MAX_ARRAY_HEADER_SIZE) {\n-        throw e;\n+      if (!manualReset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjQwODIy", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458640822", "createdAt": "2020-07-30T18:10:19Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxMDoxOVrOG5uTFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxMDoxOVrOG5uTFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MDU2Nw==", "bodyText": "Old code moved here for reuse.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463180567", "createdAt": "2020-07-30T18:10:19Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.serialization.msgpack;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjQyMTA5", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-458642109", "createdAt": "2020-07-30T18:12:17Z", "commit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxMjoxN1rOG5uXHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxMjoxN1rOG5uXHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTU5OA==", "bodyText": "This will incur a small cost. Without DDSpanData it was possible to get naked access to the underlying map via DDSpanContext, whereas in implementing this interface it is prudent to wrap.", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463181598", "createdAt": "2020-07-30T18:12:17Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -368,6 +368,11 @@ public int getError() {\n     return context.getErrorFlag() ? 1 : 0;\n   }\n \n+  @Override\n+  public Map<String, String> getBaggage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a"}, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "committedDate": "2020-07-30T17:50:12Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}, "afterCommit": {"oid": "7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "committedDate": "2020-07-31T18:59:00Z", "message": "post rebase spotless"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "committedDate": "2020-07-31T18:59:00Z", "message": "post rebase spotless"}, "afterCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d78961ae741e64a53339251a449be3251f3057db", "committedDate": "2020-07-31T19:12:37Z", "message": "post rebase spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5OTU3OTAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#pullrequestreview-459957900", "createdAt": "2020-08-03T11:40:23Z", "commit": {"oid": "d78961ae741e64a53339251a449be3251f3057db"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMTo0MDoyM1rOG62QoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMjoyMDoyN1rOG63WAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1OTU4NA==", "bodyText": "I assume that the 1s connect timeout is to make sure that we don't hang for a long time trying to connect to the agent. Would it make sense to have it configurable just in case, for troubleshooting?", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464359584", "createdAt": "2020-08-03T11:40:23Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -305,16 +335,44 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n-  void detectEndpointAndBuildClient() {\n+  String detectEndpointAndBuildClient() {\n+    // TODO clean this up\n     if (httpClient == null) {\n-      final HttpUrl v4Url = getUrl(host, port, TRACES_ENDPOINT_V4);\n-      if (endpointAvailable(v4Url, unixDomainSocketPath, timeoutMillis, true)) {\n-        tracesUrl = v4Url;\n-      } else {\n-        log.debug(\"API v0.4 endpoints not available. Downgrading to v0.3\");\n-        tracesUrl = getUrl(host, port, TRACES_ENDPOINT_V3);\n+      this.agentRunning = isAgentRunning();\n+      // TODO should check agentRunning, but CoreTracerTest depends on being\n+      //  able to detect an endpoint without an open socket...\n+      for (String candidate : ENDPOINTS) {\n+        tracesUrl = getUrl(host, port, candidate);\n+        this.httpClient = buildClientIfAvailable(tracesUrl, unixDomainSocketPath, timeoutMillis);\n+        if (null != httpClient) {\n+          detectedVersion = candidate;\n+          log.debug(\"connected to agent {}\", candidate);\n+          return candidate;\n+        } else {\n+          log.debug(\"API {} endpoints not available. Downgrading\", candidate);\n+        }\n+      }\n+      if (null == tracesUrl) {\n+        log.error(\"no compatible agent detected\");\n       }\n-      httpClient = buildHttpClient(unixDomainSocketPath, timeoutMillis);\n+    } else {\n+      log.warn(\"No connectivity to datadog agent\");\n+    }\n+    if (null == detectedVersion) {\n+      log.debug(\"Tried all of {}, no connectivity to datadog agent\", ENDPOINTS);\n+    }\n+    return detectedVersion;\n+  }\n+\n+  private boolean isAgentRunning() {\n+    try (Socket socket = new Socket()) {\n+      socket.setSoTimeout(CONNECT_TIMEOUT_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NDk0Ng==", "bodyText": "Lovely little dance here with the Packer", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464374946", "createdAt": "2020-08-03T12:15:07Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.TagsAndBaggageConsumer;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, final Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      span.processTagsAndBaggage(\n+          new TagsAndBaggageConsumer() {\n+            @Override\n+            public void accept(Map<String, Object> tags, Map<String, String> baggage) {\n+              // since tags can \"override\" baggage, we need to count the non overlapping ones\n+              int size = tags.size();\n+              boolean overlap = false;\n+              for (String key : baggage.keySet()) {\n+                if (!tags.containsKey(key)) {\n+                  size++;\n+                } else {\n+                  overlap = true;\n+                }\n+              }\n+              writable.startMap(size);\n+              for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+                // tags and baggage may intersect, but tags take priority\n+                if (!overlap || !tags.containsKey(entry.getKey())) {\n+                  writeDictionaryEncoded(writable, entry.getKey());\n+                  writeDictionaryEncoded(writable, entry.getValue());\n+                }\n+              }\n+              for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+                writeDictionaryEncoded(writable, entry.getKey());\n+                writeDictionaryEncoded(writable, entry.getValue());\n+              }\n+            }\n+          });\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NjExMQ==", "bodyText": "Shouldn't this be moved a few lines below and use the payload.sizeInBytes()?", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464376111", "createdAt": "2020-08-03T12:17:47Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/PayloadDispatcher.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class PayloadDispatcher implements ByteBufferConsumer {\n+\n+  static final int DEFAULT_BUFFER_SIZE = 2 << 20; // 2MB\n+\n+  private final DDAgentApi api;\n+  private int representativeCount;\n+  private TraceMapper traceMapper;\n+  private Packer packer;\n+  private final Monitor monitor;\n+\n+  PayloadDispatcher(DDAgentApi api, Monitor monitor) {\n+    this.api = api;\n+    this.monitor = monitor;\n+  }\n+\n+  void flush() {\n+    if (null != packer) {\n+      packer.flush();\n+    }\n+  }\n+\n+  void addTrace(List<? extends DDSpanData> trace) {\n+    selectTraceMapper();\n+    // the call below is blocking and will trigger IO if a flush is necessary\n+    // there are alternative approaches to avoid blocking here, such as\n+    // introducing an unbound queue and another thread to do the IO\n+    // however, we can't block the application threads from here.\n+    if (null != traceMapper) {\n+      packer.format(trace, traceMapper);\n+    } else { // if the mapper is null, then there's no agent running, so we should drop\n+      log.debug(\"dropping {} traces because no agent was detected\", 1);\n+    }\n+    ++representativeCount;\n+  }\n+\n+  private void selectTraceMapper() {\n+    if (null == traceMapper) {\n+      this.traceMapper = api.selectTraceMapper();\n+      if (null == packer) {\n+        this.packer = new Packer(this, ByteBuffer.allocate(DEFAULT_BUFFER_SIZE));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void accept(int messageCount, ByteBuffer buffer) {\n+    // the packer calls this when the buffer is full,\n+    // or when the packer is flushed at a heartbeat\n+    if (messageCount > 0) {\n+      final int sizeInBytes = buffer.limit() - buffer.position();\n+      monitor.onSerialize(sizeInBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NzM0NQ==", "bodyText": "Perhaps move out the magic 20 to a constant since its use is now split over multiple files?", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464377345", "createdAt": "2020-08-03T12:20:27Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+public class Util {\n+\n+  private static final byte[] DIGIT_TENS = {\n+    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n+    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n+    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n+    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n+    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n+    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n+    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n+    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n+    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n+    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n+  };\n+\n+  private static final byte[] DIGIT_ONES = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+  };\n+\n+  public static void writeLongAsString(\n+      final long value, final Writable destination, byte[] numberByteArray) {\n+    int pos = 20; // start from the end", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92c1fa4a45ffda761b3a962ecf7f3733f754a4ec", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/92c1fa4a45ffda761b3a962ecf7f3733f754a4ec", "committedDate": "2020-08-04T08:42:39Z", "message": "add trace format discovery mechanism"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25fe8c64d2d638f0e85b51dcc8bff584077b0b50", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/25fe8c64d2d638f0e85b51dcc8bff584077b0b50", "committedDate": "2020-08-04T08:42:39Z", "message": "remove unused DDAgentWriter from Monitor methods which avoids unsafe publication of"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15145476906c9b4ea26a15edda4e6d0298bd7a33", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/15145476906c9b4ea26a15edda4e6d0298bd7a33", "committedDate": "2020-08-04T08:43:08Z", "message": "dictionary encode trace messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "073061368a828e5d1171f81211f48bee4ebd42d7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/073061368a828e5d1171f81211f48bee4ebd42d7", "committedDate": "2020-08-04T08:43:11Z", "message": "port baggage overlap to v0.5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76784e2406dc7577cdfbda7f89be588cbb87be00", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/76784e2406dc7577cdfbda7f89be588cbb87be00", "committedDate": "2020-08-04T08:43:11Z", "message": "ensure dictionary encoded values are never null"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d78961ae741e64a53339251a449be3251f3057db", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d78961ae741e64a53339251a449be3251f3057db", "committedDate": "2020-07-31T19:12:37Z", "message": "post rebase spotless"}, "afterCommit": {"oid": "c01b20672eae92275cb1f038d2b7800a30444d2f", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c01b20672eae92275cb1f038d2b7800a30444d2f", "committedDate": "2020-08-04T08:59:36Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848d02b258e5a1d2cfe38820d3ab58aa63a923f1", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/848d02b258e5a1d2cfe38820d3ab58aa63a923f1", "committedDate": "2020-08-04T09:11:10Z", "message": "introduce DDSpanData to make it possible to test trace processing without creating a tracer or pending trace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a3f467a43af02d427538b5f1a14efd267da3719", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0a3f467a43af02d427538b5f1a14efd267da3719", "committedDate": "2020-08-04T09:11:10Z", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b9ebeb37392d865e802771fc5833c7456e43656", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4b9ebeb37392d865e802771fc5833c7456e43656", "committedDate": "2020-08-04T09:11:10Z", "message": "post rebase spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abd86a5a5ce933a25a3b08f3b1cba37d02cfb8b7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/abd86a5a5ce933a25a3b08f3b1cba37d02cfb8b7", "committedDate": "2020-08-04T09:11:10Z", "message": "select different buffer sizes depending on format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea4d181f02f7f6fea6455ca83b9466ffc5a37d75", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ea4d181f02f7f6fea6455ca83b9466ffc5a37d75", "committedDate": "2020-08-04T09:11:10Z", "message": "review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c01b20672eae92275cb1f038d2b7800a30444d2f", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c01b20672eae92275cb1f038d2b7800a30444d2f", "committedDate": "2020-08-04T08:59:36Z", "message": "review comments"}, "afterCommit": {"oid": "8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "committedDate": "2020-08-04T09:12:11Z", "message": "revapi"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ea345cffe816446bad6ae091c262ba50d9cddd2", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9ea345cffe816446bad6ae091c262ba50d9cddd2", "committedDate": "2020-08-04T09:33:22Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "committedDate": "2020-08-04T09:12:11Z", "message": "revapi"}, "afterCommit": {"oid": "9ea345cffe816446bad6ae091c262ba50d9cddd2", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9ea345cffe816446bad6ae091c262ba50d9cddd2", "committedDate": "2020-08-04T09:33:22Z", "message": "revapi"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2256, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}