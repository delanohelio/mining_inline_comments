{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0NDExMjc1", "number": 2235, "title": "AgentTestRunner refactor and cleanup", "bodyText": "The previous iteration of AgentTestRunner had numerous issues which made #2213 impossible:\n\nAbuse of static fields made it hard to reason about and debug.  State was shared in unintuitive ways between tests\nThe CoreTracer instance was not only shared between tests in the same class but also between multiple test classes\nAbuse of @BeforeClass/@AfterClass on non-static methods made it difficult to follow or predict test execution\nThe bytebuddy listener (TEST_LISTENER) jumped through multiple hoops to connect static<->nonstatic instances\n\nThus, I made the following changes:\n\n\nConvert AgentTestRunner to a groovy class:\nThis allows the use of @Shared, setupSpec(), setup(), cleanup() and cleanupSpec().  All actions take place in clearly defined steps.\n\n\nRemoval of all static field state\nFor obvious reasons.\n\n\nAdd forceInstallGlobalTracer to TracerInstaller:\nPreviously, whichever test class accessed the static block first in AgentTestRunner set the tracer instance for all tests on the classloader.  Adding this method allows setting and resetting the tracer per test class.\n\n\nMake AgentTestRunner implement AgentBuilder.Listener directly:\nTEST_LISTENER was clunky.  Now, derived test classes that want to modify transformation behavior can do so with a simple override.\n\n\nRework of WithGlobalTracer:\nThe log context tests broke with the above changes because WithGlobalTracer made the previously correct assumption that a tracer is only installed once.  With this PR, a tracer is installed for each test class and the callbacks need to be called again. Given that installing a tracer is rare (once per JVM outside of tests) and adding a callback is rare (once per logging framework), I simplified the code by just using synchronized blocks where appropriate.\n\n\nThings I did not do:\n\n\nUpdate field names\nChanging TEST_WRITER to testWriter would muddy up the PR for little benefit\n\n\nCreate a new CoreTracer per test\nThis should work now but I'm leaving that for a followup PR.  Leaving the status quo of CoreTracer per test class\n\n\nThe end result is a much cleaner (and ~120 lines shorter) base test class", "createdAt": "2020-12-22T22:52:42Z", "url": "https://github.com/DataDog/dd-trace-java/pull/2235", "merged": true, "mergeCommit": {"oid": "befcb0e3a27dd647c4b29a9c6ac18380a4c442c3"}, "closed": true, "closedAt": "2020-12-29T17:09:32Z", "author": {"login": "randomanderson"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdoy1OsABqjQxNDIwNjY1MzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdq9IeLgFqTU1OTYwMjIzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54263974303a818b057292e24e9e664fa6990532", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/54263974303a818b057292e24e9e664fa6990532", "committedDate": "2020-12-22T22:48:59Z", "message": "Big refactor"}, "afterCommit": {"oid": "1b8b3992dc39ab80590b2ba55287897531ffeb62", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1b8b3992dc39ab80590b2ba55287897531ffeb62", "committedDate": "2020-12-22T23:07:27Z", "message": "Big refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d2091eea589bbe370cfa89d12d0ecb72b197abc", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3d2091eea589bbe370cfa89d12d0ecb72b197abc", "committedDate": "2020-12-23T21:27:09Z", "message": "Allow WithGlobalCallback to work across multiple tracer installations"}, "afterCommit": {"oid": "b21dfa1c69be637d7c1749028ccaf5375153a9d9", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b21dfa1c69be637d7c1749028ccaf5375153a9d9", "committedDate": "2020-12-23T22:46:26Z", "message": "Allow WithGlobalCallback to work across multiple tracer installations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b21dfa1c69be637d7c1749028ccaf5375153a9d9", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b21dfa1c69be637d7c1749028ccaf5375153a9d9", "committedDate": "2020-12-23T22:46:26Z", "message": "Allow WithGlobalCallback to work across multiple tracer installations"}, "afterCommit": {"oid": "0430aecd576a4a117c25216afd27ebfe2801eac9", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0430aecd576a4a117c25216afd27ebfe2801eac9", "committedDate": "2020-12-24T17:58:10Z", "message": "ignore class load errors from the http server being shutdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f6d7daab357e8cef30b57732cf2040027073f99", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5f6d7daab357e8cef30b57732cf2040027073f99", "committedDate": "2020-12-24T19:29:25Z", "message": "Add ability to override tracer registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6bf31d407f3f9e01e2d11bb3531f244b6cad555", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c6bf31d407f3f9e01e2d11bb3531f244b6cad555", "committedDate": "2020-12-24T19:29:25Z", "message": "Use TEST_TRACER directly instead of method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0430aecd576a4a117c25216afd27ebfe2801eac9", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0430aecd576a4a117c25216afd27ebfe2801eac9", "committedDate": "2020-12-24T17:58:10Z", "message": "ignore class load errors from the http server being shutdown"}, "afterCommit": {"oid": "b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "committedDate": "2020-12-24T19:29:25Z", "message": "ignore class load errors from the http server being shutdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3745cfabd2d19f30a2a0ef82f9fd4d2244bc66b5", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3745cfabd2d19f30a2a0ef82f9fd4d2244bc66b5", "committedDate": "2020-12-24T21:13:28Z", "message": "Big refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22900bc5c822b56830ff1e542af5001a67731707", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/22900bc5c822b56830ff1e542af5001a67731707", "committedDate": "2020-12-24T21:13:28Z", "message": "Fix scala tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be57e16ea2bf8abdc8e3a5e4f5542c0cb2611356", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/be57e16ea2bf8abdc8e3a5e4f5542c0cb2611356", "committedDate": "2020-12-24T21:13:28Z", "message": "Fix codenarc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7972a67c23a438ad2babd539096d469ecfae61f7", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7972a67c23a438ad2babd539096d469ecfae61f7", "committedDate": "2020-12-24T21:13:28Z", "message": "Allow WithGlobalCallback to work across multiple tracer installations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb383c1a19b09ab4826f3342199422d8cacd68b3", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fb383c1a19b09ab4826f3342199422d8cacd68b3", "committedDate": "2020-12-24T21:13:28Z", "message": "ignore class load errors from the http server being shutdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/28a4be28deac23da5b3dfc32ddb85e83934e2e86", "committedDate": "2020-12-24T21:13:28Z", "message": "Ignore coverage because of Groovy bug"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "committedDate": "2020-12-24T19:29:25Z", "message": "ignore class load errors from the http server being shutdown"}, "afterCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/28a4be28deac23da5b3dfc32ddb85e83934e2e86", "committedDate": "2020-12-24T21:13:28Z", "message": "Ignore coverage because of Groovy bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjEwMjgy", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#pullrequestreview-559210282", "createdAt": "2020-12-28T16:19:15Z", "commit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjoxOToxNVrOIL895w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNjo0Mjo1OFrOIL9aQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwNDEzNQ==", "bodyText": "Consider adding a warning level log message when this is used so it can be identified if somehow invoked in non-test env's.  (This could also be done in the forceRegister methods instead.)", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549404135", "createdAt": "2020-12-28T16:19:15Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/TracerInstaller.java", "diffHunk": "@@ -25,9 +25,21 @@ public static void installGlobalTracer(final CoreTracer tracer) {\n     try {\n       GlobalTracer.registerIfAbsent(tracer);\n       AgentTracer.registerIfAbsent(tracer);\n+\n+      log.debug(\"Global tracer installed\");\n+    } catch (final RuntimeException re) {\n+      log.warn(\"Failed to register tracer: {}\", tracer, re);\n+    }\n+  }\n+\n+  public static void forceInstallGlobalTracer(CoreTracer tracer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwNzgxNQ==", "bodyText": "Do we need a way for tests to remove callbacks after test completion?", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549407815", "createdAt": "2020-12-28T16:31:21Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -31,50 +32,52 @@ public boolean addTraceInterceptor(TraceInterceptor traceInterceptor) {\n         @Override\n         public void addScopeListener(ScopeListener listener) {}\n       };\n-  private static final AtomicReference<Tracer> provider = new AtomicReference<>(NO_OP);\n+\n+  private static final Collection<Callback> installationCallbacks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwODgzOQ==", "bodyText": "I'm not sure I understand this change... please elaborate.", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549408839", "createdAt": "2020-12-28T16:34:45Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/test/groovy/context/FieldBackedProviderTest.groovy", "diffHunk": "@@ -32,21 +33,14 @@ import static datadog.trace.bootstrap.config.provider.SystemPropertiesConfigSour\n import static org.junit.Assume.assumeTrue\n \n class FieldBackedProviderTest extends AgentTestRunner {\n-\n   @Override\n-  boolean onInstrumentationError(\n-    final String typeName,\n-    final ClassLoader classLoader,\n-    final JavaModule module,\n-    final boolean loaded,\n-    final Throwable throwable) {\n-    // Incorrect* classes assert on incorrect api usage. Error expected.\n-    return !(typeName.startsWith(ContextTestInstrumentation.getName() + '$Incorrect') && throwable.getMessage().startsWith(\"Incorrect Context Api Usage detected.\"))\n-  }\n+  void onDiscovery(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {\n+    if (typeName?.endsWith(\"UntransformableKeyClass\")) {\n+      throw new AbortTransformationException(\n+        \"Aborting transform for class name = \" + typeName + \", loader = \" + classLoader)\n+    }\n \n-  @Override\n-  protected boolean shouldTransformClass(final String className, final ClassLoader classLoader) {\n-    return className == null || (!className.endsWith(\"UntransformableKeyClass\"))\n+    super.onDiscovery(typeName, classLoader, module, loaded)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwOTQ1OA==", "bodyText": "Why is it necessary? I would expect the .class to be implicit now that this is groovy.", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549409458", "createdAt": "2020-12-28T16:36:35Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDY0OQ==", "bodyText": "Seems odd to call this again in setup() after the agent is initialized.", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549410649", "createdAt": "2020-12-28T16:40:24Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDk2MA==", "bodyText": "Why call this again here?", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549410960", "createdAt": "2020-12-28T16:41:27Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()\n+\n+    println \"Starting test: ${getSpecificationContext().getCurrentIteration().getName()}\"\n+\n+    TEST_TRACER.flush()\n+    TEST_WRITER.start()\n+\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  void cleanup() {\n+    TEST_TRACER.flush()\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMTM5NQ==", "bodyText": "Should the GlobalTracer be reset with a no-op instance before/after this is closed?", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549411395", "createdAt": "2020-12-28T16:42:58Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()\n+\n+    println \"Starting test: ${getSpecificationContext().getCurrentIteration().getName()}\"\n+\n+    TEST_TRACER.flush()\n+    TEST_WRITER.start()\n+\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  void cleanup() {\n+    TEST_TRACER.flush()\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  /** Override to clean up things after the agent is removed */\n+  protected void cleanupAfterAgent() {}\n+\n+  def cleanupSpec() {\n+    TEST_TRACER?.close()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86"}, "originalPosition": 164}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b", "author": {"user": {"login": "randomanderson", "name": "Laplie Anderson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0607b0a76b7d5008643b6bd9c7af8f503b40031b", "committedDate": "2020-12-28T18:52:12Z", "message": "PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzAwOTQ4", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#pullrequestreview-559300948", "createdAt": "2020-12-28T21:01:16Z", "commit": {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NTk5NjU5", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#pullrequestreview-559599659", "createdAt": "2020-12-29T16:09:28Z", "commit": {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5NjAyMjMw", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#pullrequestreview-559602230", "createdAt": "2020-12-29T16:15:31Z", "commit": {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoxNTozMVrOIMS3Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxNjoxNTozMVrOIMS3Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2Mjg3OQ==", "bodyText": "This is not suppose to be public api, right? Maybe comment", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549762879", "createdAt": "2020-12-29T16:15:31Z", "author": {"login": "lpriima"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -31,50 +32,52 @@ public boolean addTraceInterceptor(TraceInterceptor traceInterceptor) {\n         @Override\n         public void addScopeListener(ScopeListener listener) {}\n       };\n-  private static final AtomicReference<Tracer> provider = new AtomicReference<>(NO_OP);\n+\n+  private static final Collection<Callback> installationCallbacks = new ArrayList<>();\n+  private static Tracer provider = NO_OP;\n \n   public static void registerIfAbsent(Tracer p) {\n-    if (p != null && p != NO_OP) {\n-      boolean installed = provider.compareAndSet(NO_OP, p);\n-      if (installed) {\n-        Callback callback = installationCallback.getAndSet(null);\n-        if (callback != null) {\n+    if (p == null || p == NO_OP) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    synchronized (installationCallbacks) {\n+      if (provider == NO_OP) {\n+        provider = p;\n+        for (Callback callback : installationCallbacks) {\n           callback.installed(p);\n         }\n       }\n     }\n   }\n \n+  public static void forceRegister(Tracer tracer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2801, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}