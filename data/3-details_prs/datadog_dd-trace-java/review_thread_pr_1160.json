{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4ODQ4MzUw", "number": 1160, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxNToxM1rODVrk0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMDo0MDoxN1rODVv0yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDYwNjI1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxNToxM1rOFaCQ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxNToxM1rOFaCQ2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NDM3Ng==", "bodyText": "Long term, I'd like to get away from the use of Singletons like Config -- but for now, I think this is fine.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362844376", "createdAt": "2020-01-03T15:15:13Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDYxMTA2OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxNzoyM1rOFaCT6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxNzoyM1rOFaCT6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NTE2MQ==", "bodyText": "Why not call Thread.getStackTraceElement[] instead?\nIdeally, we also use the frame walking API on newer versions of Java, but that can wait until later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362845161", "createdAt": "2020-01-03T15:17:23Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDYxMzg1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxODoyNVrOFaCVkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToxODoyNVrOFaCVkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NTU4NQ==", "bodyText": "I'd like to see a health metric for anomalous situations as well.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362845585", "createdAt": "2020-01-03T15:18:25Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDYxNzYzOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToyMDowM1rOFaCX4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToyMDowM1rOFaCX4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NjE3OQ==", "bodyText": "This feels like an optional behavior that might be better handled through a Listener mechanism.\nHowever, I'm fine with deferring that to a later PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362846179", "createdAt": "2020-01-03T15:20:03Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDYyMjg0OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxNToyMjoxOFrOFaCbJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QyMzoxNjo0OFrOFfHmJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw==", "bodyText": "I think requesting and traversing the StackTraceElement[] would be easier to follow that filtering Writer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362847013", "createdAt": "2020-01-03T15:22:18Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();\n+      final Writer stackString = new FilteredStringWriter();\n+      stacktrace.printStackTrace(new PrintWriter(stackString));\n+      setTag(\"slow.stack\", stackString.toString());\n+    }\n+  }\n+\n+  // Writer that skips the first line and lines until FILTER doesn't match.\n+  private static final class FilteredStringWriter extends Writer {\n+    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n+\n+    private final StringWriter writer = new StringWriter();\n+\n+    private State state = State.SKIP_LINE; // Skip the exception type and message\n+    private StringBuilder buffer = new StringBuilder();\n+    private int lineIndex = 0;\n+\n+    @Override\n+    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+      if ((off < 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1MzQ0NQ==", "bodyText": "I agree. It would be also useful to make the filter configurable. There is often a lot of framework code that can be ignored. I'd even consider including only frames from my code. It worked great in mjprof", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362953445", "createdAt": "2020-01-03T20:37:57Z", "author": {"login": "jkubrynski"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();\n+      final Writer stackString = new FilteredStringWriter();\n+      stacktrace.printStackTrace(new PrintWriter(stackString));\n+      setTag(\"slow.stack\", stackString.toString());\n+    }\n+  }\n+\n+  // Writer that skips the first line and lines until FILTER doesn't match.\n+  private static final class FilteredStringWriter extends Writer {\n+    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n+\n+    private final StringWriter writer = new StringWriter();\n+\n+    private State state = State.SKIP_LINE; // Skip the exception type and message\n+    private StringBuilder buffer = new StringBuilder();\n+    private int lineIndex = 0;\n+\n+    @Override\n+    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+      if ((off < 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw=="}, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3NDYzMA==", "bodyText": "For simplicity, I'm not going to make it configurable in this PR... we can evaluate that later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r368174630", "createdAt": "2020-01-17T23:16:48Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDSpan.java", "diffHunk": "@@ -86,12 +89,112 @@ private void finishAndAddToTrace(final long durationNano) {\n     // ensure a min duration of 1\n     if (this.durationNano.compareAndSet(0, Math.max(1, durationNano))) {\n       log.debug(\"Finished: {}\", this);\n+      addStacktraceIfThresholdExceeded();\n       context.getTrace().addSpan(this);\n     } else {\n       log.debug(\"{} - already finished!\", this);\n     }\n   }\n \n+  private void addStacktraceIfThresholdExceeded() {\n+    final long spanDurationStacktraceNanos = Config.get().getSpanDurationStacktraceNanos();\n+    if (!isError()\n+        && spanDurationStacktraceNanos > 0\n+        && durationNano.get() > spanDurationStacktraceNanos\n+        // If this span was finished async, then the stacktrace will be less meaningful.\n+        && context.threadId == Thread.currentThread().getId()) {\n+      final Exception stacktrace = new Exception();\n+      final Writer stackString = new FilteredStringWriter();\n+      stacktrace.printStackTrace(new PrintWriter(stackString));\n+      setTag(\"slow.stack\", stackString.toString());\n+    }\n+  }\n+\n+  // Writer that skips the first line and lines until FILTER doesn't match.\n+  private static final class FilteredStringWriter extends Writer {\n+    private static final char[] FILTER = \"\\tat datadog.opentracing.\".toCharArray();\n+\n+    private final StringWriter writer = new StringWriter();\n+\n+    private State state = State.SKIP_LINE; // Skip the exception type and message\n+    private StringBuilder buffer = new StringBuilder();\n+    private int lineIndex = 0;\n+\n+    @Override\n+    public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+      if ((off < 0)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjg0NzAxMw=="}, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MTMwMjUxOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QyMDo0MDoxOFrOFaI9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQxNjoxMzozMlrOFah7QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1NDAyOA==", "bodyText": "Depending on a use-case of course, but for regular web applications 1 second is a strict setting, and many users can be flooded.", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r362954028", "createdAt": "2020-01-03T20:40:18Z", "author": {"login": "jkubrynski"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -129,6 +132,8 @@\n   private static final boolean DEFAULT_DB_CLIENT_HOST_SPLIT_BY_INSTANCE = false;\n   private static final String DEFAULT_SPLIT_BY_TAGS = \"\";\n   private static final int DEFAULT_PARTIAL_FLUSH_MIN_SPANS = 1000;\n+  private static final int DEFAULT_SPAN_DURATION_STACKTRACE_MILLIS =\n+      (int) TimeUnit.SECONDS.toMillis(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM2MzEzNw==", "bodyText": "I was trying to find a balance between a config default that is useful, but not burdensome...  My thought is that a stacktrace is expensive, but if a span is more than a second, then the cost of a stacktrace is likely not noticeable compared to the rest of the trace.  Do you have any suggestions for a different config default?", "url": "https://github.com/DataDog/dd-trace-java/pull/1160#discussion_r363363137", "createdAt": "2020-01-06T16:13:32Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -129,6 +132,8 @@\n   private static final boolean DEFAULT_DB_CLIENT_HOST_SPLIT_BY_INSTANCE = false;\n   private static final String DEFAULT_SPLIT_BY_TAGS = \"\";\n   private static final int DEFAULT_PARTIAL_FLUSH_MIN_SPANS = 1000;\n+  private static final int DEFAULT_SPAN_DURATION_STACKTRACE_MILLIS =\n+      (int) TimeUnit.SECONDS.toMillis(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjk1NDAyOA=="}, "originalCommit": {"oid": "ca4c27253d72584e06dbff28aeaf4e8c6324866c"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 466, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}