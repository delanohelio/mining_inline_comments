{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3Nzc1MzE2", "number": 1948, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozNTo0M1rOEqaqKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoxNzoxNlrOEq18zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTEyNDI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozNTo0M1rOHcnF2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo1NDo0NVrOHelWcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjY1MA==", "bodyText": "I don't recall for sure, but I think ByteBuddy might not call this when there's an exception and you don't have an onThrowable declaration.", "url": "https://github.com/DataDog/dd-trace-java/pull/1948#discussion_r499762650", "createdAt": "2020-10-05T17:35:43Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "diffHunk": "@@ -37,90 +29,69 @@\n @AutoService(Instrumenter.class)\n public final class AkkaForkJoinTaskInstrumentation extends Instrumenter.Default {\n \n-  static final String TASK_CLASS_NAME = \"akka.dispatch.forkjoin.ForkJoinTask\";\n-\n-  static final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER = hasClassesNamed(TASK_CLASS_NAME);\n-\n   public AkkaForkJoinTaskInstrumentation() {\n     super(\"java_concurrent\", \"akka_concurrent\");\n   }\n \n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return CLASS_LOADER_MATCHER;\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return extendsClass(named(TASK_CLASS_NAME));\n-  }\n-\n   @Override\n   public Map<String, String> contextStore() {\n-    return singletonMap(TASK_CLASS_NAME, State.class.getName());\n+    return singletonMap(\"akka.dispatch.forkjoin.ForkJoinTask\", State.class.getName());\n   }\n \n   @Override\n-  public Map<String, String> contextStoreForAll() {\n-    final Map<String, String> map = new HashMap<>();\n-    map.put(Runnable.class.getName(), State.class.getName());\n-    map.put(Callable.class.getName(), State.class.getName());\n-    return Collections.unmodifiableMap(map);\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.forkjoin.ForkJoinTask\");\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        named(\"exec\").and(takesArguments(0)).and(not(isAbstract())),\n-        AkkaForkJoinTaskInstrumentation.class.getName() + \"$ForkJoinTaskAdvice\");\n+    Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>(4);\n+    transformers.put(isMethod().and(named(\"doExec\")), getClass().getName() + \"$DoExec\");\n+    transformers.put(isMethod().and(named(\"fork\")), getClass().getName() + \"$Fork\");\n+    transformers.put(isMethod().and(named(\"cancel\")), getClass().getName() + \"$Cancel\");\n+    return transformers;\n   }\n \n-  public static class ForkJoinTaskAdvice {\n-\n-    /**\n-     * When {@link ForkJoinTask} object is submitted to {@link ForkJoinPool} as {@link Runnable} or\n-     * {@link Callable} it will not get wrapped, instead it will be casted to {@code ForkJoinTask}\n-     * directly. This means state is still stored in {@code Runnable} or {@code Callable} and we\n-     * need to use that state.\n-     */\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static TraceScope enter(@Advice.This final ForkJoinTask thiz) {\n-      final ContextStore<ForkJoinTask, State> contextStore =\n-          InstrumentationContext.get(ForkJoinTask.class, State.class);\n-      TraceScope scope = AdviceUtils.startTaskScope(contextStore, thiz);\n-      if (thiz instanceof Runnable) {\n-        final ContextStore<Runnable, State> runnableContextStore =\n-            InstrumentationContext.get(Runnable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(runnableContextStore, (Runnable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n+  public static final class DoExec {\n+    @Advice.OnMethodEnter\n+    public static <T> TraceScope before(@Advice.This ForkJoinTask<T> task) {\n+      State state = InstrumentationContext.get(ForkJoinTask.class, State.class).get(task);\n+      if (null != state) {\n+        TraceScope.Continuation continuation = state.getAndResetContinuation();\n+        if (null != continuation) {\n+          return continuation.activate();\n         }\n       }\n-      if (thiz instanceof Callable) {\n-        final ContextStore<Callable, State> callableContextStore =\n-            InstrumentationContext.get(Callable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(callableContextStore, (Callable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n-        }\n+      return null;\n+    }\n+\n+    @Advice.OnMethodExit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7402cb0e3d94b359edf994061eaaea9fca0844b8"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NDE5MQ==", "bodyText": "Good to know, thanks", "url": "https://github.com/DataDog/dd-trace-java/pull/1948#discussion_r499774191", "createdAt": "2020-10-05T17:57:20Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "diffHunk": "@@ -37,90 +29,69 @@\n @AutoService(Instrumenter.class)\n public final class AkkaForkJoinTaskInstrumentation extends Instrumenter.Default {\n \n-  static final String TASK_CLASS_NAME = \"akka.dispatch.forkjoin.ForkJoinTask\";\n-\n-  static final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER = hasClassesNamed(TASK_CLASS_NAME);\n-\n   public AkkaForkJoinTaskInstrumentation() {\n     super(\"java_concurrent\", \"akka_concurrent\");\n   }\n \n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return CLASS_LOADER_MATCHER;\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return extendsClass(named(TASK_CLASS_NAME));\n-  }\n-\n   @Override\n   public Map<String, String> contextStore() {\n-    return singletonMap(TASK_CLASS_NAME, State.class.getName());\n+    return singletonMap(\"akka.dispatch.forkjoin.ForkJoinTask\", State.class.getName());\n   }\n \n   @Override\n-  public Map<String, String> contextStoreForAll() {\n-    final Map<String, String> map = new HashMap<>();\n-    map.put(Runnable.class.getName(), State.class.getName());\n-    map.put(Callable.class.getName(), State.class.getName());\n-    return Collections.unmodifiableMap(map);\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.forkjoin.ForkJoinTask\");\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        named(\"exec\").and(takesArguments(0)).and(not(isAbstract())),\n-        AkkaForkJoinTaskInstrumentation.class.getName() + \"$ForkJoinTaskAdvice\");\n+    Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>(4);\n+    transformers.put(isMethod().and(named(\"doExec\")), getClass().getName() + \"$DoExec\");\n+    transformers.put(isMethod().and(named(\"fork\")), getClass().getName() + \"$Fork\");\n+    transformers.put(isMethod().and(named(\"cancel\")), getClass().getName() + \"$Cancel\");\n+    return transformers;\n   }\n \n-  public static class ForkJoinTaskAdvice {\n-\n-    /**\n-     * When {@link ForkJoinTask} object is submitted to {@link ForkJoinPool} as {@link Runnable} or\n-     * {@link Callable} it will not get wrapped, instead it will be casted to {@code ForkJoinTask}\n-     * directly. This means state is still stored in {@code Runnable} or {@code Callable} and we\n-     * need to use that state.\n-     */\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static TraceScope enter(@Advice.This final ForkJoinTask thiz) {\n-      final ContextStore<ForkJoinTask, State> contextStore =\n-          InstrumentationContext.get(ForkJoinTask.class, State.class);\n-      TraceScope scope = AdviceUtils.startTaskScope(contextStore, thiz);\n-      if (thiz instanceof Runnable) {\n-        final ContextStore<Runnable, State> runnableContextStore =\n-            InstrumentationContext.get(Runnable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(runnableContextStore, (Runnable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n+  public static final class DoExec {\n+    @Advice.OnMethodEnter\n+    public static <T> TraceScope before(@Advice.This ForkJoinTask<T> task) {\n+      State state = InstrumentationContext.get(ForkJoinTask.class, State.class).get(task);\n+      if (null != state) {\n+        TraceScope.Continuation continuation = state.getAndResetContinuation();\n+        if (null != continuation) {\n+          return continuation.activate();\n         }\n       }\n-      if (thiz instanceof Callable) {\n-        final ContextStore<Callable, State> callableContextStore =\n-            InstrumentationContext.get(Callable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(callableContextStore, (Callable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n-        }\n+      return null;\n+    }\n+\n+    @Advice.OnMethodExit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjY1MA=="}, "originalCommit": {"oid": "7402cb0e3d94b359edf994061eaaea9fca0844b8"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2MzIxMQ==", "bodyText": "Interesting.  Do we need to add some static analysis to flag such cases?", "url": "https://github.com/DataDog/dd-trace-java/pull/1948#discussion_r500463211", "createdAt": "2020-10-06T17:12:56Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "diffHunk": "@@ -37,90 +29,69 @@\n @AutoService(Instrumenter.class)\n public final class AkkaForkJoinTaskInstrumentation extends Instrumenter.Default {\n \n-  static final String TASK_CLASS_NAME = \"akka.dispatch.forkjoin.ForkJoinTask\";\n-\n-  static final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER = hasClassesNamed(TASK_CLASS_NAME);\n-\n   public AkkaForkJoinTaskInstrumentation() {\n     super(\"java_concurrent\", \"akka_concurrent\");\n   }\n \n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return CLASS_LOADER_MATCHER;\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return extendsClass(named(TASK_CLASS_NAME));\n-  }\n-\n   @Override\n   public Map<String, String> contextStore() {\n-    return singletonMap(TASK_CLASS_NAME, State.class.getName());\n+    return singletonMap(\"akka.dispatch.forkjoin.ForkJoinTask\", State.class.getName());\n   }\n \n   @Override\n-  public Map<String, String> contextStoreForAll() {\n-    final Map<String, String> map = new HashMap<>();\n-    map.put(Runnable.class.getName(), State.class.getName());\n-    map.put(Callable.class.getName(), State.class.getName());\n-    return Collections.unmodifiableMap(map);\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.forkjoin.ForkJoinTask\");\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        named(\"exec\").and(takesArguments(0)).and(not(isAbstract())),\n-        AkkaForkJoinTaskInstrumentation.class.getName() + \"$ForkJoinTaskAdvice\");\n+    Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>(4);\n+    transformers.put(isMethod().and(named(\"doExec\")), getClass().getName() + \"$DoExec\");\n+    transformers.put(isMethod().and(named(\"fork\")), getClass().getName() + \"$Fork\");\n+    transformers.put(isMethod().and(named(\"cancel\")), getClass().getName() + \"$Cancel\");\n+    return transformers;\n   }\n \n-  public static class ForkJoinTaskAdvice {\n-\n-    /**\n-     * When {@link ForkJoinTask} object is submitted to {@link ForkJoinPool} as {@link Runnable} or\n-     * {@link Callable} it will not get wrapped, instead it will be casted to {@code ForkJoinTask}\n-     * directly. This means state is still stored in {@code Runnable} or {@code Callable} and we\n-     * need to use that state.\n-     */\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static TraceScope enter(@Advice.This final ForkJoinTask thiz) {\n-      final ContextStore<ForkJoinTask, State> contextStore =\n-          InstrumentationContext.get(ForkJoinTask.class, State.class);\n-      TraceScope scope = AdviceUtils.startTaskScope(contextStore, thiz);\n-      if (thiz instanceof Runnable) {\n-        final ContextStore<Runnable, State> runnableContextStore =\n-            InstrumentationContext.get(Runnable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(runnableContextStore, (Runnable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n+  public static final class DoExec {\n+    @Advice.OnMethodEnter\n+    public static <T> TraceScope before(@Advice.This ForkJoinTask<T> task) {\n+      State state = InstrumentationContext.get(ForkJoinTask.class, State.class).get(task);\n+      if (null != state) {\n+        TraceScope.Continuation continuation = state.getAndResetContinuation();\n+        if (null != continuation) {\n+          return continuation.activate();\n         }\n       }\n-      if (thiz instanceof Callable) {\n-        final ContextStore<Callable, State> callableContextStore =\n-            InstrumentationContext.get(Callable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(callableContextStore, (Callable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n-        }\n+      return null;\n+    }\n+\n+    @Advice.OnMethodExit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjY1MA=="}, "originalCommit": {"oid": "7402cb0e3d94b359edf994061eaaea9fca0844b8"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzMTI4Mw==", "bodyText": "We should, because it's a scope leak waiting to happen", "url": "https://github.com/DataDog/dd-trace-java/pull/1948#discussion_r501831283", "createdAt": "2020-10-08T15:54:45Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "diffHunk": "@@ -37,90 +29,69 @@\n @AutoService(Instrumenter.class)\n public final class AkkaForkJoinTaskInstrumentation extends Instrumenter.Default {\n \n-  static final String TASK_CLASS_NAME = \"akka.dispatch.forkjoin.ForkJoinTask\";\n-\n-  static final ElementMatcher<ClassLoader> CLASS_LOADER_MATCHER = hasClassesNamed(TASK_CLASS_NAME);\n-\n   public AkkaForkJoinTaskInstrumentation() {\n     super(\"java_concurrent\", \"akka_concurrent\");\n   }\n \n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return CLASS_LOADER_MATCHER;\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return extendsClass(named(TASK_CLASS_NAME));\n-  }\n-\n   @Override\n   public Map<String, String> contextStore() {\n-    return singletonMap(TASK_CLASS_NAME, State.class.getName());\n+    return singletonMap(\"akka.dispatch.forkjoin.ForkJoinTask\", State.class.getName());\n   }\n \n   @Override\n-  public Map<String, String> contextStoreForAll() {\n-    final Map<String, String> map = new HashMap<>();\n-    map.put(Runnable.class.getName(), State.class.getName());\n-    map.put(Callable.class.getName(), State.class.getName());\n-    return Collections.unmodifiableMap(map);\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.forkjoin.ForkJoinTask\");\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        named(\"exec\").and(takesArguments(0)).and(not(isAbstract())),\n-        AkkaForkJoinTaskInstrumentation.class.getName() + \"$ForkJoinTaskAdvice\");\n+    Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>(4);\n+    transformers.put(isMethod().and(named(\"doExec\")), getClass().getName() + \"$DoExec\");\n+    transformers.put(isMethod().and(named(\"fork\")), getClass().getName() + \"$Fork\");\n+    transformers.put(isMethod().and(named(\"cancel\")), getClass().getName() + \"$Cancel\");\n+    return transformers;\n   }\n \n-  public static class ForkJoinTaskAdvice {\n-\n-    /**\n-     * When {@link ForkJoinTask} object is submitted to {@link ForkJoinPool} as {@link Runnable} or\n-     * {@link Callable} it will not get wrapped, instead it will be casted to {@code ForkJoinTask}\n-     * directly. This means state is still stored in {@code Runnable} or {@code Callable} and we\n-     * need to use that state.\n-     */\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static TraceScope enter(@Advice.This final ForkJoinTask thiz) {\n-      final ContextStore<ForkJoinTask, State> contextStore =\n-          InstrumentationContext.get(ForkJoinTask.class, State.class);\n-      TraceScope scope = AdviceUtils.startTaskScope(contextStore, thiz);\n-      if (thiz instanceof Runnable) {\n-        final ContextStore<Runnable, State> runnableContextStore =\n-            InstrumentationContext.get(Runnable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(runnableContextStore, (Runnable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n+  public static final class DoExec {\n+    @Advice.OnMethodEnter\n+    public static <T> TraceScope before(@Advice.This ForkJoinTask<T> task) {\n+      State state = InstrumentationContext.get(ForkJoinTask.class, State.class).get(task);\n+      if (null != state) {\n+        TraceScope.Continuation continuation = state.getAndResetContinuation();\n+        if (null != continuation) {\n+          return continuation.activate();\n         }\n       }\n-      if (thiz instanceof Callable) {\n-        final ContextStore<Callable, State> callableContextStore =\n-            InstrumentationContext.get(Callable.class, State.class);\n-        final TraceScope newScope =\n-            AdviceUtils.startTaskScope(callableContextStore, (Callable) thiz);\n-        if (null != newScope) {\n-          if (null != scope) {\n-            newScope.close();\n-          } else {\n-            scope = newScope;\n-          }\n-        }\n+      return null;\n+    }\n+\n+    @Advice.OnMethodExit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjY1MA=="}, "originalCommit": {"oid": "7402cb0e3d94b359edf994061eaaea9fca0844b8"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzU5NTY3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/test/java/LinearTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoxNzoxNlrOHdSBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoxNzoxNlrOHdSBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2NTk1Mg==", "bodyText": "Nice, I was going to ask how to test this.  Glad to see that we've already thought about it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1948#discussion_r500465952", "createdAt": "2020-10-06T17:17:16Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/test/java/LinearTask.java", "diffHunk": "@@ -0,0 +1,45 @@\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+\n+import akka.dispatch.forkjoin.RecursiveTask;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+\n+public class LinearTask extends RecursiveTask<Integer> {\n+  private final int depth;\n+  private final int parent;\n+\n+  public LinearTask(int depth) {\n+    this(0, depth);\n+  }\n+\n+  private LinearTask(int parent, int depth) {\n+    this.parent = parent;\n+    this.depth = depth;\n+  }\n+\n+  @Override\n+  protected Integer compute() {\n+    try {\n+      // introduces delay to encourage parallelism\n+      // which will expose problems with context propagation\n+      Thread.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43c504c36d2d27a86d931f11a50deed3ef62beba"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4883, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}