{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDM3NTE3", "number": 1297, "title": "Add exception sampling event", "bodyText": "In order to reduce the number of exception events which can become quite overwhelming a statistical sampling is employed to pick semi-random exceptions and generate events only for those. The sampling rate is adaptive and ensures that the number of events in an average recording will converge to a finite, not very large number.\nThis change also adds an exception type histogram where the total number of exception instance per type is kept for the duration of the JFR chunk (eg. 2 minutes window).\nTogether, these to events will make it easy to identify frequently thrown exception types and where they are being thrown.\nI am not being able to get all CI tests passing - however, muzzle and integration smoke tests seem to be fine. The rest is failing intermittently in completely unrelated test cases,", "createdAt": "2020-03-05T18:38:45Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1297", "merged": true, "mergeCommit": {"oid": "eb272bcc00cebdabc4a4382def2e666a4173dbf4"}, "closed": true, "closedAt": "2020-04-20T14:31:55Z", "author": {"login": "jbachorik"}, "timelineItems": {"totalCount": 204, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZeTDSgH2gAyMzg0NDM3NTE3OjMwZjI3ODc2OGViNGI5NDAzNjVkN2MwMWI5NTJkNGNhODljZTc4MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZfqg8gFqTM5NjQ4NzUxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "30f278768eb4b940365d7c01b952d4ca89ce7824", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/30f278768eb4b940365d7c01b952d4ca89ce7824", "committedDate": "2020-04-20T12:32:09Z", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44ed263bf67ef1cdfa666e0333b1905be79a4f4f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/44ed263bf67ef1cdfa666e0333b1905be79a4f4f", "committedDate": "2020-04-20T12:58:48Z", "message": "Make format check happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df2a2a6e39f66c7911675fc9afe6885b5c717a4e", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/df2a2a6e39f66c7911675fc9afe6885b5c717a4e", "committedDate": "2020-04-20T13:47:07Z", "message": "Can not check for JFR in 'defaultEnabled()'.\nJFR presence flag is set only later in the constructor, after 'defaultEnabled()' has already been called."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDg3NTE3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-396487517", "createdAt": "2020-04-20T14:07:41Z", "commit": {"oid": "df2a2a6e39f66c7911675fc9afe6885b5c717a4e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTQxMzU3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381941357", "createdAt": "2020-03-26T12:02:44Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowMjo0NFrOF8DpwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowMjo0NFrOF8DpwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODcyMQ==", "bodyText": "I do not think this is used.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398518721", "createdAt": "2020-03-26T12:02:44Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 249}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTQzMDc5", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381943079", "createdAt": "2020-03-26T12:05:21Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowNToyMlrOF8DvLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowNToyMlrOF8DvLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA==", "bodyText": "I think this can be removed: I do not think it provides any actual testing value.\nIn your tests you already control number of windows, so if window rolling is busted your sampling averages will be busted as well. This just seems to introduce unnecessary complexity to the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398520108", "createdAt": "2020-03-26T12:05:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 256}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a89c17e57c49c861f046007160809a324fb5b1cd", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a89c17e57c49c861f046007160809a324fb5b1cd", "committedDate": "2020-03-26T12:37:52Z", "message": "Update dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle\n\nCo-Authored-By: Nikolay Martynov <mar.kolya@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d76a589d75f6ca6a2c057cfbe1d50cb4b9d0c7bf", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d76a589d75f6ca6a2c057cfbe1d50cb4b9d0c7bf", "committedDate": "2020-03-26T13:14:18Z", "message": "Make sure sampler tests are run"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e5346fc729bb847e5cf1c704581328b3a368d44d", "committedDate": "2020-03-26T13:32:06Z", "message": "Merge pull request #1343 from DataDog/mar-kolya/sampler-fix-tests\n\nsampler fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDI0NjU4", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382024658", "createdAt": "2020-03-26T13:48:29Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo0ODoyOVrOF8HtfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo0ODoyOVrOF8HtfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NTIxMg==", "bodyText": "Thanks for all the comment - this code is much easier to understand this way!", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398585212", "createdAt": "2020-03-26T13:48:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDI2MTkw", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382026190", "createdAt": "2020-03-26T13:50:03Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo1MDowNFrOF8HynQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo1MDowNFrOF8HynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NjUyNQ==", "bodyText": "I think there is a bug here: you use threshold from the end of the window in the beginning of the next window.\nIn worst (best?) case scenario if all your guesses were correct then in the end of the window threshold will be zero - this is not what you want in the beginning.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398586525", "createdAt": "2020-03-26T13:50:04Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDM5MTE3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382039117", "createdAt": "2020-03-26T14:03:17Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowMzoxN1rOF8IbHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowMzoxN1rOF8IbHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5Njg5Mw==", "bodyText": "This is called in AtomicReference#updateAndGet and AtomicReference#updateAndGet may call supplier multiple times resulting in over-count. AtomicReference#updateAndGet wants supplier to be side-effect-free.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398596893", "createdAt": "2020-03-26T14:03:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDQwMTQ1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382040145", "createdAt": "2020-03-26T14:04:24Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNDoyNFrOF8IeRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNDoyNFrOF8IeRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5NzcwMQ==", "bodyText": "I guess this is a technicality, but I do not think object containing AtomicLong and modifying it can be called 'immutable' :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398597701", "createdAt": "2020-03-26T14:04:24Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDQxODc1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382041875", "createdAt": "2020-03-26T14:06:17Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNjoxN1rOF8IjfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNjoxN1rOF8IjfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5OTAzNw==", "bodyText": "I would suggest naming like eventsSeen and eventsSampled used throughout", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398599037", "createdAt": "2020-03-26T14:06:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDY3NzE2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382067716", "createdAt": "2020-03-26T14:32:01Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozMjowMVrOF8JxkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozMjowMVrOF8JxkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA==", "bodyText": "naming of all three variables here could really use some improvement - I'm not sure I can really follow intent here", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398619024", "createdAt": "2020-03-26T14:32:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDg1NzMy", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382085732", "createdAt": "2020-03-26T14:49:59Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0OTo1OVrOF8Kn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0OTo1OVrOF8Kn5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjkzMw==", "bodyText": "Message should provide an easy insight into what had failed - currently calculation in the message is very different from calculation in the test meaning that when things fail we do not see how far off we are", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398632933", "createdAt": "2020-03-26T14:49:59Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;\n+    Assertions.assertTrue(\n+        dev <= 0.2d * samplesPerWindow,\n+        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDk0Mjk1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-382094295", "createdAt": "2020-03-26T14:58:15Z", "commit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1ODoxNlrOF8LBmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1ODoxNlrOF8LBmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzOTUxNA==", "bodyText": "Using three different time units in same function seems... excessive... especially considering that this is a test.\nWould it make sense to use nanoseconds everywhere? Or maybe even Instant since we are aiming for java8 anyway?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398639514", "createdAt": "2020-03-26T14:58:16Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50a817811d66aadfa0201924a73d66ff514c2fca", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/50a817811d66aadfa0201924a73d66ff514c2fca", "committedDate": "2020-03-27T12:11:23Z", "message": "Clean up unused code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a580fc157aa71fe9ab6650fa0dcb562ed213470a", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a580fc157aa71fe9ab6650fa0dcb562ed213470a", "committedDate": "2020-03-27T12:11:42Z", "message": "Change compatibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6879c0fc1ab030a63bfed827980cb9d56711bbb3", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6879c0fc1ab030a63bfed827980cb9d56711bbb3", "committedDate": "2020-03-27T12:13:21Z", "message": "A complete change in the sampler implementation.\nUsing adaptive interval with random jitter to provide the required guarantees about the total number of samples per certain time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415ccd9599a377e671848a9bc548c52e8ff78db7", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/415ccd9599a377e671848a9bc548c52e8ff78db7", "committedDate": "2020-03-27T14:33:22Z", "message": "Use Duration instead of a combination of a number and TimeUnit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0371c85e886731376f0f135acd48d23e7021e6b2", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0371c85e886731376f0f135acd48d23e7021e6b2", "committedDate": "2020-03-27T14:53:20Z", "message": "Remove non-existent helper class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fafac3714934c1aae2da7600948436b735c909f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6fafac3714934c1aae2da7600948436b735c909f", "committedDate": "2020-03-27T16:05:21Z", "message": "Replace synchronized block with try-lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c6a0d77ec696a4cde1f274ff315f5bad159203a", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8c6a0d77ec696a4cde1f274ff315f5bad159203a", "committedDate": "2020-03-27T18:13:45Z", "message": "Make gradle happier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67e846f01f262299fa68a653d06d222e7f2bd258", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/67e846f01f262299fa68a653d06d222e7f2bd258", "committedDate": "2020-03-30T00:18:59Z", "message": "Some WIP on sampler\n\nJust ideas, not ready to use"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35cc75bfe0d0293dff66d5fb5cf62b56424cd222", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/35cc75bfe0d0293dff66d5fb5cf62b56424cd222", "committedDate": "2020-03-30T13:39:20Z", "message": "Improve uniform sampler\n\nAdd idea of 'budget' from previous windows to reduce amount of\nclamping.\nMake uniform samper 'default'."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04bc9d349e6ad2ddc71839596290e34b9510b4b6", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/04bc9d349e6ad2ddc71839596290e34b9510b4b6", "committedDate": "2020-03-30T17:24:13Z", "message": "Follow-up changes to exception profiling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5cad9715de5045bc4a40d7fe8aa4654b10e20f2", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b5cad9715de5045bc4a40d7fe8aa4654b10e20f2", "committedDate": "2020-03-31T13:58:58Z", "message": "Fix codenarc violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c7141b7c51d1a7626932706523a065320154c45", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0c7141b7c51d1a7626932706523a065320154c45", "committedDate": "2020-03-31T14:00:04Z", "message": "Add exponential timestamp provider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38dc8ca0462293f2f3f3622da692805b865e1b17", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/38dc8ca0462293f2f3f3622da692805b865e1b17", "committedDate": "2020-03-31T14:00:28Z", "message": "Simplify EMA calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5c6fed2903713620a6998d297039c7ae51cadfc", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e5c6fed2903713620a6998d297039c7ae51cadfc", "committedDate": "2020-04-01T14:24:50Z", "message": "Tune the budgeting to provide better error margins"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2547c8389a72a876a82f7649325a5908da37f935", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2547c8389a72a876a82f7649325a5908da37f935", "committedDate": "2020-04-01T17:46:10Z", "message": "Clean up the EMA for budget.\nRemove the cut-off test and leave it for later."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c4d3ce0c18f1878d146df867980bd926130488c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6c4d3ce0c18f1878d146df867980bd926130488c", "committedDate": "2020-04-02T11:41:29Z", "message": "Allow specifying target lookback for sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d326004bf642c19bb5539c31ce4c8d2fde709622", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d326004bf642c19bb5539c31ce4c8d2fde709622", "committedDate": "2020-04-03T13:29:19Z", "message": "Increase the number of retries for intermittent test failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ac450113ffc9c271047ae7fe578ab7e31ebb1d8", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7ac450113ffc9c271047ae7fe578ab7e31ebb1d8", "committedDate": "2020-04-07T18:54:20Z", "message": "Rework sampler implementation to use a separate window maintenance thread"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "375864eddd9eada9a34fe0bf2f1281cbf8337fab", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/375864eddd9eada9a34fe0bf2f1281cbf8337fab", "committedDate": "2020-04-08T09:04:09Z", "message": "Merge remote-tracking branch 'origin/master' into jb/PROF-581_exceptions_sampler\n\n# Conflicts:\n#\tdd-trace-api/src/main/java/datadog/trace/api/Config.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e51c1486c229f62ddf5b35a3ef05ce9f4963e57e", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e51c1486c229f62ddf5b35a3ef05ce9f4963e57e", "committedDate": "2020-04-08T09:09:27Z", "message": "Rename sampler limit config option.\nAlso remove other unused sampler options."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1befa547207ff63fe6b07c2c4163f3afd4f6ec0", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e1befa547207ff63fe6b07c2c4163f3afd4f6ec0", "committedDate": "2020-04-08T09:12:20Z", "message": "Use custom Pair class instead of Map.Entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8fd519e8d17b88aff942ffa0dec0f008a84aea0", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f8fd519e8d17b88aff942ffa0dec0f008a84aea0", "committedDate": "2020-04-08T09:13:09Z", "message": "Make ExceptionInstrumentation final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4500f989783a5fbabca54b3211880a0d2041711b", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4500f989783a5fbabca54b3211880a0d2041711b", "committedDate": "2020-04-08T09:13:32Z", "message": "Improve javadoc location"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90c7248ce860aa3ff21cd0c68ca611d5e1c2f689", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/90c7248ce860aa3ff21cd0c68ca611d5e1c2f689", "committedDate": "2020-04-08T09:36:43Z", "message": "Placate the formatting check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/38fdffaa8f7073dc8ad443c01db854786022a54f", "committedDate": "2020-04-08T10:07:09Z", "message": "Update instrumentation helper classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODkzMTkx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389893191", "createdAt": "2020-04-08T11:40:00Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MDowMVrOGCrQqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MDowMVrOGCrQqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg==", "bodyText": "would it make sense to load our event classes instead - to be 100% sure we can do that when exception is actually thrown?..", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405459112", "createdAt": "2020-04-08T11:40:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     */\n+\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODk1MjM4", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389895238", "createdAt": "2020-04-08T11:43:15Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzoxNVrOGCrW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzoxNVrOGCrW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDczMQ==", "bodyText": "Please make this a constant with javadoc into why this is the value it is", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460731", "createdAt": "2020-04-08T11:43:15Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODk1NDAz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389895403", "createdAt": "2020-04-08T11:43:31Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzozMVrOGCrXjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzozMVrOGCrXjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDg3Ng==", "bodyText": "you can make this a constant and remove this method", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460876", "createdAt": "2020-04-08T11:43:31Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);\n+    exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n+  }\n+\n+  private static Duration getSamplingWindowDuration() {\n+    return Duration.of(SAMPLING_WINDOW_DURATION_SEC, ChronoUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODk1OTE1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389895915", "createdAt": "2020-04-08T11:44:21Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0NDoyMVrOGCrZMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0NDoyMVrOGCrZMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MTI5Nw==", "bodyText": "One more magic number - please constantify and document", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405461297", "createdAt": "2020-04-08T11:44:21Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODk4OTI2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389898926", "createdAt": "2020-04-08T11:48:56Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0ODo1NlrOGCriwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0ODo1NlrOGCriwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Mzc0Ng==", "bodyText": "you could make addSample return boolean to make this less awkward", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405463746", "createdAt": "2020-04-08T11:48:56Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTAxMzA3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389901307", "createdAt": "2020-04-08T11:52:44Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1Mjo0NVrOGCrqdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1Mjo0NVrOGCrqdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTcxOQ==", "bodyText": "I'm not sure that you can extrapolate burst budget with EMA. The whole point of burst budget is to react to short bursts, the whole point of EMA is not to react to that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405465719", "createdAt": "2020-04-08T11:52:45Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);\n+\n+    /*\n+     * Atomically replace the Counts instance such that sample requests during window maintenance will be\n+     * using the newly created counts instead of the ones currently processed by the maintenance routine.\n+     */\n+\n+    Counts counts = countsRef.getAndSet(new Counts());\n+    final long totalCount = counts.testCounter.sum();\n+    final long sampledCount = counts.sampleCounter.get();\n+\n+    long sampleBudget = samplesPerWindow - sampledCount;\n+    avgBudget = Double.isNaN(avgBudget) ? sampleBudget : avgBudget + emaAlpha * (sampleBudget - avgBudget);\n+    targetSamples = samplesPerWindow + Math.round(Math.max(avgBudget, 0) * windowCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTAyNTYx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389902561", "createdAt": "2020-04-08T11:54:37Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDozN1rOGCru5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDozN1rOGCru5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Njg1NQ==", "bodyText": "These two are unused", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405466855", "createdAt": "2020-04-08T11:54:37Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW = 1;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTAyNzQ1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389902745", "createdAt": "2020-04-08T11:54:52Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDo1M1rOGCrvgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDo1M1rOGCrvgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzAwOQ==", "bodyText": "this should bre renamed to DEFAULT_PROFILING_EXCEPTION_SAMPLE_LIMIT", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467009", "createdAt": "2020-04-08T11:54:53Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTAzMTUz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389903153", "createdAt": "2020-04-08T11:55:32Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NTozMlrOGCrwyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NTozMlrOGCrwyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzMzNw==", "bodyText": "you could use statically imported name here for consistency", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467337", "createdAt": "2020-04-08T11:55:32Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/test/groovy/datadog/trace/api/ConfigTest.groovy", "diffHunk": "@@ -150,6 +155,9 @@ class ConfigTest extends DDSpecification {\n     config.profilingProxyPort == Config.DEFAULT_PROFILING_PROXY_PORT\n     config.profilingProxyUsername == null\n     config.profilingProxyPassword == null\n+    config.profilingExceptionSampleLimit == Config.DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTA3MTA4", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389907108", "createdAt": "2020-04-08T12:01:41Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjowMTo0MlrOGCr-DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjowMTo0MlrOGCr-DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3MDczMw==", "bodyText": "it seems to be these should be available in some library", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405470733", "createdAt": "2020-04-08T12:01:42Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return rnd.nextDouble() <= burstProbability ? maxEvents : minEvents;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    int[] totalParts = new int[windows];\n+    double[] sampledParts = new double[windows];\n+    double[] sampleIndexSkew = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalParts[w] = events;\n+      sampledParts[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = calculateMean(sampleIndices);\n+      sampleIndexSkew[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledPartMean = calculateMean(sampledParts);\n+    double sampledPartStdev = calculateStddev(sampledParts, sampledPartMean);\n+    double totalPartMean = calculateMean(totalParts);\n+\n+    double correctionFactor = Math.min(((totalPartMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkew) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkew.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkew.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledPartMean * expectedSamples,\n+        sampledPartStdev * expectedSamples,\n+        (sampledPartMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private double calculateStddev(double[] data, double average) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 305}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "202e86052bc76e344ac056dbca7a4b9033593306", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/202e86052bc76e344ac056dbca7a4b9033593306", "committedDate": "2020-04-08T12:04:49Z", "message": "Do not mess up bytecode level"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74e1ea5df9b3b14269b5cc9cdf4967e2ab0f3f0b", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/74e1ea5df9b3b14269b5cc9cdf4967e2ab0f3f0b", "committedDate": "2020-04-08T12:11:41Z", "message": "Clean up configs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTE2Mzk3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389916397", "createdAt": "2020-04-08T12:15:38Z", "commit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoxNTozOFrOGCscfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoxNTozOFrOGCscfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg==", "bodyText": "would you consider injecting executor instead to avoid making rollWindow visible and make sure that parameters to scheduleAtFixedRate are correct", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405478526", "createdAt": "2020-04-08T12:15:38Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4", "committedDate": "2020-04-08T12:21:47Z", "message": "Bring in few more suggested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5OTI4NTE1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-389928515", "createdAt": "2020-04-08T12:32:49Z", "commit": {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjozMjo0OVrOGCtCPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjozMjo0OVrOGCtCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4ODE5MA==", "bodyText": "It seems to me that 'expected' behaviour would be to assume there were no exceptions before sampler was created - i.e. we have 'max possible budget'.\nThis should allow you to remove this calculation. Also the added benefit we would be able to capture exception bursts right at start up", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405488190", "createdAt": "2020-04-08T12:32:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0063d26fb32ab524a68920374df7c40be52175c7", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0063d26fb32ab524a68920374df7c40be52175c7", "committedDate": "2020-04-08T12:40:07Z", "message": "Rename variables and use commons math to do mean and stdev"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "committedDate": "2020-04-08T17:17:49Z", "message": "Use forward-projecting budget calculations.\nKeep both EMA and ring buffer based calculations in place so we can run more experiments till we decide which one to use."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3295b5fbbc097189ea675a2d19dcc153b39661b", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b3295b5fbbc097189ea675a2d19dcc153b39661b", "committedDate": "2020-04-08T17:34:29Z", "message": "Increase the error margin"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMDU2Mjgw", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-391056280", "createdAt": "2020-04-09T19:04:01Z", "commit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTowNDowMVrOGDlpQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTowNDowMVrOGDlpQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg==", "bodyText": "Color me convinced! Please go ahead and remove array implementation.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406415682", "createdAt": "2020-04-09T19:04:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMDYxNjI1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-391061625", "createdAt": "2020-04-09T19:12:22Z", "commit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOToxMjoyMlrOGDl5YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOToxMjoyMlrOGDl5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ==", "bodyText": "To be honest - I do not think this makes @ParameterizedTest justified... What do you link about just having a private test function and multiple @Test for each element here?\nI think this would make things clearer and provide an opportunity for comments about why we do these tests because currently this seems somewhat unclear.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406419809", "createdAt": "2020-04-09T19:12:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    double[] totalEventsPerWindow = new double[windows];\n+    double[] sampledEventsPerWindow = new double[windows];\n+    double[] sampleIndexSkewPerWindow = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    double sampledEventsPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    double correctionFactor = Math.min(((totalEventsPerWindowMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledEventsPerWindowMean * expectedSamples,\n+        sampledEventsPerWindowStdev * expectedSamples,\n+        (sampledEventsPerWindowMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\n+        \"\\t percentual error = {}%\", Math.signum(samples - targetSamples) * percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static double[] toDoubleArray(List<? extends Number> data) {\n+    double[] rslt = new double[data.size()];\n+    int index = 0;\n+    for (Number n : data) {\n+      rslt[index++] = n.doubleValue();\n+    }\n+    return rslt;\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static Stream<Arguments> samplerParams() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 325}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "097fa858f81d4b52a5199722219b12a538b49fc8", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/097fa858f81d4b52a5199722219b12a538b49fc8", "committedDate": "2020-04-13T11:26:31Z", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler"}, "afterCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2a3bb7e322e9e4a0319f21af27575abe62ac99ad", "committedDate": "2020-04-08T17:17:49Z", "message": "Use forward-projecting budget calculations.\nKeep both EMA and ring buffer based calculations in place so we can run more experiments till we decide which one to use."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/744f668b3454f77ad85b215ac1387e40308f02fe", "committedDate": "2020-04-13T12:39:26Z", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed25c98ab37c4c176f81483986fac45756cebce3", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ed25c98ab37c4c176f81483986fac45756cebce3", "committedDate": "2020-04-13T13:59:16Z", "message": "Simplify code a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fd1fa9d82de06b4a7add2ddf8defb7ed424a845", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3fd1fa9d82de06b4a7add2ddf8defb7ed424a845", "committedDate": "2020-04-13T13:59:27Z", "message": "Make gradle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b39b37db7e3d27de23f725c7751e06c7b5089273", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b39b37db7e3d27de23f725c7751e06c7b5089273", "committedDate": "2020-04-13T14:06:56Z", "message": "Load our event classe to make sure they are loading fine\n\nTo avoid accidentally breaking customer code by instrumentation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "873ca2209ec1f3352a95562890c7bcf976bb78c9", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/873ca2209ec1f3352a95562890c7bcf976bb78c9", "committedDate": "2020-04-13T14:50:27Z", "message": "Revert change to load our exception event class\n\nWe cannot do this because it is not visible on apps classloader after\ninstrumentation has been applied."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "556e96e1e5c649d2a854e89eb84e951de4750eae", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/556e96e1e5c649d2a854e89eb84e951de4750eae", "committedDate": "2020-04-13T14:50:34Z", "message": "Add exception cause information to exception event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc689f037c7644db5aaf21eaec1b324c2be2aa34", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dc689f037c7644db5aaf21eaec1b324c2be2aa34", "committedDate": "2020-04-13T16:52:28Z", "message": "Remove array based EMA calculations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62765c9d0b9b1b7602f440176819246df8402fae", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/62765c9d0b9b1b7602f440176819246df8402fae", "committedDate": "2020-04-13T17:09:46Z", "message": "Minor tests cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c927438b79f3159dad9a92d074977c90506914e5", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c927438b79f3159dad9a92d074977c90506914e5", "committedDate": "2020-04-13T17:46:43Z", "message": "Define mockito dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3889014026f62fdf4a1dde6f5ffe87c239f164e0", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3889014026f62fdf4a1dde6f5ffe87c239f164e0", "committedDate": "2020-04-13T18:38:12Z", "message": "Inject common executor into ExceptionSampler\n\nOriginal implementation had bugs in it which were not covered with tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dc63c7e382b033636e6ed336ea2997e9b80149f", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0dc63c7e382b033636e6ed336ea2997e9b80149f", "committedDate": "2020-04-13T18:43:47Z", "message": "Simnplify sampler tests\n\nRunning multiple threads blocked on phaser should have exactly the\nsame effect as just starting new threads on each iteration - which is simpler."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7438b588f79dac662e9be75a382d063f0ff10acd", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7438b588f79dac662e9be75a382d063f0ff10acd", "committedDate": "2020-04-13T18:47:24Z", "message": "Use sfl4j"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjQ4MzA1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-392248305", "createdAt": "2020-04-13T16:13:32Z", "commit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoxNDoyMlrOGErseA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDowMjowNlrOGEzROw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA==", "bodyText": "This fails on CI quite often: https://circleci.com/gh/DataDog/dd-trace-java/53540", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407563384", "createdAt": "2020-04-13T16:14:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MzA5MQ==", "bodyText": "There are two bugs in line below and third bug in constructor passing value for startWindowRolling... To this means we should have tests for this :)\nPlease consider #1363 - change to use mocks is not scary at all.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407643091", "createdAt": "2020-04-13T18:39:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NjE3NA==", "bodyText": "Should be done in #1363", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407686174", "createdAt": "2020-04-13T19:59:43Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NzQ4Mw==", "bodyText": "There is also one more potential problem here: if app blows up right after start up we may try to schedule things on dead executor and blow up too - this would be confusing to the client. We can avoid this and I suggest waiting for #1366 to just use that solution (and add some tests to it).", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407687483", "createdAt": "2020-04-13T20:02:06Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5494804e58f5c355ed7e1c36e4719bac27e360c", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f5494804e58f5c355ed7e1c36e4719bac27e360c", "committedDate": "2020-04-13T23:30:39Z", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b560c7a39574aa65fbb5b9b51aaa491994d21776", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b560c7a39574aa65fbb5b9b51aaa491994d21776", "committedDate": "2020-04-13T23:31:23Z", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exception-sampler-changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb1c15bf2302b7b84235c4b2481978e7878dfdad", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cb1c15bf2302b7b84235c4b2481978e7878dfdad", "committedDate": "2020-04-14T01:05:56Z", "message": "Use new safe periodic tasks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47a3241988dd541e3803387a87c8ce49e448711f", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/47a3241988dd541e3803387a87c8ce49e448711f", "committedDate": "2020-04-14T01:27:05Z", "message": "Make gradle happy temporarily\n\nAdd temporary fix to gradle to make things compile.\nWill have to open another PR to make things beautiful."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bc73d5452a8293d54958ff8dd46e319d0511a1e", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0bc73d5452a8293d54958ff8dd46e319d0511a1e", "committedDate": "2020-04-14T11:14:01Z", "message": "javadoc fix\n\nCo-Authored-By: Jaroslav Bachorik <jaroslav.bachorik@datadoghq.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1068a7e2a5810f0e822537c37d85c0cba490a54c", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1068a7e2a5810f0e822537c37d85c0cba490a54c", "committedDate": "2020-04-14T11:42:01Z", "message": "Add sourceset for java11\n\nwithout it changing java version affects whole project"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a72093e2367f4b0e18a87213b815ab33e896f858", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a72093e2367f4b0e18a87213b815ab33e896f858", "committedDate": "2020-04-14T11:42:01Z", "message": "Remove exception cause\n\nwe will have to think more about this"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d67989280a267cbd6b9672ff2acb9174e9c2ad1", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1d67989280a267cbd6b9672ff2acb9174e9c2ad1", "committedDate": "2020-04-14T11:47:32Z", "message": "Merge pull request #1363 from DataDog/mar-kolya/exception-sampler-changes\n\nexception sampler changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ab3d3fffce2b79bfc949b93db5d104bce822179", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3ab3d3fffce2b79bfc949b93db5d104bce822179", "committedDate": "2020-04-14T12:53:31Z", "message": "Fix java version in exceptions instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc854c799b294d119ca29cac0fd0b418619c8a89", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dc854c799b294d119ca29cac0fd0b418619c8a89", "committedDate": "2020-04-14T13:22:53Z", "message": "Do not use Java11 only APIs\n\nWe want things working on Java8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96f47c5e56f4cfac516346a265f15e20cb69dbce", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/96f47c5e56f4cfac516346a265f15e20cb69dbce", "committedDate": "2020-04-14T14:04:04Z", "message": "Merge pull request #1368 from DataDog/mar-kolya/fix-exception-instrumentation-java-version\n\nfix exception instrumentation java version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "334b106de70881e3b91b79d3e248b5690e65d3b8", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/334b106de70881e3b91b79d3e248b5690e65d3b8", "committedDate": "2020-04-14T14:20:51Z", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' of github.com:DataDog/dd-trace-java into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1b6620bf08e7b172cdfa0de4025802be451a55", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5c1b6620bf08e7b172cdfa0de4025802be451a55", "committedDate": "2020-04-14T15:59:04Z", "message": "Merge branch 'mar-kolya/add-thread-utils-to-bootstrap' into mar-kolya/fix-thread-utils-dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74350c3b20443fb3ea102e04ffca1c219b623a59", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/74350c3b20443fb3ea102e04ffca1c219b623a59", "committedDate": "2020-04-14T16:01:04Z", "message": "Undo packaging hack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bb199a333a2fc6a6e3790bdb54436959b4c1efa", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8bb199a333a2fc6a6e3790bdb54436959b4c1efa", "committedDate": "2020-04-14T16:05:58Z", "message": "Transform parametrized tests into separate test cases.\nAdd 'benchmark' mode to allow exploring reliability boundaries."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70ce151de74b0697b2cd0e75bfe1e3b8e113a651", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/70ce151de74b0697b2cd0e75bfe1e3b8e113a651", "committedDate": "2020-04-14T16:16:41Z", "message": "Decrease the sampling window size.\nAt least in the simulated env in tests the smaller window size has positive effect on the overall error margin."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ce87dc59c099314c90fca586452d8ada017946", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/24ce87dc59c099314c90fca586452d8ada017946", "committedDate": "2020-04-14T16:25:33Z", "message": "Add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b59c196f3bef4067caab828433e541aef6517a7a", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b59c196f3bef4067caab828433e541aef6517a7a", "committedDate": "2020-04-14T16:28:09Z", "message": "Merge pull request #1372 from DataDog/mar-kolya/fix-thread-utils-dependency\n\nfix thread utils dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "879c3c06db63d4b8f01129bf251878853fe06ac9", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/879c3c06db63d4b8f01129bf251878853fe06ac9", "committedDate": "2020-04-14T16:52:57Z", "message": "Fix duration calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9458fa8a6a10e6e7a362744d758473887e03ce5f", "committedDate": "2020-04-14T17:00:57Z", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTI3NTIz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-393127523", "createdAt": "2020-04-14T17:06:52Z", "commit": {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowNjo1MlrOGFYfgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowNjo1MlrOGFYfgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NzM0Ng==", "bodyText": "It would be nice to have more comments in this function - it is somewhat long and there a a lot of non obvious local variables", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408297346", "createdAt": "2020-04-14T17:06:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,424 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static java.lang.Math.abs;\n+import static java.lang.Math.min;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n+class StreamingSamplerTest {\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n+      throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler instance =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long samples = 0L;\n+\n+    final double[] totalEventsPerWindow = new double[WINDOWS];\n+    final double[] sampledEventsPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final List<Integer> sampleIndices = new ArrayList<>();\n+      final long samplesBase = samples;\n+      final int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      final double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      rollWindow();\n+    }\n+    final double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    final double sampledEventsPerWindowStddev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    final double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    final double correctionFactor =\n+        min(((totalEventsPerWindowMean * WINDOWS) / expectedSamples), 1);\n+    final double targetSamples = expectedSamples * correctionFactor;\n+    final double percentualError = round(((targetSamples - samples) / targetSamples) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTI4MDQ2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-393128046", "createdAt": "2020-04-14T17:07:34Z", "commit": {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3b485fbe522292d4361bcc32f323bdf372a1029e", "committedDate": "2020-04-15T10:29:03Z", "message": "Improve test structure and add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjE3OTQ5", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-395617949", "createdAt": "2020-04-17T16:53:23Z", "commit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MzoyM1rOGHVrnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoxMTo1M1rOGHWRUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODQ0NA==", "bodyText": "This isn't really doing anything different from ClassLoaderMatcher.hasClassesNamed().  I don't think you can get a resource from the bootstrap classpath...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410348444", "createdAt": "2020-04-17T16:53:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ==", "bodyText": "Can you add a defaultEnabled class returning false (to disable by default) or at least hasJfr?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410351365", "createdAt": "2020-04-17T16:58:36Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg==", "bodyText": "static import ElementMatchers.* and change to a ternary?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352102", "createdAt": "2020-04-17T16:59:58Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjQzOA==", "bodyText": "Same suggestion here... (static import and ternary)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352438", "createdAt": "2020-04-17T17:00:32Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n+    }\n+    return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjkzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n          \n          \n            \n                      isConstructor(), packageName + \".ExceptionAdvice\");", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352933", "createdAt": "2020-04-17T17:01:30Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg==", "bodyText": "Since this doesn't have the java 7 compatibility requirement, should this use LongAdder instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410356902", "createdAt": "2020-04-17T17:09:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODA5Nw==", "bodyText": "I think a class comment here would be helpful.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410358097", "createdAt": "2020-04-17T17:11:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62ead6ed0dfa653dd1cf5226b171e74db8db0e7b", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/62ead6ed0dfa653dd1cf5226b171e74db8db0e7b", "committedDate": "2020-04-20T10:07:18Z", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler\n\n# Conflicts:\n#\tdd-smoke-tests/profiling-integration-tests/src/main/java/datadog/smoketest/profiling/ProfilingTestApplication.java\n#\tdd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy\n#\tgradle/dependencies.gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e4a69fe9b89e063aaa27e3a1ba6bf1c08740228", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9e4a69fe9b89e063aaa27e3a1ba6bf1c08740228", "committedDate": "2020-04-20T10:18:58Z", "message": "Update dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java\n\nCo-Authored-By: Tyler Benson <tyler.benson@datadoghq.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0806f03b9172bbe4d897d9409285048c28263030", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0806f03b9172bbe4d897d9409285048c28263030", "committedDate": "2020-04-20T12:24:11Z", "message": "Improve docs and test coverage of ExceptionHistogram"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfde6e32fb0f5b6170e8ed6124c53f678c6e2ea4", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cfde6e32fb0f5b6170e8ed6124c53f678c6e2ea4", "committedDate": "2020-04-20T12:31:57Z", "message": "Add static imports for ElementMatchers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6d2c32779b5fcedaa8355245a2700324d0d85b3a", "committedDate": "2020-03-05T16:51:44Z", "message": "PROF-581: Add exception sampling event\n\nIn order to reduce the number of exception events which can become quite overwhelming a statistical sampling is employed to pick semi-random exceptions and generate events only for those. The sampling rate is adaptive and ensures that the number of events in an average recording will converge to a finite, not very large number."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODQwNjAx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-369840601", "createdAt": "2020-03-05T19:13:06Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxMzowNlrOFygbvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxMzowNlrOFygbvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUwOQ==", "bodyText": "I think injecting java8 classes into bootstrap may be not very good. Also I do not quite see why this cannot be part of instrumentation that uses it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r388504509", "createdAt": "2020-03-05T19:13:06Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-jfr-bootstrap/agent-jfr-bootstrap.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDc4NDQ5", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370478449", "createdAt": "2020-03-06T16:57:42Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjo1Nzo0MlrOFzACYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjo1Nzo0MlrOFzACYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA==", "bodyText": "is there any point in compiling this for java 7? and if so why do you  need java11 compiler? You may want to clarify incomments...\nAlso I think you've cargoculted comments above this line that may not apply - and this is true for all 3 blocks in this file.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389022304", "createdAt": "2020-03-06T16:57:42Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg0NjA5", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370484609", "createdAt": "2020-03-06T17:06:12Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowNjoxMlrOFzAa8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowNjoxMlrOFzAa8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyODU5Mw==", "bodyText": "I think generally style of this repo avoids shortened variable names like this - and I feel it would be easy on everybody if style is preserved :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389028593", "createdAt": "2020-03-06T17:06:12Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg2NDEx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370486411", "createdAt": "2020-03-06T17:09:10Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowOToxMFrOFzAhDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowOToxMFrOFzAhDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng==", "bodyText": "I have a strong feeling you should not need this and you should be able to use ExceptionEventSampler from advice directly.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389030156", "createdAt": "2020-03-06T17:09:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.exceptions.jfr;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+\n+/**\n+ * A simple accessor bridge implementation.\n+ * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n+ * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n+ * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n+ * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n+ */\n+public class ExceptionEventSamplerBridge {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkwMTM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370490137", "createdAt": "2020-03-06T17:14:49Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxNDo0OVrOFzAseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxNDo0OVrOFzAseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMzA4MQ==", "bodyText": "Could you please make sure you follow settings in https://github.com/DataDog/dd-trace-java/blob/master/CONTRIBUTING.md to avoid stray changes when someone else edits this code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389033081", "createdAt": "2020-03-06T17:14:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkyOTQx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370492941", "createdAt": "2020-03-06T17:19:12Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxOToxMlrOFzA1LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxOToxMlrOFzA1LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA==", "bodyText": "I think it may not make sense to split sampling (and event creation) into one place and commit into another...\nYou might as well put the whole thing into ExceptionEventSampler.sample(e) - and potentially rename it accordingly.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389035308", "createdAt": "2020-03-06T17:19:12Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTAzNTA1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-370503505", "createdAt": "2020-03-06T17:35:58Z", "commit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzozNTo1OFrOFzBWjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzozNTo1OFrOFzBWjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA==", "bodyText": "This would mean that bootstrap would need to see classes from dd-trace-ot - this seem wrong.\nInstead you may want to consider having essentially a wrapper class on bootstrap level that has a 'field' that is initialized into correct sampling implementation by initialization code in some other place - probably when apm starts up or something.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389043854", "createdAt": "2020-03-06T17:35:58Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35e43687a950566378edcdba6256e88cadcdcb02", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/35e43687a950566378edcdba6256e88cadcdcb02", "committedDate": "2020-03-06T19:01:49Z", "message": "Add initial impl of exception histogram event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54b9d41f7116ff7c16b8285f71ed1013473dc693", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/54b9d41f7116ff7c16b8285f71ed1013473dc693", "committedDate": "2020-03-09T19:17:25Z", "message": "Implementation cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "committedDate": "2020-03-10T11:24:04Z", "message": "Debugging failing integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3cdcdb87cc4a430be37c3ef9c27572abfe5a1c4", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c3cdcdb87cc4a430be37c3ef9c27572abfe5a1c4", "committedDate": "2020-03-10T11:02:34Z", "message": "Debugging failing integration test"}, "afterCommit": {"oid": "fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fac58e0e03efaca4f7f5ceaec2adbbab1540f508", "committedDate": "2020-03-10T11:24:04Z", "message": "Debugging failing integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/751897f197dfe76b558220bfdc5d139e7a22f7fb", "committedDate": "2020-03-10T15:55:03Z", "message": "Restructure the code to avoid adding v.52 classes to bootstrap"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMTQwMjc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-372140276", "createdAt": "2020-03-10T16:53:20Z", "commit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjo1MzoyMFrOF0X9bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjo1MzoyMFrOF0X9bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA==", "bodyText": "Why Exception and not Throwable?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390462828", "createdAt": "2020-03-10T16:53:20Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ebcf717d1f3ed13961406a4d6231a959a58ffb2", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1ebcf717d1f3ed13961406a4d6231a959a58ffb2", "committedDate": "2020-03-10T17:19:34Z", "message": "Appease muzzle and lower the chance of intermittent failure in adaptive sampler test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a92597e40157d774d88813ba36292ffe5d24a6e4", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a92597e40157d774d88813ba36292ffe5d24a6e4", "committedDate": "2020-03-10T17:23:02Z", "message": "Do not use acronyms as variable names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "600c3d8933d7d90a74dc5945aba6c47cad2fde46", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/600c3d8933d7d90a74dc5945aba6c47cad2fde46", "committedDate": "2020-03-10T17:34:53Z", "message": "Add comment about java.lang.Exception instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "048bcb514bd72f8dc2927fe6026cfc18a343e061", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/048bcb514bd72f8dc2927fe6026cfc18a343e061", "committedDate": "2020-03-10T17:36:27Z", "message": "Formatting changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60b496a3e3b03b864019d50f4fffcd1eef201671", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/60b496a3e3b03b864019d50f4fffcd1eef201671", "committedDate": "2020-03-10T18:01:38Z", "message": "Disable AdaptiveIntervalSamplerTest in CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbcfe5e1f5fb07e9e4d3730a6407110897f603fa", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cbcfe5e1f5fb07e9e4d3730a6407110897f603fa", "committedDate": "2020-03-11T09:07:20Z", "message": "Update docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33359432ff42293c7aea81ea1bafba993bf021f2", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/33359432ff42293c7aea81ea1bafba993bf021f2", "committedDate": "2020-03-11T09:34:53Z", "message": "Impose hard limit on number of samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd37c07c8a800ff85770c17575411bd5e2bea102", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fd37c07c8a800ff85770c17575411bd5e2bea102", "committedDate": "2020-03-11T09:39:48Z", "message": "Formatting changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/568b50978d76134f1a902c1c512102507687faec", "committedDate": "2020-03-11T10:19:49Z", "message": "Simplify the exception profiling enablement checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDIyMjM5", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377022239", "createdAt": "2020-03-18T16:15:14Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjoxNToxNFrOF4Mkcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjoxNToxNFrOF4Mkcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDUxNA==", "bodyText": "I do not think other options are using similar suffixes... you may want to drop it and just have a comment for now. After this is released we will just update docs.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394470514", "createdAt": "2020-03-18T16:15:14Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -127,6 +127,13 @@\n   public static final String PROFILING_PROXY_PORT = \"profiling.proxy.port\";\n   public static final String PROFILING_PROXY_USERNAME = \"profiling.proxy.username\";\n   public static final String PROFILING_PROXY_PASSWORD = \"profiling.proxy.password\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_INTERVAL =\n+      \"profiling.exception-sampler.interval\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_MAX_SAMPLES =\n+      \"profiling.exception-sampler.max-samples\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_TIME_WINDOW =\n+      \"profiling.exception-sampler.time-window.sec\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDM1NjE2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377035616", "createdAt": "2020-03-18T16:30:28Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMDoyOVrOF4NOPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMDoyOVrOF4NOPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA==", "bodyText": "Blowing up in advice might not be a very good strategy... Would it be possible to gracefully skip exception handling instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394481214", "createdAt": "2020-03-18T16:30:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {\n+    ExceptionProfiling.config = config;\n+  }\n+\n+  /**\n+   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n+   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n+   *\n+   * @return the shared instance\n+   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n+   *     called yet\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    assert config != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDM3NDIy", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377037422", "createdAt": "2020-03-18T16:32:35Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMjozNVrOF4NTtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMjozNVrOF4NTtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg==", "bodyText": "Do you need this statically separately? Presumably you have a singleton instance - can you have non static config there and have a non static init method?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394482612", "createdAt": "2020-03-18T16:32:35Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDQwMDA2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377040006", "createdAt": "2020-03-18T16:35:34Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNTozNVrOF4Nbrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNTozNVrOF4Nbrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA==", "bodyText": "Having hashes of unlimited size may be problematic... You may want to consider putting hard limit on this somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394484654", "createdAt": "2020-03-18T16:35:35Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDQxMzE0", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377041314", "createdAt": "2020-03-18T16:37:06Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNzowN1rOF4NfkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNzowN1rOF4NfkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA==", "bodyText": "I was under impression this should be done in advice because otherwise event will have strange callstack. Has this changed?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394485648", "createdAt": "2020-03-18T16:37:07Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(String type, long count) {\n+    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDQ5MTcz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377049173", "createdAt": "2020-03-18T16:46:09Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NjowOVrOF4N3lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NjowOVrOF4N3lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MTc5Nw==", "bodyText": "It would be really nice to have javadoc here explaining what this does", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394491797", "createdAt": "2020-03-18T16:46:09Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDUyMTI0", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377052124", "createdAt": "2020-03-18T16:49:30Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0OTozMVrOF4OAeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0OTozMVrOF4OAeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NDA3NA==", "bodyText": "Stylewise I feel like keeping mutable fields separate form immutable makes things easier to understand.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394494074", "createdAt": "2020-03-18T16:49:31Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDU4ODcz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377058873", "createdAt": "2020-03-18T16:57:17Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo1NzoxN1rOF4OVqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo1NzoxN1rOF4OVqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5OTQ5Nw==", "bodyText": "This doesn't seem to be used. Do you really need this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394499497", "createdAt": "2020-03-18T16:57:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads\n+      currentTop = expectedHits(interval);\n+      counter.addAndGet(counterTop);\n+      sampleCounter++;\n+      ts = ts1;\n+      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n+      // other\n+      // threads\n+      counterTop = currentTop;\n+\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public String getId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDY0OTc0", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377064974", "createdAt": "2020-03-18T17:04:33Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzowNDozM1rOF4OorQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzowNDozM1rOF4OorQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ==", "bodyText": "is this comment correct? you are not writing to counterTop here", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394504365", "createdAt": "2020-03-18T17:04:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MDc1MzQz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377075343", "createdAt": "2020-03-18T17:17:03Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNzowM1rOF4PH4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNzowM1rOF4PH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMjM1NA==", "bodyText": "Wouldn't this short circuit prevent you from properly scaling sampling interval?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394512354", "createdAt": "2020-03-18T17:17:03Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NjU3NzIx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377657721", "createdAt": "2020-03-19T12:07:09Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjowNzowOVrOF4ri0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjowNzowOVrOF4ri0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3ODAwMQ==", "bodyText": "As discussed offline: there might be a simpler approach to just keep expected number of exceptions per window and then randomly sample each exception with probability based on expected number of exceptions and target number of exceptions.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394978001", "createdAt": "2020-03-19T12:07:09Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NjYyMTE3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377662117", "createdAt": "2020-03-19T12:13:51Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoxMzo1MlrOF4rwMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoxMzo1MlrOF4rwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MTQyNQ==", "bodyText": "Please consider using smoke test framework for this, see ProfilingTestApplication as an example.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394981425", "createdAt": "2020-03-19T12:13:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java", "diffHunk": "@@ -0,0 +1,28 @@\n+import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+public class JfrHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NjY3MzMx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-377667331", "createdAt": "2020-03-19T12:21:56Z", "commit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoyMTo1N1rOF4r_yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoyMTo1N1rOF4r_yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4NTQxNw==", "bodyText": "The thing here is that we compile event classes and supporting code for java11 bytecode so for JDK 8 with backported jfr we will attempt to load java11 classes into java8", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394985417", "createdAt": "2020-03-19T12:21:57Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    boolean jfr = false;\n+    try {\n+      /* Check only for the open-sources JFR implementation.\n+       * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+       * enhanced\n+       */\n+      Class.forName(\"jdk.jfr.Event\");\n+      jfr = true;\n+    } catch (ClassNotFoundException ignored) {\n+    }\n+    hasJfr = jfr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10b269b046ba34c00f4c7899e727bf7e506230fd", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/10b269b046ba34c00f4c7899e727bf7e506230fd", "committedDate": "2020-03-20T13:46:11Z", "message": "Replace adaptive sampler with a streaming sampler implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/569cfa3ccc90e32b0c881700236ddd59552b75b3", "committedDate": "2020-03-20T16:28:49Z", "message": "Add exception sampling to profiling smoke test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDAxNjU3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379401657", "createdAt": "2020-03-23T12:56:46Z", "commit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1Njo0NlrOF6EJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1Njo0NlrOF6EJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyOTY2MQ==", "bodyText": "It would be nice to run tests for this on zulu8. Please have a look at #1331 for an example.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396429661", "createdAt": "2020-03-23T12:56:46Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "diffHunk": "@@ -0,0 +1,46 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDAyMDQ0", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379402044", "createdAt": "2020-03-23T12:57:17Z", "commit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzoxN1rOF6EKkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzoxN1rOF6EKkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyOTk3MA==", "bodyText": "Is this change intentional?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396429970", "createdAt": "2020-03-23T12:57:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java", "diffHunk": "@@ -42,15 +43,16 @@\n    * <p>This has to be public because it is created via reflection\n    */\n   public OpenJdkController(final Config config)\n-      throws ConfigurationException, ClassNotFoundException {\n+    throws ConfigurationException, ClassNotFoundException {\n+    System.err.println(\"===> OpenJDKController start\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88bab1eeb8ab2e6d699b1c00618c208d640fbefe", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/88bab1eeb8ab2e6d699b1c00618c208d640fbefe", "committedDate": "2020-03-23T17:55:27Z", "message": "Truncate exception histogram map on chunk rotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1dd7269de36549a60b327d050f71f4054ce9e8e", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a1dd7269de36549a60b327d050f71f4054ce9e8e", "committedDate": "2020-03-23T18:01:45Z", "message": "Remove debug output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41da2107f8f1a1e92a1cd05bf6324de57aa18ea6", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/41da2107f8f1a1e92a1cd05bf6324de57aa18ea6", "committedDate": "2020-03-23T18:02:54Z", "message": "Change the sampler implementation to CDF based"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/33944845f3ba2a299c8359a879244acada65d4f8", "committedDate": "2020-03-23T18:03:16Z", "message": "Add ZULU8 support"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODExMjgw", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379811280", "createdAt": "2020-03-23T20:50:04Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDo1MDowNFrOF6XkJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDo1MDowNFrOF6XkJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA==", "bodyText": "Don't know if it helps but you can precompute newThreshold outside of synchronized block as it seems to rely on local values (if I am not mistaken) and do only the if and the 2 updates of long in the synchronized blocks.\nThe other approach will be: if SampleCount and threshold can fit into Integers, you can pack them into only one Long and to a single CAS ensuring atomicity :)\nBut in any cases should be proven that sync block is a real bottleneck :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396747814", "createdAt": "2020-03-23T20:50:04Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd06ebd4e6cd7af210d51e71667d6db6db95a43b", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/dd06ebd4e6cd7af210d51e71667d6db6db95a43b", "committedDate": "2020-03-23T22:06:55Z", "message": "Multiple fixes for exception histogram\n\n* Add limit to histogram size\n* Make sure entries are removed in the same iteration they were used\n* Improve tests\n* Fix configuration object initialization\n* Add tests for new config fields"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODU5MDI2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379859026", "createdAt": "2020-03-23T22:09:39Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowOTozOVrOF6Z7_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowOTozOVrOF6Z7_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjY4NQ==", "bodyText": "This will keep entries for longer than needed. Please consider #1334", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786685", "createdAt": "2020-03-23T22:09:39Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, AtomicLong> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(final Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(final int maxTopItems, final boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(final String type, final long count) {\n+    final ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();\n+    }\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  boolean record(final String typeName) {\n+    if (typeName == null) {\n+      return false;\n+    }\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      final boolean[] firstHit = new boolean[] {false};\n+      histoMap\n+          .computeIfAbsent(\n+              typeName,\n+              k -> {\n+                try {\n+                  return new AtomicLong();\n+                } finally {\n+                  firstHit[0] = true;\n+                }\n+              })\n+          .incrementAndGet();\n+\n+      return firstHit[0];\n+    }\n+    return false;\n+  }\n+\n+  void processAndReset(final ValueVisitor processor) {\n+    Stream<Map.Entry<String, Long>> items =\n+        histoMap\n+            .entrySet()\n+            .stream()\n+            .map(e -> entry(e.getKey(), e.getValue().getAndSet(0L)))\n+            .filter(e -> e.getValue() != 0)\n+            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n+    histoMap.entrySet().removeIf(e -> e.getValue().get() == 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODU5MzU4", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379859358", "createdAt": "2020-03-23T22:10:18Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMDoxOFrOF6Z8-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMDoxOFrOF6Z8-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjkzNw==", "bodyText": "This is wrong and test that verifies this should have been updated. Please consider #1334", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786937", "createdAt": "2020-03-23T22:10:18Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -635,6 +658,20 @@ private Config(final Properties properties, final Config parent) {\n     profilingProxyPassword =\n         properties.getProperty(PROFILING_PROXY_PASSWORD, parent.profilingProxyPassword);\n \n+    profilingExceptionSamplerSlidingWindow =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW);\n+    profilingExceptionSamplerSlidingWindowSamples =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES);\n+    profilingExceptionHistoMax =\n+        getPropertyIntegerValue(\n+            properties, PROFILING_EXCEPTION_HISTO_MAX, DEFAULT_PROFILING_EXCEPTION_HISTO_MAX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODU5Nzgw", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379859780", "createdAt": "2020-03-23T22:11:13Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxM1rOF6Z-Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxM1rOF6Z-Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NzMwMw==", "bodyText": "Could you please explain why this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396787303", "createdAt": "2020-03-23T22:11:13Z", "author": {"login": "mar-kolya"}, "path": "settings.gradle", "diffHunk": "@@ -72,6 +73,7 @@ include ':dd-java-agent:instrumentation:elasticsearch:transport-2'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5.3'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-6'\n+include ':dd-java-agent:instrumentation:exception-profiling'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODU5ODA4", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-379859808", "createdAt": "2020-03-23T22:11:16Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxNlrOF6Z-fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxNlrOF6Z-fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NzMyNg==", "bodyText": "Could you please explain why this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396787326", "createdAt": "2020-03-23T22:11:16Z", "author": {"login": "mar-kolya"}, "path": "settings.gradle", "diffHunk": "@@ -33,6 +33,7 @@ include ':dd-java-agent:load-generator'\n include ':dd-java-agent:agent-profiling'\n include ':dd-java-agent:agent-profiling:profiling-controller'\n include ':dd-java-agent:agent-profiling:profiling-controller-openjdk'\n+include ':dd-java-agent:agent-profiling:profiling-exceptions'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c4a1c8fa65ef1d31a440b4dc99678ec0020179a", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1c4a1c8fa65ef1d31a440b4dc99678ec0020179a", "committedDate": "2020-03-24T11:00:32Z", "message": "Made deregister package private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e465dcb796d1010115774dda9729a80fc8fcdf44", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e465dcb796d1010115774dda9729a80fc8fcdf44", "committedDate": "2020-03-24T11:01:32Z", "message": "Remove logging left behind by accident"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5721f6e1edc28118e76560430322fac6f104f27", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b5721f6e1edc28118e76560430322fac6f104f27", "committedDate": "2020-03-24T11:08:25Z", "message": "Count 'clipped' exceptions and provide to provide information about histogram overflow"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "362006d57449f0ff57f46377f13452d6935d0b15", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/362006d57449f0ff57f46377f13452d6935d0b15", "committedDate": "2020-03-24T11:28:59Z", "message": "Update helper list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88471b749c6a8a2c3ff32f142fa7465de724b927", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/88471b749c6a8a2c3ff32f142fa7465de724b927", "committedDate": "2020-03-24T12:13:43Z", "message": "Use enablement config for exception instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b619a5f6153a68bacba68077b91f3467125fae4", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1b619a5f6153a68bacba68077b91f3467125fae4", "committedDate": "2020-03-24T12:51:23Z", "message": "Remove unneccessary dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8ceb258bc9dcc6a53700cf907a5b7fd69548763", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f8ceb258bc9dcc6a53700cf907a5b7fd69548763", "committedDate": "2020-03-24T12:51:32Z", "message": "Make sure samplier is initialized before using it\n\nException class can be loaded and instantiated before Sampler code had\na chance to initialize. This results in advice seeing null in static\nfield - so we have to check for that."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwMjc4NzUz", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-380278753", "createdAt": "2020-03-24T12:54:33Z", "commit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjo1NDozM1rOF6u2dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjo1NDozM1rOF6u2dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTMzMw==", "bodyText": "Do we still need this whole module separately - maybe this could be moved to advice? This would somewhat simplify dependency management.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397129333", "createdAt": "2020-03-24T12:54:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "diffHunk": "@@ -0,0 +1,50 @@\n+// Set properties before any plugins get loaded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "089ee25024525b39c5d34269f8e74d02ca99973c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/089ee25024525b39c5d34269f8e74d02ca99973c", "committedDate": "2020-03-24T13:13:12Z", "message": "PROF-581: Add exception sampling event\n\nIn order to reduce the number of exception events which can become quite overwhelming a statistical sampling is employed to pick semi-random exceptions and generate events only for those. The sampling rate is adaptive and ensures that the number of events in an average recording will converge to a finite, not very large number."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "610e4171ac6a1c8004e169c3e0724433b58e79bd", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/610e4171ac6a1c8004e169c3e0724433b58e79bd", "committedDate": "2020-03-24T13:13:12Z", "message": "Add initial impl of exception histogram event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36e9609d0eb6723df2dfba6192cffd84a6a107f8", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/36e9609d0eb6723df2dfba6192cffd84a6a107f8", "committedDate": "2020-03-24T13:13:12Z", "message": "Implementation cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb27f092710fdf6af90153fdcd7f0e5aacc3863c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cb27f092710fdf6af90153fdcd7f0e5aacc3863c", "committedDate": "2020-03-24T13:13:12Z", "message": "Debugging failing integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f2f9dc479fe9ff2cc86f98afd2ee1af29c5fbab", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7f2f9dc479fe9ff2cc86f98afd2ee1af29c5fbab", "committedDate": "2020-03-24T13:13:12Z", "message": "Restructure the code to avoid adding v.52 classes to bootstrap"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f22b7de0b9138fa601edbe4caed379cc9bc6222c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f22b7de0b9138fa601edbe4caed379cc9bc6222c", "committedDate": "2020-03-24T13:13:12Z", "message": "Appease muzzle and lower the chance of intermittent failure in adaptive sampler test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "003e0f37242d11a05d52941f6d0885d374edf308", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/003e0f37242d11a05d52941f6d0885d374edf308", "committedDate": "2020-03-24T13:13:12Z", "message": "Do not use acronyms as variable names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86d8a7a0a6cf24eb8a9412a424a86b3a4b2778c6", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/86d8a7a0a6cf24eb8a9412a424a86b3a4b2778c6", "committedDate": "2020-03-24T13:13:12Z", "message": "Add comment about java.lang.Exception instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55c90bd10e6d0ff0e5580a5364c4cbd9a51206ed", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/55c90bd10e6d0ff0e5580a5364c4cbd9a51206ed", "committedDate": "2020-03-24T13:13:12Z", "message": "Formatting changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47ec13cc935aa67fe06f6b33a1d52706701fca16", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/47ec13cc935aa67fe06f6b33a1d52706701fca16", "committedDate": "2020-03-24T13:13:12Z", "message": "Disable AdaptiveIntervalSamplerTest in CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "739116dc5d274ae0666c96d6a8fdad002b6937e1", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/739116dc5d274ae0666c96d6a8fdad002b6937e1", "committedDate": "2020-03-24T13:13:12Z", "message": "Update docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f1e3a8996bbd2200b16700c56bd8dc39da1833c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4f1e3a8996bbd2200b16700c56bd8dc39da1833c", "committedDate": "2020-03-24T13:13:12Z", "message": "Impose hard limit on number of samples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b6a1b481973a64b9c126879bd10d5d25ddac546", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3b6a1b481973a64b9c126879bd10d5d25ddac546", "committedDate": "2020-03-24T13:13:12Z", "message": "Formatting changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fdb1479ca1a51f6a96ad5b53dd78ea8f5878b1a", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7fdb1479ca1a51f6a96ad5b53dd78ea8f5878b1a", "committedDate": "2020-03-24T13:13:12Z", "message": "Simplify the exception profiling enablement checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea64495eae767eb902e113c08242301db6c43701", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ea64495eae767eb902e113c08242301db6c43701", "committedDate": "2020-03-24T13:13:12Z", "message": "Replace adaptive sampler with a streaming sampler implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41b69ab58975f11e44ee8d97136bc4ade2bc2d4f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/41b69ab58975f11e44ee8d97136bc4ade2bc2d4f", "committedDate": "2020-03-24T13:13:12Z", "message": "Add exception sampling to profiling smoke test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d130cfa7e84ee893e2e65208189f08bf8e7b7a8c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d130cfa7e84ee893e2e65208189f08bf8e7b7a8c", "committedDate": "2020-03-24T13:13:12Z", "message": "Truncate exception histogram map on chunk rotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "713bcb702ded2b704e140ef87d16bf43d33d58b9", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/713bcb702ded2b704e140ef87d16bf43d33d58b9", "committedDate": "2020-03-24T13:13:12Z", "message": "Remove debug output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe80d3459a3a1cbf7d0890152d48a0380959e311", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fe80d3459a3a1cbf7d0890152d48a0380959e311", "committedDate": "2020-03-24T13:13:12Z", "message": "Change the sampler implementation to CDF based"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13b44afa3a6533ed2282cce8dea99dede19acd92", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/13b44afa3a6533ed2282cce8dea99dede19acd92", "committedDate": "2020-03-24T13:13:12Z", "message": "Add ZULU8 support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25a8e1231d248bdfeeb3a7ef5ab072cf786c5411", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/25a8e1231d248bdfeeb3a7ef5ab072cf786c5411", "committedDate": "2020-03-24T13:13:35Z", "message": "Merge remote-tracking branch 'origin/jb/PROF-581_exceptions_sampler' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb9b38aa32a599e5098a248adf2bc778ad519c69", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cb9b38aa32a599e5098a248adf2bc778ad519c69", "committedDate": "2020-03-24T13:16:26Z", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exceptions-histogram-fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a43a009e95eafd06b63fd2e6ff77d859ed529eb", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8a43a009e95eafd06b63fd2e6ff77d859ed529eb", "committedDate": "2020-03-24T13:30:37Z", "message": "Make compiler happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b0de5efb4d7741eed8564559840bd8d5773b236", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1b0de5efb4d7741eed8564559840bd8d5773b236", "committedDate": "2020-03-24T14:13:04Z", "message": "Fix timing of chunk rotation is tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08158dd1bc552292fc14b45334033653ad86d629", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/08158dd1bc552292fc14b45334033653ad86d629", "committedDate": "2020-03-25T11:55:39Z", "message": "Use geometric distribution CDF to compute next sample threshold"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e05d10a2f2529768d01aaef953db85fae6a3e453", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e05d10a2f2529768d01aaef953db85fae6a3e453", "committedDate": "2020-03-25T11:58:07Z", "message": "Merge branch 'master' into mar-kolya/exceptions-histogram-fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d7e8c67f97b47bff336e0812b28014dd7b76d9c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6d7e8c67f97b47bff336e0812b28014dd7b76d9c", "committedDate": "2020-03-25T11:58:09Z", "message": "Merge branch 'master' into jb/PROF-581_exceptions_sampler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf537c7df6bc221eca7983af01b1714ab49c3728", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cf537c7df6bc221eca7983af01b1714ab49c3728", "committedDate": "2020-03-25T12:14:06Z", "message": "Fix configs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6313523d766c30cf95d4883a08df00329a20325", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a6313523d766c30cf95d4883a08df00329a20325", "committedDate": "2020-03-25T12:50:03Z", "message": "Merge branch 'jb/PROF-581_exceptions_sampler' into mar-kolya/exceptions-histogram-fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a159568fa83d3018bc37b13a27503739c88e70", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/21a159568fa83d3018bc37b13a27503739c88e70", "committedDate": "2020-03-25T14:02:40Z", "message": "Add missing helper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07ce810d262958c9c5b85b234374296dd1b08940", "author": {"user": {"login": "mar-kolya", "name": "Nikolay Martynov"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/07ce810d262958c9c5b85b234374296dd1b08940", "committedDate": "2020-03-25T14:30:11Z", "message": "Merge pull request #1334 from DataDog/mar-kolya/exceptions-histogram-fixes\n\nMultiple fixes for exception histogram"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc30f5d5b6f2201691b0621fce6748e08eaf3654", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cc30f5d5b6f2201691b0621fce6748e08eaf3654", "committedDate": "2020-03-25T16:42:54Z", "message": "Do not cause class initialization when checking for JFR availability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f628af8e0518fcb400386520fdf9a9e4ebc4e32f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f628af8e0518fcb400386520fdf9a9e4ebc4e32f", "committedDate": "2020-03-25T16:59:19Z", "message": "Fold exception profiling support into the instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9e03f5335d737f95c7504170f66f6e927b87df8", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b9e03f5335d737f95c7504170f66f6e927b87df8", "committedDate": "2020-03-25T17:58:07Z", "message": "Try to fix test dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c6a65fa5c0d22e2c57add605a87519d81b4dbe3", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6c6a65fa5c0d22e2c57add605a87519d81b4dbe3", "committedDate": "2020-03-25T18:26:16Z", "message": "Maybe this will make the build pass?"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2996cbc230692a8ae398480d74104d5215ec4b12", "committedDate": "2020-03-25T19:04:06Z", "message": "Placate google format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTIxMTE2", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381921116", "createdAt": "2020-03-26T11:31:59Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMjowMFrOF8Conw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMjowMFrOF8Conw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw==", "bodyText": "We should address this fix me.\nFirst of all I'm not convinced that firsthit that may be skipped is actually useful.\nAnd if we decide that it is we should update tests to make sure it actually works the way we think it does.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502047", "createdAt": "2020-03-26T11:32:00Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();\n+          } finally {\n+            firstHit[0] = true;\n+          }\n+        })\n+      .incrementAndGet();\n+\n+    // FIXME: this 'first hit' logic is confusing and untested", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTIyMDQ1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381922045", "createdAt": "2020-03-26T11:33:28Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMzoyOVrOF8Crgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMzoyOVrOF8Crgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng==", "bodyText": "If we decide to keep this firstHit logic I think this code we will much more self-explanatory if we just pass firstHit intosample() call and make sample() do the right thing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502786", "createdAt": "2020-03-26T11:33:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static final Config config = Config.get();\n+\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+\n+  /**\n+   * Get a pre-configured shared instance.\n+   *\n+   * @return the shared instance\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    return ExceptionProfiling.INSTANCE;\n+  }\n+\n+  private final ExceptionHistogram histogram;\n+  private final ExceptionSampler sampler;\n+\n+  private ExceptionProfiling() {\n+    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n+  }\n+\n+  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n+    this.sampler = sampler;\n+    this.histogram = histogram;\n+  }\n+\n+  public ExceptionSampleEvent process(final Exception e) {\n+    // always record the exception in histogram\n+    final boolean firstHit = histogram.record(e);\n+\n+    if (sampler.isEnabled()) {\n+      /*\n+       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n+       * and the sample event should be emitted regardless of the sampling result.\n+       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n+       * of 'firstHit'.\n+       */\n+      if (firstHit | sampler.sample()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTIyOTY0", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381922964", "createdAt": "2020-03-26T11:34:49Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozNDo0OVrOF8Cubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozNDo0OVrOF8Cubw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMzUzNQ==", "bodyText": "This class doesn't seem to be providing much value now :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398503535", "createdAt": "2020-03-26T11:34:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+final class ExceptionSampler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTI4MzMx", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381928331", "createdAt": "2020-03-26T11:43:10Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0MzoxMFrOF8C_YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0MzoxMFrOF8C_YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNzg3Mw==", "bodyText": "Please consider replacing this with this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            sourceCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            targetCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            \n          \n          \n            \n            compileJava {\n          \n          \n            \n              sourceCompatibility = JavaVersion.VERSION_1_7\n          \n          \n            \n              targetCompatibility = JavaVersion.VERSION_1_7\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n          \n          \n            \n            compileMain_java11Java {\n          \n          \n            \n              doFirst {\n          \n          \n            \n                // Disable '-processing' because some annotations are not claimed.\n          \n          \n            \n                // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n          \n          \n            \n                // Disable '-path' because we do not have some of the paths seem to be missing.\n          \n          \n            \n                // Compile to 8 compatible byte code\n          \n          \n            \n                options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n          \n          \n            \n                options.fork = true\n          \n          \n            \n                options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n          \n          \n            \n              }\n          \n          \n            \n            }\n          \n          \n            \n            compileTestJava {\n          \n          \n            \n              sourceCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n              targetCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n          \n          \n            \n            [compileMain_java11Java, compileTestJava].each {\n          \n          \n            \n              it.doFirst {\n          \n          \n            \n                // Disable '-processing' because some annotations are not claimed.\n          \n          \n            \n                // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n          \n          \n            \n                // Disable '-path' because we do not have some of the paths seem to be missing.\n          \n          \n            \n                // Compile to 8 compatible byte code\n          \n          \n            \n                options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n          \n          \n            \n                options.fork = true\n          \n          \n            \n                options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nI think it will do the right thing and is slightly simpler", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398507873", "createdAt": "2020-03-26T11:43:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+  // Zulu has backported profiling support\n+  forceJdk = ['ZULU8']\n+  // By default tests with be compiled for `minJavaVersionForTests` version,\n+  // but in this case we would like to avoid this since we would like to run with ZULU8\n+  skipSettingTestJavaVersion = true\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+\n+  testCompile deps.junit5\n+  testCompile deps.jmc\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_8\n+targetCompatibility = JavaVersion.VERSION_1_8\n+\n+compileJava {\n+  sourceCompatibility = JavaVersion.VERSION_1_7\n+  targetCompatibility = JavaVersion.VERSION_1_7\n+}\n+\n+// Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    // Compile to 8 compatible byte code\n+    options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTMwOTE1", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381930915", "createdAt": "2020-03-26T11:46:55Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0Njo1NlrOF8DH4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0Njo1NlrOF8DH4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ==", "bodyText": "I'm not sure I can immediately see how this would be useful.\nMaybe instead of this we could keep cause's message if cause is present?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398510049", "createdAt": "2020-03-26T11:46:56Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.datadog.profiling.exceptions;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"datadog.ExceptionSample\")\n+@Label(\"ExceptionSample\")\n+@Description(\"Datadog exception sample event.\")\n+@Category(\"Datadog\")\n+public class ExceptionSampleEvent extends Event {\n+  @Label(\"Exception Type\")\n+  private String type;\n+\n+  @Label(\"Exception message\")\n+  private final String message;\n+\n+  @Label(\"Exception stackdepth\")\n+  private final int stackDepth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxOTMyMTg3", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#pullrequestreview-381932187", "createdAt": "2020-03-26T11:48:50Z", "commit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0ODo1MFrOF8DMMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0ODo1MFrOF8DMMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTE1Mw==", "bodyText": "I do not think this is used", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398511153", "createdAt": "2020-03-26T11:48:50Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java", "diffHunk": "@@ -108,6 +108,10 @@ public boolean add(final List<DDSpan> trace) {\n     GlobalTracer.registerIfAbsent((datadog.trace.api.Tracer) TEST_TRACER);\n   }\n \n+  protected static Instrumentation getInstrumentation() {\n+    return INSTRUMENTATION;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2554, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}