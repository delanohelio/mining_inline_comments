{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMzI5Njk2", "number": 1739, "title": "Out-of-Order Scope Close Handling", "bodyText": "The functional part of this change is simply improving out-of-order close behavior.\nPreviously, given a stack C, B, A...\nIf B was closed out-of-order, then C would be left on-top.\nOnce C was closed, B would be restored to the top of stack.\nBut B would need to be closed again, which would in turn restore C.\nThis behavior could then lead to unbounded stack growth.\nThe new code behaves better -- given a stack C, B, A...\nIf B is closed out-of-order, then C would be left on-top\nOnce C is closed, the stack will skip over B, since it is already closed -- returning to A.\nThen A can be closed properly (without any additional closes of B or C).\nUltimately, this doesn't entirely eliminate the possibility of having the stack grow indefinitely,\nbut I believe it does reduce it significantly.\nIn hindsight, this could have been achieved via the toRestore field already on\nContinuableScope, but I've elected to implemented a conventional stack instead.\nThe stack clean-up works by cleaning up the stack on querying active / activeScope.\nAt access time, the ContinuableScopeManager checks if the ContinuableScope is still active.\nIf it isn't, then the stack top is moved back a scope at a time until an active\nscope is found.\nTo avoid doing the clean-up often, the stack is proactively unwound on a normal close in\nContinuableScope.close.\nChanged inner-classes to be static to make class boundaries more apparent\nDropped the toRestore & depth fields from ContinuableScope\nRestoration is now managed via ContinuableScope[]\ndepth is no longer tracked on the ContinuableScope, but instead tracked by the\ntopPos member of ScopeStack\nIn this change, I've taken care to maintain the existing reference counting &\nnotification semantics -- despite my general feeling that they are not\ncompletely intuitive or correct.\nI've also taken care to do minimum of moving code around -- including in tests\nto make the change easier to review for correctness.\nAs such, most things have a 1-to-1 replacement...\n\nContinuableScope.depth -> ContinuableScopeManager.ScopeStack.depth\nContinuableScope.toRestore linked list -> ScopeManager.stack\nContinuableScopeManager.tlsScope.remove -> ContinuableScopeManager.ScopeStack.clear", "createdAt": "2020-08-03T18:24:29Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1739", "merged": true, "mergeCommit": {"oid": "1f343781fb85ea3a262e066fa8809ca1ad032441"}, "closed": true, "closedAt": "2020-08-05T18:22:33Z", "author": {"login": "dougqh"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6WbuWgH2gAyNDYyMzI5Njk2OjJjZGY0NTk5YjgxOWE2ZGE0YTVjOTJjMjU1ZmM4ZGIxZjA2MmFjZTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc796UDgFqTQ2MTc5NTMzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2cdf4599b819a6da4a5c92c255fc8db1f062ace9", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2cdf4599b819a6da4a5c92c255fc8db1f062ace9", "committedDate": "2020-07-31T16:01:53Z", "message": "Explicitly pass scopeManager\n\nBeginning to unravel messy object divisions by making pass of scopeManager explicit -- rather than using instance inner classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9fdd8684b8441f816bd408694e7ca1206700623", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e9fdd8684b8441f816bd408694e7ca1206700623", "committedDate": "2020-07-31T19:14:00Z", "message": "Replacing scope link list with a proper stack\n\nReplacing the scope link list with a thread local stack\n\nAs the first step - using a non-performant java.util.Stack\nIt will be replaced in a subsequent change\n\nFixing ScopeManagerTest to not probe the internals of the ScopeManager object"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bd51dd908b0b8b5238faeaa6a47ef69a46fac92", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1bd51dd908b0b8b5238faeaa6a47ef69a46fac92", "committedDate": "2020-07-31T19:22:27Z", "message": "Replacing Stack with ArrayList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de0e48ea8afea4c8ed1b6b39191ec81c315beee", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8de0e48ea8afea4c8ed1b6b39191ec81c315beee", "committedDate": "2020-08-03T18:19:46Z", "message": "Final step in introducing stack & handling out-of-order close\n\nReplaced the ArrayList with a ContinuableScope[] in ScopeStack\n\nDropped the toRestore & depth fields from ContinuableScope\nRestoration is now managed via ContinuableScope[]\ndepth is no longer tracked on the ContinuableScope, but instead tracked by the\ntopPos member of ScopeStack\n\nIn this change, I've taken care to maintain the existing reference counting &\nnotification semantics -- despite my general feeling that they are not\ncompletely intuitive or correct.\n\nI've also taken care to do minimum of moving code around -- including in tests\nto make the change easier to review for correctness.\n\nAs such, most things have a 1-to-1 replacement...\n- ContinuableScope.depth -> ContinuableScopeManager.ScopeStack.depth\n- ContinuableScope.toRestore linked list -> ScopeManager.stack\n- ContinuableScopeManager.tlsScope.remove -> ContinuableScopeManager.ScopeStack.clear\n\nThe functional part of this change is simply improving out-of-order close behavior.\n\nPreviously, given a stack C, B, A...\nIf B was closed out-of-order, then C would be left on-top.\nOnce C was closed, B would be restored to the top of stack.\nBut B would need to close again to proper close A.\n\nIf B was not closed twice, then the stack could grow indefinitely.\n\nThe new code behaves a bit better -- given a stack C, B, A...\nIf B is closed out-of-order, then C would left on-top\nOnce C is closed, the stack will skip over B, since it is already closed -- returning to A.\nThen A can be closed properly with an extra close of B.\n\nThis doesn't eliminate the possibility of having the stack grow indefinitely,\nbut I believe it does reduce it significantly.\n\nIn hindsight, this could have been achieved via the toRestore field already on\nContinuableScope, but I've elected to implemented a conventional stack instead.\n\nThe stack clean-up works by cleaning up the stack on querying active / activeScope.\nAt access time, the ContinuableScopeManager checks if the ContinuableScope is still active.\nIf it isn't, then the stack top is moved back a scope at a time until an active\nscope is found.\n\nTo avoid doing the clean-up often, the stack is proactively unwound on a normal close in\nContinuableScope.close."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa31e4ed6547e6d5ec036f4801dbbbab6014347d", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fa31e4ed6547e6d5ec036f4801dbbbab6014347d", "committedDate": "2020-08-03T19:17:55Z", "message": "Fixing previously overlooked OpenTel wrapper change\n\nThe OpenTel test was checking for the old out-of-order close behavior.  The test has been revised to reflect the new behavior."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32b556328665644b8ac5b97238d441c4cdd0628a", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/32b556328665644b8ac5b97238d441c4cdd0628a", "committedDate": "2020-08-03T19:48:25Z", "message": "Restoring imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/157fe113d6b84069d6beef7d519f23ca00c49410", "committedDate": "2020-08-03T20:16:45Z", "message": "Fixing the same problem in the OpenTracing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzEzNTM2", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460313536", "createdAt": "2020-08-03T20:18:58Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo1OFrOG7HYlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo1OFrOG7HYlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDE0OQ==", "bodyText": "Stack now unwinds back to empty step on next request for currentSpan", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464640149", "createdAt": "2020-08-03T20:18:58Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentelemetry/src/test/groovy/OpenTelemetryTest.groovy", "diffHunk": "@@ -223,14 +223,9 @@ class OpenTelemetryTest extends AgentTestRunner {\n     secondScope.close()\n \n     then:\n-    tracer.currentSpan.delegate == firstScope.delegate.span()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzEzNzM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460313737", "createdAt": "2020-08-03T20:19:22Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToyMlrOG7HZQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToyMlrOG7HZQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDMyMA==", "bodyText": "Stack now unwinds back to empty on next call to active", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464640320", "createdAt": "2020-08-03T20:19:22Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.31/src/test/groovy/OpenTracing31Test.groovy", "diffHunk": "@@ -239,14 +239,7 @@ class OpenTracing31Test extends AgentTestRunner {\n     secondScope.close()\n \n     then:\n-    tracer.scopeManager().active().delegate == firstScope.delegate\n-    0 * _\n-\n-    when:\n-    firstScope.close()\n-\n-    then:\n-    0 * _\n+    assert tracer.scopeManager().active() == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f187b73671bc54c8569ad7d3701a926c7550ffd6", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f187b73671bc54c8569ad7d3701a926c7550ffd6", "committedDate": "2020-08-03T20:35:18Z", "message": "Removing stray commented out code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzIzNzg5", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460323789", "createdAt": "2020-08-03T20:36:53Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNjo1NFrOG7H5oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNjo1NFrOG7H5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODYwOQ==", "bodyText": "depth moved from ContinuableScope to ScopeStack", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648609", "createdAt": "2020-08-03T20:36:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -66,15 +74,21 @@ private ContinuableScopeManager(\n \n   @Override\n   public AgentScope activate(final AgentSpan span, final ScopeSource source) {\n-    final ContinuableScope active = tlsScope.get();\n+    ScopeStack scopeStack = scopeStack();\n+\n+    final ContinuableScope active = scopeStack.top();\n     if (active != null && active.span().equals(span)) {\n-      return active.incrementReferences();\n+      active.incrementReferences();\n+      return active;\n     }\n-    final int currentDepth = active == null ? 0 : active.depth();\n+\n+    // DQH - This check could go before the check above, since depth limit checking is fast\n+    final int currentDepth = scopeStack.depth();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzI0MjQ2", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460324246", "createdAt": "2020-08-03T20:37:38Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNzozOFrOG7H6_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNzozOFrOG7H6_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODk1OQ==", "bodyText": "tlsScope.set becomes scopeStack().push\nscopeStack is ThreadLocal", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648959", "createdAt": "2020-08-03T20:37:38Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzI0NTY0", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460324564", "createdAt": "2020-08-03T20:38:09Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozODoxMFrOG7H7-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozODoxMFrOG7H7-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTIxMA==", "bodyText": "tlsScope.get becomes scopeStack().top()\ntop() is the fix-up version that unwinds the stack if necessary", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649210", "createdAt": "2020-08-03T20:38:10Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);\n     scope.afterActivated();\n     return scope;\n   }\n \n   @Override\n   public TraceScope active() {\n-    return tlsScope.get();\n+    return scopeStack().top();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzI1MjUy", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460325252", "createdAt": "2020-08-03T20:39:22Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozOToyMlrOG7H-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozOToyMlrOG7H-Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw==", "bodyText": "I switched away from instance inner classes to static inner classes to make the boundaries more clear.\nI think this code could be organized better, but for the moment, I didn't move things around much to keep the diff to a minimum.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649763", "createdAt": "2020-08-03T20:39:22Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +122,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzI2MzM1", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460326335", "createdAt": "2020-08-03T20:41:14Z", "commit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MToxNFrOG7IBgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MToxNFrOG7IBgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDYyNQ==", "bodyText": "set(toRestore) becomes scopeStack().blindPop().\nblindPop -- pops the stack without checking what's on top.  The top checking was done above in the same fashion as the original code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464650625", "createdAt": "2020-08-03T20:41:14Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -159,18 +192,35 @@ public void close() {\n       if (null != continuation) {\n         span().context().getTrace().cancelContinuation(continuation);\n       }\n-      tlsScope.set(toRestore);\n+      if (onTop) scopeStack.blindPop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5786715129eb7310febc21ad45b9f913d432e8f", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c5786715129eb7310febc21ad45b9f913d432e8f", "committedDate": "2020-08-03T20:49:12Z", "message": "Adding comments explaining the various ScopeStack methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e62a411455e3056f6287da17805c8f9bf7e8831", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3e62a411455e3056f6287da17805c8f9bf7e8831", "committedDate": "2020-08-03T21:00:11Z", "message": "Misc clean-up\n\nFixed errant stackRef intended to be stack\nAdded / clarified comments\nConsistently applied final"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzM5MjI2", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460339226", "createdAt": "2020-08-03T21:03:00Z", "commit": {"oid": "3e62a411455e3056f6287da17805c8f9bf7e8831"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMzowMVrOG7IpHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMzowMVrOG7IpHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2MDc2NA==", "bodyText": "I could have changed the value in the assert.\nOr, remove the bounds check mistake here.\nI chose to do the latter.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464660764", "createdAt": "2020-08-03T21:03:01Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerDepthTest.groovy", "diffHunk": "@@ -61,22 +61,22 @@ class ScopeManagerDepthTest extends DDSpecification {\n \n     when: \"fill up the scope stack\"\n     AgentScope scope = null\n-    for (int i = 0; i <= defaultLimit; i++) {\n+    for (int i = 0; i < defaultLimit; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e62a411455e3056f6287da17805c8f9bf7e8831"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "author": {"user": {"login": "dougqh", "name": "Douglas Q Hawkins"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d707e6de5ef65ea16f8413ba7ed062291aff1a97", "committedDate": "2020-08-04T15:21:20Z", "message": "Re-running spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTY4MDc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460968076", "createdAt": "2020-08-04T16:17:10Z", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoxNzoxMFrOG7nuxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoxNzoxMFrOG7nuxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MDExNw==", "bodyText": "this is an assignment to a local and is never reflected onto the instance\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stack = Arrays.copyOf(stack, stack.length >> 1);\n          \n          \n            \n                        this.stack = Arrays.copyOf(stack, stack.length >> 1);", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465170117", "createdAt": "2020-08-04T16:17:10Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 243}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTcwNDIy", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460970422", "createdAt": "2020-08-04T16:20:07Z", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMDowN1rOG7n2FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMDowN1rOG7n2FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MTk4OA==", "bodyText": "What about reserving a null first element of the array and adding 1 to every position?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465171988", "createdAt": "2020-08-04T16:20:07Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 264}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTcyMTE3", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460972117", "createdAt": "2020-08-04T16:22:17Z", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMjoxN1rOG7n7Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMjoxN1rOG7n7Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MzMxMA==", "bodyText": "Which tests need to be removed to avoid this?\nIt feels like it's a good practice to clear the array out ASAP, i.e. in the stack's pop method. Does something prevent this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465173310", "createdAt": "2020-08-04T16:22:17Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length << 1);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      if (topPos == -1) return false;\n+\n+      return stack[topPos].equals(expectedScope);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos + 1;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 311}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTczMzYw", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460973360", "createdAt": "2020-08-04T16:23:48Z", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMzo0OFrOG7n_AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMzo0OFrOG7n_AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NDI3Mw==", "bodyText": "There's only one template in the pattern, but two parameters\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n          \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465174273", "createdAt": "2020-08-04T16:23:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTc1MzA0", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-460975304", "createdAt": "2020-08-04T16:26:09Z", "commit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNjowOVrOG7oE_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNjowOVrOG7oE_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA==", "bodyText": "I hate to bikeshed but I have a strong aversion to unbraced conditional statements because I've been burnt by them in the past.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465175804", "createdAt": "2020-08-04T16:26:09Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzgzMDg2", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-461783086", "createdAt": "2020-08-05T15:34:37Z", "commit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozNDozN1rOG8PK7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozNDozN1rOG8PK7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjMwMw==", "bodyText": "Nice touch using slot 0 as a holder for null to avoid the -1 math and checks.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465816303", "createdAt": "2020-08-05T15:34:37Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -308,7 +311,6 @@ final ContinuableScope top() {\n      * useful in logging to avoid side effects, but could be used in other places with caution.\n      */\n     final ContinuableScope noFixupTop() {\n-      if (topPos == -1) return null;\n       return stack[topPos];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzk1MzUz", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-461795353", "createdAt": "2020-08-05T15:48:27Z", "commit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyOFrOG8PwUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyOFrOG8PwUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg3Mg==", "bodyText": "leftover?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825872", "createdAt": "2020-08-05T15:48:28Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzk2MzE1", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-461796315", "createdAt": "2020-08-05T15:49:33Z", "commit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31cd244b968a657400cf6be1971f408e385de974", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/31cd244b968a657400cf6be1971f408e385de974", "committedDate": "2020-08-05T16:00:37Z", "message": "tweaks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "committedDate": "2020-08-05T15:31:33Z", "message": "tweaks"}, "afterCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/31cd244b968a657400cf6be1971f408e385de974", "committedDate": "2020-08-05T16:00:37Z", "message": "tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODA3MDY1", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-461807065", "createdAt": "2020-08-05T16:01:51Z", "commit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNzk1MzM1", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#pullrequestreview-461795335", "createdAt": "2020-08-05T15:48:26Z", "commit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyNlrOG8PwPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjozMToyN1rOG8ReeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg1NQ==", "bodyText": "Do we really want this to be protected?  Perhaps private?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825855", "createdAt": "2020-08-05T15:48:26Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNjYxMg==", "bodyText": "Delete?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465826612", "createdAt": "2020-08-05T15:49:36Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMDA2Mg==", "bodyText": "I'm actually a little surprised... I assumed that this was in violation to google-java-format but the check passed.  I'd support making this a build failure somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465830062", "createdAt": "2020-08-05T15:54:37Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA=="}, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTIyMQ==", "bodyText": "The cost of noFixupTop seems minimal.  Perhaps we don't need the guard clause here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831221", "createdAt": "2020-08-05T15:56:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTgwMg==", "bodyText": "I had the same debate when I worked on this a few months ago...", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831802", "createdAt": "2020-08-05T15:57:13Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +122,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw=="}, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMjM4NA==", "bodyText": "Not related to this PR, but we should encapsulate this in the Monitor...", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465832384", "createdAt": "2020-08-05T15:58:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");\n \n         if (source == ScopeSource.MANUAL) {\n-          statsDClient.incrementCounter(\"scope.user.close.error\");\n+          scopeManager.statsDClient.incrementCounter(\"scope.user.close.error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0Mzc2NQ==", "bodyText": "How did you decide on 16?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465843765", "createdAt": "2020-08-05T16:15:55Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0NDc1MQ==", "bodyText": "Looks like this is intended to reduce the size of the stack. Please comment and maybe extract to a separate method?\nAlso, do we need to set a minimum for the default size?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465844751", "createdAt": "2020-08-05T16:17:24Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MDMwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n          \n          \n            \n                 * Pushes a new scope onto the current stack, the new scope is pushed onto the stack without", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465850304", "createdAt": "2020-08-05T16:25:44Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MTM5MQ==", "bodyText": "Should we have a separate methods to handle growing/shrinking the stack?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465851391", "createdAt": "2020-08-05T16:27:23Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1NDA3Mw==", "bodyText": "seems like the next call to top() would result in shrinking the array.  Consider setting a new array with default/minimum size instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465854073", "createdAt": "2020-08-05T16:31:27Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      return expectedScope.equals(stack[topPos]);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests\n+    final void clear() {\n+      topPos = 0;\n+      Arrays.fill(stack, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 312}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2076, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}