{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMDAzNjc4", "number": 1962, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOToyMDowMlrOEr-HkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOToyMDowMlrOEr-HkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTQxOTY4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/monitor/CPUTimer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOToyMDowMlrOHfB9Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMDoxOToxN1rOHfD4Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMDAwMw==", "bodyText": "I don't think this is necessary.", "url": "https://github.com/DataDog/dd-trace-java/pull/1962#discussion_r502300003", "createdAt": "2020-10-09T09:20:02Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/monitor/CPUTimer.java", "diffHunk": "@@ -23,21 +21,25 @@\n   @Override\n   public Recording start() {\n     super.start();\n-    this.start = threadMXBean.getCurrentThreadCpuTime();\n+    this.start = SystemAccess.getCurrentThreadCpuTime();\n     return this;\n   }\n \n   @Override\n   public void reset() {\n-    long cpuNanos = threadMXBean.getCurrentThreadCpuTime();\n-    this.cpuTime += (cpuNanos - start);\n+    long cpuNanos = SystemAccess.getCurrentThreadCpuTime();\n+    if (start > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00dc98dbb4e9a11df355a7913c3faa555db00e47"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMTM5NA==", "bodyText": "it's necessary to handle the case where we have CPU timers in place before we make JMX available - in such cases the cpu time will be negative while JMX is not yet ready (that's the current contract in the SystemAccess javadoc) and we won't bother aggregating it. As soon as JMX is up then we will aggregate CPU time.\nThis also matches how the profiler uses this method in ScopeEvent: \n  \n    \n      dd-trace-java/dd-trace-core/jfr-openjdk/src/main/java/datadog/trace/core/jfr/openjdk/ScopeEvent.java\n    \n    \n         Line 52\n      in\n      e4331fb\n    \n    \n    \n    \n\n        \n          \n           if (cpuTime > 0) {", "url": "https://github.com/DataDog/dd-trace-java/pull/1962#discussion_r502331394", "createdAt": "2020-10-09T10:19:17Z", "author": {"login": "mcculls"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/monitor/CPUTimer.java", "diffHunk": "@@ -23,21 +21,25 @@\n   @Override\n   public Recording start() {\n     super.start();\n-    this.start = threadMXBean.getCurrentThreadCpuTime();\n+    this.start = SystemAccess.getCurrentThreadCpuTime();\n     return this;\n   }\n \n   @Override\n   public void reset() {\n-    long cpuNanos = threadMXBean.getCurrentThreadCpuTime();\n-    this.cpuTime += (cpuNanos - start);\n+    long cpuNanos = SystemAccess.getCurrentThreadCpuTime();\n+    if (start > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMDAwMw=="}, "originalCommit": {"oid": "00dc98dbb4e9a11df355a7913c3faa555db00e47"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4686, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}