{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzQ2NjEy", "number": 1916, "title": "Add delay before Pending Trace submits to Writer", "bodyText": "The delay allows additional async work to be added to the trace as long as it completes in a reasonable period.\nThis allows us to relax restrictions on reporting traces in PendingTrace in a future PR.", "createdAt": "2020-09-25T20:10:30Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1916", "merged": true, "mergeCommit": {"oid": "6e35307acdab02dd039f64b65d7d64237bfa9738"}, "closed": true, "closedAt": "2020-10-05T20:58:52Z", "author": {"login": "tylerbenson"}, "timelineItems": {"totalCount": 71, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMb1KjABqjM4MDkyODM2OTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPyYxygFqTUwMjYxNzMwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82f246afdc2b4840882272c439cd25f563037518", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/82f246afdc2b4840882272c439cd25f563037518", "committedDate": "2020-09-25T20:06:09Z", "message": "Update Tests"}, "afterCommit": {"oid": "c0996df6e55fa448f2ce7845b1ebc33efc323ff7", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c0996df6e55fa448f2ce7845b1ebc33efc323ff7", "committedDate": "2020-09-25T20:29:24Z", "message": "Update Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ea6441a6065dc5bba2c4abf633418c3b188a8a8", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1ea6441a6065dc5bba2c4abf633418c3b188a8a8", "committedDate": "2020-09-28T14:30:50Z", "message": "Add small delay before writing traces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dfe51a55d4c17f2a43c11f0474886e227645e6a", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3dfe51a55d4c17f2a43c11f0474886e227645e6a", "committedDate": "2020-09-28T14:30:50Z", "message": "Update Tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b08ae05bd965470b538adfeba832e0888308bf97", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b08ae05bd965470b538adfeba832e0888308bf97", "committedDate": "2020-09-25T23:15:35Z", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests."}, "afterCommit": {"oid": "cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "committedDate": "2020-09-28T14:30:50Z", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/376a716c454a5bcbd86272f595c185513a019b13", "committedDate": "2020-09-28T15:05:01Z", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/cd7db9725faa13d44e1f9ef3adf5bb950823d6d1", "committedDate": "2020-09-28T14:30:50Z", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests."}, "afterCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/376a716c454a5bcbd86272f595c185513a019b13", "committedDate": "2020-09-28T15:05:01Z", "message": "Flush PendingTrace buffer in AgentTestRunner\n\nTo improve test reliability by ensuring delayed traces don't leak between tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NjgyMDAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497682000", "createdAt": "2020-09-28T16:06:18Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNjoxOFrOHZFgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNjoxOFrOHZFgGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA==", "bodyText": "This is disabled by default, I would keep it in", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496066584", "createdAt": "2020-09-28T16:06:18Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NjgyOTM0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497682934", "createdAt": "2020-09-28T16:07:21Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNzoyMlrOHZFinw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNzoyMlrOHZFinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NzIzMQ==", "bodyText": "Why ConcurrentLinkedQueue? Less contention? We have JCTools as a dependency now, consider using it here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496067231", "createdAt": "2020-09-28T16:07:22Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Njg0MTM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497684137", "createdAt": "2020-09-28T16:08:48Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowODo0OFrOHZFmBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowODo0OFrOHZFmBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2ODEwMw==", "bodyText": "I think we should rework this to initialise the thread in the constructor and start the thread here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496068103", "createdAt": "2020-09-28T16:08:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Njg3NDU2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497687456", "createdAt": "2020-09-28T16:12:49Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxMjo0OVrOHZFwWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxMjo0OVrOHZFwWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA==", "bodyText": "I tend to use Thread.currentThread().isInterrupted() because it doesn't clear the interrupted status, not sure this is important though.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496070744", "createdAt": "2020-09-28T16:12:49Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Njg5NDc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497689476", "createdAt": "2020-09-28T16:15:18Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNToxOFrOHZF2iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNToxOFrOHZF2iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ==", "bodyText": "I think it would be better to block (call take()) here than sleep and poll", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496072329", "createdAt": "2020-09-28T16:15:18Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NjkxNzEw", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497691710", "createdAt": "2020-09-28T16:17:52Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNzo1MlrOHZF9SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNzo1MlrOHZF9SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng==", "bodyText": "if we just do this in the constructor we can't create 2 of them", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496074056", "createdAt": "2020-09-28T16:17:52Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzAwNjAy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497700602", "createdAt": "2020-09-28T16:28:48Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoyODo0OFrOHZGY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoyODo0OFrOHZGY3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MTExNg==", "bodyText": "How often will this be called? Can we reuse a timestamp here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496081116", "createdAt": "2020-09-28T16:28:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzAyNjY5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497702669", "createdAt": "2020-09-28T16:31:24Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMToyNFrOHZGfLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMToyNFrOHZGfLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ==", "bodyText": "I don't think we should do this. We are of secondary importance to the application. If we're shutting down, we need to shut down ASAP. Risking prevention of application shutdown to flush tracing data isn't right.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496082735", "createdAt": "2020-09-28T16:31:24Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzA0Mjgw", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497704280", "createdAt": "2020-09-28T16:33:31Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMzozMlrOHZGj8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMzozMlrOHZGj8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4Mzk1NQ==", "bodyText": "We can do this more efficiently with drainTo either on the BlockingQueue interface or JCTools drain method.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496083955", "createdAt": "2020-09-28T16:33:32Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzA1NDk1", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497705495", "createdAt": "2020-09-28T16:35:05Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozNTowNVrOHZGnmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozNTowNVrOHZGnmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDg4OA==", "bodyText": "We have a timestamp here - maybe we should pass it through.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496084888", "createdAt": "2020-09-28T16:35:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -102,6 +103,7 @@ public final void finish() {\n \n   @Override\n   public final void finish(final long stoptimeMicros) {\n+    context.getTrace().touch(); // Update timestamp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzMwNjgx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497730681", "createdAt": "2020-09-28T17:04:05Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzowNDowNVrOHZHxCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzowNDowNVrOHZHxCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ==", "bodyText": "Should this logic be encapsulated in PendingTrace so that it returns a boolean? What happens if someone unaware of this bit of logic here changes the time source it uses?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496103691", "createdAt": "2020-09-28T17:04:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzM2ODUz", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497736853", "createdAt": "2020-09-28T17:12:35Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMjozNlrOHZIDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMjozNlrOHZIDBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ==", "bodyText": "I assume waitForTraces is really wait for chunks written?\nI'm not sure that the tests should need to know about that.  That said, I think this is the pragmatic choice for now.\nBut long term, I think we should be waiting on a span count (preferably implied from the DSL) rather than having all the instrumentations tests know about the internal chunking of the publishing mechanism.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496108295", "createdAt": "2020-09-28T17:12:36Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzM3NTI5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497737529", "createdAt": "2020-09-28T17:13:34Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMzozNFrOHZIFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMzozNFrOHZIFFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODgyMg==", "bodyText": "Fine for now, but this is another case of coupling the tests to the internals of the publishing system.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496108822", "createdAt": "2020-09-28T17:13:34Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "diffHunk": "@@ -123,6 +123,11 @@ class OpenTracing32Test extends AgentTestRunner {\n     then:\n     (scope.span().delegate as DDSpan).isFinished() == finishSpan\n \n+    cleanup:\n+    if (finishSpan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzM4Njc5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497738679", "createdAt": "2020-09-28T17:15:08Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNTowOFrOHZIIoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNTowOFrOHZIIoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwOTcyOQ==", "bodyText": "I'm assuming this a non-functional reformatting.\nThis would be easier to review if those changes had been done in a separate commit -- preferably even a separate PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496109729", "createdAt": "2020-09-28T17:15:08Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/scala-concurrent/src/slickTest/groovy/SlickTest.groovy", "diffHunk": "@@ -62,14 +62,20 @@ class SlickTest extends AgentTestRunner {\n \n     // Expect two traces because two queries have been run\n     assertTraces(2) {\n-      trace(2, {\n-        span {}\n+      trace(2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzQwMzE4", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497740318", "createdAt": "2020-09-28T17:17:23Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNzoyNFrOHZINaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNzoyNFrOHZINaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg==", "bodyText": "Rather than sleeping, would it better to await completion?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496110952", "createdAt": "2020-09-28T17:17:24Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzQxNjIy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497741622", "createdAt": "2020-09-28T17:19:13Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxOToxM1rOHZIRUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxOToxM1rOHZIRUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMTk1NQ==", "bodyText": "Files.isDirectory would be a bit cleaner and allocate less -- not that allocation is a problem in test", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496111955", "createdAt": "2020-09-28T17:19:13Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "diffHunk": "@@ -65,6 +65,8 @@ abstract class AbstractSmokeTest extends Specification {\n     if (buildDirectory == null || shadowJarPath == null) {\n       throw new AssertionError(\"Expected system properties not found. Smoke tests have to be run from Gradle. Please make sure that is the case.\")\n     }\n+    assert new File(buildDirectory).isDirectory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzQ0MzIx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497744321", "createdAt": "2020-09-28T17:22:59Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzU2MzE5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497756319", "createdAt": "2020-09-28T17:39:22Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMlrOHZI95w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMlrOHZI95w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw==", "bodyText": "I think we should take out this sleep (as mentioned elsewhere), but the handling of InterruptedException here is a bit odd.\nWe might as well let it bubble up and break the containing loop.  Right now, we catch it just to reset the interrupt status and then bail the loop later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496123367", "createdAt": "2020-09-28T17:39:22Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzU4Mzc3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497758377", "createdAt": "2020-09-28T17:42:23Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0MjoyM1rOHZJETA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0MjoyM1rOHZJETA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA==", "bodyText": "Given that the queue is shared, sleeping here seems questionable.  I think if a new PendingTrace comes in, we want to wake up and evaluate it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496125004", "createdAt": "2020-09-28T17:42:23Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzYwMzMx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497760331", "createdAt": "2020-09-28T17:44:59Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0NDo1OVrOHZJKYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0NDo1OVrOHZJKYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjU2Mg==", "bodyText": "This comment is kind of cryptic.  And if we don't need to write, maybe, we should call a cleanUp routine directly instead.  I think that would be more clear.\nAlso, given that I don't think a PendingTrace has a definitive end, I'm curious what clean-up we are doing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496126562", "createdAt": "2020-09-28T17:44:59Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzYyMzM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497762337", "createdAt": "2020-09-28T17:47:54Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0Nzo1NFrOHZJRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0Nzo1NFrOHZJRIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODI5MA==", "bodyText": "This time is probably now a bit misleading.  We might want to put this to be around the actual write.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128290", "createdAt": "2020-09-28T17:47:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?\n       try (Recording recording = tracer.writeTimer()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzYyOTE1", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497762915", "createdAt": "2020-09-28T17:48:46Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0ODo0NlrOHZJS8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0ODo0NlrOHZJS8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODc1Mg==", "bodyText": "timer here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128752", "createdAt": "2020-09-28T17:48:46Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzYzMTkz", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497763193", "createdAt": "2020-09-28T17:49:13Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OToxNFrOHZJT6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OToxNFrOHZJT6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTAwMA==", "bodyText": "Should this have a health metric?  Should we track how many times we re-enqueue?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129000", "createdAt": "2020-09-28T17:49:14Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzYzNTEx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497763511", "createdAt": "2020-09-28T17:49:41Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OTo0MlrOHZJU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OTo0MlrOHZJU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI0OQ==", "bodyText": "timer here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129249", "createdAt": "2020-09-28T17:49:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzY1MTU5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497765159", "createdAt": "2020-09-28T17:51:59Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1MTo1OVrOHZJaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1MTo1OVrOHZJaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMDYyNw==", "bodyText": "Why the call to activeSpan?  Are we relying on some side-effect in the test?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496130627", "createdAt": "2020-09-28T17:51:59Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-data-1.8/src/test/groovy/SpringJpaTest.groovy", "diffHunk": "@@ -37,10 +39,14 @@ class SpringJpaTest extends AgentTestRunner {\n   }\n \n   def \"test CRUD\"() {\n+    JpaCustomerRepository repo\n     // moved inside test -- otherwise, miss the opportunity to instrument\n-    def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n-    def repo = context.getBean(JpaCustomerRepository)\n-\n+    def setupSpan = runUnderTrace(\"setup\") {\n+      def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n+      repo = context.getBean(JpaCustomerRepository)\n+      activeSpan()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Nzc0MTQx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-497774141", "createdAt": "2020-09-28T18:04:28Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODowNDoyOFrOHZJ2Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODowNDoyOFrOHZJ2Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNzc1MQ==", "bodyText": "isWritten doesn't need to be AtomicBoolean if we're going to synchronize anyway.  This could simply be a volatile.\n\nThis part doesn't have to be fixed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496137751", "createdAt": "2020-09-28T18:04:28Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,7 +277,7 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d67779f990f36957ed9109f21abc18faabcb61dc", "committedDate": "2020-09-28T21:48:10Z", "message": "Various code review fixes\n\n* Switched to a blocking queue\n* Removed SpanCleaner and queued tasks directly\n* Changed thread init behavior for PendingTraceBuffer\n* Added PendingTrace.Factory to improve interactions for creation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTYyMzIy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498562322", "createdAt": "2020-09-29T14:55:35Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NTozNVrOHZxcSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NTozNVrOHZxcSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjUwNQ==", "bodyText": "Yes, I appreciate we're dealing with technical debt pragmatically here, but it would be nice not to need to do things like this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786505", "createdAt": "2020-09-29T14:55:35Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -83,6 +83,13 @@\n   private static final String LANG_INTERPRETER_VENDOR_STATSD_TAG = \"lang_interpreter_vendor\";\n   private static final String TRACER_VERSION_STATSD_TAG = \"tracer_version\";\n \n+  // FIXME: This is static instead of instance because we don't reliably close the tracer in tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTYyODU2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498562856", "createdAt": "2020-09-29T14:56:04Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NjowNFrOHZxd3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NjowNFrOHZxd3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjkxMA==", "bodyText": "nice", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786910", "createdAt": "2020-09-29T14:56:04Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -120,8 +130,10 @@ public void touch() {\n     lastReferenced = Clock.currentNanoTicks();\n   }\n \n-  public long getLastReferenced() {\n-    return lastReferenced;\n+  public boolean lastReferencedNanosAgo(long nanos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTY0ODU3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498564857", "createdAt": "2020-09-29T14:57:55Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1Nzo1NVrOHZxjxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1Nzo1NVrOHZxjxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODQyMA==", "bodyText": "I would consider making this quite a lot bigger", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788420", "createdAt": "2020-09-29T14:57:55Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTY1NTc2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498565576", "createdAt": "2020-09-29T14:58:35Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1ODozNVrOHZxlug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1ODozNVrOHZxlug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODkyMg==", "bodyText": "Maybe allocate a private static final instance", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788922", "createdAt": "2020-09-29T14:58:35Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTg1NTM0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498585534", "createdAt": "2020-09-29T15:07:54Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowNzo1NFrOHZyB2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowNzo1NFrOHZyB2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjEyMg==", "bodyText": "I believe this was where the Thread.join() was, and is no longer here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496796122", "createdAt": "2020-09-29T15:07:54Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTg4ODg1", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498588885", "createdAt": "2020-09-29T15:09:42Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjEzNTE5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498613519", "createdAt": "2020-09-29T15:26:12Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNToyNjoxMlrOHZzAVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNToyNjoxMlrOHZzAVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw==", "bodyText": "So I'm a bit afraid that holding back traces when we actually reach zero will make all our traces back up in this buffer, while it's actually only the ones that were we don't reach zero that we need to force flush at a certain interval.\nWhat is it that we want to achieve longterm with this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496812117", "createdAt": "2020-09-29T15:26:12Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjgxNDcy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498681472", "createdAt": "2020-09-29T16:40:24Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0MDoyNFrOHZ3c3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0MDoyNFrOHZ3c3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NDk1Ng==", "bodyText": "Rather than doing an instanceof check on DDAgentWriter, it would make more sense to add a flush method onto the Writer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496884956", "createdAt": "2020-09-29T16:40:24Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -487,10 +492,19 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();\n+    if (writer instanceof DDAgentWriter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjgzMzIx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498683321", "createdAt": "2020-09-29T16:42:41Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0Mjo0MVrOHZ3iaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0Mjo0MVrOHZ3iaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NjM3Ng==", "bodyText": "Should the constructor be public?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496886376", "createdAt": "2020-09-29T16:42:41Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -26,17 +25,32 @@\n \n @Slf4j\n public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements AgentTrace {\n+  private static final long CLEAN_FREQUENCY = 1;\n \n-  static PendingTrace create(final CoreTracer tracer, final DDId traceId) {\n-    final PendingTrace pendingTrace = new PendingTrace(tracer, traceId);\n-    pendingTrace.addPendingTrace();\n-    return pendingTrace;\n-  }\n+  public static class Factory {\n+    private final CoreTracer tracer;\n+    private final PendingTraceBuffer pendingTraceBuffer;\n+\n+    public Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Njg1NjE5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498685619", "createdAt": "2020-09-29T16:45:41Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0NTo0MVrOHZ3p9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0NTo0MVrOHZ3p9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ==", "bodyText": "Okay, so short-circuit clean-up if we've already written.\nI still need clarification on the lifecycle of PendingTrace object to understand if this is correct.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496888309", "createdAt": "2020-09-29T16:45:41Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjkzNjI0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498693624", "createdAt": "2020-09-29T16:55:30Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NTozMFrOHZ4DXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NTozMFrOHZ4DXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NDgxNQ==", "bodyText": "Can you explain a bit more what's happening here?\nWhy do we need to start & wait now?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496894815", "createdAt": "2020-09-29T16:55:30Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanContextTest.groovy", "diffHunk": "@@ -7,6 +7,10 @@ import datadog.trace.util.test.DDSpecification\n \n class DDSpanContextTest extends DDSpecification {\n \n+  def setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Njk0OTk5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498694999", "createdAt": "2020-09-29T16:57:11Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NzoxMlrOHZ4HgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NzoxMlrOHZ4HgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NTg3Mw==", "bodyText": "As aside, I think we could have maintained the old API and that would have kept the diff easier to read.\nPending.create could internally do tracer.pendingTraceFactory.create.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496895873", "createdAt": "2020-09-29T16:57:12Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanSerializationTest.groovy", "diffHunk": "@@ -138,7 +138,7 @@ class DDSpanSerializationTest extends DDSpecification {\n       false,\n       null,\n       tags.size(),\n-      PendingTrace.create(tracer, DDId.ONE),\n+      tracer.pendingTraceFactory.create(DDId.ONE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Njk2ODgy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498696882", "createdAt": "2020-09-29T16:59:28Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1OToyOFrOHZ4NGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1OToyOFrOHZ4NGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzMwNA==", "bodyText": "I'd like to understand why we needed to add this in so many places.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496897304", "createdAt": "2020-09-29T16:59:28Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerTest.groovy", "diffHunk": "@@ -97,6 +98,7 @@ class ScopeManagerTest extends DDSpecification {\n \n     when:\n     span.finish()\n+    writer.waitForTraces(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4Njk4ODU0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498698854", "createdAt": "2020-09-29T17:01:55Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NzI1ODk5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498725899", "createdAt": "2020-09-29T17:36:31Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzozNjozMVrOHZ5laQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzozNjozMVrOHZ5laQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxOTkxMw==", "bodyText": "Is this an anonymous function being immediately invoked?  Is this not equivalent to...\nTEST_WRITER.waitForTraces(1)\nwaitForTraces = true", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496919913", "createdAt": "2020-09-29T17:36:31Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/couchbase-2.0/src/test/groovy/CouchbaseClientTest.groovy", "diffHunk": "@@ -37,6 +37,11 @@ class CouchbaseClientTest extends AbstractCouchbaseTest {\n     cluster = CouchbaseCluster.create(environment, Arrays.asList(\"127.0.0.1\"))\n     manager = cluster.clusterManager(USERNAME, PASSWORD)\n     type = bucketSettings.type().name()\n+\n+    waitForTraces = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NzMwNDgw", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-498730480", "createdAt": "2020-09-29T17:42:17Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0MjoxN1rOHZ5zIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0MjoxN1rOHZ5zIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ==", "bodyText": "Can PENDING_TRACE_BUFFER.close raise an exception?\nIf so, this should have a try / finally.\nGenerally, I'd just assume closing logic, should do try / finally for each step for safety.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496923425", "createdAt": "2020-09-29T17:42:17Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -334,13 +357,15 @@ private void removePendingTrace() {\n   }\n \n   static void initialize() {\n+    PENDING_TRACE_BUFFER.start();\n     final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n     if (oldCleaner != null) {\n       oldCleaner.close();\n     }\n   }\n \n   static void close() {\n+    PENDING_TRACE_BUFFER.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MTQ5NDI0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-499149424", "createdAt": "2020-09-30T07:23:43Z", "commit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNzoyMzo0M1rOHaQd8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNzo0NTowNFrOHaRMZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5NDgzNA==", "bodyText": "I have a hard time following the wider implications of these changes. Will this mean that in the future when all reference counting is removed, we will flush any Trace with a Span that does work for longer than, or takes longer to  start than FORCE_SEND_DELAY_MS, which is currently 5 ms, and not report any more spans that happen after that or what will happen? I mean work taking more than 5 ms is not uncommon.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497294834", "createdAt": "2020-09-30T07:23:43Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;\n+    worker.interrupt();\n+  }\n+\n+  public void flush() {\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!closed && !Thread.currentThread().isInterrupted()) {\n+\n+        PendingTrace pendingTrace = queue.take(); // block until available.\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNjcyNQ==", "bodyText": "I completely agree that we need to clean up/remove the continuations, but I'm not so sure that we should remove all forms of reference counting, since I don't see how we can validate correctness of an instrumentation without some form of strict mode during testing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497306725", "createdAt": "2020-09-30T07:45:04Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTc0MTUx", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-500574151", "createdAt": "2020-10-01T17:36:48Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozNjo0OFrOHbUkHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozNjo0OFrOHbUkHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDUyNg==", "bodyText": "I suppose we only have one but I think AtomicReference might overkill.  volatile + double checking would be sufficient.  We can leave this as is.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498410526", "createdAt": "2020-10-01T17:36:48Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjU0NDM0", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-500654434", "createdAt": "2020-10-01T19:28:59Z", "commit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyODo1OVrOHbYFuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyODo1OVrOHbYFuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODI4MQ==", "bodyText": "I think the raciness of lastReferenced is fine, but I think this warrants a comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498468281", "createdAt": "2020-10-01T19:28:59Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "370050a84cd5b770df8bdfe56807cce6d95db62e", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/370050a84cd5b770df8bdfe56807cce6d95db62e", "committedDate": "2020-10-01T20:41:16Z", "message": "Fix handling for late arrival of spans\n\nMore code review fixes\n* Make PendingTrace.Factory package private\n* Increase buffer size\n* Various cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d75d7d2ffa76f4328a96b24ce3f3ab1e4d880c55", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d75d7d2ffa76f4328a96b24ce3f3ab1e4d880c55", "committedDate": "2020-10-01T20:43:32Z", "message": "Merge branch 'master' into tyler/pending-trace-delay\n\n# Conflicts:\n#\tdd-trace-core/src/main/java/datadog/trace/core/DDSpan.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47106517ba07afce1ebc1a232495a0dc8c6035fc", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/47106517ba07afce1ebc1a232495a0dc8c6035fc", "committedDate": "2020-10-01T21:34:45Z", "message": "More review and test fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7678312cfab45090d2fbd460c30c803ef87a57c2", "committedDate": "2020-10-02T20:44:16Z", "message": "Allow immediate writes if no remaining pending references\n\nUpdate the tests... was more complicated to test PendingTraceBuffer since it now requires continuations for root to be delayed.\n\nI removed the test that verifies the trace discarded if span GC'd because it is unreliable... the trace gets buffered and success depends on if GC cleaning happens before the buffer timeout expires."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f14e6e4f4ed71bffc25b05ea394af72ad63c96f6", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f14e6e4f4ed71bffc25b05ea394af72ad63c96f6", "committedDate": "2020-10-02T20:07:09Z", "message": "Allow immediate writes if no remaining pending references\n\nUpdate the tests... was more complicated to test PendingTraceBuffer since it now requires continuations for root to be delayed."}, "afterCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7678312cfab45090d2fbd460c30c803ef87a57c2", "committedDate": "2020-10-02T20:44:16Z", "message": "Allow immediate writes if no remaining pending references\n\nUpdate the tests... was more complicated to test PendingTraceBuffer since it now requires continuations for root to be delayed.\n\nI removed the test that verifies the trace discarded if span GC'd because it is unreliable... the trace gets buffered and success depends on if GC cleaning happens before the buffer timeout expires."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzAwNTU5", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502300559", "createdAt": "2020-10-05T18:10:20Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMDoyMFrOHcoN0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMDoyMFrOHcoN0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTA3NQ==", "bodyText": "Having to wait & clear everywhere is a code smell for me, but we'll leave improved testing for another PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499781075", "createdAt": "2020-10-05T18:10:20Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/HttpServletResponseTest.groovy", "diffHunk": "@@ -29,6 +29,7 @@ class HttpServletResponseTest extends AgentTestRunner {\n     // We need to call service so HttpServletAdvice can link the request to the response.\n     servlet.service((ServletRequest) request, (ServletResponse) response)\n     assert response.__datadogContext$javax$servlet$http$HttpServletResponse != null\n+    TEST_WRITER.waitForTraces(1)\n     TEST_WRITER.clear()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzAxNTMw", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502301530", "createdAt": "2020-10-05T18:11:41Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMTo0MlrOHcoQmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMTo0MlrOHcoQmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTc4NQ==", "bodyText": "Does this need a try / finally?  What's expected to happen with the writer if PendingTraceBuffer.flush raises an exception.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499781785", "createdAt": "2020-10-05T18:11:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -494,10 +499,17 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzA2MDI1", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502306025", "createdAt": "2020-10-05T18:17:52Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxNzo1MlrOHcodjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxNzo1MlrOHcodjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTEwMQ==", "bodyText": "What is being changed here?  Is this a non-functional change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499785101", "createdAt": "2020-10-05T18:17:52Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/CoreSpanBuilderTest.groovy", "diffHunk": "@@ -269,25 +269,24 @@ class CoreSpanBuilderTest extends DDSpecification {\n     // others are just for fun\n \n     def root = tracer.buildSpan(\"fake_O\").withServiceName(\"foo\").start()\n-    spans.add(root)\n \n-    final long tickEnd = System.currentTimeMillis()\n+    def lastSpan = root", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzA2OTY2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502306966", "createdAt": "2020-10-05T18:19:11Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxOToxMVrOHcogYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxOToxMVrOHcogYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTgyNA==", "bodyText": "I think we should get out the habit of poking into the internals as part of tests.\nAdmittedly, this case is borderline, since it is in the same package.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499785824", "createdAt": "2020-10-05T18:19:11Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceBufferTest.groovy", "diffHunk": "@@ -0,0 +1,303 @@\n+package datadog.trace.core\n+\n+import com.timgroup.statsd.NoOpStatsDClient\n+import datadog.trace.api.DDId\n+import datadog.trace.bootstrap.instrumentation.api.ScopeSource\n+import datadog.trace.context.TraceScope\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory\n+import datadog.trace.core.monitor.Monitoring\n+import datadog.trace.core.scopemanager.ContinuableScopeManager\n+import datadog.trace.util.test.DDSpecification\n+import spock.lang.Subject\n+import spock.lang.Timeout\n+\n+import java.util.concurrent.CountDownLatch\n+\n+import static datadog.trace.core.PendingTraceBuffer.BUFFER_SIZE\n+import static datadog.trace.core.SpanFactory.newSpanOf\n+\n+@Timeout(5)\n+class PendingTraceBufferTest extends DDSpecification {\n+  @Subject\n+  def buffer = new PendingTraceBuffer()\n+  def bufferSpy = Spy(buffer)\n+\n+  def tracer = Mock(CoreTracer)\n+  def scopeManager = new ContinuableScopeManager(10, new DDNoopScopeEventFactory(), new NoOpStatsDClient(), true, true)\n+  def factory = new PendingTrace.Factory(tracer, bufferSpy)\n+  List<TraceScope.Continuation> continuations = []\n+\n+  def cleanup() {\n+    buffer.close()\n+    buffer.worker.join(1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzA5Mzky", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502309392", "createdAt": "2020-10-05T18:22:38Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMjozOVrOHcontA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMjozOVrOHcontA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NzcwMA==", "bodyText": "Yes, to solve that, I think you'd have to have a way to get reference directly to the Task.  I'm not sure it is worth the trouble, so this is fine for now.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499787700", "createdAt": "2020-10-05T18:22:39Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceTest.groovy", "diffHunk": "@@ -283,28 +261,37 @@ class PendingTraceTest extends DDSpecification {\n     then:\n     trace.pendingReferenceCount.get() == 2\n     trace.weakSpans.size() == 2\n-    trace.asList() == [child1]\n+    trace.finishedSpans.asList() == [child1]\n     writer == []\n     writer.traceCount.get() == 0\n \n     when:\n     child2.finish()\n+    writer.waitForTraces(1)\n \n     then:\n     trace.pendingReferenceCount.get() == 1\n     trace.weakSpans.size() == 1\n-    trace.asList() == []\n+    trace.finishedSpans.isEmpty()\n     writer == [[child2, child1]]\n     writer.traceCount.get() == 1\n \n     when:\n     rootSpan.finish()\n+    writer.waitForTraces(2)\n \n     then:\n     trace.pendingReferenceCount.get() == 0\n     trace.weakSpans.size() == 0\n-    trace.asList() == [rootSpan]\n+    trace.finishedSpans.isEmpty()\n     writer == [[child2, child1], [rootSpan]]\n     writer.traceCount.get() == 2\n   }\n+\n+  boolean cleaningScheduled(PendingTrace trace) {\n+    // This might be racy if the task is in progress and not rescheduled.\n+    return AgentTaskScheduler.INSTANCE.workQueue.any { task ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 297}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzA5OTY1", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502309965", "createdAt": "2020-10-05T18:23:26Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMzoyNlrOHcopVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMzoyNlrOHcopVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODExOQ==", "bodyText": "I'm assuming this change is just clean-up.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499788119", "createdAt": "2020-10-05T18:23:26Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "diffHunk": "@@ -27,7 +31,7 @@ class TraceInterceptorTest extends DDSpecification {\n     tracer.interceptors.add(new TraceInterceptor() {\n       @Override\n       Collection<? extends MutableSpan> onTraceComplete(Collection<? extends MutableSpan> trace) {\n-        return null\n+        return []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzEwNjE3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502310617", "createdAt": "2020-10-05T18:24:24Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNDoyNFrOHcorQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNDoyNFrOHcorQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODYwOA==", "bodyText": "This code isn't immediately obvious.  I think some comments would help.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499788608", "createdAt": "2020-10-05T18:24:24Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "diffHunk": "@@ -70,20 +74,27 @@ class TraceInterceptorTest extends DDSpecification {\n   def \"interceptor can discard a trace (p=#score)\"() {\n     setup:\n     def called = new AtomicBoolean(false)\n+    def latch = new CountDownLatch(1)\n     def priority = score\n     tracer.interceptors.add(new TraceInterceptor() {\n       @Override\n       Collection<? extends MutableSpan> onTraceComplete(Collection<? extends MutableSpan> trace) {\n         called.set(true)\n-        return Collections.emptyList()\n+        latch.countDown()\n+        return []\n       }\n \n       @Override\n       int priority() {\n         return priority\n       }\n     })\n-    tracer.buildSpan(\"test\").start().finish()\n+    tracer.buildSpan(\"test \" + score).start().finish()\n+    if (score == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzExNTUy", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502311552", "createdAt": "2020-10-05T18:25:41Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNTo0MlrOHcot-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNTo0MlrOHcot-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4OTMwNQ==", "bodyText": "These are cumulative?  That seems bad from composability perspective, but again, test clean-up can come later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499789305", "createdAt": "2020-10-05T18:25:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/taginterceptor/TagInterceptorTest.groovy", "diffHunk": "@@ -370,13 +380,15 @@ class TagInterceptorTest extends DDSpecification {\n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(\"error\", \"true\").start()\n     span.finish()\n+    writer.waitForTraces(2)\n \n     then:\n     span.error\n \n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(Tags.DB_STATEMENT, \"some-statement\").start()\n     span.finish()\n+    writer.waitForTraces(3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzEzMzM2", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502313336", "createdAt": "2020-10-05T18:28:13Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyODoxM1rOHcozIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyODoxM1rOHcozIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MDYyNg==", "bodyText": "Non-functional?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499790626", "createdAt": "2020-10-05T18:28:13Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/ot31CompatabilityTest/groovy/OT31ApiTest.groovy", "diffHunk": "@@ -13,10 +13,10 @@ import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n \n // This test focuses on things that are different between OpenTracing API 0.31.0 and 0.32.0\n class OT31ApiTest extends DDSpecification {\n-  static final WRITER = new ListWriter()\n+  def writer = new ListWriter()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzM2NjM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502336637", "createdAt": "2020-10-05T19:00:48Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowMDo0OFrOHcp3Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowMDo0OFrOHcp3Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwODA2Nw==", "bodyText": "I think this probably needs some elaboration -- not necessarily as header doc, but I'm expect more documentation inside PendingTrace & PendingTraceBuffer.  I'd like a better high-level view of the overall flow that someone can read without reading over all the code to understand what's happening.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499808067", "createdAt": "2020-10-05T19:00:48Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -23,6 +23,24 @@\n import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * This class implements the following data flow rules when a Span is finished:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzc3MDk4", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502377098", "createdAt": "2020-10-05T20:00:17Z", "commit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c7ec7b10698a41e0fe2eb3c722d4efb63cfed69", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7c7ec7b10698a41e0fe2eb3c722d4efb63cfed69", "committedDate": "2020-10-05T20:37:52Z", "message": "Another comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1", "author": {"user": {"login": "tylerbenson", "name": "Tyler Benson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4fd9d71140df330d2dc1018a5b35e1c341829fd1", "committedDate": "2020-10-05T20:38:51Z", "message": "Merge branch 'master' into tyler/pending-trace-delay"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNjE3MzAz", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#pullrequestreview-502617303", "createdAt": "2020-10-06T06:28:25Z", "commit": {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyODoyNVrOHc3mJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyODoyNVrOHc3mJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMzA2Mw==", "bodyText": "I know I'm late to the game, but I noticed this while rebasing my branch on top of latest master, and you can most definitely have a continuation on a root span, so this is not correct. The effect is that a number of tests run noticeably slower (as in I can see it on the test counter incrementing slowly), and the new tests that didn't wait now needs to wait for the tracer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r500033063", "createdAt": "2020-10-06T06:28:25Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -203,45 +269,34 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n     synchronized (continuation) {\n       if (continuation.isRegistered()) {\n         continuation.cancel(weakContinuations);\n-        expireReference();\n+        expireReference(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1"}, "originalPosition": 239}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3163, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}