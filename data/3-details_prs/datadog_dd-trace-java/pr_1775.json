{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MTcxMzYz", "number": 1775, "title": "Replace disruptor with MpscCompoundQueue", "bodyText": "Replaces the disruptor with a queue specialised to multiple producers and a single consumer from JCTools, based on the relative performance in benchmarks, and to aid a priority based multi-lane publication system.\nThis changes attribution of dropped traces at the boundary between two batches slightly: traces dropped after the last trace which makes it in to the buffer may be attributed to the representative count for the batch, but this stabilises after the first batch is sent.\nThe performance of what's on this branch hasn't been sanity checked yet.", "createdAt": "2020-08-14T20:32:00Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1775", "merged": true, "mergeCommit": {"oid": "3aa2a3397fbf086a7f52174991bba983a951df6a"}, "closed": true, "closedAt": "2020-08-17T16:16:27Z", "author": {"login": "richardstartin"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-yY4YgH2gAyNDY4MTcxMzYzOmM1NjNiNjg5N2UzNWQ2MzQ4ZDFiMTg5YmM0ZTI3OTIzYTgzZWQ5Y2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_zgLagBqjM2NjIyMTE2ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c563b6897e35d6348d1b189bc4e27923a83ed9ce", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c563b6897e35d6348d1b189bc4e27923a83ed9ce", "committedDate": "2020-08-14T10:51:49Z", "message": "don't refer to queue implementation in the TraceProcessing pipeline's interface"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5", "committedDate": "2020-08-14T20:30:03Z", "message": "replace disruptor with JCTools MpscCompoundQueue"}, "afterCommit": {"oid": "52073b0fa4243eec9f967549a7edb567211d7e11", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/52073b0fa4243eec9f967549a7edb567211d7e11", "committedDate": "2020-08-14T20:47:49Z", "message": "replace disruptor with JCTools MpscCompoundQueue"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52073b0fa4243eec9f967549a7edb567211d7e11", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/52073b0fa4243eec9f967549a7edb567211d7e11", "committedDate": "2020-08-14T20:47:49Z", "message": "replace disruptor with JCTools MpscCompoundQueue"}, "afterCommit": {"oid": "5b71e52786c042b2486ce0b2552f57da78705e03", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5b71e52786c042b2486ce0b2552f57da78705e03", "committedDate": "2020-08-14T20:52:05Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b71e52786c042b2486ce0b2552f57da78705e03", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5b71e52786c042b2486ce0b2552f57da78705e03", "committedDate": "2020-08-14T20:52:05Z", "message": "revapi"}, "afterCommit": {"oid": "6de1c4eb07e55924e0d8bec7233421041da80432", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6de1c4eb07e55924e0d8bec7233421041da80432", "committedDate": "2020-08-14T21:05:49Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e6938817317eeddfd23380b0e2762f3c8db8ab7", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3e6938817317eeddfd23380b0e2762f3c8db8ab7", "committedDate": "2020-08-14T21:18:20Z", "message": "remove rather strange assertion"}, "afterCommit": {"oid": "d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "committedDate": "2020-08-14T21:19:37Z", "message": "remove rather strange assertion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9d087a8ecef8810fb2f80b09d6343aff79d875c", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f9d087a8ecef8810fb2f80b09d6343aff79d875c", "committedDate": "2020-08-14T21:39:42Z", "message": "replace disruptor with JCTools MpscCompoundQueue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13efa90988acf48f91a21af789a4321ce9733791", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/13efa90988acf48f91a21af789a4321ce9733791", "committedDate": "2020-08-14T21:39:42Z", "message": "revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "committedDate": "2020-08-14T21:19:37Z", "message": "remove rather strange assertion"}, "afterCommit": {"oid": "eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "committedDate": "2020-08-14T21:39:42Z", "message": "remove rather strange assertion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODYxNTY4", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#pullrequestreview-467861568", "createdAt": "2020-08-14T20:38:01Z", "commit": {"oid": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDo0MTowOFrOHBCvLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQyMDo1OToxNFrOHBDJ6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NTQ2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * traces are published in batches to the Datadog Agent}.\n          \n          \n            \n             * traces are published in batches to the Datadog Agent.", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470855469", "createdAt": "2020-08-14T20:41:08Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1Njc2Mg==", "bodyText": "If you don't restrict publishing to just heartbeats, then it doesn't matter if this is successfully added to the queue.", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470856762", "createdAt": "2020-08-14T20:44:52Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1OTExMg==", "bodyText": "If you remove this, then it doesn't matter if heartbeats are successfully added to the queue.", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470859112", "createdAt": "2020-08-14T20:51:06Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler\n+      implements Runnable, MessagePassingQueue.Consumer<Object> {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void accept(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52073b0fa4243eec9f967549a7edb567211d7e11"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDQ0MQ==", "bodyText": "Any risk of an object that isn't these two types being added to the queue?\nIf so it looks like it'll just be ignored, so I guess it doesn't matter.", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470860441", "createdAt": "2020-08-14T20:54:33Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler\n+      implements Runnable, MessagePassingQueue.Consumer<Object> {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void accept(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat\n+            if (doTimeFlush && millisecondTime() > nextFlushMillis) {\n+              payloadDispatcher.flush();\n+              scheduleNextTimeFlush();\n+            }\n+          } else {\n+            // TODO populate `_sample_rate` metric in a way that accounts for lost/dropped traces\n+            payloadDispatcher.addTrace(processor.onTraceComplete(trace));\n+          }\n+        } else if (event instanceof FlushEvent) {\n+          payloadDispatcher.flush();\n+          ((FlushEvent) event).sync();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b71e52786c042b2486ce0b2552f57da78705e03"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MjMxNQ==", "bodyText": "How much bigger is this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470862315", "createdAt": "2020-08-14T20:59:14Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -38,7 +38,8 @@ dependencies {\n   compile deps.okhttp\n   compile group: 'com.squareup.moshi', name: 'moshi', version: '1.9.2'\n   compile group: 'com.github.jnr', name: 'jnr-unixsocket', version: \"${versions.jnr_unixsocket}\"\n-  compile group: 'com.lmax', name: 'disruptor', version: '3.4.2'\n+  compile group: 'org.jctools', name: 'jctools-core', version: '3.1.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b71e52786c042b2486ce0b2552f57da78705e03"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1f6eeb1242b36e09ab93086c76da4c85b635681", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c1f6eeb1242b36e09ab93086c76da4c85b635681", "committedDate": "2020-08-14T21:44:39Z", "message": "remove rather strange assertion"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "committedDate": "2020-08-14T21:39:42Z", "message": "remove rather strange assertion"}, "afterCommit": {"oid": "c1f6eeb1242b36e09ab93086c76da4c85b635681", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c1f6eeb1242b36e09ab93086c76da4c85b635681", "committedDate": "2020-08-14T21:44:39Z", "message": "remove rather strange assertion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19cd528c20b9ed905ac9af72206863206e4dd083", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/19cd528c20b9ed905ac9af72206863206e4dd083", "committedDate": "2020-08-15T14:08:24Z", "message": "better consumer backoff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDIyMjU0", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#pullrequestreview-468422254", "createdAt": "2020-08-17T12:35:46Z", "commit": {"oid": "19cd528c20b9ed905ac9af72206863206e4dd083"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMjozNTo0NlrOHBm5jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMjozNTo0NlrOHBm5jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0Nzk0OQ==", "bodyText": "So System.nanoTime() is a relative time, and the value can be negative (there is no guarantee that the value starts at 0). How does NANOSECONDS.toMillis deal with that? Also, the comparison needs to be done relative to a start time since the counter could potentially wrap in the middle of an interval.", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r471447949", "createdAt": "2020-08-17T12:35:46Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.util.ThreadUtil.onSpinWait;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    int parallelism = Runtime.getRuntime().availableProcessors();\n+    this.primaryQueue = new MpscCompoundQueue<>(Math.max(capacity, parallelism), parallelism);\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler implements Runnable {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void onEvent(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat\n+            if (doTimeFlush && millisecondTime() > nextFlushMillis) {\n+              payloadDispatcher.flush();\n+              scheduleNextTimeFlush();\n+            }\n+          } else {\n+            // TODO populate `_sample_rate` metric in a way that accounts for lost/dropped traces\n+            payloadDispatcher.addTrace(processor.onTraceComplete(trace));\n+          }\n+        } else if (event instanceof FlushEvent) {\n+          payloadDispatcher.flush();\n+          ((FlushEvent) event).sync();\n+        }\n+      } catch (final Throwable e) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Error while serializing trace\", e);\n+        }\n+        List<DDSpan> data = event instanceof List ? (List<DDSpan>) event : null;\n+        monitor.onFailedSerialize(data, e);\n+      }\n+    }\n+\n+    private void scheduleNextTimeFlush() {\n+      if (doTimeFlush) {\n+        nextFlushMillis = millisecondTime() + flushIntervalMillis;\n+      }\n+    }\n+\n+    private long millisecondTime() {\n+      // important: nanoTime is monotonic, currentTimeMillis is not\n+      return NANOSECONDS.toMillis(System.nanoTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cd528c20b9ed905ac9af72206863206e4dd083"}, "originalPosition": 193}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb6ad0fa858f0f0d5827a5042c1b12b341152199", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/bb6ad0fa858f0f0d5827a5042c1b12b341152199", "committedDate": "2020-08-17T13:15:55Z", "message": "more resilient time-triggered flushes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDY5MTI2", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#pullrequestreview-468469126", "createdAt": "2020-08-17T13:36:54Z", "commit": {"oid": "bb6ad0fa858f0f0d5827a5042c1b12b341152199"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "committedDate": "2020-08-17T14:43:27Z", "message": "make sure non-root traces are published"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5c29401d5a749a355243f64981cb0bf071965cc", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e5c29401d5a749a355243f64981cb0bf071965cc", "committedDate": "2020-08-17T14:23:54Z", "message": "make sure non-root traces are published"}, "afterCommit": {"oid": "655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "committedDate": "2020-08-17T14:43:27Z", "message": "make sure non-root traces are published"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2127, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}