{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNzUxMzk0", "number": 1977, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNDo1NlrOEtDpGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyMDoxN1rOEtEHSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgxMDQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNDo1NlrOHgogMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyNzoyOVrOHgpnnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDA4MA==", "bodyText": "Is this expected to stay like this long term?", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503980080", "createdAt": "2020-10-13T14:04:56Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaWrappedRunnableInstrumentation; its responsibility\n+ * is to capture context if there is an active scope.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class AkkaForkJoinExecutorTaskInstrumentation extends Instrumenter.Default {\n+  public AkkaForkJoinExecutorTaskInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // prevents Runnable from being instrumented unless this\n+    // instrumentation would take effect (unless something else\n+    // instruments it).\n+    return hasClassesNamed(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(Runnable.class.getName(), State.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5ODM2Nw==", "bodyText": "To make this work properly this instrumentation would need to be radically different, so no, this probably isn't long term, and only happens when Scala 2.11 is in use.", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503998367", "createdAt": "2020-10-13T14:27:29Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaWrappedRunnableInstrumentation; its responsibility\n+ * is to capture context if there is an active scope.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class AkkaForkJoinExecutorTaskInstrumentation extends Instrumenter.Default {\n+  public AkkaForkJoinExecutorTaskInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // prevents Runnable from being instrumented unless this\n+    // instrumentation would take effect (unless something else\n+    // instruments it).\n+    return hasClassesNamed(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(Runnable.class.getName(), State.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDA4MA=="}, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjgyNDM1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNzo1MlrOHgoo_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDowNzo1MlrOHgoo_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjMzMw==", "bodyText": "wrapped?", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503982333", "createdAt": "2020-10-13T14:07:52Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaWrappedRunnableInstrumentation; its responsibility\n+ * is to capture context if there is an active scope.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class AkkaForkJoinExecutorTaskInstrumentation extends Instrumenter.Default {\n+  public AkkaForkJoinExecutorTaskInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // prevents Runnable from being instrumented unless this\n+    // instrumentation would take effect (unless something else\n+    // instruments it).\n+    return hasClassesNamed(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(Runnable.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isConstructor().and(takesArgument(0, named(Runnable.class.getName()))),\n+        getClass().getName() + \"$Construct\");\n+  }\n+\n+  public static final class Construct {\n+    @Advice.OnMethodExit\n+    public static void construct(@Advice.Argument(0) Runnable wrapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Njg0MTYzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaWrappedRunnableInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoxMTowNFrOHgozNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyNzo0MVrOHgpoIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4NDk1MQ==", "bodyText": "both this and AkkaForkJoinExecutorTaskInstrumentation are instrumenting the same class.  Why separate them?", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503984951", "createdAt": "2020-10-13T14:11:04Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaWrappedRunnableInstrumentation.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils.endTaskScope;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils.startTaskScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaForkJoinExecutorTaskInstrumentation; its\n+ * responsibility is to activate any captured scope.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class AkkaWrappedRunnableInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaWrappedRunnableInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // prevents Runnable from being instrumented unless this\n+    // instrumentation would take effect (unless something else\n+    // instruments it).\n+    return hasClassesNamed(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(Runnable.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5ODQ5Nw==", "bodyText": "This was an oversight.", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503998497", "createdAt": "2020-10-13T14:27:41Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaWrappedRunnableInstrumentation.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils.endTaskScope;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils.startTaskScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaForkJoinExecutorTaskInstrumentation; its\n+ * responsibility is to activate any captured scope.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class AkkaWrappedRunnableInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaWrappedRunnableInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // prevents Runnable from being instrumented unless this\n+    // instrumentation would take effect (unless something else\n+    // instruments it).\n+    return hasClassesNamed(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(Runnable.class.getName(), State.class.getName());\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4NDk1MQ=="}, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Njg3NTU4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoxNzo1NlrOHgpISQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDozNzozMFrOHgqGOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MDM0NQ==", "bodyText": "Can you elaborate on how this collaboration works in this comment for future people who might be working in here", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503990345", "createdAt": "2020-10-13T14:17:56Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaWrappedRunnableInstrumentation; its responsibility", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAwNjIwMQ==", "bodyText": "I removed the second instrumentation and the comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r504006201", "createdAt": "2020-10-13T14:37:30Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinExecutorTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask requires special treatment and can't\n+ * be handled generically despite being a subclass of akka.dispatch.ForkJoinTask, because of its\n+ * error handling.\n+ *\n+ * <p>This instrumentation collaborates with AkkaWrappedRunnableInstrumentation; its responsibility", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MDM0NQ=="}, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Njg4Nzc4OnYy", "diffSide": "LEFT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyMDoxN1rOHgpP3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyMDoxN1rOHgpP3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5MjI4NQ==", "bodyText": "This is incorrect - both need to be instrumented to be correct with work-stealing", "url": "https://github.com/DataDog/dd-trace-java/pull/1977#discussion_r503992285", "createdAt": "2020-10-13T14:20:17Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaForkJoinTaskInstrumentation.java", "diffHunk": "@@ -41,19 +43,20 @@ public AkkaForkJoinTaskInstrumentation() {\n \n   @Override\n   public ElementMatcher<? super TypeDescription> typeMatcher() {\n-    return named(\"akka.dispatch.forkjoin.ForkJoinTask\");\n+    return extendsClass(named(\"akka.dispatch.forkjoin.ForkJoinTask\"))\n+        .and(not(named(\"akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask\")));\n   }\n \n   @Override\n   public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n     Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>(4);\n-    transformers.put(isMethod().and(named(\"doExec\")), getClass().getName() + \"$DoExec\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd6666d161367fd47312438de2ea91c73ea3ecbc"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4698, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}