{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3ODc5NzIw", "number": 1873, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMTowMzowNFrOEkezrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMjoxMlrOEkrnig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Njg4OTQwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMTowMzowNFrOHTcwsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMTowMzowNFrOHTcwsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NjIwOA==", "bodyText": "If I can merge #1878 first, we can use already cached UTF-8 string here", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490156208", "createdAt": "2020-09-17T11:03:04Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.springscheduling.SpringSchedulingDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Method;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpannedMethodInvocation implements MethodInvocation {\n+\n+  private final AgentSpan parent;\n+  private final MethodInvocation delegate;\n+\n+  public SpannedMethodInvocation(AgentSpan parent, MethodInvocation delegate) {\n+    this.parent = parent;\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public Method getMethod() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override\n+  public Object[] getArguments() {\n+    return delegate.getArguments();\n+  }\n+\n+  @Override\n+  public Object proceed() throws Throwable {\n+    CharSequence spanName = DECORATE.spanNameForMethod(delegate.getMethod());\n+    // TODO kill all APIs requiring String parameters with fire\n+    final AgentSpan span =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9f2d81e70eeff0d9e93a7a66cad0d615892209e"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODg4ODk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/spring-scheduling-3.1.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozMzozOFrOHTwC6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozMzozOFrOHTwC6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3MjE2OQ==", "bodyText": "I don't think this comment applies since we updated the version and the test doesn't test with 7.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490472169", "createdAt": "2020-09-17T18:33:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/spring-scheduling-3.1.gradle", "diffHunk": "@@ -22,11 +22,16 @@ testSets {\n }\n \n dependencies {\n-  // 3.2.3 is the first version with which the tests will run. Lower versions require other\n-  // classes and packages to be imported. Versions 3.1.0+ work with the instrumentation.\n-  compileOnly group: 'org.springframework', name: 'spring-context', version: '3.1.0.RELEASE'\n-  testCompile group: 'org.springframework', name: 'spring-context', version: '3.2.3.RELEASE'\n+  // choose a recent version so that we can test both lambdas (JDK8)\n+  // @Async requires proxying and older versions can't read classfile versions > 51\n+  // we muzzle older versions of spring anyway\n+  compileOnly group: 'org.springframework', name: 'spring-context', version: '5.0.0.RELEASE'\n+  testCompile group: 'org.springframework', name: 'spring-context', version: '5.0.0.RELEASE'\n+\n+  // for a test case with CompletableFuture\n+  testCompile project(':dd-java-agent:instrumentation:java-concurrent')\n+  testCompile project(':dd-java-agent:instrumentation:trace-annotation')\n \n   // this is the latest version that supports Java 7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7d7f2506f0b01fdc3ec2bb884dc80e9219820d6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODkwMDI3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncInstrumentation.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODozNjo1MFrOHTwJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowNjo1MFrOHTxKoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3Mzk0Mw==", "bodyText": "I'm a little concerned about adding instrumentation for a class that seems relatively unrelated to scheduling in the module for spring-scheduling.  Is @Async used for anything besides spring scheduling?", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490473943", "createdAt": "2020-09-17T18:36:50Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncInstrumentation.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class SpringAsyncInstrumentation extends Instrumenter.Default {\n+\n+  public SpringAsyncInstrumentation() {\n+    super(\"spring-async\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"org.springframework.aop.interceptor.AsyncExecutionInterceptor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7d7f2506f0b01fdc3ec2bb884dc80e9219820d6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4Njg5Mw==", "bodyText": "This intercepts the annotation (notice the package) org.springframework.scheduling.annotation.Async.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490486893", "createdAt": "2020-09-17T19:00:31Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncInstrumentation.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class SpringAsyncInstrumentation extends Instrumenter.Default {\n+\n+  public SpringAsyncInstrumentation() {\n+    super(\"spring-async\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"org.springframework.aop.interceptor.AsyncExecutionInterceptor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3Mzk0Mw=="}, "originalCommit": {"oid": "a7d7f2506f0b01fdc3ec2bb884dc80e9219820d6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5MDUyOQ==", "bodyText": "Yes, this seems pretty clearly related to Async to me.  Although, I'll admit their package naming makes me a little concern that maybe AsyncExecutionInterceptor does more.\nBut presuming AsyncExecutionInterceptor is specific to @Async annotations, I think this is probably the right place.\nIt solves my general aim which to let the frameworks find the target methods for us -- rather than us seeking them out.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490490529", "createdAt": "2020-09-17T19:06:50Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncInstrumentation.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public class SpringAsyncInstrumentation extends Instrumenter.Default {\n+\n+  public SpringAsyncInstrumentation() {\n+    super(\"spring-async\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"org.springframework.aop.interceptor.AsyncExecutionInterceptor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3Mzk0Mw=="}, "originalCommit": {"oid": "a7d7f2506f0b01fdc3ec2bb884dc80e9219820d6"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODk1NTIzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo1Mjo1NFrOHTwsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowNTowN1rOHTxGtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MjczNQ==", "bodyText": "There's a fair bit of history here, but I can't find any original sources. I think these summarize the problem well:\nopentracing/opentracing-java#361 (comment)\nhttps://github.com/Nike-Inc/wingtips#warning-about-error-handling-when-using-try-with-resources-to-autoclose-spans", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490482735", "createdAt": "2020-09-17T18:52:54Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.springscheduling.SpringSchedulingDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Method;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpannedMethodInvocation implements MethodInvocation {\n+\n+  private final AgentSpan parent;\n+  private final MethodInvocation delegate;\n+\n+  public SpannedMethodInvocation(AgentSpan parent, MethodInvocation delegate) {\n+    this.parent = parent;\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public Method getMethod() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override\n+  public Object[] getArguments() {\n+    return delegate.getArguments();\n+  }\n+\n+  @Override\n+  public Object proceed() throws Throwable {\n+    CharSequence spanName = DECORATE.spanNameForMethod(delegate.getMethod());\n+    final AgentSpan span =\n+        parent == null ? startSpan(spanName) : startSpan(spanName, parent.context());\n+    try (AgentScope scope = activateSpan(span)) {\n+      // question: is this necessary? What does it do?\n+      // if the delegate does async work is everything OK because of this?\n+      // if the delegate does async work, should I need to worry about it here?\n+      scope.setAsyncPropagation(true);\n+      return delegate.proceed();\n+    } finally {\n+      // question: Why can't this just be AutoCloseable? Dogma?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4OTUyNw==", "bodyText": "That reads like an issue with programming discipline, and sacrifices convenience in the common case for the inability to be incorrect in the rare case. Just my opinion.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490489527", "createdAt": "2020-09-17T19:05:07Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.springscheduling.SpringSchedulingDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Method;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpannedMethodInvocation implements MethodInvocation {\n+\n+  private final AgentSpan parent;\n+  private final MethodInvocation delegate;\n+\n+  public SpannedMethodInvocation(AgentSpan parent, MethodInvocation delegate) {\n+    this.parent = parent;\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public Method getMethod() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override\n+  public Object[] getArguments() {\n+    return delegate.getArguments();\n+  }\n+\n+  @Override\n+  public Object proceed() throws Throwable {\n+    CharSequence spanName = DECORATE.spanNameForMethod(delegate.getMethod());\n+    final AgentSpan span =\n+        parent == null ? startSpan(spanName) : startSpan(spanName, parent.context());\n+    try (AgentScope scope = activateSpan(span)) {\n+      // question: is this necessary? What does it do?\n+      // if the delegate does async work is everything OK because of this?\n+      // if the delegate does async work, should I need to worry about it here?\n+      scope.setAsyncPropagation(true);\n+      return delegate.proceed();\n+    } finally {\n+      // question: Why can't this just be AutoCloseable? Dogma?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MjczNQ=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODk1NjEyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo1MzoxMFrOHTwstQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo1MzoxMFrOHTwstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4Mjg2OQ==", "bodyText": "This will hopefully be unnecessary with the planned changes to PendingTrace.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490482869", "createdAt": "2020-09-17T18:53:10Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpannedMethodInvocation.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.springscheduling.SpringSchedulingDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Method;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpannedMethodInvocation implements MethodInvocation {\n+\n+  private final AgentSpan parent;\n+  private final MethodInvocation delegate;\n+\n+  public SpannedMethodInvocation(AgentSpan parent, MethodInvocation delegate) {\n+    this.parent = parent;\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public Method getMethod() {\n+    return delegate.getMethod();\n+  }\n+\n+  @Override\n+  public Object[] getArguments() {\n+    return delegate.getArguments();\n+  }\n+\n+  @Override\n+  public Object proceed() throws Throwable {\n+    CharSequence spanName = DECORATE.spanNameForMethod(delegate.getMethod());\n+    final AgentSpan span =\n+        parent == null ? startSpan(spanName) : startSpan(spanName, parent.context());\n+    try (AgentScope scope = activateSpan(span)) {\n+      // question: is this necessary? What does it do?\n+      // if the delegate does async work is everything OK because of this?\n+      // if the delegate does async work, should I need to worry about it here?\n+      scope.setAsyncPropagation(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODk4ODI2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMjoxMlrOHTxAXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMDo1Mzo0MlrOHT1JyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg==", "bodyText": "One other thing to mention is that currently this will result in the span likely being reported as a separate trace since you're not using continuations to force the trace to stick around.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490487902", "createdAt": "2020-09-17T19:02:12Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4OTk4Ng==", "bodyText": "I think that is fine modeling wise because it's timing does not matter for the critical path", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490489986", "createdAt": "2020-09-17T19:05:52Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5Mjc0OA==", "bodyText": "I'm confused by saying it is a separate trace, isn't it just spans sent separately?  That's what I think it should be.\nI think today.  These spans might go to PendingTrace that is thought to be done, but I think that's a problem with PendingTrace.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490492748", "createdAt": "2020-09-17T19:10:48Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5NzIxNQ==", "bodyText": "@dougqh to clarify, I mean it would likely be reported independently from the rest of the trace.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490497215", "createdAt": "2020-09-17T19:19:19Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwMzEyNw==", "bodyText": "This feels like the wrong API to me. I should need to call AgentSpan.finish() to finish the span. DDSpanContext has a PendingTrace - so why shouldn't AgentSpan.finish() be enough to hold the PendingTrace back?", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490503127", "createdAt": "2020-09-17T19:26:08Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1NTg0OA==", "bodyText": "Yes, right now, an unfinished span holds back sending the trace leg.\nBut that's leading to problems where an unfinished span, holds back the whole trace.\nI think we want to get away from that.\nMy thought is that a span is published in the first payload when it finishes before the root span.\n(Except for long root spans for batch jobs where we need to send sooner).\nOtherwise, the span is deemed to have finished late.  If it makes it with a grace period, it can be included.  Otherwise, it goes separately.  But basically, it is only guarantee if it finishes before the root.", "url": "https://github.com/DataDog/dd-trace-java/pull/1873#discussion_r490555848", "createdAt": "2020-09-17T20:53:42Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-scheduling-3.1/src/main/java/datadog/trace/instrumentation/springscheduling/SpringAsyncAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.instrumentation.springscheduling;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+\n+import net.bytebuddy.asm.Advice;\n+import org.aopalliance.intercept.MethodInvocation;\n+\n+public class SpringAsyncAdvice {\n+\n+  @Advice.OnMethodEnter(suppress = Throwable.class)\n+  public static void scheduleAsync(\n+      @Advice.Argument(value = 0, readOnly = false) MethodInvocation invocation) {\n+    invocation = new SpannedMethodInvocation(activeSpan(), invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NzkwMg=="}, "originalCommit": {"oid": "bc2fb5e86582413e7e192c6905d0c3524fc91a20"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4818, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}