{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMzI5Njk2", "number": 1739, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo1OFrOEUvn_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjozMToyN1rOEVfReg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MjYyOnYy", "diffSide": "LEFT", "path": "dd-java-agent/instrumentation/opentelemetry/src/test/groovy/OpenTelemetryTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo1OFrOG7HYlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxODo1OFrOG7HYlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDE0OQ==", "bodyText": "Stack now unwinds back to empty step on next request for currentSpan", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464640149", "createdAt": "2020-08-03T20:18:58Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentelemetry/src/test/groovy/OpenTelemetryTest.groovy", "diffHunk": "@@ -223,14 +223,9 @@ class OpenTelemetryTest extends AgentTestRunner {\n     secondScope.close()\n \n     then:\n-    tracer.currentSpan.delegate == firstScope.delegate.span()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTg3MzgwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/opentracing/api-0.31/src/test/groovy/OpenTracing31Test.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToyMlrOG7HZQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDoxOToyMlrOG7HZQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MDMyMA==", "bodyText": "Stack now unwinds back to empty on next call to active", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464640320", "createdAt": "2020-08-03T20:19:22Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.31/src/test/groovy/OpenTracing31Test.groovy", "diffHunk": "@@ -239,14 +239,7 @@ class OpenTracing31Test extends AgentTestRunner {\n     secondScope.close()\n \n     then:\n-    tracer.scopeManager().active().delegate == firstScope.delegate\n-    0 * _\n-\n-    when:\n-    firstScope.close()\n-\n-    then:\n-    0 * _\n+    assert tracer.scopeManager().active() == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkyODMxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNjo1NFrOG7H5oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNjo1NFrOG7H5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODYwOQ==", "bodyText": "depth moved from ContinuableScope to ScopeStack", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648609", "createdAt": "2020-08-03T20:36:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -66,15 +74,21 @@ private ContinuableScopeManager(\n \n   @Override\n   public AgentScope activate(final AgentSpan span, final ScopeSource source) {\n-    final ContinuableScope active = tlsScope.get();\n+    ScopeStack scopeStack = scopeStack();\n+\n+    final ContinuableScope active = scopeStack.top();\n     if (active != null && active.span().equals(span)) {\n-      return active.incrementReferences();\n+      active.incrementReferences();\n+      return active;\n     }\n-    final int currentDepth = active == null ? 0 : active.depth();\n+\n+    // DQH - This check could go before the check above, since depth limit checking is fast\n+    final int currentDepth = scopeStack.depth();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkzMDUyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNzozOFrOG7H6_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozNzozOFrOG7H6_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODk1OQ==", "bodyText": "tlsScope.set becomes scopeStack().push\nscopeStack is ThreadLocal", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648959", "createdAt": "2020-08-03T20:37:38Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkzMjIyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozODoxMFrOG7H7-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozODoxMFrOG7H7-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTIxMA==", "bodyText": "tlsScope.get becomes scopeStack().top()\ntop() is the fix-up version that unwinds the stack if necessary", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649210", "createdAt": "2020-08-03T20:38:10Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);\n     scope.afterActivated();\n     return scope;\n   }\n \n   @Override\n   public TraceScope active() {\n-    return tlsScope.get();\n+    return scopeStack().top();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTkzNTgxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDozOToyMlrOG7H-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1NzoxM1rOG8QHeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw==", "bodyText": "I switched away from instance inner classes to static inner classes to make the boundaries more clear.\nI think this code could be organized better, but for the moment, I didn't move things around much to keep the diff to a minimum.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649763", "createdAt": "2020-08-03T20:39:22Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +122,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTgwMg==", "bodyText": "I had the same debate when I worked on this a few months ago...", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831802", "createdAt": "2020-08-05T15:57:13Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +122,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw=="}, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTk0MTQ0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo0MToxNFrOG7IBgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzowMDoxMVrOG7pWQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDYyNQ==", "bodyText": "set(toRestore) becomes scopeStack().blindPop().\nblindPop -- pops the stack without checking what's on top.  The top checking was done above in the same fashion as the original code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464650625", "createdAt": "2020-08-03T20:41:14Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -159,18 +192,35 @@ public void close() {\n       if (null != continuation) {\n         span().context().getTrace().cancelContinuation(continuation);\n       }\n-      tlsScope.set(toRestore);\n+      if (onTop) scopeStack.blindPop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NjYxMQ==", "bodyText": "onTop is always true here because it's checked above and a return is the only non exceptional exit from that block.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465196611", "createdAt": "2020-08-04T17:00:11Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -159,18 +192,35 @@ public void close() {\n       if (null != continuation) {\n         span().context().getTrace().cancelContinuation(continuation);\n       }\n-      tlsScope.set(toRestore);\n+      if (onTop) scopeStack.blindPop();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDYyNQ=="}, "originalCommit": {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjAwNTY4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerDepthTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMzowMVrOG7IpHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMTowMzowMVrOG7IpHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2MDc2NA==", "bodyText": "I could have changed the value in the assert.\nOr, remove the bounds check mistake here.\nI chose to do the latter.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464660764", "createdAt": "2020-08-03T21:03:01Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerDepthTest.groovy", "diffHunk": "@@ -61,22 +61,22 @@ class ScopeManagerDepthTest extends DDSpecification {\n \n     when: \"fill up the scope stack\"\n     AgentScope scope = null\n-    for (int i = 0; i <= defaultLimit; i++) {\n+    for (int i = 0; i < defaultLimit; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e62a411455e3056f6287da17805c8f9bf7e8831"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTMxMTAxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoxNzoxMFrOG7nuxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoxNzoxMFrOG7nuxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MDExNw==", "bodyText": "this is an assignment to a local and is never reflected onto the instance\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stack = Arrays.copyOf(stack, stack.length >> 1);\n          \n          \n            \n                        this.stack = Arrays.copyOf(stack, stack.length >> 1);", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465170117", "createdAt": "2020-08-04T16:17:10Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTMyMzE4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMDowN1rOG7n2FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMDowN1rOG7n2FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MTk4OA==", "bodyText": "What about reserving a null first element of the array and adding 1 to every position?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465171988", "createdAt": "2020-08-04T16:20:07Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTMzMTcxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMjoxN1rOG7n7Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0NjozMFrOG8Pq9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MzMxMA==", "bodyText": "Which tests need to be removed to avoid this?\nIt feels like it's a good practice to clear the array out ASAP, i.e. in the stack's pop method. Does something prevent this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465173310", "createdAt": "2020-08-04T16:22:17Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length << 1);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      if (topPos == -1) return false;\n+\n+      return stack[topPos].equals(expectedScope);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos + 1;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNDUwMA==", "bodyText": "I think that the proper use of top and blindPop already leads to a cleared out stack. This seems to be used to make sure that the scopes don't leak between tests even if they fail.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465824500", "createdAt": "2020-08-05T15:46:30Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length << 1);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      if (topPos == -1) return false;\n+\n+      return stack[topPos].equals(expectedScope);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos + 1;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MzMxMA=="}, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTMzODAyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMzo0OFrOG7n_AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyMzo0OFrOG7n_AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NDI3Mw==", "bodyText": "There's only one template in the pattern, but two parameters\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n          \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465174273", "createdAt": "2020-08-04T16:23:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNTM0NzUxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNjoyNjowOVrOG7oE_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1NDozN1rOG8QArg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA==", "bodyText": "I hate to bikeshed but I have a strong aversion to unbraced conditional statements because I've been burnt by them in the past.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465175804", "createdAt": "2020-08-04T16:26:09Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMDA2Mg==", "bodyText": "I'm actually a little surprised... I assumed that this was in violation to google-java-format but the check passed.  I'd support making this a build failure somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465830062", "createdAt": "2020-08-05T15:54:37Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA=="}, "originalCommit": {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTQ0NjYwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTozNDozN1rOG8PK7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0MDozMlrOG8PbAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjMwMw==", "bodyText": "Nice touch using slot 0 as a holder for null to avoid the -1 math and checks.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465816303", "createdAt": "2020-08-05T15:34:37Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -308,7 +311,6 @@ final ContinuableScope top() {\n      * useful in logging to avoid side effects, but could be used in other places with caution.\n      */\n     final ContinuableScope noFixupTop() {\n-      if (topPos == -1) return null;\n       return stack[topPos];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDQxOA==", "bodyText": "shh!", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465820418", "createdAt": "2020-08-05T15:40:32Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -308,7 +311,6 @@ final ContinuableScope top() {\n      * useful in logging to avoid side effects, but could be used in other places with caution.\n      */\n     final ContinuableScope noFixupTop() {\n-      if (topPos == -1) return null;\n       return stack[topPos];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjMwMw=="}, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTUwNjQ3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyNlrOG8PwPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyNlrOG8PwPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg1NQ==", "bodyText": "Do we really want this to be protected?  Perhaps private?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825855", "createdAt": "2020-08-05T15:48:26Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTUwNjU4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0ODoyOFrOG8PwUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1OTozMFrOG8QNUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg3Mg==", "bodyText": "leftover?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825872", "createdAt": "2020-08-05T15:48:28Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMzI5Ng==", "bodyText": "Yes I think we should remove this. I'll do it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465833296", "createdAt": "2020-08-05T15:59:30Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg3Mg=="}, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTUxMTA0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0OTozNlrOG8PzNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo0OTozNlrOG8PzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNjYxMg==", "bodyText": "Delete?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465826612", "createdAt": "2020-08-05T15:49:36Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTUzOTQwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1NjoxOVrOG8QFNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1NjoxOVrOG8QFNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTIyMQ==", "bodyText": "The cost of noFixupTop seems minimal.  Perhaps we don't need the guard clause here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831221", "createdAt": "2020-08-05T15:56:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTU0NjM4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1ODowOVrOG8QJwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTo1ODowOVrOG8QJwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMjM4NA==", "bodyText": "Not related to this PR, but we should encapsulate this in the Monitor...", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465832384", "createdAt": "2020-08-05T15:58:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");\n \n         if (source == ScopeSource.MANUAL) {\n-          statsDClient.incrementCounter(\"scope.user.close.error\");\n+          scopeManager.statsDClient.incrementCounter(\"scope.user.close.error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTYxNTA0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoxNTo1NVrOG8Q2NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoxNTo1NVrOG8Q2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0Mzc2NQ==", "bodyText": "How did you decide on 16?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465843765", "createdAt": "2020-08-05T16:15:55Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTYyMDkzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoxNzoyNFrOG8Q6Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoxNzoyNFrOG8Q6Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0NDc1MQ==", "bodyText": "Looks like this is intended to reduce the size of the stack. Please comment and maybe extract to a separate method?\nAlso, do we need to set a minimum for the default size?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465844751", "createdAt": "2020-08-05T16:17:24Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTY1NTc0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNTo0NFrOG8RPwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNTo0NFrOG8RPwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MDMwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n          \n          \n            \n                 * Pushes a new scope onto the current stack, the new scope is pushed onto the stack without", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465850304", "createdAt": "2020-08-05T16:25:44Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTY2MjY3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNzoyM1rOG8RT_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjoyNzoyM1rOG8RT_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MTM5MQ==", "bodyText": "Should we have a separate methods to handle growing/shrinking the stack?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465851391", "createdAt": "2020-08-05T16:27:23Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTY3OTMwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjozMToyN1rOG8ReeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjozMToyN1rOG8ReeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1NDA3Mw==", "bodyText": "seems like the next call to top() would result in shrinking the array.  Consider setting a new array with default/minimum size instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465854073", "createdAt": "2020-08-05T16:31:27Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      return expectedScope.equals(stack[topPos]);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests\n+    final void clear() {\n+      topPos = 0;\n+      Arrays.fill(stack, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31cd244b968a657400cf6be1971f408e385de974"}, "originalPosition": 312}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4983, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}