{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MTYyNDkx", "number": 1883, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1MDoxNlrOEk-oMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDo1Njo0OFrOElAWSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjEwMjg4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/CallableWrapper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1MDoxNlrOHUOAqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1MDoxNlrOHUOAqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2MzExMw==", "bodyText": "Thank you. I've been too lazy to do anything about these.", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490963113", "createdAt": "2020-09-18T13:50:16Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/CallableWrapper.java", "diffHunk": "@@ -22,11 +22,13 @@ public Object call() throws Exception {\n   }\n \n   public static Callable<?> wrapIfNeeded(final Callable<?> task) {\n-    // We wrap only lambdas' anonymous classes and if given object has not already been wrapped.\n-    // Anonymous classes have '/' in class name which is not allowed in 'normal' classes.\n-    if (task.getClass().getName().contains(\"/\") && (!(task instanceof CallableWrapper))) {\n-      log.debug(\"Wrapping callable task {}\", task);\n-      return new CallableWrapper(task);\n+    if (!(task instanceof CallableWrapper)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjExMDgyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/AbstractExecutorInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1MjowMVrOHUOFYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1MjowMVrOHUOFYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2NDMyMg==", "bodyText": "Nice", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490964322", "createdAt": "2020-09-18T13:52:01Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/AbstractExecutorInstrumentation.java", "diffHunk": "@@ -27,22 +27,22 @@\n    * Only apply executor instrumentation to whitelisted executors. To apply to all executors, use\n    * override setting above.\n    */\n-  private final Collection<String> WHITELISTED_EXECUTORS;\n+  private final Collection<String> PERMITTED_EXECUTORS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjEyNjk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMzo1NTo1OFrOHUOPhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDoyMToyMlrOHUPSTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2NjkxNg==", "bodyText": "How costly is this? I mean if you schedule something it probably isn't time critical, but anyway it's String comparisons.", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490966916", "createdAt": "2020-09-18T13:55:58Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    // targeting the concrete type because it's an implementation detail\n+    // that this executor's submit calls schedule, and our instrumentation\n+    // is not idempotent\n+    return named(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Runnable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleRunnableAdvice\");\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Callable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleCallableAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    final Map<String, String> map = new HashMap<>(4);\n+    map.put(Runnable.class.getName(), State.class.getName());\n+    map.put(Callable.class.getName(), State.class.getName());\n+    map.put(Future.class.getName(), State.class.getName());\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  public static class ScheduleRunnableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {\n+        // don't instrument our background tasks!\n+        return null;\n+      }\n+      final TraceScope scope = activeScope();\n+      task = new RunnableWrapper(task);\n+      final ContextStore<Runnable, State> contextStore =\n+          InstrumentationContext.get(Runnable.class, State.class);\n+      return ExecutorInstrumentationUtils.setupState(contextStore, task, scope);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exitSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Enter final State state,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Return final Future future) {\n+      if (state != null && future != null) {\n+        final ContextStore<Future, State> contextStore =\n+            InstrumentationContext.get(Future.class, State.class);\n+        contextStore.put(future, state);\n+      }\n+      ExecutorInstrumentationUtils.cleanUpOnMethodExit(executor, state, throwable);\n+    }\n+  }\n+\n+  public static class ScheduleCallableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Callable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2ODMzMA==", "bodyText": "Yes - @mcculls has a better solution to this which is for us not to use ScheduledExecutorService ourselves at all. This will disappear soon.", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490968330", "createdAt": "2020-09-18T13:58:06Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    // targeting the concrete type because it's an implementation detail\n+    // that this executor's submit calls schedule, and our instrumentation\n+    // is not idempotent\n+    return named(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Runnable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleRunnableAdvice\");\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Callable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleCallableAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    final Map<String, String> map = new HashMap<>(4);\n+    map.put(Runnable.class.getName(), State.class.getName());\n+    map.put(Callable.class.getName(), State.class.getName());\n+    map.put(Future.class.getName(), State.class.getName());\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  public static class ScheduleRunnableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {\n+        // don't instrument our background tasks!\n+        return null;\n+      }\n+      final TraceScope scope = activeScope();\n+      task = new RunnableWrapper(task);\n+      final ContextStore<Runnable, State> contextStore =\n+          InstrumentationContext.get(Runnable.class, State.class);\n+      return ExecutorInstrumentationUtils.setupState(contextStore, task, scope);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exitSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Enter final State state,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Return final Future future) {\n+      if (state != null && future != null) {\n+        final ContextStore<Future, State> contextStore =\n+            InstrumentationContext.get(Future.class, State.class);\n+        contextStore.put(future, state);\n+      }\n+      ExecutorInstrumentationUtils.cleanUpOnMethodExit(executor, state, throwable);\n+    }\n+  }\n+\n+  public static class ScheduleCallableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Callable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2NjkxNg=="}, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk3MjU2OA==", "bodyText": "We also need to avoid instrumenting tasks from profiling system start up!", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490972568", "createdAt": "2020-09-18T14:04:39Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    // targeting the concrete type because it's an implementation detail\n+    // that this executor's submit calls schedule, and our instrumentation\n+    // is not idempotent\n+    return named(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Runnable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleRunnableAdvice\");\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Callable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleCallableAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    final Map<String, String> map = new HashMap<>(4);\n+    map.put(Runnable.class.getName(), State.class.getName());\n+    map.put(Callable.class.getName(), State.class.getName());\n+    map.put(Future.class.getName(), State.class.getName());\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  public static class ScheduleRunnableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {\n+        // don't instrument our background tasks!\n+        return null;\n+      }\n+      final TraceScope scope = activeScope();\n+      task = new RunnableWrapper(task);\n+      final ContextStore<Runnable, State> contextStore =\n+          InstrumentationContext.get(Runnable.class, State.class);\n+      return ExecutorInstrumentationUtils.setupState(contextStore, task, scope);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exitSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Enter final State state,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Return final Future future) {\n+      if (state != null && future != null) {\n+        final ContextStore<Future, State> contextStore =\n+            InstrumentationContext.get(Future.class, State.class);\n+        contextStore.put(future, state);\n+      }\n+      ExecutorInstrumentationUtils.cleanUpOnMethodExit(executor, state, throwable);\n+    }\n+  }\n+\n+  public static class ScheduleCallableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Callable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2NjkxNg=="}, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDAxMg==", "bodyText": "I've removing this, we can avoid this by checking if the active scope is defined or not", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r490984012", "createdAt": "2020-09-18T14:21:22Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    // targeting the concrete type because it's an implementation detail\n+    // that this executor's submit calls schedule, and our instrumentation\n+    // is not idempotent\n+    return named(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Runnable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleRunnableAdvice\");\n+    transformers.put(\n+        named(\"schedule\").and(takesArgument(0, Callable.class)),\n+        ScheduledExecutorServiceInstrumentation.class.getName() + \"$ScheduleCallableAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    final Map<String, String> map = new HashMap<>(4);\n+    map.put(Runnable.class.getName(), State.class.getName());\n+    map.put(Callable.class.getName(), State.class.getName());\n+    map.put(Future.class.getName(), State.class.getName());\n+    return Collections.unmodifiableMap(map);\n+  }\n+\n+  public static class ScheduleRunnableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {\n+        // don't instrument our background tasks!\n+        return null;\n+      }\n+      final TraceScope scope = activeScope();\n+      task = new RunnableWrapper(task);\n+      final ContextStore<Runnable, State> contextStore =\n+          InstrumentationContext.get(Runnable.class, State.class);\n+      return ExecutorInstrumentationUtils.setupState(contextStore, task, scope);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exitSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Enter final State state,\n+        @Advice.Thrown final Throwable throwable,\n+        @Advice.Return final Future future) {\n+      if (state != null && future != null) {\n+        final ContextStore<Future, State> contextStore =\n+            InstrumentationContext.get(Future.class, State.class);\n+        contextStore.put(future, state);\n+      }\n+      ExecutorInstrumentationUtils.cleanUpOnMethodExit(executor, state, throwable);\n+    }\n+  }\n+\n+  public static class ScheduleCallableAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static State enterSchedule(\n+        @Advice.This final Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Callable task) {\n+      if (task.getClass().getName().startsWith(\"datadog.common.exec.\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk2NjkxNg=="}, "originalCommit": {"oid": "800f646a659ae4263c73a8e11799e6d6638c4e46"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjM3NjIxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDo1NDo1M1rOHUQoSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjoxMjowMFrOHUTeQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwNjAyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");\n          \n          \n            \n                super(\"java-concurrent\");", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r491006024", "createdAt": "2020-09-18T14:54:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99bf6d878707148e723f9552f1051a9a0e48662d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDQ4NA==", "bodyText": "well, it only instruments one specific implementation?", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r491014484", "createdAt": "2020-09-18T15:08:32Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwNjAyNA=="}, "originalCommit": {"oid": "99bf6d878707148e723f9552f1051a9a0e48662d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA1MjYwOQ==", "bodyText": "then it should be something like \"java-concurrent\", \"scheduled-threadpool-executor\" or something like that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r491052609", "createdAt": "2020-09-18T16:12:00Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ScheduledExecutorServiceInstrumentation.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class ScheduledExecutorServiceInstrumentation extends Instrumenter.Default {\n+\n+  public ScheduledExecutorServiceInstrumentation() {\n+    super(\"java.util.concurrent.ScheduledThreadPoolExecutor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwNjAyNA=="}, "originalCommit": {"oid": "99bf6d878707148e723f9552f1051a9a0e48662d"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MjM4NDcyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/JavaExecutorInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDo1Njo0OFrOHUQtaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNDo1ODoxNVrOHUQw5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwNzMzOQ==", "bodyText": "Do we still want to keep the schedule method advice above?", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r491007339", "createdAt": "2020-09-18T14:56:48Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/JavaExecutorInstrumentation.java", "diffHunk": "@@ -81,6 +81,9 @@\n     public static State enterJobSubmit(\n         @Advice.This final Executor executor,\n         @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      // there are cased like ScheduledExecutorService.submit (which we instrument)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99bf6d878707148e723f9552f1051a9a0e48662d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwODIzMQ==", "bodyText": "yes, for other executors. We can move them over one by one as we discover those where submit calls in to schedule", "url": "https://github.com/DataDog/dd-trace-java/pull/1883#discussion_r491008231", "createdAt": "2020-09-18T14:58:15Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/JavaExecutorInstrumentation.java", "diffHunk": "@@ -81,6 +81,9 @@\n     public static State enterJobSubmit(\n         @Advice.This final Executor executor,\n         @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      // there are cased like ScheduledExecutorService.submit (which we instrument)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAwNzMzOQ=="}, "originalCommit": {"oid": "99bf6d878707148e723f9552f1051a9a0e48662d"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4831, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}