{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDM3NTE3", "number": 1297, "reviewThreads": {"totalCount": 68, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxMzowNlrODljIPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoxMTo1M1rODy-uUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjk5NDU0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-jfr-bootstrap/agent-jfr-bootstrap.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToxMzowNlrOFygbvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzozMToyM1rOF0Zh_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUwOQ==", "bodyText": "I think injecting java8 classes into bootstrap may be not very good. Also I do not quite see why this cannot be part of instrumentation that uses it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r388504509", "createdAt": "2020-03-05T19:13:06Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-jfr-bootstrap/agent-jfr-bootstrap.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDE3Ng==", "bodyText": "This injection is safe - the classes will not be loaded unless someone asks for them. And we will ask for them only from JFR (or other JDK 8+ only code which will be running only in JDK 8+ env).\nAs for why it can not be a part of the instrumentation - I had a chat with you where you described how I needed to declare helper classes I wanted to use from instrumentation. And these helper classes would be injected for each class loader each instrumented class was loaded by and I don't want this - I need a JVM wide singleton. That's why I did all this dance to have a separate bootstrap compiled for JDK 8 and the access bridge which will actually give the instrumentation access to those classes ...\nIf there is any easier way to achieve my goals I am all ears - the simpler the better!", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r388810176", "createdAt": "2020-03-06T09:56:18Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-jfr-bootstrap/agent-jfr-bootstrap.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUwOQ=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4ODU3NA==", "bodyText": "The whole bootstrap is gone.\nNow the instrumentation is guarded by the presence of jdk.jfr.Event class - muzzle test is passing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390488574", "createdAt": "2020-03-10T17:31:23Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-jfr-bootstrap/agent-jfr-bootstrap.gradle", "diffHunk": "@@ -0,0 +1,33 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUwOQ=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDM1Mjk2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjo1Nzo0MlrOFzACYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzozMDoyN1rOF0ZfkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA==", "bodyText": "is there any point in compiling this for java 7? and if so why do you  need java11 compiler? You may want to clarify incomments...\nAlso I think you've cargoculted comments above this line that may not apply - and this is true for all 3 blocks in this file.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389022304", "createdAt": "2020-03-06T16:57:42Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMTcxNw==", "bodyText": "There are two source roots - one for 7 and for 11.\nIn 7 there is the instrumentation impl which I was under impression was required to be Java 7 compatible.\nIn 11 there are classes using JFR APIs - these APIs are currently available only in JDK 11 (LTS) so this needs to be compiled with java 11", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389031717", "createdAt": "2020-03-06T17:12:15Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MDM5Ng==", "bodyText": "Hold on... there might be different problem then...\nSo first of all - you should not need to tune compile settings for instrumentation itself - it will be compiled by java8 for java7 by default. So this block should go away.\nSecondly - if instrumentation matches it will try to load code from advice and apply it to Exception - even on JVM that cannot run it... I have a feeling this will not end well. In order to fix this I think you need to add matcher for classloader that makes sure you have jfr classes available.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389050396", "createdAt": "2020-03-06T17:48:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1OTQ4Mg==", "bodyText": "After some discussion off GH: last point may not be of a concern, but we need to make sure we test this and ideally we should not throw strange looking exceptions into logs during startup.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389059482", "createdAt": "2020-03-06T18:07:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4Nzk1Mw==", "bodyText": "Java 7 compilation is gone", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390487953", "createdAt": "2020-03-10T17:30:27Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,53 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+  testCompile project(':dd-java-agent:agent-jfr-bootstrap')\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_7\n+targetCompatibility = JavaVersion.VERSION_1_7\n+\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '11', '-target','11','-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}\n+\n+compileTestJava {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    options.compilerArgs.addAll(['-source', '7', '-target','7','-Xlint:all,-processing,-options,-path'])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyMjMwNA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDM5MDc3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowNjoxMlrOFzAa8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoyMzo0MFrOFzA-MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyODU5Mw==", "bodyText": "I think generally style of this repo avoids shortened variable names like this - and I feel it would be easy on everybody if style is preserved :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389028593", "createdAt": "2020-03-06T17:06:12Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNzYxNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389037617", "createdAt": "2020-03-06T17:23:40Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAyODU5Mw=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDQwMDY4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzowOToxMFrOFzAhDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxOTowMzoxNlrOFzD64g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng==", "bodyText": "I have a strong feeling you should not need this and you should be able to use ExceptionEventSampler from advice directly.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389030156", "createdAt": "2020-03-06T17:09:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.exceptions.jfr;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+\n+/**\n+ * A simple accessor bridge implementation.\n+ * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n+ * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n+ * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n+ * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n+ */\n+public class ExceptionEventSamplerBridge {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNzg1Nw==", "bodyText": "I will re-check. I had problems using that class and that's why I came up with the bridge.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389037857", "createdAt": "2020-03-06T17:24:10Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.exceptions.jfr;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+\n+/**\n+ * A simple accessor bridge implementation.\n+ * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n+ * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n+ * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n+ * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n+ */\n+public class ExceptionEventSamplerBridge {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NTkyMg==", "bodyText": "Ok. It is gone. Not sure what exactly was my problem when I tried that originally but now the helper class from bootstrap behaves as expected and there is no more need for the extra bridge class.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389085922", "createdAt": "2020-03-06T19:03:16Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/jfr/ExceptionEventSamplerBridge.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.exceptions.jfr;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionEventSampler;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+\n+/**\n+ * A simple accessor bridge implementation.\n+ * {@linkplain datadog.exceptions.instrumentation.ExceptionAdvice} can only access classes declared by {@linkplain Instrumenter.Default#helperClassNames()}\n+ * but these helper classes are loaded per the instrumented class classloader - hence it may be loaded multiple times.\n+ * However, the {@linkplain ExceptionEventSampler} instance must be a singleton within the context of JVM. Therefore it is\n+ * not possible to use that class directly as a helper and it needs to be accessed via this bridge.\n+ */\n+public class ExceptionEventSamplerBridge {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMDE1Ng=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDQxODc0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxNDo0OVrOFzAseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzoyOToxMlrOF023yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMzA4MQ==", "bodyText": "Could you please make sure you follow settings in https://github.com/DataDog/dd-trace-java/blob/master/CONTRIBUTING.md to avoid stray changes when someone else edits this code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389033081", "createdAt": "2020-03-06T17:14:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2OTI4OA==", "bodyText": "Done. However, the recommended 'On Save' action is applying different formatting than Google java format so I now need to re-run googleJavaFormat task before each commit to revert unwanted format changes :/", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390969288", "createdAt": "2020-03-11T13:29:12Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzMzA4MQ=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDQzMjY0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzoxOToxMlrOFzA1LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzozNDoxNFrOFzBTQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA==", "bodyText": "I think it may not make sense to split sampling (and event creation) into one place and commit into another...\nYou might as well put the whole thing into ExceptionEventSampler.sample(e) - and potentially rename it accordingly.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389035308", "createdAt": "2020-03-06T17:19:12Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODUwOQ==", "bodyText": "In fact you can take this further and make different implementations of ExceptionEventSampler.sample(e) that are 'JVM-agnostic' and use correct one...\nThis way ur instrumentation will not depend on any non java7 classes directly - and among other things will not produce odd exceptions when run under java7", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389038509", "createdAt": "2020-03-06T17:25:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODU1OQ==", "bodyText": "Yeah, started with that. Unfortunately, JFR fills in the stacktrace at the place where the event is committed. When I did that in the sampler I had misleading stacktraces so I had to split it like this :(", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389038559", "createdAt": "2020-03-06T17:25:38Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MDc4NQ==", "bodyText": "Would you mind commenting that for posterity?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389040785", "createdAt": "2020-03-06T17:29:46Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MzAxMQ==", "bodyText": "Sure. It is not really clear why it must done as it is ...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389043011", "createdAt": "2020-03-06T17:34:14Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/datadog/exceptions/instrumentation/ExceptionAdvice.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.exceptions.instrumentation;\n+\n+import datadog.exceptions.jfr.ExceptionEventSamplerBridge;\n+import datadog.trace.bootstrap.instrumentation.jfr.exceptions.ExceptionSampleEvent;\n+import net.bytebuddy.asm.Advice;\n+\n+public class ExceptionAdvice {\n+  @Advice.OnMethodExit(suppress = Throwable.class)\n+  public static void onExit(@Advice.This final Exception e) {\n+    ExceptionSampleEvent ese = ExceptionEventSamplerBridge.sample(e);\n+    if (ese != null && ese.shouldCommit()) {\n+      ese.commit();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzNTMwOA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDQ4NjI1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzozNTo1OFrOFzBWjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODoyNToxMVrOF0bmCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA==", "bodyText": "This would mean that bootstrap would need to see classes from dd-trace-ot - this seem wrong.\nInstead you may want to consider having essentially a wrapper class on bootstrap level that has a 'field' that is initialized into correct sampling implementation by initialization code in some other place - probably when apm starts up or something.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389043854", "createdAt": "2020-03-06T17:35:58Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NjE4Mg==", "bodyText": "agent-bootstrap already depends on dd-trace-api\ndependencies {\n  compile project(':dd-trace-api')\n  compile project(':dd-java-agent:agent-jfr-bootstrap')\n  compile deps.opentracing\n  compile deps.slf4j\n  compile group: 'org.slf4j', name: 'slf4j-simple', version: versions.slf4j\n  // ^ Generally a bad idea for libraries, but we're shadowing.\n}\n\nDo you think it may cause problems? I am running it in dev and there does not seem to be any errors.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r389046182", "createdAt": "2020-03-06T17:39:53Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDA0Mw==", "bodyText": "Not putting the support classes to bootstrap any more.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390484043", "createdAt": "2020-03-10T17:24:32Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMjM3Ng==", "bodyText": "Removed from bootstrap", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390522376", "createdAt": "2020-03-10T18:25:11Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-jfr-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/jfr/exceptions/ExceptionEventSampler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package datadog.trace.bootstrap.instrumentation.jfr.exceptions;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.AdaptiveIntervalSampler;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception event sampler. Uses {@linkplain Config} class to configure a\n+ * {@linkplain AdaptiveIntervalSampler} instance using either system properties, environment or\n+ * properties override.\n+ */\n+public final class ExceptionEventSampler {\n+  private static final int TIME_WINDOW_SECS;\n+  private static final int MAX_WINDOW_SAMPLES;\n+\n+  private static final AdaptiveIntervalSampler SAMPLER;\n+  private static final int SAMPLER_INTERVAL;\n+  private static final EventType EXCEPTION_SAMPLE_EVENT_TYPE;\n+\n+  static {\n+    Config cfg = Config.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Mzg1NA=="}, "originalCommit": {"oid": "6d2c32779b5fcedaa8355245a2700324d0d85b3a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTc3Nzk0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjo1MzoyMFrOF0X9bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwOTowMDo1NFrOF0uFcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA==", "bodyText": "Why Exception and not Throwable?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390462828", "createdAt": "2020-03-10T16:53:20Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDYzMA==", "bodyText": "We do not want to instrument Errors - we are already tracking them by the native JFR event(s)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390484630", "createdAt": "2020-03-10T17:25:29Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}, "originalCommit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NTIzNQ==", "bodyText": "ok.  A comment in this class to that effect might be beneficial.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390485235", "createdAt": "2020-03-10T17:26:24Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}, "originalCommit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyNTMzMQ==", "bodyText": "Comment added", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r390825331", "createdAt": "2020-03-11T09:00:54Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return new String[] {\n+      \"com.datadog.profiling.exceptions.AdaptiveIntervalSampler\",\n+      \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionHistogram$ValueVisitor\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$1\",\n+      \"com.datadog.profiling.exceptions.ExceptionProfiling$Singleton\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+      \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+    };\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return ElementMatchers.is(Exception.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MjgyOA=="}, "originalCommit": {"oid": "751897f197dfe76b558220bfdc5d139e7a22f7fb"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTA4NzA0OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjoxNToxNFrOF4Mkcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzowMTo0MFrOF7lHXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDUxNA==", "bodyText": "I do not think other options are using similar suffixes... you may want to drop it and just have a comment for now. After this is released we will just update docs.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394470514", "createdAt": "2020-03-18T16:15:14Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -127,6 +127,13 @@\n   public static final String PROFILING_PROXY_PORT = \"profiling.proxy.port\";\n   public static final String PROFILING_PROXY_USERNAME = \"profiling.proxy.username\";\n   public static final String PROFILING_PROXY_PASSWORD = \"profiling.proxy.password\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_INTERVAL =\n+      \"profiling.exception-sampler.interval\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_MAX_SAMPLES =\n+      \"profiling.exception-sampler.max-samples\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_TIME_WINDOW =\n+      \"profiling.exception-sampler.time-window.sec\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAxODM5Ng==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398018396", "createdAt": "2020-03-25T17:01:40Z", "author": {"login": "jbachorik"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -127,6 +127,13 @@\n   public static final String PROFILING_PROXY_PORT = \"profiling.proxy.port\";\n   public static final String PROFILING_PROXY_USERNAME = \"profiling.proxy.username\";\n   public static final String PROFILING_PROXY_PASSWORD = \"profiling.proxy.password\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_INTERVAL =\n+      \"profiling.exception-sampler.interval\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_MAX_SAMPLES =\n+      \"profiling.exception-sampler.max-samples\";\n+  public static final String PROFILING_EXCEPTION_SAMPLER_TIME_WINDOW =\n+      \"profiling.exception-sampler.time-window.sec\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MDUxNA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTE1MTMyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMDoyOVrOF4NOPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzozMzoxOFrOF4Pxuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA==", "bodyText": "Blowing up in advice might not be a very good strategy... Would it be possible to gracefully skip exception handling instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394481214", "createdAt": "2020-03-18T16:30:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {\n+    ExceptionProfiling.config = config;\n+  }\n+\n+  /**\n+   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n+   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n+   *\n+   * @return the shared instance\n+   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n+   *     called yet\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    assert config != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4OTkwNQ==", "bodyText": "IDK. The idea was that this should blow up during development or staging, etc. - since it is depending solely on calling init(config) in right order. If it is silently ignored there is a good chance no one will ever inspect the logs and notice that we exception profiling is not working because of this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394489905", "createdAt": "2020-03-18T16:43:22Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {\n+    ExceptionProfiling.config = config;\n+  }\n+\n+  /**\n+   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n+   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n+   *\n+   * @return the shared instance\n+   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n+   *     called yet\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    assert config != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMzA2Nw==", "bodyText": "We should have integration test that verifies that exception events are being written. This assertion is likely (and hopefully) ignored by @Advice.OnMethodExit(suppress = Throwable.class) - so as things currently stay I do not think it is useful anyway...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394523067", "createdAt": "2020-03-18T17:33:18Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {\n+    ExceptionProfiling.config = config;\n+  }\n+\n+  /**\n+   * Get a pre-configured shared instance. !!! BEFORE FIRST CALL OF THIS METHOD {@linkplain\n+   * ExceptionProfiling#init(Config)} MUST HAVE BEEN INVOKED\n+   *\n+   * @return the shared instance\n+   * @throws NullPointerException if {@linkplain ExceptionProfiling#init(Config)} has not been\n+   *     called yet\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    assert config != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTIxNA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTE1OTUxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozMjozNVrOF4NTtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzozNTozM1rOF4P3BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg==", "bodyText": "Do you need this statically separately? Presumably you have a singleton instance - can you have non static config there and have a non static init method?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394482612", "createdAt": "2020-03-18T16:32:35Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDE0Ng==", "bodyText": "I think if you make this non static you can get rid off Singleton class", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394484146", "createdAt": "2020-03-18T16:34:48Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MzcxNQ==", "bodyText": "IDK - I need to configure it in the controller and use from advice - and it needs to be a JVM wide singleton there. From my experiments it seems that Config is not accessible from the advice.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394493715", "createdAt": "2020-03-18T16:49:00Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyNDQyMA==", "bodyText": "ExceptionProfiling.getInstance().process(e) in advice and ExceptionProfiling.getInstance().init(config) in controller should get you there, no?\nYou do not need to store reference to config when calling init - you can fetch and store values...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394524420", "createdAt": "2020-03-18T17:35:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.FlightRecorderListener;\n+import jdk.jfr.Recording;\n+import jdk.jfr.RecordingState;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static volatile Config config = null;\n+\n+  private static final class Singleton {\n+    static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+  }\n+\n+  /**\n+   * Initialization routine. !!! MUST BE CALLED BEFORE {@linkplain ExceptionProfiling#getInstance()}\n+   * - otherwise that call will crash\n+   *\n+   * @param config the system configuration\n+   */\n+  public static void init(final Config config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MjYxMg=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTE3MTkzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNTozNVrOF4Nbrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzozMToyOFrOF4PtNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA==", "bodyText": "Having hashes of unlimited size may be problematic... You may want to consider putting hard limit on this somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394484654", "createdAt": "2020-03-18T16:35:35Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NzQ3Mg==", "bodyText": "Ok. Realistically, there should not be more than few thousands of entries but I will take a look at putting a hard limit there.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394487472", "createdAt": "2020-03-18T16:39:47Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMTkwOA==", "bodyText": "We've had structures blowing out of control in the past - this affects apps and is hard to debug on client side - so best to avoid, maybe with some careful debug logging...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394521908", "createdAt": "2020-03-18T17:31:28Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NDY1NA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTE3NzcyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjozNzowN1rOF4NfkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNDo0NlrOF4PCcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA==", "bodyText": "I was under impression this should be done in advice because otherwise event will have strange callstack. Has this changed?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394485648", "createdAt": "2020-03-18T16:37:07Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(String type, long count) {\n+    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4Njc0MA==", "bodyText": "This is ok since this particular event is not collecting stack trace.\nOnly events with stack traces are sensitive to the location of commit", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394486740", "createdAt": "2020-03-18T16:38:44Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(String type, long count) {\n+    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMDk2MA==", "bodyText": "nm", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394510960", "createdAt": "2020-03-18T17:14:46Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, LongAdder> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(int maxTopItems, boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    this.exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(String type, long count) {\n+    ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4NTY0OA=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTIxNDM5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NjowOVrOF4N3lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NjowOVrOF4N3lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MTc5Nw==", "bodyText": "It would be really nice to have javadoc here explaining what this does", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394491797", "createdAt": "2020-03-18T16:46:09Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTIyODI5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0OTozMVrOF4OAeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0OTozMVrOF4OAeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NDA3NA==", "bodyText": "Stylewise I feel like keeping mutable fields separate form immutable makes things easier to understand.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394494074", "createdAt": "2020-03-18T16:49:31Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTI2MTkzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo1NzoxN1rOF4OVqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo1NzoxN1rOF4OVqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5OTQ5Nw==", "bodyText": "This doesn't seem to be used. Do you really need this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394499497", "createdAt": "2020-03-18T16:57:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads\n+      currentTop = expectedHits(interval);\n+      counter.addAndGet(counterTop);\n+      sampleCounter++;\n+      ts = ts1;\n+      // write to 'counterTop' makes all previous changes to shared data visible after ts is read by\n+      // other\n+      // threads\n+      counterTop = currentTop;\n+\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  public String getId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTI5MTkyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzowNDozM1rOF4OorQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzozMDozN1rOF4PrGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ==", "bodyText": "is this comment correct? you are not writing to counterTop here", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394504365", "createdAt": "2020-03-18T17:04:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwOTI2Mg==", "bodyText": "It is correct. It is explaining the connection between reading and writing to counterTop. I was pondering adding the line number of the write but then decided not do that as each change to the source file would render the comment incorrect.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394509262", "createdAt": "2020-03-18T17:11:59Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMTM3MQ==", "bodyText": "The way it is worded is still confusing (and on top of that variable naming currrentTop and counterTop is easy to misread... I'd suggest rewording this somehow. You do not have to reference specific line, you can say something like 'belowm when counterTop is saved` or something like that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394521371", "createdAt": "2020-03-18T17:30:37Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }\n+    final long currentCnt = counter.decrementAndGet();\n+\n+    if (currentCnt % currentTop == 0L) {\n+      final long ts1 = System.nanoTime();\n+      // all changes done by other threads before writing to 'ts' will be visible after this line\n+      final long tDiff = ts1 - ts;\n+      final double projectedSamplesCnt = timeWindowNs / (double) tDiff;\n+      final double intervalScale = projectedSamplesCnt / maxSamples;\n+      final long newInterval = Math.max(Math.round(interval * intervalScale), minInterval);\n+      // calculate interval diff in a way it does not swing wildly\n+      final long intervalDiff =\n+          newInterval == interval\n+              ? 0\n+              : Math.round(\n+                  Math.log(Math.abs(newInterval - interval)) * (newInterval < interval ? -1 : 1));\n+      interval = interval + intervalDiff;\n+      // write to counterTop makes all previous changes to shared data visible after counterTop is\n+      // read by other threads", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUwNDM2NQ=="}, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTMzODM2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNzowM1rOF4PH4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNzoxNzowM1rOF4PH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxMjM1NA==", "bodyText": "Wouldn't this short circuit prevent you from properly scaling sampling interval?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394512354", "createdAt": "2020-03-18T17:17:03Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(\n+      final String id,\n+      final int minInterval,\n+      final int stdDevPercent,\n+      final long timeWindowMs,\n+      final long maxSamples) {\n+    this.id = id;\n+    this.minInterval = minInterval;\n+    stdDev = Math.max(Math.min(stdDevPercent, 100), 1) / 100d;\n+    interval = minInterval;\n+    timeWindowNs = TimeUnit.NANOSECONDS.convert(timeWindowMs, TimeUnit.MILLISECONDS);\n+    this.maxSamples = maxSamples;\n+    // for small minimal intervals the sampler can overshoot significantly; trying to compensate for\n+    // that here\n+    targetSamples = Math.round(maxSamples / (Math.max(1, 3 - Math.log10(minInterval))));\n+    counterTop = expectedHits(interval);\n+    counter = new AtomicLong(counterTop);\n+  }\n+\n+  private long expectedHits(final long interval) {\n+    return Math.max(\n+        Math.round(ThreadLocalRandom.current().nextGaussian() * interval * stdDev) + interval, 1);\n+  }\n+\n+  public void reset() {\n+    log.debug(\"Sampler reset [id: {}]\", id);\n+    interval = minInterval;\n+    sampleCounter = 0L;\n+    // write to volatile 'counterTop' to force the visibility of change to 'interval'\n+    counterTop = counterTop * dummyMultiplier;\n+  }\n+\n+  public boolean sample() {\n+    /*\n+     * All changes done by other threads before writing to 'counterTop' will be visible after this\n+     * line\n+     */\n+    long currentTop = counterTop;\n+    if (sampleCounter >= maxSamples) {\n+      // hit the hard limit; no more samples\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODIxNDQ5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjowNzowOVrOF4ri0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjowNzowOVrOF4ri0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3ODAwMQ==", "bodyText": "As discussed offline: there might be a simpler approach to just keep expected number of exceptions per window and then randomly sample each exception with probability based on expected number of exceptions and target number of exceptions.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394978001", "createdAt": "2020-03-19T12:07:09Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/AdaptiveIntervalSampler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class AdaptiveIntervalSampler {\n+  private final double stdDev;\n+  private final String id;\n+  private final int minInterval;\n+  private long interval;\n+  private final long timeWindowNs;\n+  private final long maxSamples;\n+  private final long targetSamples;\n+  private volatile long counterTop = 0L;\n+  private final AtomicLong counter;\n+  private long ts = System.nanoTime();\n+  private long sampleCounter = 0L;\n+  private final int dummyMultiplier = 1;\n+\n+  public AdaptiveIntervalSampler(\n+      final String id, final int minInterval, final long timeWindowMs, final long maxSamples) {\n+    this(id, minInterval, 50, timeWindowMs, maxSamples);\n+  }\n+\n+  public AdaptiveIntervalSampler(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODIzNTM4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoxMzo1MlrOF4rwMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoxMzo1MlrOF4rwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MTQyNQ==", "bodyText": "Please consider using smoke test framework for this, see ProfilingTestApplication as an example.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394981425", "createdAt": "2020-03-19T12:13:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/groovy/JfrHelper.java", "diffHunk": "@@ -0,0 +1,28 @@\n+import com.datadog.profiling.exceptions.ExceptionSampleEvent;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+public class JfrHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0ODI1OTMxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoyMTo1N1rOF4r_yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxMjoyMTo1N1rOF4r_yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4NTQxNw==", "bodyText": "The thing here is that we compile event classes and supporting code for java11 bytecode so for JDK 8 with backported jfr we will attempt to load java11 classes into java8", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r394985417", "createdAt": "2020-03-19T12:21:57Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+@Slf4j\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+public class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    boolean jfr = false;\n+    try {\n+      /* Check only for the open-sources JFR implementation.\n+       * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+       * enhanced\n+       */\n+      Class.forName(\"jdk.jfr.Event\");\n+      jfr = true;\n+    } catch (ClassNotFoundException ignored) {\n+    }\n+    hasJfr = jfr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "568b50978d76134f1a902c1c512102507687faec"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzQ5NTM5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1Njo0NlrOF6EJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1Njo0NlrOF6EJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyOTY2MQ==", "bodyText": "It would be nice to run tests for this on zulu8. Please have a look at #1331 for an example.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396429661", "createdAt": "2020-03-23T12:56:46Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "diffHunk": "@@ -0,0 +1,46 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzQ5NzI1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzoxN1rOF6EKkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjo1NzoxN1rOF6EKkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQyOTk3MA==", "bodyText": "Is this change intentional?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396429970", "createdAt": "2020-03-23T12:57:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-controller-openjdk/src/main/java/com/datadog/profiling/controller/openjdk/OpenJdkController.java", "diffHunk": "@@ -42,15 +43,16 @@\n    * <p>This has to be public because it is created via reflection\n    */\n   public OpenJdkController(final Config config)\n-      throws ConfigurationException, ClassNotFoundException {\n+    throws ConfigurationException, ClassNotFoundException {\n+    System.err.println(\"===> OpenJDKController start\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "569cfa3ccc90e32b0c881700236ddd59552b75b3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTQzNTc1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMDo1MDowNFrOF6XkJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNjozODoyOVrOF7kD7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA==", "bodyText": "Don't know if it helps but you can precompute newThreshold outside of synchronized block as it seems to rely on local values (if I am not mistaken) and do only the if and the 2 updates of long in the synchronized blocks.\nThe other approach will be: if SampleCount and threshold can fit into Integers, you can pack them into only one Long and to a single CAS ensuring atomicity :)\nBut in any cases should be proven that sync block is a real bottleneck :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396747814", "createdAt": "2020-03-23T20:50:04Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzNzU2Nw==", "bodyText": "Well, you got me thinking and I have a solution with atomically updating sampler state working in a state machine fashion :) Looks good and no synchronization FTW :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397937567", "createdAt": "2020-03-25T15:18:11Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk5ODgwNw==", "bodyText": "Yes, at the expense of more allocations ;-)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397998807", "createdAt": "2020-03-25T16:35:20Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMTEzNA==", "bodyText": "Yep. But we are looking at ~1-2 extra allocations per second in a sane setup - the allocation will happen only on sample or window roll. Anyway, there is nothing like a free lunch :(", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398001134", "createdAt": "2020-03-25T16:38:29Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -2,78 +2,167 @@\n \n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.LongAdder;\n import java.util.function.Supplier;\n \n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. Because of very non-trivial nature of this task given the hard limit on samples and the\n+ * sampler being non-remembering the actual implementation is just an approximation. It is using\n+ * rather short 'sampling windows' (few seconds at max) during which at most N samples will be\n+ * taken. This allows for predictability of the number of samples after a certain period of time T\n+ * has elapsed ~ (T / W) * N, where W is the sampling window duration.\n+ *\n+ * <p>The sampler is using exponential CDF as a base for random probing, adjusted in a way that the\n+ * probability of the <b>hit</b> goes to 0 rapidly once the sample limit was hit. The 'lambda'\n+ * parameter of the exponential distribution (or rate) is adjusted from window to window to better\n+ * reflect the expected rate considering the number of events per the sampling window and the sample\n+ * limit. Using this trick it is possible to slightly compensate for the samples being skewed,\n+ * favoring the earlier events.\n+ */\n public class StreamingSampler {\n-  private static final int SCALE = 10_000;\n+  /** Using scale to avoid floating point comparisons */\n+  private static final long SCALE = 10_000_000L;\n \n-  private final long slidingWindowDuration;\n-  private final int slidingWindowSize;\n+  private final long samplingWindowDuration;\n+  private final int samplingWindowSize;\n \n   private final Supplier<Long> timeStampSupplier;\n   private final LongAdder hitCounter = new LongAdder();\n-  private final AtomicLong sampleCounter = new AtomicLong(0L);\n \n-  private final AtomicLong slidingWindowEndTsRef;\n-  private final AtomicInteger thresholdRef;\n+  private final AtomicLong samplingWindowEndTsRef;\n+  private final AtomicLong thresholdRef;\n \n+  private long lambda;\n+  private volatile long sampleCounter = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   */\n   public StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize) {\n-    this(slidingWindowDuration, slidingWindowUnit, slidingWindowSize, System::nanoTime);\n+      final int maxSamplesInWindow) {\n+    this(samplingWindowDuration, slidingWindowUnit, maxSamplesInWindow, System::nanoTime);\n   }\n \n   StreamingSampler(\n-      final long slidingWindowDuration,\n+      final long samplingWindowDuration,\n       final TimeUnit slidingWindowUnit,\n-      final int slidingWindowSize,\n+      final int samplingWindowSize,\n       final Supplier<Long> timeStampSupplier) {\n-    this.slidingWindowDuration =\n-        TimeUnit.NANOSECONDS.convert(slidingWindowDuration, slidingWindowUnit);\n-    this.slidingWindowSize = slidingWindowSize;\n-    slidingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.slidingWindowDuration);\n-    thresholdRef = new AtomicInteger(Math.round((1f / slidingWindowSize) * SCALE));\n+    this.samplingWindowDuration =\n+        TimeUnit.NANOSECONDS.convert(samplingWindowDuration, slidingWindowUnit);\n+    this.samplingWindowSize = samplingWindowSize;\n+    samplingWindowEndTsRef = new AtomicLong(timeStampSupplier.get() + this.samplingWindowDuration);\n+    lambda = 10;\n+    thresholdRef = new AtomicLong(computeThreshold(0, lambda));\n     this.timeStampSupplier = timeStampSupplier;\n   }\n \n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n   public boolean sample() {\n-    hitCounter.increment();\n-    final int threshold = thresholdRef.get();\n     boolean result = false;\n+    hitCounter.increment();\n+    final long threshold = thresholdRef.get();\n+    final long s = sampleCounter;\n     if (test(threshold)) {\n-      final long samples = sampleCounter.incrementAndGet();\n-      thresholdRef.getAndUpdate(v -> v == threshold ? getNextThreshold(samples, v) : v);\n-      result = true;\n+      long newSampleCount = -1;\n+      long newThreshold = -1;\n+      /*\n+       * Trying to do this completely lock-free leads to a very complex code which tends to blow up the hard limits.\n+       * Let's just do the sane thing and put the critical block, which is kept very minimal, into synchronized section.\n+       * For our purposes the crucial part is making sure we haven't already got sample hit for the same sample number.\n+       */\n+      synchronized (this) {\n+        if (sampleCounter == s) {\n+          newSampleCount = s + 1;\n+          newThreshold = computeThreshold(newSampleCount, lambda);\n+          thresholdRef.set(newThreshold);\n+          sampleCounter = newSampleCount;\n+          result = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0NzgxNA=="}, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY3NjI4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowOTozOVrOF6Z7_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjowOTozOVrOF6Z7_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjY4NQ==", "bodyText": "This will keep entries for longer than needed. Please consider #1334", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786685", "createdAt": "2020-03-23T22:09:39Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/src/main/java/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+  private final Map<String, AtomicLong> histoMap = new ConcurrentHashMap<>();\n+  private final EventType exceptionCountEventType;\n+  private final int maxTopItems;\n+  private final boolean forceEnabled;\n+\n+  @FunctionalInterface\n+  interface ValueVisitor {\n+    void visit(String key, long value);\n+  }\n+\n+  ExceptionHistogram(final Config config) {\n+    this(config.getProfilingExceptionHistoMax(), false);\n+  }\n+\n+  ExceptionHistogram(final int maxTopItems, final boolean forceEnabled) {\n+    this.maxTopItems = maxTopItems;\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    this.forceEnabled = forceEnabled;\n+\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, this::emit);\n+  }\n+\n+  private void emit() {\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      processAndReset(this::newExceptionCountEvent);\n+    }\n+  }\n+\n+  private void newExceptionCountEvent(final String type, final long count) {\n+    final ExceptionCountEvent event = new ExceptionCountEvent(type, count);\n+    if (event.shouldCommit()) {\n+      event.commit();\n+    }\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  boolean record(final String typeName) {\n+    if (typeName == null) {\n+      return false;\n+    }\n+    if (forceEnabled || exceptionCountEventType.isEnabled()) {\n+      final boolean[] firstHit = new boolean[] {false};\n+      histoMap\n+          .computeIfAbsent(\n+              typeName,\n+              k -> {\n+                try {\n+                  return new AtomicLong();\n+                } finally {\n+                  firstHit[0] = true;\n+                }\n+              })\n+          .incrementAndGet();\n+\n+      return firstHit[0];\n+    }\n+    return false;\n+  }\n+\n+  void processAndReset(final ValueVisitor processor) {\n+    Stream<Map.Entry<String, Long>> items =\n+        histoMap\n+            .entrySet()\n+            .stream()\n+            .map(e -> entry(e.getKey(), e.getValue().getAndSet(0L)))\n+            .filter(e -> e.getValue() != 0)\n+            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()));\n+    histoMap.entrySet().removeIf(e -> e.getValue().get() == 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY3NzgwOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMDoxOFrOF6Z8-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMDoxOFrOF6Z8-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NjkzNw==", "bodyText": "This is wrong and test that verifies this should have been updated. Please consider #1334", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396786937", "createdAt": "2020-03-23T22:10:18Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -635,6 +658,20 @@ private Config(final Properties properties, final Config parent) {\n     profilingProxyPassword =\n         properties.getProperty(PROFILING_PROXY_PASSWORD, parent.profilingProxyPassword);\n \n+    profilingExceptionSamplerSlidingWindow =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW);\n+    profilingExceptionSamplerSlidingWindowSamples =\n+        getPropertyIntegerValue(\n+            properties,\n+            PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES,\n+            DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES);\n+    profilingExceptionHistoMax =\n+        getPropertyIntegerValue(\n+            properties, PROFILING_EXCEPTION_HISTO_MAX, DEFAULT_PROFILING_EXCEPTION_HISTO_MAX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY4MDE1OnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxM1rOF6Z-Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTowOToyOFrOGAZsGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NzMwMw==", "bodyText": "Could you please explain why this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396787303", "createdAt": "2020-03-23T22:11:13Z", "author": {"login": "mar-kolya"}, "path": "settings.gradle", "diffHunk": "@@ -72,6 +73,7 @@ include ':dd-java-agent:instrumentation:elasticsearch:transport-2'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5.3'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-6'\n+include ':dd-java-agent:instrumentation:exception-profiling'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA3NDA3Mg==", "bodyText": "nm, misread", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r403074072", "createdAt": "2020-04-03T15:09:28Z", "author": {"login": "mar-kolya"}, "path": "settings.gradle", "diffHunk": "@@ -72,6 +73,7 @@ include ':dd-java-agent:instrumentation:elasticsearch:transport-2'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-5.3'\n include ':dd-java-agent:instrumentation:elasticsearch:transport-6'\n+include ':dd-java-agent:instrumentation:exception-profiling'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NzMwMw=="}, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1OTY4MDMxOnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxNlrOF6Z-fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMjoxMToxNlrOF6Z-fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NzMyNg==", "bodyText": "Could you please explain why this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r396787326", "createdAt": "2020-03-23T22:11:16Z", "author": {"login": "mar-kolya"}, "path": "settings.gradle", "diffHunk": "@@ -33,6 +33,7 @@ include ':dd-java-agent:load-generator'\n include ':dd-java-agent:agent-profiling'\n include ':dd-java-agent:agent-profiling:profiling-controller'\n include ':dd-java-agent:agent-profiling:profiling-controller-openjdk'\n+include ':dd-java-agent:agent-profiling:profiling-exceptions'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTgyNTQ1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjo1NDozM1rOF6u2dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjo1NDozM1rOF6u2dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTMzMw==", "bodyText": "Do we still need this whole module separately - maybe this could be moved to advice? This would somewhat simplify dependency management.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r397129333", "createdAt": "2020-03-24T12:54:33Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-exceptions/profiling-exceptions.gradle", "diffHunk": "@@ -0,0 +1,50 @@\n+// Set properties before any plugins get loaded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33944845f3ba2a299c8359a879244acada65d4f8"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQ4MDkxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMjowMFrOF8Conw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjo0ODoyMFrOGISweQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw==", "bodyText": "We should address this fix me.\nFirst of all I'm not convinced that firsthit that may be skipped is actually useful.\nAnd if we decide that it is we should update tests to make sure it actually works the way we think it does.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502047", "createdAt": "2020-03-26T11:32:00Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();\n+          } finally {\n+            firstHit[0] = true;\n+          }\n+        })\n+      .incrementAndGet();\n+\n+    // FIXME: this 'first hit' logic is confusing and untested", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjQxMg==", "bodyText": "And it latter case we should also have a comment explaining gotchars of this aproach.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502412", "createdAt": "2020-03-26T11:32:44Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();\n+          } finally {\n+            firstHit[0] = true;\n+          }\n+        })\n+      .incrementAndGet();\n+\n+    // FIXME: this 'first hit' logic is confusing and untested", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTExMw==", "bodyText": "Improved the implementation slightly and added a concurrency test (which requires opening up some methods for package private access but I really doubt there is another way to make sure the test is actually entering the critical section from 2 threads at the same time).\nAdded explaining comment as well ...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411349113", "createdAt": "2020-04-20T12:48:20Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();\n+          } finally {\n+            firstHit[0] = true;\n+          }\n+        })\n+      .incrementAndGet();\n+\n+    // FIXME: this 'first hit' logic is confusing and untested", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjA0Nw=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQ4NTg2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozMzoyOVrOF8Crgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjoyNzoyNFrOF8EeFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng==", "bodyText": "If we decide to keep this firstHit logic I think this code we will much more self-explanatory if we just pass firstHit intosample() call and make sample() do the right thing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398502786", "createdAt": "2020-03-26T11:33:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static final Config config = Config.get();\n+\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+\n+  /**\n+   * Get a pre-configured shared instance.\n+   *\n+   * @return the shared instance\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    return ExceptionProfiling.INSTANCE;\n+  }\n+\n+  private final ExceptionHistogram histogram;\n+  private final ExceptionSampler sampler;\n+\n+  private ExceptionProfiling() {\n+    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n+  }\n+\n+  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n+    this.sampler = sampler;\n+    this.histogram = histogram;\n+  }\n+\n+  public ExceptionSampleEvent process(final Exception e) {\n+    // always record the exception in histogram\n+    final boolean firstHit = histogram.record(e);\n+\n+    if (sampler.isEnabled()) {\n+      /*\n+       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n+       * and the sample event should be emitted regardless of the sampling result.\n+       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n+       * of 'firstHit'.\n+       */\n+      if (firstHit | sampler.sample()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNTYyNQ==", "bodyText": "Also, I think this is wrong: if we force the selection of 'first' exceptions and count them as samples we reduce sampling of all non-first events. I'm not sure this is desired.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398505625", "createdAt": "2020-03-26T11:38:44Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static final Config config = Config.get();\n+\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+\n+  /**\n+   * Get a pre-configured shared instance.\n+   *\n+   * @return the shared instance\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    return ExceptionProfiling.INSTANCE;\n+  }\n+\n+  private final ExceptionHistogram histogram;\n+  private final ExceptionSampler sampler;\n+\n+  private ExceptionProfiling() {\n+    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n+  }\n+\n+  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n+    this.sampler = sampler;\n+    this.histogram = histogram;\n+  }\n+\n+  public ExceptionSampleEvent process(final Exception e) {\n+    // always record the exception in histogram\n+    final boolean firstHit = histogram.record(e);\n+\n+    if (sampler.isEnabled()) {\n+      /*\n+       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n+       * and the sample event should be emitted regardless of the sampling result.\n+       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n+       * of 'firstHit'.\n+       */\n+      if (firstHit | sampler.sample()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzMjExNw==", "bodyText": "We haven't reached any decision in an off-line chat. Therefore I left it as it was.\n\nIf we decide to keep this firstHit logic I think this code we will much more self-explanatory if we just pass firstHit into sample() call and make sample() do the right thing.\n\nThen it will become the property of the sampler, where I am not convinced it belongs to.\n\nAlso, I think this is wrong: if we force the selection of 'first' exceptions and count them as samples we reduce sampling of all non-first events. I'm not sure this is desired.\n\nWe do not count the first exception as a sample (unless the random check passes the threshold, that is). If anything, it will slightly decrease the sampling interval in the first sampling window.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398532117", "createdAt": "2020-03-26T12:27:24Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionProfiling.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+\n+/**\n+ * JVM-wide singleton exception profiling service. Uses {@linkplain Config} class to configure\n+ * itself using either system properties, environment or properties override.\n+ */\n+public final class ExceptionProfiling {\n+  private static final Config config = Config.get();\n+\n+  private static final ExceptionProfiling INSTANCE = new ExceptionProfiling();\n+\n+  /**\n+   * Get a pre-configured shared instance.\n+   *\n+   * @return the shared instance\n+   */\n+  public static ExceptionProfiling getInstance() {\n+    return ExceptionProfiling.INSTANCE;\n+  }\n+\n+  private final ExceptionHistogram histogram;\n+  private final ExceptionSampler sampler;\n+\n+  private ExceptionProfiling() {\n+    this(new ExceptionSampler(config), new ExceptionHistogram(config));\n+  }\n+\n+  ExceptionProfiling(final ExceptionSampler sampler, final ExceptionHistogram histogram) {\n+    this.sampler = sampler;\n+    this.histogram = histogram;\n+  }\n+\n+  public ExceptionSampleEvent process(final Exception e) {\n+    // always record the exception in histogram\n+    final boolean firstHit = histogram.record(e);\n+\n+    if (sampler.isEnabled()) {\n+      /*\n+       * If the histogram hasn't contained that particular exception type up till now then 'firstHit' == true\n+       * and the sample event should be emitted regardless of the sampling result.\n+       * We need a non-short-circuiting OR such that 'sampler.sample()' is called regardless of value\n+       * of 'firstHit'.\n+       */\n+      if (firstHit | sampler.sample()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMjc4Ng=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDQ5MDUyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozNDo0OVrOF8Cubw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTozNDo0OVrOF8Cubw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwMzUzNQ==", "bodyText": "This class doesn't seem to be providing much value now :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398503535", "createdAt": "2020-03-26T11:34:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+final class ExceptionSampler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDUxNzQ2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0MzoxMFrOF8C_YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjoyODo0M1rOF8EhNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNzg3Mw==", "bodyText": "Please consider replacing this with this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            sourceCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            targetCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            \n          \n          \n            \n            compileJava {\n          \n          \n            \n              sourceCompatibility = JavaVersion.VERSION_1_7\n          \n          \n            \n              targetCompatibility = JavaVersion.VERSION_1_7\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n          \n          \n            \n            compileMain_java11Java {\n          \n          \n            \n              doFirst {\n          \n          \n            \n                // Disable '-processing' because some annotations are not claimed.\n          \n          \n            \n                // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n          \n          \n            \n                // Disable '-path' because we do not have some of the paths seem to be missing.\n          \n          \n            \n                // Compile to 8 compatible byte code\n          \n          \n            \n                options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n          \n          \n            \n                options.fork = true\n          \n          \n            \n                options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n          \n          \n            \n              }\n          \n          \n            \n            }\n          \n          \n            \n            compileTestJava {\n          \n          \n            \n              sourceCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n              targetCompatibility = JavaVersion.VERSION_1_8\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            // Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n          \n          \n            \n            [compileMain_java11Java, compileTestJava].each {\n          \n          \n            \n              it.doFirst {\n          \n          \n            \n                // Disable '-processing' because some annotations are not claimed.\n          \n          \n            \n                // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n          \n          \n            \n                // Disable '-path' because we do not have some of the paths seem to be missing.\n          \n          \n            \n                // Compile to 8 compatible byte code\n          \n          \n            \n                options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n          \n          \n            \n                options.fork = true\n          \n          \n            \n                options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nI think it will do the right thing and is slightly simpler", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398507873", "createdAt": "2020-03-26T11:43:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+  // Zulu has backported profiling support\n+  forceJdk = ['ZULU8']\n+  // By default tests with be compiled for `minJavaVersionForTests` version,\n+  // but in this case we would like to avoid this since we would like to run with ZULU8\n+  skipSettingTestJavaVersion = true\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+\n+  testCompile deps.junit5\n+  testCompile deps.jmc\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_8\n+targetCompatibility = JavaVersion.VERSION_1_8\n+\n+compileJava {\n+  sourceCompatibility = JavaVersion.VERSION_1_7\n+  targetCompatibility = JavaVersion.VERSION_1_7\n+}\n+\n+// Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    // Compile to 8 compatible byte code\n+    options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzMjkxNg==", "bodyText": "I will try. I did it in the way it is done because all other attempts to actually influence compileTestJava task did not work. It was still compiling with the top level defined compatibility.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398532916", "createdAt": "2020-03-26T12:28:43Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/exception-profiling.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_11\n+  // Zulu has backported profiling support\n+  forceJdk = ['ZULU8']\n+  // By default tests with be compiled for `minJavaVersionForTests` version,\n+  // but in this case we would like to avoid this since we would like to run with ZULU8\n+  skipSettingTestJavaVersion = true\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply plugin: \"idea\"\n+\n+dependencies {\n+  compile project(':dd-java-agent:agent-tooling')\n+\n+  testCompile deps.junit5\n+  testCompile deps.jmc\n+}\n+\n+sourceCompatibility = JavaVersion.VERSION_1_8\n+targetCompatibility = JavaVersion.VERSION_1_8\n+\n+compileJava {\n+  sourceCompatibility = JavaVersion.VERSION_1_7\n+  targetCompatibility = JavaVersion.VERSION_1_7\n+}\n+\n+// Must use Java 11 to build JFR enabled code - there is no JFR in OpenJDK 8 (revisit once JFR in Java 8 is available)\n+compileMain_java11Java {\n+  doFirst {\n+    // Disable '-processing' because some annotations are not claimed.\n+    // Disable '-options' because we are compiling for java8 without specifying bootstrap - intentionally.\n+    // Disable '-path' because we do not have some of the paths seem to be missing.\n+    // Compile to 8 compatible byte code\n+    options.compilerArgs.addAll(['-source', '8', '-target', '8', '-Xlint:all,-processing,-options,-path'])\n+    options.fork = true\n+    options.forkOptions.javaHome = file(System.env.JAVA_11_HOME)\n+  }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNzg3Mw=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDUzMTYxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0Njo1NlrOF8DH4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDo1MTowNVrOGEo88Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ==", "bodyText": "I'm not sure I can immediately see how this would be useful.\nMaybe instead of this we could keep cause's message if cause is present?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398510049", "createdAt": "2020-03-26T11:46:56Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.datadog.profiling.exceptions;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"datadog.ExceptionSample\")\n+@Label(\"ExceptionSample\")\n+@Description(\"Datadog exception sample event.\")\n+@Category(\"Datadog\")\n+public class ExceptionSampleEvent extends Event {\n+  @Label(\"Exception Type\")\n+  private String type;\n+\n+  @Label(\"Exception message\")\n+  private final String message;\n+\n+  @Label(\"Exception stackdepth\")\n+  private final int stackDepth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NTg4Ng==", "bodyText": "Should we still consider storing message for the cause?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405455886", "createdAt": "2020-04-08T11:33:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.datadog.profiling.exceptions;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"datadog.ExceptionSample\")\n+@Label(\"ExceptionSample\")\n+@Description(\"Datadog exception sample event.\")\n+@Category(\"Datadog\")\n+public class ExceptionSampleEvent extends Event {\n+  @Label(\"Exception Type\")\n+  private String type;\n+\n+  @Label(\"Exception message\")\n+  private final String message;\n+\n+  @Label(\"Exception stackdepth\")\n+  private final int stackDepth;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxODQ0OQ==", "bodyText": "Please consider #1363", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407518449", "createdAt": "2020-04-13T14:51:05Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampleEvent.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.datadog.profiling.exceptions;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Event;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Name(\"datadog.ExceptionSample\")\n+@Label(\"ExceptionSample\")\n+@Description(\"Datadog exception sample event.\")\n+@Category(\"Datadog\")\n+public class ExceptionSampleEvent extends Event {\n+  @Label(\"Exception Type\")\n+  private String type;\n+\n+  @Label(\"Exception message\")\n+  private final String message;\n+\n+  @Label(\"Exception stackdepth\")\n+  private final int stackDepth;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMDA0OQ=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDUzOTIzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo0ODo1MFrOF8DMMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjozMToxMlrOF8EmzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTE1Mw==", "bodyText": "I do not think this is used", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398511153", "createdAt": "2020-03-26T11:48:50Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java", "diffHunk": "@@ -108,6 +108,10 @@ public boolean add(final List<DDSpan> trace) {\n     GlobalTracer.registerIfAbsent((datadog.trace.api.Tracer) TEST_TRACER);\n   }\n \n+  protected static Instrumentation getInstrumentation() {\n+    return INSTRUMENTATION;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNDM0OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398534348", "createdAt": "2020-03-26T12:31:12Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.java", "diffHunk": "@@ -108,6 +108,10 @@ public boolean add(final List<DDSpan> trace) {\n     GlobalTracer.registerIfAbsent((datadog.trace.api.Tracer) TEST_TRACER);\n   }\n \n+  protected static Instrumentation getInstrumentation() {\n+    return INSTRUMENTATION;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTE1Mw=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDU4NzgxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowMjo0NFrOF8DpwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjozMjowOVrOF8Eo8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODcyMQ==", "bodyText": "I do not think this is used.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398518721", "createdAt": "2020-03-26T12:02:44Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNDg5Ng==", "bodyText": "That's a case of callbacks :) Not necessarily 100% used. I can use it in the test to make sure the number of callbacks equals the number of samples though.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398534896", "createdAt": "2020-03-26T12:32:09Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxODcyMQ=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDU5NjgwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjowNToyMlrOF8DvLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoxNzowOVrOF8zHQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA==", "bodyText": "I think this can be removed: I do not think it provides any actual testing value.\nIn your tests you already control number of windows, so if window rolling is busted your sampling averages will be busted as well. This just seems to introduce unnecessary complexity to the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398520108", "createdAt": "2020-03-26T12:05:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzNjQzMw==", "bodyText": "Actually it does provide a value - in the test I am using simulated clock with random spread within a variability interval and can not guarantee that the requested number of windows will correspond to the observed number of windows. That's where this callback comes handy.\nAlso, I am not sure that an empty callback definition adds a lot of complexity.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398536433", "createdAt": "2020-03-26T12:34:45Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUzODUzNg==", "bodyText": "I think that unit tests testing/viewing internals of implementation is actually not write way to test. So eventhough this in of itself doesn't add much of a complexity - needing it suggests that our tests could be expanded to actually give us confidence that our implementation is correct without looking at the guts.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398538536", "createdAt": "2020-03-26T12:38:25Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NjMyMg==", "bodyText": "Removed", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399296322", "createdAt": "2020-03-27T14:17:09Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),\n+            isExpired ? 0 : samples + 1,\n+            samplesPerWindow,\n+            windowDurationNs,\n+            isExpired ? ts : windowStartTs,\n+            isSampled,\n+            isExpired,\n+            tsProvider);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a sampling test.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     sampling test\n+     */\n+    boolean sampled() {\n+      return sampledFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Checks whether the state was created for a window roll.<br>\n+     * After this method is invoked all subsequent invocations will return {@literal false}\n+     *\n+     * @return {@literal true} only if this is the first invocation and the state was created for a\n+     *     window roll\n+     */\n+    boolean expired() {\n+      return expiredFlag.getAndSet(false);\n+    }\n+\n+    /**\n+     * Use geometric cumulative distribution function (CDF) to calculate the threshold against which\n+     * to test a uniformly distributed random number to decide whether the current test should yield\n+     * sample or not.\n+     */\n+    private static double computeThreshold(\n+        final long samplesPerWindow, final long samples, final long interval) {\n+      /*\n+       * The probability 'p' is calculated as the ratio between the outstanding samples per current window and the total\n+       * expected sample per window.\n+       */\n+      final long samplesDiff = samplesPerWindow - samples;\n+      final double p = (double) samplesDiff / (samplesPerWindow + 1);\n+\n+      /*\n+       * The CDF '1\u2212(1\u2212p)^x+1', where 'x' is the tested interval, will give the probability of a sample appearing in\n+       * the next 'x' tests.\n+       */\n+      return 1 - Math.pow(1 - p, interval + 1);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"SamplerState{\"\n+          + \"eventCount=\"\n+          + eventCounter.get()\n+          + \", samples=\"\n+          + samples\n+          + \", threshold=\"\n+          + threshold\n+          + \", windowStartTs=\"\n+          + windowStartTs\n+          + \", windowEndTs=\"\n+          + windowEndTs\n+          + \", windowDurationNs=\"\n+          + windowDurationNs\n+          + \", samplesPerWindow=\"\n+          + samplesPerWindow\n+          + \", sampledFlag=\"\n+          + sampledFlag\n+          + '}';\n+    }\n+  }\n+\n+  private final AtomicReference<SamplerState> stateRef = new AtomicReference<>();\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param samplingWindowDuration the sampling window duration\n+   * @param slidingWindowUnit the time unit for the sampling window duration\n+   * @param maxSamplesInWindow the maximum number of samples in the sampling window\n+   * @param initialInterval the initial sampling interval (number of events between two samples)\n+   */\n+  public StreamingSampler(\n+      final long samplingWindowDuration,\n+      final TimeUnit slidingWindowUnit,\n+      final int maxSamplesInWindow,\n+      final int initialInterval) {\n+    this(\n+        samplingWindowDuration,\n+        slidingWindowUnit,\n+        maxSamplesInWindow,\n+        initialInterval,\n+        System::nanoTime);\n+  }\n+\n+  StreamingSampler(\n+      final long windowDurationNs,\n+      final TimeUnit windowDurationUnit,\n+      final int samplesPerWindow,\n+      final int initialInterval,\n+      final Supplier<Long> tsProvider) {\n+    stateRef.set(\n+        new SamplerState(\n+            0,\n+            initialInterval,\n+            0L,\n+            samplesPerWindow,\n+            TimeUnit.NANOSECONDS.convert(windowDurationNs, windowDurationUnit),\n+            tsProvider));\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  public boolean sample() {\n+    // atomically test and update the state\n+    final SamplerState sampledState = stateRef.updateAndGet(SamplerState::trySample);\n+\n+    // do not invoke the callback from the concurrent update part to minimize collision probability\n+    if (sampledState != null) {\n+      if (sampledState.expired()) {\n+        onWindowRoll(sampledState);\n+      }\n+      if (sampledState.sampled()) {\n+        onSample(sampledState);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * A custom callback to observe sample event. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after taking this sample\n+   */\n+  protected void onSample(final SamplerState state) {}\n+\n+  /**\n+   * A custom callback to observe rolling of the sampling window. Mostly for debugging purposes.\n+   *\n+   * @param state the sampler state after rolling the window\n+   */\n+  protected void onWindowRoll(final SamplerState state) {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUyMDEwOA=="}, "originalCommit": {"oid": "2996cbc230692a8ae398480d74104d5215ec4b12"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTAwMzIxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo0ODoyOVrOF8HtfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo0ODoyOVrOF8HtfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NTIxMg==", "bodyText": "Thanks for all the comment - this code is much easier to understand this way!", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398585212", "createdAt": "2020-03-26T13:48:29Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTAxMTM2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo1MDowNFrOF8HynQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMzo1MDowNFrOF8HynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU4NjUyNQ==", "bodyText": "I think there is a bug here: you use threshold from the end of the window in the beginning of the next window.\nIn worst (best?) case scenario if all your guesses were correct then in the end of the window threshold will be zero - this is not what you want in the beginning.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398586525", "createdAt": "2020-03-26T13:50:04Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();\n+      // test a uniformly distributed random number against the current threshold\n+      final boolean isSampled = ThreadLocalRandom.current().nextDouble() <= threshold;\n+\n+      final long ts = tsProvider.get();\n+      // a state is expired if the current time stamp is beyond the expected window end time stamp\n+      final boolean isExpired = ts > windowEndTs;\n+      if (isSampled || isExpired) {\n+        /*\n+         * Get the estimated event set size per the sampling window given the up-to-now incoming rate and the window duration.\n+         */\n+        final double estimatedSetSize = ((double) tested / (ts - windowStartTs)) * windowDurationNs;\n+        /*\n+         * Derive the desired sampling interval as such the expected number of samples can cover the estimated size\n+         * in one sampling window.\n+         */\n+        final long interval =\n+            Math.max(Math.round(estimatedSetSize / (samplesPerWindow - samples + 1)), 1);\n+        // generate a new derived immutable state\n+        return new SamplerState(\n+            isExpired ? 0 : tested,\n+            computeThreshold(samplesPerWindow, samples, interval),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTA3NjA4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowMzoxN1rOF8IbHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoxNzo0NFrOF8zItg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5Njg5Mw==", "bodyText": "This is called in AtomicReference#updateAndGet and AtomicReference#updateAndGet may call supplier multiple times resulting in over-count. AtomicReference#updateAndGet wants supplier to be side-effect-free.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398596893", "createdAt": "2020-03-26T14:03:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NjY5NA==", "bodyText": "Correct. Changed the implementation to use synchronized block instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399296694", "createdAt": "2020-03-27T14:17:44Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;\n+    // was this state created for a sampling test?\n+    private final AtomicBoolean sampledFlag;\n+    // was this state create for a window roll?\n+    private final AtomicBoolean expiredFlag;\n+    final long samples;\n+    final double threshold;\n+    final long windowStartTs;\n+    final long windowEndTs;\n+    final long windowDurationNs;\n+    final long samplesPerWindow;\n+\n+    private final Supplier<Long> tsProvider;\n+\n+    private SamplerState(\n+        final long events,\n+        final double threshold,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final long windowStartTs,\n+        final boolean sampled,\n+        final boolean expired,\n+        final Supplier<Long> tsProvider) {\n+      eventCounter = new AtomicLong(events);\n+      this.threshold = threshold;\n+      this.samples = samples;\n+\n+      this.windowDurationNs = windowDurationNs;\n+      this.windowStartTs = windowStartTs;\n+      windowEndTs = windowStartTs + windowDurationNs;\n+      this.samplesPerWindow = samplesPerWindow;\n+      this.tsProvider = tsProvider;\n+      sampledFlag = new AtomicBoolean(sampled);\n+      expiredFlag = new AtomicBoolean(expired);\n+    }\n+\n+    SamplerState(\n+        final long events,\n+        final long interval,\n+        final long samples,\n+        final long samplesPerWindow,\n+        final long windowDurationNs,\n+        final Supplier<Long> tsProvider) {\n+      this(\n+          events,\n+          computeThreshold(samplesPerWindow, samples, interval),\n+          samples,\n+          samplesPerWindow,\n+          windowDurationNs,\n+          tsProvider.get(),\n+          false,\n+          false,\n+          tsProvider);\n+    }\n+\n+    SamplerState trySample() {\n+      final long tested = eventCounter.incrementAndGet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5Njg5Mw=="}, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTA4MTE5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNDoyNFrOF8IeRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNDoyNFrOF8IeRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5NzcwMQ==", "bodyText": "I guess this is a technicality, but I do not think object containing AtomicLong and modifying it can be called 'immutable' :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398597701", "createdAt": "2020-03-26T14:04:24Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTA4ODk5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNjoxN1rOF8IjfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDowNjoxN1rOF8IjfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU5OTAzNw==", "bodyText": "I would suggest naming like eventsSeen and eventsSampled used throughout", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398599037", "createdAt": "2020-03-26T14:06:17Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,257 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. It is also using constant updates of the estimated event set per window such that it can\n+ * vary the expected sampling interval (how many events are between two samples in average) to cover\n+ * the events within one window by approximately the number of requested samples per window. Due to\n+ * all the numbers being just estimates the actual number of samples may vary slightly (the tests\n+ * show the variability being around 20%) and it must be understood that the expected number of\n+ * samples per window is not a hard/precise limit.\n+ */\n+public class StreamingSampler {\n+  /**\n+   * Immutable sampler state wrapper. Provides methods to derive a new state on arriving sample or\n+   * window roll.\n+   */\n+  static final class SamplerState {\n+    private final AtomicLong eventCounter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTIxMTI4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozMjowMVrOF8JxkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoxODoxNFrOF8zJ8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA==", "bodyText": "naming of all three variables here could really use some improvement - I'm not sure I can really follow intent here", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398619024", "createdAt": "2020-03-26T14:32:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyOTAxOQ==", "bodyText": "Also, if Im reading intent correctly here you would want Math.abs", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398629019", "createdAt": "2020-03-26T14:45:03Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA=="}, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NzAwOQ==", "bodyText": "Fixed", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399297009", "createdAt": "2020-03-27T14:18:14Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYxOTAyNA=="}, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTI5NjcxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0OTo1OVrOF8Kn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDoxODoyNlrOF8zKfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjkzMw==", "bodyText": "Message should provide an easy insight into what had failed - currently calculation in the message is very different from calculation in the test meaning that when things fail we do not see how far off we are", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398632933", "createdAt": "2020-03-26T14:49:59Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;\n+    Assertions.assertTrue(\n+        dev <= 0.2d * samplesPerWindow,\n+        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NzE0OA==", "bodyText": "Message changed", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r399297148", "createdAt": "2020-03-27T14:18:26Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(\n+                  Math.round(totalDuration / (double) hits), TimeUnit.NANOSECONDS);\n+      this.stdDev = stdDev;\n+    }\n+\n+    @Override\n+    public Long get() {\n+      final double diff =\n+          Math.max(\n+              (step + ((rnd.nextGaussian() * step) * stdDev)) * 1_000_000L,\n+              1); // at least 1ns progress\n+      return ts.getAndAdd(Math.round(diff));\n+    }\n+  }\n+\n+  @ParameterizedTest(name = \"{index}\")\n+  @MethodSource(\"samplerParams\")\n+  void sample(\n+      final int threadCnt,\n+      final int windowDuration,\n+      final int samplesPerWindow,\n+      final int totalWindows,\n+      final int hits,\n+      final double clockStdDev)\n+      throws Exception {\n+\n+    final AtomicInteger windowCounter = new AtomicInteger(1); // implicitly 1 window\n+    final TimestampProvider tsProvider =\n+        new TimestampProvider(windowDuration, totalWindows, hits, clockStdDev);\n+    final StreamingSampler instance =\n+        new StreamingSampler(windowDuration, TimeUnit.SECONDS, samplesPerWindow, 10, tsProvider) {\n+          @Override\n+          protected void onWindowRoll(final SamplerState state) {\n+            windowCounter.incrementAndGet();\n+          }\n+        };\n+\n+    final AtomicInteger allCnt = new AtomicInteger(0);\n+    final Thread[] threads = new Thread[threadCnt];\n+    System.out.println(\n+        \"==> windows: \"\n+            + totalWindows\n+            + \", threads: \"\n+            + threadCnt\n+            + \", clockDev: \"\n+            + clockStdDev\n+            + \", samplesPerWindow: \"\n+            + samplesPerWindow);\n+    for (int j = 0; j < threads.length; j++) {\n+      threads[j] =\n+          new Thread(\n+              () -> {\n+                int cnt = 0;\n+                for (long i = 0; i < hits; i++) {\n+                  if (instance.sample()) {\n+                    cnt += 1;\n+                  }\n+                }\n+                allCnt.addAndGet(cnt);\n+              });\n+      threads[j].start();\n+    }\n+    for (final Thread thread : threads) {\n+      thread.join();\n+    }\n+    final double perWindow = (allCnt.get() / (double) windowCounter.get());\n+    System.out.println(\"===> \" + allCnt.get() + \", \" + perWindow + \", \" + windowCounter.get());\n+    System.out.println();\n+    final double dev = perWindow - samplesPerWindow;\n+    Assertions.assertTrue(\n+        dev <= 0.2d * samplesPerWindow,\n+        allCnt.get() + \" <= (\" + samplesPerWindow + \" * \" + totalWindows + \") [\" + threadCnt + ']');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMjkzMw=="}, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTMzNjk2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1ODoxNlrOF8LBmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1ODoxNlrOF8LBmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzOTUxNA==", "bodyText": "Using three different time units in same function seems... excessive... especially considering that this is a test.\nWould it make sense to use nanoseconds everywhere? Or maybe even Instant since we are aiming for java8 anyway?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r398639514", "createdAt": "2020-03-26T14:58:16Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package com.datadog.profiling.exceptions;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class StreamingSamplerTest {\n+  private static final class TimestampProvider implements Supplier<Long> {\n+    private final Random rnd = new Random();\n+    private final AtomicLong ts = new AtomicLong(0L);\n+    private final int step;\n+    private final double stdDev;\n+\n+    TimestampProvider(\n+        final int windowDuration, final int totalWindows, final int hits, final double stdDev) {\n+      final long totalDuration =\n+          TimeUnit.NANOSECONDS.convert(windowDuration, TimeUnit.SECONDS) * totalWindows;\n+      step =\n+          (int)\n+              TimeUnit.MILLISECONDS.convert(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5346fc729bb847e5cf1c704581328b3a368d44d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjA5NjIzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MDowMVrOGCrQqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNDowNzo1MlrOGEnmMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg==", "bodyText": "would it make sense to load our event classes instead - to be 100% sure we can do that when exception is actually thrown?..", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405459112", "createdAt": "2020-04-08T11:40:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     */\n+\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMTI1Ng==", "bodyText": "Sure, why not.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406421256", "createdAt": "2020-04-09T19:15:09Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     */\n+\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ5NjI0Mg==", "bodyText": "Apparently we cannot do this :)\nPlease consider #1363", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407496242", "createdAt": "2020-04-13T14:07:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     */\n+\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1OTExMg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEwNjE4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzoxNVrOGCrW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzoxNVrOGCrW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDczMQ==", "bodyText": "Please make this a constant with javadoc into why this is the value it is", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460731", "createdAt": "2020-04-08T11:43:15Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEwNzEwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzozMVrOGCrXjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MzozMVrOGCrXjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDg3Ng==", "bodyText": "you can make this a constant and remove this method", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405460876", "createdAt": "2020-04-08T11:43:31Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionSampler.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import jdk.jfr.EventType;\n+\n+final class ExceptionSampler {\n+  private static final int SAMPLING_WINDOW_DURATION_SEC = 1;\n+  private final StreamingSampler sampler;\n+  private final EventType exceptionSampleType;\n+\n+  ExceptionSampler(final Config config) {\n+    this(\n+        getSamplingWindowDuration(), // fixed 1sec sampling window\n+        getSamplesPerWindow(config));\n+  }\n+\n+  ExceptionSampler(final Duration windowDuration, final int samplesPerWindow) {\n+    sampler = new StreamingSampler(windowDuration, samplesPerWindow, 60);\n+    exceptionSampleType = EventType.getEventType(ExceptionSampleEvent.class);\n+  }\n+\n+  private static Duration getSamplingWindowDuration() {\n+    return Duration.of(SAMPLING_WINDOW_DURATION_SEC, ChronoUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEwOTU1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0NDoyMVrOGCrZMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0NDoyMVrOGCrZMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MTI5Nw==", "bodyText": "One more magic number - please constantify and document", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405461297", "createdAt": "2020-04-08T11:44:21Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEyNDkxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0ODo1NlrOGCriwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0ODo1NlrOGCriwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Mzc0Ng==", "bodyText": "you could make addSample return boolean to make this less awkward", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405463746", "createdAt": "2020-04-08T11:48:56Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEzNzY3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1Mjo0NVrOGCrqdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NToxMFrOGCrwGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTcxOQ==", "bodyText": "I'm not sure that you can extrapolate burst budget with EMA. The whole point of burst budget is to react to short bursts, the whole point of EMA is not to react to that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405465719", "createdAt": "2020-04-08T11:52:45Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);\n+\n+    /*\n+     * Atomically replace the Counts instance such that sample requests during window maintenance will be\n+     * using the newly created counts instead of the ones currently processed by the maintenance routine.\n+     */\n+\n+    Counts counts = countsRef.getAndSet(new Counts());\n+    final long totalCount = counts.testCounter.sum();\n+    final long sampledCount = counts.sampleCounter.get();\n+\n+    long sampleBudget = samplesPerWindow - sampledCount;\n+    avgBudget = Double.isNaN(avgBudget) ? sampleBudget : avgBudget + emaAlpha * (sampleBudget - avgBudget);\n+    targetSamples = samplesPerWindow + Math.round(Math.max(avgBudget, 0) * windowCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzE2MQ==", "bodyText": "I can change that back - but didn't see any difference in results.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467161", "createdAt": "2020-04-08T11:55:10Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);\n+\n+    /*\n+     * Atomically replace the Counts instance such that sample requests during window maintenance will be\n+     * using the newly created counts instead of the ones currently processed by the maintenance routine.\n+     */\n+\n+    Counts counts = countsRef.getAndSet(new Counts());\n+    final long totalCount = counts.testCounter.sum();\n+    final long sampledCount = counts.sampleCounter.get();\n+\n+    long sampleBudget = samplesPerWindow - sampledCount;\n+    avgBudget = Double.isNaN(avgBudget) ? sampleBudget : avgBudget + emaAlpha * (sampleBudget - avgBudget);\n+    targetSamples = samplesPerWindow + Math.round(Math.max(avgBudget, 0) * windowCount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NTcxOQ=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjE0NDk4OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDozN1rOGCru5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDozN1rOGCru5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2Njg1NQ==", "bodyText": "These two are unused", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405466855", "createdAt": "2020-04-08T11:54:37Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW = 1;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_WINDOW_SAMPLES = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjE0NjAxOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDo1M1rOGCrvgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NDo1M1rOGCrvgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzAwOQ==", "bodyText": "this should bre renamed to DEFAULT_PROFILING_EXCEPTION_SAMPLE_LIMIT", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467009", "createdAt": "2020-04-08T11:54:53Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -190,6 +195,11 @@\n   public static final int DEFAULT_PROFILING_UPLOAD_TIMEOUT = 30; // seconds\n   public static final String DEFAULT_PROFILING_UPLOAD_COMPRESSION = \"on\";\n   public static final int DEFAULT_PROFILING_PROXY_PORT = 8080;\n+  public static final int DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT = 10_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjE0ODA1OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/test/groovy/datadog/trace/api/ConfigTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NTozMlrOGCrwyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo1NTozMlrOGCrwyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2NzMzNw==", "bodyText": "you could use statically imported name here for consistency", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405467337", "createdAt": "2020-04-08T11:55:32Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-api/src/test/groovy/datadog/trace/api/ConfigTest.groovy", "diffHunk": "@@ -150,6 +155,9 @@ class ConfigTest extends DDSpecification {\n     config.profilingProxyPort == Config.DEFAULT_PROFILING_PROXY_PORT\n     config.profilingProxyUsername == null\n     config.profilingProxyPassword == null\n+    config.profilingExceptionSampleLimit == Config.DEFAULT_PROFILING_EXCEPTION_SAMPLER_LIMIT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjE2OTc3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjowMTo0MlrOGCr-DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjowMTo0MlrOGCr-DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3MDczMw==", "bodyText": "it seems to be these should be available in some library", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405470733", "createdAt": "2020-04-08T12:01:42Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return rnd.nextDouble() <= burstProbability ? maxEvents : minEvents;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    int[] totalParts = new int[windows];\n+    double[] sampledParts = new double[windows];\n+    double[] sampleIndexSkew = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalParts[w] = events;\n+      sampledParts[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = calculateMean(sampleIndices);\n+      sampleIndexSkew[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledPartMean = calculateMean(sampledParts);\n+    double sampledPartStdev = calculateStddev(sampledParts, sampledPartMean);\n+    double totalPartMean = calculateMean(totalParts);\n+\n+    double correctionFactor = Math.min(((totalPartMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkew) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkew.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkew.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledPartMean * expectedSamples,\n+        sampledPartStdev * expectedSamples,\n+        (sampledPartMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private double calculateStddev(double[] data, double average) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjIxOTI3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoxNTozOFrOGCscfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDowMjowNlrOGEzROw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg==", "bodyText": "would you consider injecting executor instead to avoid making rollWindow visible and make sure that parameters to scheduleAtFixedRate are correct", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405478526", "createdAt": "2020-04-08T12:15:38Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NDE3NQ==", "bodyText": "Relying on scheduled task in unit tests is very ... unwieldy. You don't want to run 1 minute per case to test the expected load, right?\nSo, injecting the executor would allow us to test that the JDK bundled executor is properly scheduling things?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405484175", "createdAt": "2020-04-08T12:25:30Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMzM1NQ==", "bodyText": "I was thinking more along the lines of providing mock executor that you can control through tests", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405513355", "createdAt": "2020-04-08T13:12:40Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDA0Ng==", "bodyText": "I would need to create our specific interface for that since the common utility executor we have is not a ScheduledExecutorService it just delegates to it. So we would end up with a specific type which would need to be provided to the sampler - exposing the internal workings even more.\nIn addition to that we will need to implement synchronization mechanism between the data generation and window rolling which will complicate the matter a bit further.\nAll in all - I am not really convinced that this will improve things. We will just end up having fishy code in a different place.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420046", "createdAt": "2020-04-09T19:12:48Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MzA5MQ==", "bodyText": "There are two bugs in line below and third bug in constructor passing value for startWindowRolling... To this means we should have tests for this :)\nPlease consider #1363 - change to use mocks is not scary at all.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407643091", "createdAt": "2020-04-13T18:39:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NzQ4Mw==", "bodyText": "There is also one more potential problem here: if app blows up right after start up we may try to schedule things on dead executor and blow up too - this would be confusing to the client. We can avoid this and I suggest waiting for #1366 to just use that solution (and add some tests to it).", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407687483", "createdAt": "2020-04-13T20:02:06Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODUyNg=="}, "originalCommit": {"oid": "38fdffaa8f7073dc8ad443c01db854786022a54f"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjI3OTY1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjozMjo0OVrOGCtCPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOToxMzoxNFrOGDl7BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4ODE5MA==", "bodyText": "It seems to me that 'expected' behaviour would be to assume there were no exceptions before sampler was created - i.e. we have 'max possible budget'.\nThis should allow you to remove this calculation. Also the added benefit we would be able to capture exception bursts right at start up", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r405488190", "createdAt": "2020-04-08T12:32:49Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDIyOQ==", "bodyText": "The counter should go away. We are using the budget size only.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420229", "createdAt": "2020-04-09T19:13:14Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  private static final class Counts {\n+    private final LongAdder testCounter = new LongAdder();\n+    private final AtomicLong sampleCounter = new AtomicLong(0L);\n+\n+    void addTest() {\n+      testCounter.increment();\n+    }\n+\n+    long addSample(long limit) {\n+      return sampleCounter.getAndUpdate(s -> s + (s < limit ? 1 : 0));\n+    }\n+  }\n+\n+  /*\n+   * Exponential Moving Average (EMA) last element weight.\n+   * Check out papers about using EMA for streaming data - eg.\n+   * https://nestedsoftware.com/2018/04/04/exponential-moving-average-on-streaming-data-4hhl.24876.html\n+   *\n+   * Corresponds to 'lookback' of N values:\n+   * With T being the index of the most recent value the lookback of N values means that for all values with index\n+   * T-K, where K > N, the relative weight of that value computed as (1 - alpha)^K is less or equal than the\n+   * weight assigned by a plain arithmetic average (= 1/N).\n+   */\n+  private final double emaAlpha;\n+  private final int samplesPerWindow;\n+\n+  private final AtomicReference<Counts> countsRef;\n+  private final int lookback;\n+\n+  // these attributes need to be volatile since they are accessed outside of the 'endOfWindowLock' guarded block\n+  private volatile double probability = 1d;\n+  private volatile long targetSamples = 0L;\n+\n+  // these attributes are accessed solely from the window maintenance thread\n+  private double totalCountRunningAverage = 0d;\n+  private double avgBudget = Double.NaN;\n+  private long windowCount = 0L;\n+\n+  /**\n+   * Create a new sampler instance\n+   *\n+   * @param windowDuration      the sampling window duration\n+   * @param samplesPerWindow    the maximum number of samples in the sampling window\n+   * @param lookback            the number of windows to consider in averaging the sampling rate\n+   * @param startWindowRolling  should the scheduled window roll to be started; useful for testing with manual rolls\n+   */\n+  StreamingSampler(\n+    final Duration windowDuration, final int samplesPerWindow, final int lookback, boolean startWindowRolling) {\n+    this.samplesPerWindow = samplesPerWindow;\n+    this.targetSamples = Math.round(samplesPerWindow * 0.92d);\n+    this.lookback = lookback;\n+    this.emaAlpha = computeLookbackAlpha(lookback);\n+    this.countsRef = new AtomicReference<>(new Counts());\n+\n+    if (startWindowRolling) {\n+      CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(this::rollWindow, windowDuration.getNano(), windowDuration.getNano(), TimeUnit.NANOSECONDS);\n+    }\n+  }\n+\n+  /**\n+   * Create a new sampler instance with automatic window roll.\n+   *\n+   * @param windowDuration   the sampling window duration\n+   * @param samplesPerWindow the maximum number of samples in the sampling window\n+   * @param lookback         the number of windows to consider in averaging the sampling rate\n+   */\n+  StreamingSampler(final Duration windowDuration, final int samplesPerWindow, final int lookback) {\n+    this(windowDuration, samplesPerWindow, lookback, false);\n+  }\n+\n+  /**\n+   * Provides binary answer whether the current event is to be sampled\n+   *\n+   * @return {@literal true} if the event should be sampled\n+   */\n+  final boolean sample() {\n+    Counts counts = countsRef.get();\n+    counts.addTest();\n+    if (ThreadLocalRandom.current().nextDouble() < probability) {\n+      return counts.addSample(targetSamples) < targetSamples;\n+    }\n+\n+    return false;\n+  }\n+\n+  // package private access for the tests\n+  final void rollWindow() {\n+    windowCount = Math.min(windowCount + 1, lookback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4ODE5MA=="}, "originalCommit": {"oid": "6090ff05ccd1a535d51c8e39a480bfeb88f0f0d4"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjEzNzQ2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTowNDowMVrOGDlpQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTo1OTo0M1rOGEzMHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg==", "bodyText": "Color me convinced! Please go ahead and remove array implementation.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406415682", "createdAt": "2020-04-09T19:04:01Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTc2Ng==", "bodyText": "Thanks for investigating this!", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406415766", "createdAt": "2020-04-09T19:04:10Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDMyMg==", "bodyText": "thanks!", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420322", "createdAt": "2020-04-09T19:13:26Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY4NjE3NA==", "bodyText": "Should be done in #1363", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407686174", "createdAt": "2020-04-13T19:59:43Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/StreamingSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+/**\n+ * A streaming (non-remembering) sampler.\n+ *\n+ * <p>The sampler attempts to generate at most N samples per fixed time window in randomized\n+ * fashion. For this it divides the timeline into 'profiling windows' of constant length/duration.\n+ * Each profiling window targets a constant number of samples which are scattered randomly (uniform distribution)\n+ * throughout the window duration and once the window is over the real stats of incoming events and the number of\n+ * gathered samples is used to recompute the target probability to use in the following window.\n+ * </p>\n+ * <p>\n+ * This will guarantee, if the windows are not excessively large, that the sampler will be able to adjust\n+ * to the changes in the rate of incoming events.\n+ * </p>\n+ * <p>\n+ * However, there might so rapid changes in incoming events rate that we will optimistically use all allowed samples\n+ * well before the current window has elapsed or, on the other end of the spectrum, there will be to few incoming events\n+ * and the sampler will not be able to generate the target number of samples.\n+ * </p>\n+ * <p>\n+ * To smooth out these hicups the sampler maintains an under/over-sampling budget which can be used for compensate\n+ * for too rapid changes in the incoming events rate and maintain the target average number of samples per window.\n+ * </p>\n+ */\n+class StreamingSampler {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSampler.class);\n+\n+  /*\n+   * We keep a 'budget' by counting number of unused samples form few last windows.\n+   * Exact value here should be on order of (but probably less than) size of the JFR chunk duration.\n+   * Another consideration to choosing this value is that we have to do linear number of operations\n+   * on resulting array every window so this value should not be too large.\n+   *\n+   * Note: we want sum of unused samples in previous windows - this is why we are using array for this and not EMA.\n+   * With EMA we would need to come up with some multiplier for and average and it's unclear how to do that.\n+   */\n+  private static final int CARRIED_OVER_ARRAY_SIZE = 16;\n+\n+  static boolean USE_EMA_BUDGET = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxNTY4Mg=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjE2MjE0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOToxMjoyMlrOGDl5YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoxNzozNlrOGFWfzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ==", "bodyText": "To be honest - I do not think this makes @ParameterizedTest justified... What do you link about just having a private test function and multiple @Test for each element here?\nI think this would make things clearer and provide an opportunity for comments about why we do these tests because currently this seems somewhat unclear.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406419809", "createdAt": "2020-04-09T19:12:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    double[] totalEventsPerWindow = new double[windows];\n+    double[] sampledEventsPerWindow = new double[windows];\n+    double[] sampleIndexSkewPerWindow = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    double sampledEventsPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    double correctionFactor = Math.min(((totalEventsPerWindowMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledEventsPerWindowMean * expectedSamples,\n+        sampledEventsPerWindowStdev * expectedSamples,\n+        (sampledEventsPerWindowMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\n+        \"\\t percentual error = {}%\", Math.signum(samples - targetSamples) * percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static double[] toDoubleArray(List<? extends Number> data) {\n+    double[] rslt = new double[data.size()];\n+    int index = 0;\n+    for (Number n : data) {\n+      rslt[index++] = n.doubleValue();\n+    }\n+    return rslt;\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static Stream<Arguments> samplerParams() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDk3Mg==", "bodyText": "Possible. With the smaller number of hand-crafted test data sets it is really much more suitable to have specialized cases.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r406420972", "createdAt": "2020-04-09T19:14:36Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    double[] totalEventsPerWindow = new double[windows];\n+    double[] sampledEventsPerWindow = new double[windows];\n+    double[] sampleIndexSkewPerWindow = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    double sampledEventsPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    double correctionFactor = Math.min(((totalEventsPerWindowMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledEventsPerWindowMean * expectedSamples,\n+        sampledEventsPerWindowStdev * expectedSamples,\n+        (sampledEventsPerWindowMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\n+        \"\\t percentual error = {}%\", Math.signum(samples - targetSamples) * percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static double[] toDoubleArray(List<? extends Number> data) {\n+    double[] rslt = new double[data.size()];\n+    int index = 0;\n+    for (Number n : data) {\n+      rslt[index++] = n.doubleValue();\n+    }\n+    return rslt;\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static Stream<Arguments> samplerParams() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDY1Mw==", "bodyText": "Parametrized tests were converted to single test cases.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408264653", "createdAt": "2020-04-14T16:17:36Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StreamingSamplerTest.class);\n+\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    PoissonWindowEventsSupplier(int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    BurstingWindowsEventsSupplier(double burstProbability, int minEvents, int maxEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = minEvents;\n+      this.maxEvents = maxEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    ConstantWindowsEventsSupplier(int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    RepeatingWindowsEventsSupplier(int... eventsCounts) {\n+      this.eventsCounts = Arrays.copyOf(eventsCounts, eventsCounts.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParams\")\n+  public void testSampler(\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    long expectedSamples = windows * samplesPerWindow;\n+\n+    long samples = 0L;\n+\n+    double[] totalEventsPerWindow = new double[windows];\n+    double[] sampledEventsPerWindow = new double[windows];\n+    double[] sampleIndexSkewPerWindow = new double[windows];\n+    for (int w = 0; w < windows; w++) {\n+      List<Integer> sampleIndices = new ArrayList<>();\n+      long samplesBase = samples;\n+      int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - Math.abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      instance.rollWindow();\n+    }\n+    double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    double sampledEventsPerWindowStdev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    double correctionFactor = Math.min(((totalEventsPerWindowMean * windows) / expectedSamples), 1);\n+    double targetSamples = expectedSamples * correctionFactor;\n+    double percentualError =\n+        Math.round(Math.abs(((targetSamples - samples) / targetSamples)) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;\n+    int negativeCount = 0;\n+    for (double skew : sampleIndexSkewPerWindow) {\n+      if (skew >= 0.5d) {\n+        skewPositiveAvg += skew - 0.5d;\n+      } else {\n+        negativeCount++;\n+        skewNegativeAvg += 0.5d - skew;\n+      }\n+    }\n+    int positiveCount = sampleIndexSkewPerWindow.length - negativeCount;\n+    if (positiveCount > 0) {\n+      skewPositiveAvg /= sampleIndexSkewPerWindow.length - negativeCount;\n+    }\n+    if (negativeCount > 0) {\n+      skewNegativeAvg /= negativeCount;\n+    }\n+\n+    LOGGER.info(\n+        \"\\t per window samples = (avg: {}, stdev: {}, estimated total: {}\",\n+        sampledEventsPerWindowMean * expectedSamples,\n+        sampledEventsPerWindowStdev * expectedSamples,\n+        (sampledEventsPerWindowMean * windows) / correctionFactor + \")\");\n+    LOGGER.info(\n+        \"\\t avg window skew interval = <-{}%, {}%>\",\n+        Math.round(skewNegativeAvg * 100), Math.round(skewPositiveAvg * 100));\n+    LOGGER.info(\n+        \"\\t percentual error = {}%\", Math.signum(samples - targetSamples) * percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + targetSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + targetSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static double[] toDoubleArray(List<? extends Number> data) {\n+    double[] rslt = new double[data.size()];\n+    int index = 0;\n+    for (Number n : data) {\n+      rslt[index++] = n.doubleValue();\n+    }\n+    return rslt;\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"samplerParamsConcurrency\")\n+  public void testSamplerConcurrency(\n+      int threadCount,\n+      Supplier<Integer> windowEventsSupplier,\n+      int windows,\n+      int samplesPerWindow,\n+      int lookback,\n+      int maxErrorPercent)\n+      throws Exception {\n+    LOGGER.info(\n+        \"> threads: {}, mode: {}, windows: {}, samplesPerWindow: {}, lookback: {}\",\n+        threadCount,\n+        windowEventsSupplier,\n+        windows,\n+        samplesPerWindow,\n+        lookback);\n+\n+    /*\n+     * This test attempts to simulate concurrent computations by making sure that sampling requests and the window maintenance routine are run in parallel.\n+     * It does not provide coverage of all possible execution sequences but should be good enough for getting the 'ballpark' numbers.\n+     */\n+\n+    long expectedSamples = samplesPerWindow * windows;\n+    AtomicLong allSamples = new AtomicLong(0);\n+    Thread[] threads = new Thread[threadCount];\n+\n+    Phaser phaser = new Phaser(threadCount + 1);\n+\n+    StreamingSampler instance =\n+        new StreamingSampler(Duration.ofSeconds(1), samplesPerWindow, lookback, false);\n+\n+    for (int i = 0; i < threadCount; i++) {\n+      threads[i] =\n+          new Thread(\n+              () -> {\n+                for (int w = 0; w < windows; w++) {\n+                  int events = windowEventsSupplier.get();\n+                  for (int e = 0; e < events; e++) {\n+                    if (instance.sample()) {\n+                      allSamples.incrementAndGet();\n+                    }\n+                  }\n+                  /*\n+                   * Block here until window roll is initiated from other thread.\n+                   * After the roll has been started the next window data starts arriving in parallel.\n+                   */\n+                  phaser.arriveAndAwaitAdvance();\n+                }\n+              });\n+    }\n+\n+    Thread roller =\n+        new Thread(\n+            () -> {\n+              while (!Thread.currentThread().isInterrupted()) {\n+                // wait for the next window signalled from the data generating thread before\n+                // starting to roll the window\n+                phaser.arriveAndAwaitAdvance();\n+                instance.rollWindow();\n+              }\n+            });\n+    roller.start();\n+    for (Thread t : threads) {\n+      t.start();\n+    }\n+    for (Thread t : threads) {\n+      t.join();\n+    }\n+\n+    roller.interrupt();\n+\n+    long samples = allSamples.get();\n+    int percentualError =\n+        Math.round(Math.abs(((expectedSamples - samples) / (float) expectedSamples)) * 100);\n+    LOGGER.info(\"\\t percentual error = {}%\", percentualError);\n+\n+    assertTrue(\n+        percentualError <= maxErrorPercent,\n+        \"abs((\"\n+            + expectedSamples\n+            + \" - \"\n+            + samples\n+            + \") / \"\n+            + expectedSamples\n+            + \")% > \"\n+            + maxErrorPercent\n+            + \"%\");\n+  }\n+\n+  private static Stream<Arguments> samplerParams() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxOTgwOQ=="}, "originalCommit": {"oid": "2a3bb7e322e9e4a0319f21af27575abe62ac99ad"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDE1NDk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNjoxNDoyMlrOGErseA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjozNVrOGFYVfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA==", "bodyText": "This fails on CI quite often: https://circleci.com/gh/DataDog/dd-trace-java/53540", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407563384", "createdAt": "2020-04-13T16:14:22Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3OTQzMg==", "bodyText": "I don't see any related test failures there - bunch of CustomLogManager related tests failing and ProfilingIntegrationContinuousProfilesTest failing on Zulu8", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r407979432", "createdAt": "2020-04-14T09:03:33Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA=="}, "originalCommit": {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDc4MA==", "bodyText": "I have adjusted the expected error margins.\nAlso, ran tests several 100s of iterations without breaking those margins. So, let's keep our fingers crossed that it is enough (statistics is a ...)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408294780", "createdAt": "2020-04-14T17:02:35Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,423 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class StreamingSamplerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzM4NA=="}, "originalCommit": {"oid": "744f668b3454f77ad85b215ac1387e40308f02fe"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDgzMzk2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowNjo1MlrOGFYfgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowNjo1MlrOGFYfgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NzM0Ng==", "bodyText": "It would be nice to have more comments in this function - it is somewhat long and there a a lot of non obvious local variables", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r408297346", "createdAt": "2020-04-14T17:06:52Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/test/java/com/datadog/profiling/exceptions/StreamingSamplerTest.java", "diffHunk": "@@ -0,0 +1,424 @@\n+package com.datadog.profiling.exceptions;\n+\n+import static java.lang.Math.abs;\n+import static java.lang.Math.min;\n+import static java.lang.Math.round;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.same;\n+import static org.mockito.Mockito.when;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.CommonTaskExecutor.Task;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.stat.descriptive.moment.Mean;\n+import org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+/**\n+ * Test various hand crafted scenarios of events coming in different patterns. Test both, the\n+ * isolated single threaded execution as well as events arriving on concurrent threads.\n+ *\n+ * <p>The test supports 'benchmark' mode to explore the reliability boundaries where all test cases\n+ * can be run multiple times - the number of iteration is passed in in {@literal\n+ * com.datadog.profiling.exceptions.test-iterations} system property.\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@Slf4j\n+class StreamingSamplerTest {\n+\n+  private static final Duration WINDOW_DURATION = Duration.ofSeconds(1);\n+\n+  /** Generates windows with numbers of events according to Poisson distribution */\n+  private static final class PoissonWindowEventsSupplier implements Supplier<Integer> {\n+    private final PoissonDistribution distribution;\n+\n+    /** @param eventsPerWindowMean the average number of events per window */\n+    PoissonWindowEventsSupplier(final int eventsPerWindowMean) {\n+      distribution = new PoissonDistribution(eventsPerWindowMean);\n+      distribution.reseedRandomGenerator(12345671);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return distribution.sample();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Poisson: (\"\n+          + \"mean=\"\n+          + distribution.getMean()\n+          + \", variance=\"\n+          + distribution.getNumericalVariance()\n+          + \")\";\n+    }\n+  }\n+\n+  /**\n+   * Generates bursty windows - some of the windows have extremely low number of events while the\n+   * others have very hight number of events.\n+   */\n+  private static final class BurstingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final Random rnd = new Random(176431);\n+\n+    private final double burstProbability;\n+    private final int minEvents;\n+    private final int maxEvents;\n+\n+    /**\n+     * @param burstProbability the probability of burst window happening\n+     * @param nonBurstEvents number of events in non-burst window\n+     * @param burstEvents number of events in burst window\n+     */\n+    BurstingWindowsEventsSupplier(\n+        final double burstProbability, final int nonBurstEvents, final int burstEvents) {\n+      this.burstProbability = burstProbability;\n+      this.minEvents = nonBurstEvents;\n+      this.maxEvents = burstEvents;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      if (rnd.nextDouble() <= burstProbability) {\n+        return maxEvents;\n+      } else {\n+        return minEvents;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Burst: (\"\n+          + \"probability=\"\n+          + burstProbability\n+          + \", minEvents=\"\n+          + minEvents\n+          + \", maxEvents=\"\n+          + maxEvents\n+          + ')';\n+    }\n+  }\n+\n+  /** Generates windows with constant number of events. */\n+  private static final class ConstantWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int events;\n+\n+    /** @param events number of events per window */\n+    ConstantWindowsEventsSupplier(final int events) {\n+      this.events = events;\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      return events;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Constant: (\" + \"events=\" + events + ')';\n+    }\n+  }\n+\n+  /** Generates a pre-configured repeating sequence of window events */\n+  private static final class RepeatingWindowsEventsSupplier implements Supplier<Integer> {\n+    private final int[] eventsCounts;\n+    private int pointer = 0;\n+\n+    /** @param windowEvents an array of number of events per each window in the sequence */\n+    RepeatingWindowsEventsSupplier(final int... windowEvents) {\n+      this.eventsCounts = Arrays.copyOf(windowEvents, windowEvents.length);\n+    }\n+\n+    @Override\n+    public Integer get() {\n+      try {\n+        return eventsCounts[pointer];\n+      } finally {\n+        pointer = (pointer + 1) % eventsCounts.length;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Repeating: (\" + \"definition=\" + Arrays.toString(eventsCounts) + ')';\n+    }\n+  }\n+\n+  private static final StandardDeviation STANDARD_DEVIATION = new StandardDeviation();\n+  private static final Mean MEAN = new Mean();\n+  private static final int WINDOWS = 120;\n+  private static final int SAMPLES_PER_WINDOW = 100;\n+  private static final int LOOKBACK = 30;\n+\n+  @Mock CommonTaskExecutor taskExecutor;\n+  @Captor ArgumentCaptor<Task<StreamingSampler>> rollWindowTaskCaptor;\n+  @Captor ArgumentCaptor<StreamingSampler> rollWindowTargetCaptor;\n+  @Mock ScheduledFuture scheduledFuture;\n+\n+  @BeforeEach\n+  public void setup() {\n+    when(taskExecutor.scheduleAtFixedRate(\n+            rollWindowTaskCaptor.capture(),\n+            rollWindowTargetCaptor.capture(),\n+            eq(WINDOW_DURATION.toNanos()),\n+            eq(WINDOW_DURATION.toNanos()),\n+            same(TimeUnit.NANOSECONDS),\n+            any()))\n+        .thenReturn(scheduledFuture);\n+  }\n+\n+  @Test\n+  public void testBurstLowProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.1d, 5, 5000), 40);\n+  }\n+\n+  @Test\n+  public void testBurstHighProbability() throws Exception {\n+    testSampler(new BurstingWindowsEventsSupplier(0.8d, 5, 5000), 20);\n+  }\n+\n+  @Test\n+  public void testPoissonLowFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonMidFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(283), 15);\n+  }\n+\n+  @Test\n+  public void testPoissonHighFrequency() throws Exception {\n+    testSampler(new PoissonWindowEventsSupplier(1013), 15);\n+  }\n+\n+  @Test\n+  public void testConstantVeryLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(1), 10);\n+  }\n+\n+  @Test\n+  public void testConstantLowLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(153), 15);\n+  }\n+\n+  @Test\n+  public void testConstantMediumLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(713), 15);\n+  }\n+\n+  @Test\n+  public void testConstantHighLoad() throws Exception {\n+    testSampler(new ConstantWindowsEventsSupplier(5211), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingSemiRandom() throws Exception {\n+    testSampler(\n+        new RepeatingWindowsEventsSupplier(180, 200, 0, 0, 0, 1500, 1000, 430, 200, 115, 115, 900),\n+        15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithBurst() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(1000, 0, 1000, 0, 1000, 0), 15);\n+  }\n+\n+  @Test\n+  public void testRepeatingRegularStartWithLow() throws Exception {\n+    testSampler(new RepeatingWindowsEventsSupplier(0, 1000, 0, 1000, 0, 1000), 15);\n+  }\n+\n+  private void testSampler(final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent)\n+      throws Exception {\n+    int iterations =\n+        Integer.parseInt(\n+            System.getProperty(\"com.datadog.profiling.exceptions.test-iterations\", \"1\"));\n+    for (int i = 0; i < iterations; i++) {\n+      testSamplerInline(windowEventsSupplier, maxErrorPercent);\n+      for (int numOfThreads = 1; numOfThreads <= 64; numOfThreads *= 2) {\n+        testSamplerConcurrently(numOfThreads, windowEventsSupplier, maxErrorPercent);\n+      }\n+    }\n+  }\n+\n+  private void testSamplerInline(\n+      final Supplier<Integer> windowEventsSupplier, final int maxErrorPercent) {\n+    log.info(\n+        \"> mode: {}, windows: {}, SAMPLES_PER_WINDOW: {}, LOOKBACK: {}, max error: {}%\",\n+        windowEventsSupplier, WINDOWS, SAMPLES_PER_WINDOW, LOOKBACK, maxErrorPercent);\n+    final StreamingSampler instance =\n+        new StreamingSampler(WINDOW_DURATION, SAMPLES_PER_WINDOW, LOOKBACK, taskExecutor);\n+\n+    final long expectedSamples = WINDOWS * SAMPLES_PER_WINDOW;\n+\n+    long samples = 0L;\n+\n+    final double[] totalEventsPerWindow = new double[WINDOWS];\n+    final double[] sampledEventsPerWindow = new double[WINDOWS];\n+    final double[] sampleIndexSkewPerWindow = new double[WINDOWS];\n+    for (int w = 0; w < WINDOWS; w++) {\n+      final List<Integer> sampleIndices = new ArrayList<>();\n+      final long samplesBase = samples;\n+      final int events = windowEventsSupplier.get();\n+      for (int i = 0; i < events; i++) {\n+        if (instance.sample()) {\n+          sampleIndices.add(i);\n+          samples++;\n+        }\n+      }\n+      totalEventsPerWindow[w] = events;\n+      sampledEventsPerWindow[w] =\n+          (1 - abs((samples - samplesBase - expectedSamples) / (double) expectedSamples));\n+\n+      final double sampleIndexMean = MEAN.evaluate(toDoubleArray(sampleIndices));\n+      sampleIndexSkewPerWindow[w] = events != 0 ? sampleIndexMean / events : 0;\n+      rollWindow();\n+    }\n+    final double sampledEventsPerWindowMean = MEAN.evaluate(sampledEventsPerWindow);\n+    final double sampledEventsPerWindowStddev =\n+        STANDARD_DEVIATION.evaluate(sampledEventsPerWindow, sampledEventsPerWindowMean);\n+    final double totalEventsPerWindowMean = MEAN.evaluate(totalEventsPerWindow);\n+\n+    final double correctionFactor =\n+        min(((totalEventsPerWindowMean * WINDOWS) / expectedSamples), 1);\n+    final double targetSamples = expectedSamples * correctionFactor;\n+    final double percentualError = round(((targetSamples - samples) / targetSamples) * 100);\n+\n+    double skewPositiveAvg = 0d;\n+    double skewNegativeAvg = 0d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9458fa8a6a10e6e7a362744d758473887e03ce5f"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc3Mjc3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1MzoyM1rOGHVrnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoyMDo0NlrOGHWj4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODQ0NA==", "bodyText": "This isn't really doing anything different from ClassLoaderMatcher.hasClassesNamed().  I don't think you can get a resource from the bootstrap classpath...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410348444", "createdAt": "2020-04-17T16:53:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2Mjg1MQ==", "bodyText": "ClassLoaderMatcher.hasClassNamed() does not event try to use ClassLoader.getSystemClassLoader() - bottom line, I was not able to make ClassLoaderMatcher.hasClassNamed() work and tracked that down to \n  \n    \n      dd-trace-java/dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/ClassLoaderMatcher.java\n    \n    \n         Line 135\n      in\n      5aeca66\n    \n    \n    \n    \n\n        \n          \n           if (cl == BOOTSTRAP_CLASSLOADER) {", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410362851", "createdAt": "2020-04-17T17:20:46Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODQ0NA=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc5MDM3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1ODozNlrOGHV3BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzo1MTo1OVrOGIViPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ==", "bodyText": "Can you add a defaultEnabled class returning false (to disable by default) or at least hasJfr?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410351365", "createdAt": "2020-04-17T16:58:36Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjM3Nw==", "bodyText": "Well, the idea was to have this instrumentation on by default if JFR was available.\n@thegreystone Any comments?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411262377", "createdAt": "2020-04-20T10:18:44Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4NTgyNw==", "bodyText": "The whole point of subsampling the exceptions is that we want it enabled by default.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411285827", "createdAt": "2020-04-20T10:59:54Z", "author": {"login": "thegreystone"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4NjU2Nw==", "bodyText": "That said, if the profiler isn't enabled, it can of course be disabled.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411286567", "createdAt": "2020-04-20T11:01:16Z", "author": {"login": "thegreystone"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NDYyMQ==", "bodyText": "Yes, I understand you want it enabled by default, but often times with high impact instrumentation we disable by default in one release, allow customers to validate it, then enable it by default in a subsequent release.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411394621", "createdAt": "2020-04-20T13:51:59Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTM2NQ=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc5NDUyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1OTo1OFrOGHV55g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzo1NzozOVrOGIV07w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg==", "bodyText": "static import ElementMatchers.* and change to a ternary?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352102", "createdAt": "2020-04-17T16:59:58Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE3OTkwOA==", "bodyText": "I used to be yelled at for doing a wildcard import :) But sure, why not?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411179908", "createdAt": "2020-04-20T08:12:01Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI5MDQwMA==", "bodyText": "I think our default setting still replaces static imports with specific one, so although I'd agree  with using static imports more, I'm not sure about wildcard imports - mainly from the perspective that it will be noise in somebody elses commit when it will be replaced...", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411290400", "createdAt": "2020-04-20T11:07:48Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzODU5NQ==", "bodyText": "Ok, I added the static imports.\nBut conversion to ternary is problematic - in short, javac type inference for ternary operator is rather stupid and will fail to infer the correct type, leading to unchecked cast etc. IMO, having and explicit if is the lesser evil (especially since the ternary form would be compiled down to the same bytecode).", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411338595", "createdAt": "2020-04-20T12:31:35Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5OTQwNw==", "bodyText": "sorry for the confusion... I didn't want actual wildcard imports, I just phrased it this way in the review under the assumption it would be replaced automatically to non-wildcard.\nEither way, this isn't a big deal, but thanks for looking into it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411399407", "createdAt": "2020-04-20T13:57:39Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjEwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc5NjY3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzowMDozMlrOGHV7Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzowMDozMlrOGHV7Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjQzOA==", "bodyText": "Same suggestion here... (static import and ternary)", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352438", "createdAt": "2020-04-17T17:00:32Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n+    }\n+    return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc5OTY0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzowMTozMFrOGHV9JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzowMTozMFrOGHV9JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MjkzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");\n          \n          \n            \n                      isConstructor(), packageName + \".ExceptionAdvice\");", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410352933", "createdAt": "2020-04-17T17:01:30Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java/datadog/exceptions/instrumentation/ExceptionInstrumentation.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package datadog.exceptions.instrumentation;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+/**\n+ * Provides instrumentation of {@linkplain Exception} constructor. <br>\n+ * {@linkplain Exception}, as opposed to {@linkplain Throwable} was deliberately chosen such that we\n+ * don't instrument {@linkplain Error} class/subclasses since they are tracked by a native JFR event\n+ * already.\n+ */\n+@AutoService(Instrumenter.class)\n+public final class ExceptionInstrumentation extends Instrumenter.Default {\n+  private final boolean hasJfr;\n+\n+  public ExceptionInstrumentation() {\n+    super(\"exceptions\");\n+    /* Check only for the open-sources JFR implementation.\n+     * If it is ever needed to support also the closed sourced JDK 8 version the check should be\n+     * enhanced.\n+     * Need this custom check because ClassLoaderMatcher.hasClassesNamed() does not support bootstrap class loader yet.\n+     * Note: the downside of this is that we load some JFR classes at startup.\n+     * Note2: we cannot check that we can load ExceptionSampleEvent because it is not available on the class path yet.\n+     */\n+    hasJfr = ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Event.class\") != null;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    /*\n+     * Since the only instrumentation target is java.lang.Exception which is loaded by bootstrap classloader\n+     * it is ok to use helper classes instead of hacking around a Java 8 specific bootstrap.\n+     */\n+    return hasJfr\n+        ? new String[] {\n+          \"com.datadog.profiling.exceptions.StreamingSampler\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$Counts\",\n+          \"com.datadog.profiling.exceptions.StreamingSampler$RollWindowTask\",\n+          \"com.datadog.profiling.exceptions.ExceptionCountEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram\",\n+          \"com.datadog.profiling.exceptions.ExceptionHistogram$Pair\",\n+          \"com.datadog.profiling.exceptions.ExceptionProfiling\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampleEvent\",\n+          \"com.datadog.profiling.exceptions.ExceptionSampler\"\n+        }\n+        : new String[0];\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    if (hasJfr) {\n+      // match only java.lang.Exception since java.lang.Error is tracked by another JFR event\n+      return ElementMatchers.is(Exception.class);\n+    }\n+    return ElementMatchers.none();\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    if (hasJfr) {\n+      return Collections.singletonMap(\n+          isConstructor(), \"datadog.exceptions.instrumentation.ExceptionAdvice\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzgyMzE3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzowOTozOFrOGHWMpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDowOTowOFrOGIWYtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg==", "bodyText": "Since this doesn't have the java 7 compatibility requirement, should this use LongAdder instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410356902", "createdAt": "2020-04-17T17:09:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NTMwMw==", "bodyText": "Yes. Possible.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410365303", "createdAt": "2020-04-17T17:25:21Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0ODIyMg==", "bodyText": "Actually, in order to improve the 'first hit' behavior it is necessary for this to stay AtomicLong", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411348222", "createdAt": "2020-04-20T12:46:50Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwMzQ5Ng==", "bodyText": "I'm not familiar with that problem.  Could you elaborate?", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411403496", "createdAt": "2020-04-20T14:02:43Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwODU2NA==", "bodyText": "LongAdder.increment() does not return neither the previous or the current value - mostly because of how it is internally implemented, keeping thread local separate data buckets which will get combined only when LongAdder.sum() is called. Combining the separate data buckets is not particularly cheap and should not be done too often.\nBut in order to improve the 'first hit' precision I need to be able to get the counter value before the increment. This is impossible to do with LongAdder in any sane way.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r411408564", "createdAt": "2020-04-20T14:09:08Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {\n+\n+  static final String CLIPPED_ENTRY_TYPE_NAME = \"TOO-MANY-EXCEPTIONS\";\n+\n+  private final Map<String, AtomicLong> histogram = new ConcurrentHashMap<>();\n+  private final int maxTopItems;\n+  private final int maxSize;\n+  private final EventType exceptionCountEventType;\n+  private final Runnable eventHook;\n+\n+  ExceptionHistogram(final Config config) {\n+    maxTopItems = config.getProfilingExceptionHistogramTopItems();\n+    maxSize = config.getProfilingExceptionHistogramMaxCollectionSize();\n+    exceptionCountEventType = EventType.getEventType(ExceptionCountEvent.class);\n+    eventHook = this::emit;\n+    FlightRecorder.addPeriodicEvent(ExceptionCountEvent.class, eventHook);\n+  }\n+\n+  void deregister() {\n+    FlightRecorder.removePeriodicEvent(eventHook);\n+  }\n+\n+  public boolean record(final Exception exception) {\n+    if (exception == null) {\n+      return false;\n+    }\n+    return record(exception.getClass().getCanonicalName());\n+  }\n+\n+  private boolean record(String typeName) {\n+    if (!exceptionCountEventType.isEnabled()) {\n+      return false;\n+    }\n+    if (!histogram.containsKey(typeName) && histogram.size() >= maxSize) {\n+      log.debug(\"Histogram is too big, skipping adding new entry: {}\", typeName);\n+      // Overwrite type name to limit total number of entries in the histogram\n+      typeName = CLIPPED_ENTRY_TYPE_NAME;\n+    }\n+\n+    final boolean[] firstHit = new boolean[]{false};\n+    histogram\n+      .computeIfAbsent(\n+        typeName,\n+        k -> {\n+          try {\n+            return new AtomicLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NjkwMg=="}, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzgzMDU3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoxMTo1M1rOGHWRUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoxMTo1M1rOGHWRUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODA5Nw==", "bodyText": "I think a class comment here would be helpful.", "url": "https://github.com/DataDog/dd-trace-java/pull/1297#discussion_r410358097", "createdAt": "2020-04-17T17:11:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/exception-profiling/src/main/java11/com/datadog/profiling/exceptions/ExceptionHistogram.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.datadog.profiling.exceptions;\n+\n+import datadog.trace.api.Config;\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Stream;\n+\n+@Slf4j\n+public class ExceptionHistogram {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b485fbe522292d4361bcc32f323bdf372a1029e"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 382, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}