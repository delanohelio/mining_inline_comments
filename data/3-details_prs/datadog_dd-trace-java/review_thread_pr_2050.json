{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NDM1MzQ1", "number": 2050, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNToyNTo0N1rOE3R1TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTo1NTozM1rOE32i6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2Mzk5MzA4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNToyNTo0OFrOHwh5ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0ODo1OVrOHxH9oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0OTE0Ng==", "bodyText": "This seems rather scary and will likely result in unexpected bugs elsewhere.  Do you know why this is necessary?", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520649146", "createdAt": "2020-11-10T15:25:48Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter TraceScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MjczNg==", "bodyText": "There are two things here. One is the intentional leak in the akka-http server instrumentation that you commented on, and the second is just plain defensive programming. There should never ever be anything left on the scope stack after the actor has processed a message.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521272736", "createdAt": "2020-11-11T10:48:59Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter TraceScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0OTE0Ng=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDEwNDc3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaEnvelopeInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTo0ODo1NFrOHwjBRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNTo0ODo1NFrOHwjBRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2NzQ2MA==", "bodyText": "lol... zis", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520667460", "createdAt": "2020-11-10T15:48:54Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaEnvelopeInstrumentation.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaEnvelopeInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaEnvelopeInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Envelope\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isConstructor(), getClass().getName() + \"$ConstructAdvice\");\n+  }\n+\n+  public static class ConstructAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void afterInit(@Advice.This Envelope zis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDE4MjI3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNjowNTowMFrOHwjy2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNjowNTowMFrOHwjy2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4MDE1NQ==", "bodyText": "Same concern applies here.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520680155", "createdAt": "2020-11-10T16:05:00Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.ExcludeFilterProvider;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaMailboxInstrumentation extends Instrumenter.Default\n+    implements ExcludeFilterProvider {\n+\n+  public AkkaMailboxInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Mailbox\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod().and(named(\"run\")), getClass().getName() + \"$SuppressMailboxRunAdvice\");\n+  }\n+\n+  @Override\n+  public Map<ExcludeFilter.ExcludeType, ? extends Collection<String>> excludedClasses() {\n+    List<String> excludedClass = singletonList(\"akka.dispatch.MailBox\");\n+    EnumMap<ExcludeFilter.ExcludeType, Collection<String>> excludedTypes =\n+        new EnumMap<>(ExcludeFilter.ExcludeType.class);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.RUNNABLE, excludedClass);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.FORK_JOIN_TASK, excludedClass);\n+    return excludedTypes;\n+  }\n+\n+  public static final class SuppressMailboxRunAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope enter() {\n+      // Create our own noopSpan to make sure that we close all scopes up until this\n+      // position after exit\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter final AgentScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe143a7916cfe72851921b105dbdfa41db303cfd"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEzOTc2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1MDoxN1rOHwtIWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMToxNjowMlrOHxI1vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzExMg==", "bodyText": "This seems rather odd.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833112", "createdAt": "2020-11-10T19:50:17Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4NzEwMQ==", "bodyText": "Yes, maybe I should start a blank span and scope instead, in the code below.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521287101", "createdAt": "2020-11-11T11:16:02Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzExMg=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE0MjgzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1MToxMFrOHwtKTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMToyMDoyMFrOHxI-RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg==", "bodyText": "use noopSpan() instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833612", "createdAt": "2020-11-10T19:51:10Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzc1Nw==", "bodyText": "Or maybe even AgentTracer.NoopAgentScope.INSTANCE instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520837757", "createdAt": "2020-11-10T19:58:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4OTI4NQ==", "bodyText": "Yes, I could definitely reuse the AgentTracer.NoopAgentScope.INSTANCE", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521289285", "createdAt": "2020-11-11T11:20:20Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE3ODk4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMTowOFrOHwtgUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjoyMToxMlrOHxsDhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ==", "bodyText": "This seems to be needed because the request handler which creates the span is separate from the response handler that finishes the span, so this queue is used to correlate the scopes?", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520839251", "createdAt": "2020-11-10T20:01:08Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI4NTgxOQ==", "bodyText": "Yes, the queue is used to correlate the scopes. Its use ties in to the comment below about the state machine.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521285819", "createdAt": "2020-11-11T11:13:47Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNDQyNA==", "bodyText": "it seems very surprising to me that the calls are guaranteed to be in the same order.  Maybe I don't have the right mental model, but assume that you have a request come in that takes a long time, followed by a bunch of fast requests.  How does that actually keep the right order?", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521534424", "createdAt": "2020-11-11T17:51:03Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNTQ3Mg==", "bodyText": "In reference to the order, what I gathered from observing the behavior is that a new instance of the graph stage logic is created for each connection", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521605472", "createdAt": "2020-11-11T20:00:54Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2NDA3MQ==", "bodyText": "Yes, exactly. There is a separate instance of the logic for each connection, and the in connection request order is guaranteed by the server flow machinery. I'll add this to the comments.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521864071", "createdAt": "2020-11-12T06:21:12Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE4OTI2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowNDoxMVrOHwtm1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDo0NjoyMFrOHxH4QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDkxOA==", "bodyText": "This is interesting.  I guess this is the reason you need that logic to clear the scope stack.  I don't think I understand though why the scope can't be closed after the push.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520840918", "createdAt": "2020-11-10T20:04:11Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI3MTM2MA==", "bodyText": "So akka streams are run by a state machine, and the only thing you know after the push is that this specific element has been put in the slot representing the requestOutlet. Nothing more has happened, and no request handling code has run yet. If we close the scope at that point, there will be nothing in the scope. Since the whole stream machinery has been fused we can be certain that this element will be picked up by the same thread that is running this onPush method, and then the request handling code will be run. If the request handling code completes synchronously, then the handler for the responseInlet will close the scope directly in that onPush method. Otherwise the scope will be closed by the actor messaging instrumentation cleaning the scope stack.\nI'll add a more detailed comment about how things work.\nI'll write a", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521271360", "createdAt": "2020-11-11T10:46:20Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDkxOA=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTY2MzAzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyODoxMVrOHwyGeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjozNzowMlrOHyDbXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw==", "bodyText": "Since the span is started when the request comes into the server, it would seem more logical to me to have it finish when it is returning the response to the server.  In practice I don't think there will be much difference though... just an incongruity.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520914553", "createdAt": "2020-11-10T22:28:11Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.\n                 }\n-              },\n-              new AbstractFunction1<Throwable, Throwable>() {\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  complete(requestOutlet);\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  fail(requestOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the requests goes out to the user code\n+          setHandler(\n+              requestOutlet,\n+              new AbstractOutHandler() {\n+                @Override\n+                public void onPull() throws Exception {\n+                  pull(requestInlet);\n+                }\n+\n+                @Override\n+                public void onDownstreamFinish() throws Exception {\n+                  // We can not send out any more requests to the user code so stop receiving them\n+                  cancel(requestInlet);\n+                }\n+              });\n+\n+          // This is where the response comes back from the user code\n+          setHandler(\n+              responseInlet,\n+              new AbstractInHandler() {\n+                @Override\n+                public void onPush() throws Exception {\n+                  final HttpResponse response = grab(responseInlet);\n+                  final AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                    // Check if the active scope is still the scope from when the request came in,\n+                    // and close it. If it's not, then it will be cleaned up actor message\n+                    // processing instrumentation that drives this state machine\n+                    TraceScope activeScope = activeScope();\n+                    if (activeScope == scope) {\n+                      scope.close();\n+                    }\n+                  }\n+                  push(responseOutlet, response);\n+                }\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  AgentScope scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  completeStage();\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception {\n+                  AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    // Mark the span as failed\n+                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n+                  }\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  fail(responseOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the response goes back to the server and TCP layer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5MjI5Ng==", "bodyText": "Yeah, it might better reflect the timing if the server is under load, or is saturating its bandwidth.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521292296", "createdAt": "2020-11-11T11:26:14Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.\n                 }\n-              },\n-              new AbstractFunction1<Throwable, Throwable>() {\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  complete(requestOutlet);\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  fail(requestOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the requests goes out to the user code\n+          setHandler(\n+              requestOutlet,\n+              new AbstractOutHandler() {\n+                @Override\n+                public void onPull() throws Exception {\n+                  pull(requestInlet);\n+                }\n+\n+                @Override\n+                public void onDownstreamFinish() throws Exception {\n+                  // We can not send out any more requests to the user code so stop receiving them\n+                  cancel(requestInlet);\n+                }\n+              });\n+\n+          // This is where the response comes back from the user code\n+          setHandler(\n+              responseInlet,\n+              new AbstractInHandler() {\n+                @Override\n+                public void onPush() throws Exception {\n+                  final HttpResponse response = grab(responseInlet);\n+                  final AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                    // Check if the active scope is still the scope from when the request came in,\n+                    // and close it. If it's not, then it will be cleaned up actor message\n+                    // processing instrumentation that drives this state machine\n+                    TraceScope activeScope = activeScope();\n+                    if (activeScope == scope) {\n+                      scope.close();\n+                    }\n+                  }\n+                  push(responseOutlet, response);\n+                }\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  AgentScope scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  completeStage();\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception {\n+                  AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    // Mark the span as failed\n+                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n+                  }\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  fail(responseOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the response goes back to the server and TCP layer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NzAwNA==", "bodyText": "So putting my thinking cap back on I realized that this is not  where the response goes back, but rather where the server machinery says that it can receive another response and the actual moving of the response from the user supplied code to the server code happens where it is right now. I'll update the comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r522247004", "createdAt": "2020-11-12T16:37:02Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.\n                 }\n-              },\n-              new AbstractFunction1<Throwable, Throwable>() {\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  complete(requestOutlet);\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  fail(requestOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the requests goes out to the user code\n+          setHandler(\n+              requestOutlet,\n+              new AbstractOutHandler() {\n+                @Override\n+                public void onPull() throws Exception {\n+                  pull(requestInlet);\n+                }\n+\n+                @Override\n+                public void onDownstreamFinish() throws Exception {\n+                  // We can not send out any more requests to the user code so stop receiving them\n+                  cancel(requestInlet);\n+                }\n+              });\n+\n+          // This is where the response comes back from the user code\n+          setHandler(\n+              responseInlet,\n+              new AbstractInHandler() {\n+                @Override\n+                public void onPush() throws Exception {\n+                  final HttpResponse response = grab(responseInlet);\n+                  final AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                    // Check if the active scope is still the scope from when the request came in,\n+                    // and close it. If it's not, then it will be cleaned up actor message\n+                    // processing instrumentation that drives this state machine\n+                    TraceScope activeScope = activeScope();\n+                    if (activeScope == scope) {\n+                      scope.close();\n+                    }\n+                  }\n+                  push(responseOutlet, response);\n+                }\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  AgentScope scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  completeStage();\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception {\n+                  AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    // Mark the span as failed\n+                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n+                  }\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  fail(responseOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the response goes back to the server and TCP layer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MDAwODEwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTo1NTozM1rOHxcGlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNjoxOToyOVrOHxsBow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwMjcwOA==", "bodyText": "AgentTracer.noopSpan() would be better here", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521602708", "createdAt": "2020-11-11T19:55:33Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2MzU4Nw==", "bodyText": "The reason that I construct a new span instance is that I want to minimize the chance that the cleaning code messes up the scope stack reference count for any scope that is active when we come in to this code, and using the AgentTracer.noopSpan() could easily do that since I can't distinguish between this span/scope and any that was active when calling this method.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521863587", "createdAt": "2020-11-12T06:19:29Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwMjcwOA=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4780, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}