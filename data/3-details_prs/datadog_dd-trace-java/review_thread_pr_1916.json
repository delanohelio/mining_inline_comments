{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzQ2NjEy", "number": 1916, "reviewThreads": {"totalCount": 53, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNjoxOFrOEoKGrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyODoyNVrOEqlSkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ0MDQ1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNjoxOFrOHZFgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNTo0MVrOHZ2NEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA==", "bodyText": "This is disabled by default, I would keep it in", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496066584", "createdAt": "2020-09-28T16:06:18Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDUyNg==", "bodyText": "Actually I agree we should remove this, the cost of the measurement is probably a lot higher than what we're measuring here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496084526", "createdAt": "2020-09-28T16:34:27Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDUyOQ==", "bodyText": "I moved it elsewhere.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864529", "createdAt": "2020-09-29T16:15:41Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NjU4NA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ0NDI0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowNzoyMlrOHZFinw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNTo1NFrOHZ2Nyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NzIzMQ==", "bodyText": "Why ConcurrentLinkedQueue? Less contention? We have JCTools as a dependency now, consider using it here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496067231", "createdAt": "2020-09-28T16:07:22Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDcxNQ==", "bodyText": "done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864715", "createdAt": "2020-09-29T16:15:54Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NzIzMQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ0OTcwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjowODo0OFrOHZFmBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNjowNVrOHZ2OgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2ODEwMw==", "bodyText": "I think we should rework this to initialise the thread in the constructor and start the thread here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496068103", "createdAt": "2020-09-28T16:08:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NDg5Ng==", "bodyText": "done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496864896", "createdAt": "2020-09-29T16:16:05Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2ODEwMw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ2NzAxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxMjo0OVrOHZFwWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNjoxNVrOHZ2PKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA==", "bodyText": "I tend to use Thread.currentThread().isInterrupted() because it doesn't clear the interrupted status, not sure this is important though.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496070744", "createdAt": "2020-09-28T16:12:49Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMTM3MQ==", "bodyText": "Yes, agreed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496121371", "createdAt": "2020-09-28T17:35:40Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTA2NA==", "bodyText": "done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496865064", "createdAt": "2020-09-29T16:16:15Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MDc0NA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ3NzI3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNToxOFrOHZF2iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNjo0M1rOHZ2Q-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ==", "bodyText": "I think it would be better to block (call take()) here than sleep and poll", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496072329", "createdAt": "2020-09-28T16:15:18Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MzYwMg==", "bodyText": "I tried to find something like that but I don't see that method.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496073602", "createdAt": "2020-09-28T16:17:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NzYxMg==", "bodyText": "If you take a queue which implements java.util.concurrent.BlockingQueue it should be there. If this queue handles all traces, I think we should look at using a bounded queue to prevent unbounded growth. MpscBlockingConsumerArrayQueue used in the reporting pipeline might be a better choice.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496077612", "createdAt": "2020-09-28T16:23:21Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMjE3Mw==", "bodyText": "Yes, an even if we don't do a BlockingQueue, we could do wait / notify ourselves -- definitely don't want to sleep.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496122173", "createdAt": "2020-09-28T17:37:14Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NTUyOQ==", "bodyText": "done.  Using take now that I'm using a blocking queue.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496865529", "createdAt": "2020-09-29T16:16:43Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjMyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ4ODU4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxNzo1MlrOHZF9SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNzoxN1rOHZ2TGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng==", "bodyText": "if we just do this in the constructor we can't create 2 of them", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496074056", "createdAt": "2020-09-28T16:17:52Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTkzNA==", "bodyText": "Yes, this TRACE_MONITOR feels a tad bit messy.\nConstructor might be problematic since it probably exposes a raw reference to PendingTraceBuffer.\nI also think the AtomicReference is probably overkill.  volatile + double checking would be lighter.\nDoesn't matter much here, but it is pattern we have throughout our code.\nI also don't like that this creates a Thread and then may skip starting it.\nI imagine that the backing OS resource probably isn't creating until start, but this still seems questionable for an expensive Object like Thread.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496119934", "createdAt": "2020-09-28T17:33:06Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjA3NQ==", "bodyText": "I've replaced with a single thread per instance.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866075", "createdAt": "2020-09-29T16:17:17Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3NDA1Ng=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTUzNDQ4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoyODo0OFrOHZGY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzowMjozMFrOHZHtmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MTExNg==", "bodyText": "How often will this be called? Can we reuse a timestamp here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496081116", "createdAt": "2020-09-28T16:28:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMjgxMA==", "bodyText": "If this is System.nanoTime() based it can overflow and should be used for relative comparisons - where are they done?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496102810", "createdAt": "2020-09-28T17:02:30Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MTExNg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTU0NTA1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMToyNFrOHZGfLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNzozM1rOHZ2UPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ==", "bodyText": "I don't think we should do this. We are of secondary importance to the application. If we're shutting down, we need to shut down ASAP. Risking prevention of application shutdown to flush tracing data isn't right.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496082735", "createdAt": "2020-09-28T16:31:24Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDY2NQ==", "bodyText": "This thread is a daemon thread so not such a big deal.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496110665", "createdAt": "2020-09-28T17:16:51Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMjYyNw==", "bodyText": "I was wrong, this can indeed block shutdown despite being daemon", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496122627", "createdAt": "2020-09-28T17:38:00Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjM2NQ==", "bodyText": "done.  No longer joining.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866365", "createdAt": "2020-09-29T16:17:33Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4MjczNQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTU1MjU2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozMzozMlrOHZGj8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxNzo0M1rOHZ2UxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4Mzk1NQ==", "bodyText": "We can do this more efficiently with drainTo either on the BlockingQueue interface or JCTools drain method.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496083955", "createdAt": "2020-09-28T16:33:32Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NjUwMQ==", "bodyText": "done", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496866501", "createdAt": "2020-09-29T16:17:43Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4Mzk1NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTU1ODM2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozNTowNVrOHZGnmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjo1MDo0N1rOHZHMWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDg4OA==", "bodyText": "We have a timestamp here - maybe we should pass it through.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496084888", "createdAt": "2020-09-28T16:35:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -102,6 +103,7 @@ public final void finish() {\n \n   @Override\n   public final void finish(final long stoptimeMicros) {\n+    context.getTrace().touch(); // Update timestamp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA5NDI5OA==", "bodyText": "The timestamp is a different resolution and clock type.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496094298", "createdAt": "2020-09-28T16:50:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -102,6 +103,7 @@ public final void finish() {\n \n   @Override\n   public final void finish(final long stoptimeMicros) {\n+    context.getTrace().touch(); // Update timestamp", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NDg4OA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTY3OTAyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzowNDowNVrOHZHxCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxODoxNVrOHZ2Wvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ==", "bodyText": "Should this logic be encapsulated in PendingTrace so that it returns a boolean? What happens if someone unaware of this bit of logic here changes the time source it uses?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496103691", "createdAt": "2020-09-28T17:04:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNzcyOQ==", "bodyText": "Yes, mixing time sources would be quite confusing.  We probably don't want to be calling System.currentTimeMillis directly here given that we allowed sub-ing out other time sources for spans.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496127729", "createdAt": "2020-09-28T17:46:51Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2NzAwNw==", "bodyText": "done. Logic is contained in PendingTrace now.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496867007", "createdAt": "2020-09-29T16:18:15Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwMzY5MQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTcwNzY1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMjozNlrOHZIDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDoyNzo1MVrOHcsmrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ==", "bodyText": "I assume waitForTraces is really wait for chunks written?\nI'm not sure that the tests should need to know about that.  That said, I think this is the pragmatic choice for now.\nBut long term, I think we should be waiting on a span count (preferably implied from the DSL) rather than having all the instrumentations tests know about the internal chunking of the publishing mechanism.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496108295", "createdAt": "2020-09-28T17:12:36Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNzMxNA==", "bodyText": "I can see us merging traces of a common id together at some point.  Indeed this currently treats each call to write independently.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496127314", "createdAt": "2020-09-28T17:46:07Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODUxMQ==", "bodyText": "I think for now maybe we just rename waitForTraces because I think the name is quite misleading.\nHowever, I do consider it major maintenance problem that the internals of the pending trace / writer mechanism are leaking into the tests for every instrumentation.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788511", "createdAt": "2020-09-29T14:58:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNTc0MA==", "bodyText": "What would you prefer the name to be?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498505740", "createdAt": "2020-10-01T20:50:26Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNjI4NA==", "bodyText": "FYI, In this specific case it is actually two separate traces.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498526284", "createdAt": "2020-10-01T21:38:32Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NjA2Ng==", "bodyText": "What are you calling a trace?  Do the spans have the same trace ID?  If so, I call that one trace.\nIf this is now two separate traces, I would be concerned since that would be an unrelated functional change.\nPlease clarify", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499776066", "createdAt": "2020-10-05T18:00:37Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1Mjk3Mw==", "bodyText": "there is a separate trace generated that isn't linked to the parent (as mentioned in the comment).  Previously it was likely not a problem because we only ever looked at the first span, but it can cause instability in the test.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499852973", "createdAt": "2020-10-05T20:27:51Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/mongo/driver-async-3.3/src/test/groovy/MongoAsyncClientTest.groovy", "diffHunk": "@@ -121,11 +121,12 @@ class MongoAsyncClientTest extends MongoBaseTest {\n     MongoCollection<Document> collection = runUnderTrace(\"setup\") {\n       MongoDatabase db = client.getDatabase(dbName)\n       def latch1 = new CountDownLatch(1)\n+      // This creates a trace that isn't linked to the parent... using NIO internally that we don't handle.\n       db.createCollection(collectionName, toCallback { latch1.countDown() })\n       latch1.await()\n       return db.getCollection(collectionName)\n     }\n-    TEST_WRITER.waitForTraces(1)\n+    TEST_WRITER.waitForTraces(2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODI5NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTcxMTA2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMzozNFrOHZIFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowMDowMlrOHZxqiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODgyMg==", "bodyText": "Fine for now, but this is another case of coupling the tests to the internals of the publishing system.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496108822", "createdAt": "2020-09-28T17:13:34Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "diffHunk": "@@ -123,6 +123,11 @@ class OpenTracing32Test extends AgentTestRunner {\n     then:\n     (scope.span().delegate as DDSpan).isFinished() == finishSpan\n \n+    cleanup:\n+    if (finishSpan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODUwMg==", "bodyText": "I could probably roll back some of these changes after I made the change to AgentTestRunner to flush the buffer between traces.  Seemed better to leave though rather than play the game of deciding which were needed  and which weren't.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128502", "createdAt": "2020-09-28T17:48:19Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "diffHunk": "@@ -123,6 +123,11 @@ class OpenTracing32Test extends AgentTestRunner {\n     then:\n     (scope.span().delegate as DDSpan).isFinished() == finishSpan\n \n+    cleanup:\n+    if (finishSpan) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODgyMg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4OTUwMQ==", "bodyText": "As I said, I think this is fine for now, but it does represent a problem with our layering.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496789501", "createdAt": "2020-09-29T14:59:17Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "diffHunk": "@@ -123,6 +123,11 @@ class OpenTracing32Test extends AgentTestRunner {\n     then:\n     (scope.span().delegate as DDSpan).isFinished() == finishSpan\n \n+    cleanup:\n+    if (finishSpan) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODgyMg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MDE1NQ==", "bodyText": "As I said, I think this is fine for now, but I do think it represents a significant deficiency in our abstracting & layering.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496790155", "createdAt": "2020-09-29T15:00:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/opentracing/api-0.32/src/test/groovy/OpenTracing32Test.groovy", "diffHunk": "@@ -123,6 +123,11 @@ class OpenTracing32Test extends AgentTestRunner {\n     then:\n     (scope.span().delegate as DDSpan).isFinished() == finishSpan\n \n+    cleanup:\n+    if (finishSpan) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODgyMg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTcxNjkxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/scala-concurrent/src/slickTest/groovy/SlickTest.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNTowOFrOHZIIoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowMDozMVrOHZxsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwOTcyOQ==", "bodyText": "I'm assuming this a non-functional reformatting.\nThis would be easier to review if those changes had been done in a separate commit -- preferably even a separate PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496109729", "createdAt": "2020-09-28T17:15:08Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/scala-concurrent/src/slickTest/groovy/SlickTest.groovy", "diffHunk": "@@ -62,14 +62,20 @@ class SlickTest extends AgentTestRunner {\n \n     // Expect two traces because two queries have been run\n     assertTraces(2) {\n-      trace(2, {\n-        span {}\n+      trace(2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjAzMg==", "bodyText": "This was a change that previously didn't assert anything on the @Trace span and I had to figure out what it was when trying to fix it.  I don't think this is a \"non-functional\" change.  It's still the same test but with slightly more assertions.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496126032", "createdAt": "2020-09-28T17:44:08Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/scala-concurrent/src/slickTest/groovy/SlickTest.groovy", "diffHunk": "@@ -62,14 +62,20 @@ class SlickTest extends AgentTestRunner {\n \n     // Expect two traces because two queries have been run\n     assertTraces(2) {\n-      trace(2, {\n-        span {}\n+      trace(2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwOTcyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MDU2Mw==", "bodyText": "Ah, okay.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496790563", "createdAt": "2020-09-29T15:00:31Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/scala-concurrent/src/slickTest/groovy/SlickTest.groovy", "diffHunk": "@@ -62,14 +62,20 @@ class SlickTest extends AgentTestRunner {\n \n     // Expect two traces because two queries have been run\n     assertTraces(2) {\n-      trace(2, {\n-        span {}\n+      trace(2) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwOTcyOQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTcyNDMxOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxNzoyNFrOHZINaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODowMjowNFrOHcn9LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg==", "bodyText": "Rather than sleeping, would it better to await completion?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496110952", "createdAt": "2020-09-28T17:17:24Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNDIyMA==", "bodyText": "Await what completion?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496124220", "createdAt": "2020-09-28T17:40:51Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4MjQ5Ng==", "bodyText": "According to the comment, you are waiting for the reporting of a trace.  Can that be done more explicitly?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496882496", "createdAt": "2020-09-29T16:36:45Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MTcyNw==", "bodyText": "Unfortunately the smoke test doesn't have an option for that.  Any ideas on a better way to do so?  Add a flush to the public API?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498271727", "createdAt": "2020-10-01T14:06:41Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzA4NQ==", "bodyText": "Yes, I think adding a flush would be a better approach than sleeping.  Right now, we're just creating the potential for sporadic test failures.\nOr, maybe, we're just not asserting anything -- in which case, we don't need the sleep at all.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498407085", "createdAt": "2020-10-01T17:30:23Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNjY5OA==", "bodyText": "We are asserting that traces are reported.  Would you like the flush added in this PR or a separate one?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498506698", "createdAt": "2020-10-01T20:52:23Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NjgxMg==", "bodyText": "Separate is fine.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499776812", "createdAt": "2020-10-05T18:02:04Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/cli/src/main/java/datadog/smoketest/cli/CliApplication.java", "diffHunk": "@@ -16,6 +16,9 @@ public static void main(final String[] args) throws InterruptedException {\n     app.exampleTrace();\n \n     System.out.println(\"Finished calling example trace\");\n+\n+    // Sleep to allow the trace to be reported\n+    Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDk1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTczMDYxOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxOToxM1rOHZIRUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoxOToyNVrOHZ2bTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMTk1NQ==", "bodyText": "Files.isDirectory would be a bit cleaner and allocate less -- not that allocation is a problem in test", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496111955", "createdAt": "2020-09-28T17:19:13Z", "author": {"login": "dougqh"}, "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "diffHunk": "@@ -65,6 +65,8 @@ abstract class AbstractSmokeTest extends Specification {\n     if (buildDirectory == null || shadowJarPath == null) {\n       throw new AssertionError(\"Expected system properties not found. Smoke tests have to be run from Gradle. Please make sure that is the case.\")\n     }\n+    assert new File(buildDirectory).isDirectory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg2ODE3NA==", "bodyText": "done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496868174", "createdAt": "2020-09-29T16:19:25Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "diffHunk": "@@ -65,6 +65,8 @@ abstract class AbstractSmokeTest extends Specification {\n     if (buildDirectory == null || shadowJarPath == null) {\n       throw new AssertionError(\"Expected system properties not found. Smoke tests have to be run from Gradle. Please make sure that is the case.\")\n     }\n+    assert new File(buildDirectory).isDirectory()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMTk1NQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgwMjcxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMlrOHZI95w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxNToxMlrOHcoYEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw==", "bodyText": "I think we should take out this sleep (as mentioned elsewhere), but the handling of InterruptedException here is a bit odd.\nWe might as well let it bubble up and break the containing loop.  Right now, we catch it just to reset the interrupt status and then bail the loop later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496123367", "createdAt": "2020-09-28T17:39:22Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0Mjk4NQ==", "bodyText": "I did it this way to avoid printing a lot of thrown InterruptedException's in the logs. Would you prefer the try on the outside of the loop?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496242985", "createdAt": "2020-09-28T21:28:27Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MzMwNg==", "bodyText": "Why would the InterruptedException show up in the logs?\nYou can catch inside the loop and break.\nIt would also be fine to propagate above the loop & catch there.\nBut really logs shouldn't come into play.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496893306", "createdAt": "2020-09-29T16:53:04Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MjQ5OQ==", "bodyText": "Without that catch, I was seeing the exception printed out quite a bit when I ran the tests.  I think the exception is printed out if it is thrown all the way to the root of the thread.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498272499", "createdAt": "2020-10-01T14:07:43Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwODQxOA==", "bodyText": "I went ahead and moved the catch outside the loop and removed the @SneakyThrows, but it still needs to do something with the exception.  Would you prefer just ignore it since it doesn't matter if the interrupt flag is set at that point?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498508418", "createdAt": "2020-10-01T20:56:01Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MzY5OA==", "bodyText": "What else does it need to do something with the exception?  It interrupted the loop that's what it should do.  There's no requirement that we need to log or propagate.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499783698", "createdAt": "2020-10-05T18:15:12Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();\n+        }\n+      }\n+    }\n+\n+    private void sleep() {\n+      try {\n+        Thread.sleep(SLEEP_TIME_MS);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2Nw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgxMzU3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0MjoyM1rOHZJETA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODoxNjozMlrOHZ7DJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA==", "bodyText": "Given that the queue is shared, sleeping here seems questionable.  I think if a new PendingTrace comes in, we want to wake up and evaluate it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496125004", "createdAt": "2020-09-28T17:42:23Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NDAxNA==", "bodyText": "The reason I sleep here is because anything new coming in is unlikely to meet the criteria of being old enough to report and we don't want to burn cycles popping off and re-adding traces.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496244014", "createdAt": "2020-09-28T21:30:42Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5Njc0Nw==", "bodyText": "The sleeping has been removed \ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496796747", "createdAt": "2020-09-29T15:08:41Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MTEyMw==", "bodyText": "@richardstartin , I still have sleep in this case.  if only one item is added to the queue, then it would run a hot loop until the time limit reached for publishing without this sleep.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496871123", "createdAt": "2020-09-29T16:22:15Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MjYwOA==", "bodyText": "Correction, I didn't quite understand that we're only sleep for the single item case.\nThat's kind of subtle and I think comments are warranted.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496892608", "createdAt": "2020-09-29T16:52:04Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0MzkwOQ==", "bodyText": "Thinking about this a bit more, I think we might want to change this a bit to handle the case where several traces arrive at the same time that are all frequently delayed.  I think that's likely to come up often with async web frameworks.\nI think we might want to burn through the queue until we arrive back where we started.  Once we get back to the start, I think we might want to wait.  But honestly, I'm not entirely sure.\nI'm also concerned that we're going to be churning and creating a lot of Nodes in the Queue.  One way to fix that would to use a LinkedTransferQueue, but I think a simple size restricted BlockingQueue is probably our best choice.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496943909", "createdAt": "2020-09-29T18:16:32Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);\n+          sleep();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTAwNA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgyMzQ1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0NDo1OVrOHZJKYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoyMzoxM1rOHZ2qpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjU2Mg==", "bodyText": "This comment is kind of cryptic.  And if we don't need to write, maybe, we should call a cleanUp routine directly instead.  I think that would be more clear.\nAlso, given that I don't think a PendingTrace has a definitive end, I'm curious what clean-up we are doing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496126562", "createdAt": "2020-09-28T17:44:59Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MjEwMQ==", "bodyText": "I removed this for now.  I'll add it back in with a better comment later if I need.  (I can't remember which test case was failing without this.)", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496872101", "createdAt": "2020-09-29T16:23:13Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNjU2Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgzNDg1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0Nzo1NFrOHZJRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoyMzozOVrOHZ2sZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODI5MA==", "bodyText": "This time is probably now a bit misleading.  We might want to put this to be around the actual write.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128290", "createdAt": "2020-09-28T17:47:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?\n       try (Recording recording = tracer.writeTimer()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3MjU0OQ==", "bodyText": "moved.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496872549", "createdAt": "2020-09-29T16:23:39Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,8 +235,9 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n+      // FIXME: Does this still make sense to measure?\n       try (Recording recording = tracer.writeTimer()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODI5MA=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgzNzc2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0ODo0NlrOHZJS8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxNjoyNlrOHZKPFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODc1Mg==", "bodyText": "timer here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496128752", "createdAt": "2020-09-28T17:48:46Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NDE1MQ==", "bodyText": "I'm going to put the timer inside write instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496144151", "createdAt": "2020-09-28T18:16:26Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODc1Mg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgzOTMxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OToxNFrOHZJT6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OToxNFrOHZJT6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTAwMA==", "bodyText": "Should this have a health metric?  Should we track how many times we re-enqueue?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129000", "createdAt": "2020-09-28T17:49:14Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        long currentNanoTicks = Clock.currentNanoTicks();\n+        long lastReferenced = pendingTrace.getLastReferenced();\n+        long delta = currentNanoTicks - lastReferenced;\n+\n+        if (SEND_DELAY_NS <= delta) {\n+          // Trace has been unmodified long enough, go ahead and write whatever is finished.\n+          pendingTrace.write();\n+        } else {\n+          // Trace is too new.  Requeue it and sleep to avoid a hot loop.\n+          queue.add(pendingTrace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTg0MDkyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0OTo0MlrOHZJU4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxNjowMFrOHZKOKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI0OQ==", "bodyText": "timer here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496129249", "createdAt": "2020-09-28T17:49:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzkxMw==", "bodyText": "I'm going to put the timer inside write instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496143913", "createdAt": "2020-09-28T18:16:00Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {\n+      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n+      if (thread.compareAndSet(null, newThread)) {\n+        newThread.start();\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    Thread toClose = thread.getAndSet(null);\n+    if (toClose != null) {\n+      toClose.interrupt();\n+      try {\n+        toClose.join();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+\n+  public void flush() {\n+    PendingTrace pendingTrace = queue.poll();\n+    while (pendingTrace != null) {\n+      pendingTrace.write();\n+      pendingTrace = queue.poll();\n+    }\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!Thread.interrupted()) {\n+        PendingTrace pendingTrace = queue.poll();\n+\n+        if (pendingTrace == null) {\n+          // Queue is empty.  Lets sleep and try again.\n+          sleep();\n+          continue;\n+        }\n+\n+        if (pendingTrace.isEmpty()) {\n+          // \"write\" it out to allow cleanup.\n+          pendingTrace.write();\n+          continue;\n+        }\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {\n+          // Root span is getting old. We need to send the trace to avoid being discarded by agent.\n+          pendingTrace.write();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyOTI0OQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTg0OTgyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/spring-data-1.8/src/test/groovy/SpringJpaTest.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1MTo1OVrOHZJaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowMjowNFrOHZxwrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMDYyNw==", "bodyText": "Why the call to activeSpan?  Are we relying on some side-effect in the test?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496130627", "createdAt": "2020-09-28T17:51:59Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-data-1.8/src/test/groovy/SpringJpaTest.groovy", "diffHunk": "@@ -37,10 +39,14 @@ class SpringJpaTest extends AgentTestRunner {\n   }\n \n   def \"test CRUD\"() {\n+    JpaCustomerRepository repo\n     // moved inside test -- otherwise, miss the opportunity to instrument\n-    def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n-    def repo = context.getBean(JpaCustomerRepository)\n-\n+    def setupSpan = runUnderTrace(\"setup\") {\n+      def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n+      repo = context.getBean(JpaCustomerRepository)\n+      activeSpan()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNjQ1Mw==", "bodyText": "Instead of waiting for a specific number of traces to be reported, I decided it would be better to wait for a particular trace, so I return the span and wait for that span to be reported in a trace.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496136453", "createdAt": "2020-09-28T18:02:03Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/spring-data-1.8/src/test/groovy/SpringJpaTest.groovy", "diffHunk": "@@ -37,10 +39,14 @@ class SpringJpaTest extends AgentTestRunner {\n   }\n \n   def \"test CRUD\"() {\n+    JpaCustomerRepository repo\n     // moved inside test -- otherwise, miss the opportunity to instrument\n-    def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n-    def repo = context.getBean(JpaCustomerRepository)\n-\n+    def setupSpan = runUnderTrace(\"setup\") {\n+      def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n+      repo = context.getBean(JpaCustomerRepository)\n+      activeSpan()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMDYyNw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MTcyNw==", "bodyText": "Ah, I didn't realize that groovy also does implicit return.  Now, I follow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496791727", "createdAt": "2020-09-29T15:02:04Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/spring-data-1.8/src/test/groovy/SpringJpaTest.groovy", "diffHunk": "@@ -37,10 +39,14 @@ class SpringJpaTest extends AgentTestRunner {\n   }\n \n   def \"test CRUD\"() {\n+    JpaCustomerRepository repo\n     // moved inside test -- otherwise, miss the opportunity to instrument\n-    def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n-    def repo = context.getBean(JpaCustomerRepository)\n-\n+    def setupSpan = runUnderTrace(\"setup\") {\n+      def context = new AnnotationConfigApplicationContext(JpaPersistenceConfig)\n+      repo = context.getBean(JpaCustomerRepository)\n+      activeSpan()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMDYyNw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTg5NDQ1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODowNDoyOFrOHZJ2Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMDo1ODowNFrOHbampA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNzc1MQ==", "bodyText": "isWritten doesn't need to be AtomicBoolean if we're going to synchronize anyway.  This could simply be a volatile.\n\nThis part doesn't have to be fixed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496137751", "createdAt": "2020-09-28T18:04:28Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,7 +277,7 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwOTQ3Ng==", "bodyText": "noted... this will likely go away in a future refactor anyway.  I did rename it to align with the new system.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498509476", "createdAt": "2020-10-01T20:58:04Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,7 +277,7 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNzc1MQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTk5MDg4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NTozNVrOHZxcSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NTozNVrOHZxcSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjUwNQ==", "bodyText": "Yes, I appreciate we're dealing with technical debt pragmatically here, but it would be nice not to need to do things like this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786505", "createdAt": "2020-09-29T14:55:35Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -83,6 +83,13 @@\n   private static final String LANG_INTERPRETER_VENDOR_STATSD_TAG = \"lang_interpreter_vendor\";\n   private static final String TRACER_VERSION_STATSD_TAG = \"tracer_version\";\n \n+  // FIXME: This is static instead of instance because we don't reliably close the tracer in tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTk5MzQ2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NjowNFrOHZxd3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1NjowNFrOHZxd3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4NjkxMA==", "bodyText": "nice", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496786910", "createdAt": "2020-09-29T14:56:04Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -120,8 +130,10 @@ public void touch() {\n     lastReferenced = Clock.currentNanoTicks();\n   }\n \n-  public long getLastReferenced() {\n-    return lastReferenced;\n+  public boolean lastReferencedNanosAgo(long nanos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDAwMjYwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1Nzo1NVrOHZxjxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMDo1ODoyOVrOHbandQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODQyMA==", "bodyText": "I would consider making this quite a lot bigger", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788420", "createdAt": "2020-09-29T14:57:55Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwOTY4NQ==", "bodyText": "is 4096 big enough?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498509685", "createdAt": "2020-10-01T20:58:29Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODQyMA=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDAwNTg0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1ODozNVrOHZxlug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1ODozNVrOHZxlug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4ODkyMg==", "bodyText": "Maybe allocate a private static final instance", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496788922", "createdAt": "2020-09-29T14:58:35Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -2,73 +2,60 @@\n \n import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n \n-import datadog.trace.core.util.Clock;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n \n class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n   private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n   private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n   private final long SLEEP_TIME_MS = 1;\n \n-  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n-  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n \n   public void enqueue(PendingTrace pendingTrace) {\n-    queue.add(pendingTrace);\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n   }\n \n   public void start() {\n-    if (thread.get() == null) {\n-      Thread newThread = TRACE_MONITOR.newThread(new Worker());\n-      if (thread.compareAndSet(null, newThread)) {\n-        newThread.start();\n-      }\n-    }\n+    worker.start();\n   }\n \n   @Override\n   public void close() {\n-    Thread toClose = thread.getAndSet(null);\n-    if (toClose != null) {\n-      toClose.interrupt();\n-      try {\n-        toClose.join();\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-    }\n+    closed = true;\n+    worker.interrupt();\n   }\n \n   public void flush() {\n-    PendingTrace pendingTrace = queue.poll();\n-    while (pendingTrace != null) {\n-      pendingTrace.write();\n-      pendingTrace = queue.poll();\n-    }\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDA1MDY1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTowNzo1NFrOHZyB2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjoyNToxMFrOHZ2yfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjEyMg==", "bodyText": "I believe this was where the Thread.join() was, and is no longer here.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496796122", "createdAt": "2020-09-29T15:07:54Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3NDExMQ==", "bodyText": "yep.  it's been removed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496874111", "createdAt": "2020-09-29T16:25:10Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjEyMg=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDE1MjQ2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNToyNjoxMlrOHZzAVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTowMzoyMlrOHbawUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw==", "bodyText": "So I'm a bit afraid that holding back traces when we actually reach zero will make all our traces back up in this buffer, while it's actually only the ones that were we don't reach zero that we need to force flush at a certain interval.\nWhat is it that we want to achieve longterm with this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496812117", "createdAt": "2020-09-29T15:26:12Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3NjI3Nw==", "bodyText": "The goal is to eventually remove all reference counting/continuations.  This slight async delay should cover most of the cases which would cause async work to be split up without continuations.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496876277", "createdAt": "2020-09-29T16:27:28Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNjcyNQ==", "bodyText": "I completely agree that we need to clean up/remove the continuations, but I'm not so sure that we should remove all forms of reference counting, since I don't see how we can validate correctness of an instrumentation without some form of strict mode during testing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497306725", "createdAt": "2020-09-30T07:45:04Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMTk1Mg==", "bodyText": "Maybe we need to have two different types of PendingTrace.  One that does strict ref counting and another with this timeout mechanism.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498511952", "createdAt": "2020-10-01T21:03:22Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -213,9 +247,7 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n   private void expireReference() {\n     final int count = pendingReferenceCount.decrementAndGet();\n     if (count == 0) {\n-      try (Recording recording = tracer.writeTimer()) {\n-        write();\n-      }\n+      pendingTraceBuffer.enqueue(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjExNw=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDYxOTc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0MDoyNFrOHZ3c3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0MDoyNFrOHZ3c3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NDk1Ng==", "bodyText": "Rather than doing an instanceof check on DDAgentWriter, it would make more sense to add a flush method onto the Writer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496884956", "createdAt": "2020-09-29T16:40:24Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -487,10 +492,19 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();\n+    if (writer instanceof DDAgentWriter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDYyOTI3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0Mjo0MVrOHZ3iaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxMjoxMVrOHba_Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NjM3Ng==", "bodyText": "Should the constructor be public?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496886376", "createdAt": "2020-09-29T16:42:41Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -26,17 +25,32 @@\n \n @Slf4j\n public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements AgentTrace {\n+  private static final long CLEAN_FREQUENCY = 1;\n \n-  static PendingTrace create(final CoreTracer tracer, final DDId traceId) {\n-    final PendingTrace pendingTrace = new PendingTrace(tracer, traceId);\n-    pendingTrace.addPendingTrace();\n-    return pendingTrace;\n-  }\n+  public static class Factory {\n+    private final CoreTracer tracer;\n+    private final PendingTraceBuffer pendingTraceBuffer;\n+\n+    public Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTc1MA==", "bodyText": "Changed to package visible.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498515750", "createdAt": "2020-10-01T21:12:11Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -26,17 +25,32 @@\n \n @Slf4j\n public class PendingTrace extends ConcurrentLinkedDeque<DDSpan> implements AgentTrace {\n+  private static final long CLEAN_FREQUENCY = 1;\n \n-  static PendingTrace create(final CoreTracer tracer, final DDId traceId) {\n-    final PendingTrace pendingTrace = new PendingTrace(tracer, traceId);\n-    pendingTrace.addPendingTrace();\n-    return pendingTrace;\n-  }\n+  public static class Factory {\n+    private final CoreTracer tracer;\n+    private final PendingTraceBuffer pendingTraceBuffer;\n+\n+    public Factory(CoreTracer tracer, PendingTraceBuffer pendingTraceBuffer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NjM3Ng=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDY0MTkzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo0NTo0MVrOHZ3p9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxNDo0N1rOHbbDbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ==", "bodyText": "Okay, so short-circuit clean-up if we've already written.\nI still need clarification on the lifecycle of PendingTrace object to understand if this is correct.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496888309", "createdAt": "2020-09-29T16:45:41Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzE0Nw==", "bodyText": "Since I am putting each individual PendingTrace into the AgentTaskScheduler with no way to cancel those tasks when they're done (it relies on GC to discard the tasks), this seemed like a good way to reduce that impact.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496897147", "createdAt": "2020-09-29T16:59:10Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNDQ1Ng==", "bodyText": "To answer the question about the partial flush, that is reported as a separate list of spans and association with the pending trace is no longer needed.\nI think there is a good question about late arriving spans that I need to consider further.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496904456", "createdAt": "2020-09-29T17:11:30Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNjg0NA==", "bodyText": "I removed this short circuit and fixed the late arrival flush.  The clean method will be removed in the future when we no longer track all the references.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498516844", "createdAt": "2020-10-01T21:14:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -254,27 +286,31 @@ private void expireReference() {\n     }\n   }\n \n-  private synchronized void write() {\n+  synchronized void write() {\n     if (isWritten.compareAndSet(false, true)) {\n-      removePendingTrace();\n-      if (!isEmpty()) {\n-        int size = size();\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+      try (Recording recording = tracer.writeTimer()) {\n+        if (!isEmpty()) {\n+          int size = size();\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"Writing {} spans to {}.\", size, tracer.writer);\n+          }\n+          List<DDSpan> trace = new ArrayList<>(size);\n+          trace.addAll(this);\n+          // TODO - strange that tests expect the contents\n+          //  NOT to be cleared here. Keeping the spans around\n+          //  could lead to them all being promoted by nepotism,\n+          //  whereas some of them might avoid this if they're\n+          //  dropped when we write\n+          tracer.write(trace);\n         }\n-        List<DDSpan> trace = new ArrayList<>(size);\n-        trace.addAll(this);\n-        // TODO - strange that tests expect the contents\n-        //  NOT to be cleared here. Keeping the spans around\n-        //  could lead to them all being promoted by nepotism,\n-        //  whereas some of them might avoid this if they're\n-        //  dropped when we write\n-        tracer.write(trace);\n       }\n     }\n   }\n \n   public synchronized boolean clean() {\n+    if (isWritten.get()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4ODMwOQ=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDY4NDA2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanContextTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NTozMFrOHZ4DXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzowODoxMlrOHZ4hTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NDgxNQ==", "bodyText": "Can you explain a bit more what's happening here?\nWhy do we need to start & wait now?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496894815", "createdAt": "2020-09-29T16:55:30Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanContextTest.groovy", "diffHunk": "@@ -7,6 +7,10 @@ import datadog.trace.util.test.DDSpecification\n \n class DDSpanContextTest extends DDSpecification {\n \n+  def setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwMjQ3OA==", "bodyText": "SpanFactory.WRITER.start() ensures that there aren't any traces in the writer already.  (If there are, then the waitForTraces calls below doesn't wait for the right trace.)\nThe reason waitForTraces is needed is because that allows the span processing to be applied before validating the final state of the span. (Specifically applying the span metrics expected below.)", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496902478", "createdAt": "2020-09-29T17:08:12Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanContextTest.groovy", "diffHunk": "@@ -7,6 +7,10 @@ import datadog.trace.util.test.DDSpecification\n \n class DDSpanContextTest extends DDSpecification {\n \n+  def setup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NDgxNQ=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDY5MDQ3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanSerializationTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1NzoxMlrOHZ4HgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzowMDoyNFrOHZ4Pfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NTg3Mw==", "bodyText": "As aside, I think we could have maintained the old API and that would have kept the diff easier to read.\nPending.create could internally do tracer.pendingTraceFactory.create.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496895873", "createdAt": "2020-09-29T16:57:12Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanSerializationTest.groovy", "diffHunk": "@@ -138,7 +138,7 @@ class DDSpanSerializationTest extends DDSpecification {\n       false,\n       null,\n       tags.size(),\n-      PendingTrace.create(tracer, DDId.ONE),\n+      tracer.pendingTraceFactory.create(DDId.ONE),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzkxOA==", "bodyText": "good point... didn't think about that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496897918", "createdAt": "2020-09-29T17:00:24Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanSerializationTest.groovy", "diffHunk": "@@ -138,7 +138,7 @@ class DDSpanSerializationTest extends DDSpecification {\n       false,\n       null,\n       tags.size(),\n-      PendingTrace.create(tracer, DDId.ONE),\n+      tracer.pendingTraceFactory.create(DDId.ONE),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NTg3Mw=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDY5OTI0OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerTest.groovy", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjo1OToyOFrOHZ4NGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo1NzozMlrOHZ6Xgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzMwNA==", "bodyText": "I'd like to understand why we needed to add this in so many places.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496897304", "createdAt": "2020-09-29T16:59:28Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerTest.groovy", "diffHunk": "@@ -97,6 +98,7 @@ class ScopeManagerTest extends DDSpecification {\n \n     when:\n     span.finish()\n+    writer.waitForTraces(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5OTAzNw==", "bodyText": "This test (and many others where I had to add this) was relying on the trace being immediately written to the writer below:\nwriter == [[scope.span()]]", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496899037", "createdAt": "2020-09-29T17:02:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerTest.groovy", "diffHunk": "@@ -97,6 +98,7 @@ class ScopeManagerTest extends DDSpecification {\n \n     when:\n     span.finish()\n+    writer.waitForTraces(1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzMwNA=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMjczOA==", "bodyText": "Part of the reason, I'd put more of the delay logic into the Writer in my PoC was to avoid these types of problems.\nDoing so, allowed the tests to use a simple synchronous writer.\nAs I've said elsewhere, I don't think every test should need to aware of all these publishing mechanism details.\nFor now, I think we need to leave it alone, but it is a code smell.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496932738", "createdAt": "2020-09-29T17:57:32Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/scopemanager/ScopeManagerTest.groovy", "diffHunk": "@@ -97,6 +98,7 @@ class ScopeManagerTest extends DDSpecification {\n \n     when:\n     span.finish()\n+    writer.waitForTraces(1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5NzMwNA=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg0MDAzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/couchbase-2.0/src/test/groovy/CouchbaseClientTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzozNjozMVrOHZ5laQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxMjowMlrOHbMVUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxOTkxMw==", "bodyText": "Is this an anonymous function being immediately invoked?  Is this not equivalent to...\nTEST_WRITER.waitForTraces(1)\nwaitForTraces = true", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496919913", "createdAt": "2020-09-29T17:36:31Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/couchbase-2.0/src/test/groovy/CouchbaseClientTest.groovy", "diffHunk": "@@ -37,6 +37,11 @@ class CouchbaseClientTest extends AbstractCouchbaseTest {\n     cluster = CouchbaseCluster.create(environment, Arrays.asList(\"127.0.0.1\"))\n     manager = cluster.clusterManager(USERNAME, PASSWORD)\n     type = bucketSettings.type().name()\n+\n+    waitForTraces = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTY2NQ==", "bodyText": "I only really need the TEST_WRITER.waitForTraces(1), but that returns a void, and statements in where blocks in spock must make an assignment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498275665", "createdAt": "2020-10-01T14:12:02Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/couchbase-2.0/src/test/groovy/CouchbaseClientTest.groovy", "diffHunk": "@@ -37,6 +37,11 @@ class CouchbaseClientTest extends AbstractCouchbaseTest {\n     cluster = CouchbaseCluster.create(environment, Arrays.asList(\"127.0.0.1\"))\n     manager = cluster.clusterManager(USERNAME, PASSWORD)\n     type = bucketSettings.type().name()\n+\n+    waitForTraces = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxOTkxMw=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDg2MTk5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0MjoxN1rOHZ5zIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMDo0NzozNVrOHbaSzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ==", "bodyText": "Can PENDING_TRACE_BUFFER.close raise an exception?\nIf so, this should have a try / finally.\nGenerally, I'd just assume closing logic, should do try / finally for each step for safety.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r496923425", "createdAt": "2020-09-29T17:42:17Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -334,13 +357,15 @@ private void removePendingTrace() {\n   }\n \n   static void initialize() {\n+    PENDING_TRACE_BUFFER.start();\n     final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n     if (oldCleaner != null) {\n       oldCleaner.close();\n     }\n   }\n \n   static void close() {\n+    PENDING_TRACE_BUFFER.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwODI3Ng==", "bodyText": "I need this question answered.  Or, I need this to be fixed to approve.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498408276", "createdAt": "2020-10-01T17:32:43Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -334,13 +357,15 @@ private void removePendingTrace() {\n   }\n \n   static void initialize() {\n+    PENDING_TRACE_BUFFER.start();\n     final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n     if (oldCleaner != null) {\n       oldCleaner.close();\n     }\n   }\n \n   static void close() {\n+    PENDING_TRACE_BUFFER.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNDM5OA==", "bodyText": "that close method only calls interrupt() on the worker thread with no blocking, so this should not throw any exceptions.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498504398", "createdAt": "2020-10-01T20:47:35Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -334,13 +357,15 @@ private void removePendingTrace() {\n   }\n \n   static void initialize() {\n+    PENDING_TRACE_BUFFER.start();\n     final SpanCleaner oldCleaner = SPAN_CLEANER.getAndSet(new SpanCleaner());\n     if (oldCleaner != null) {\n       oldCleaner.close();\n     }\n   }\n \n   static void close() {\n+    PENDING_TRACE_BUFFER.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMzQyNQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMzIzNjk2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNzoyMzo0M1rOHaQd8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODowNjozNFrOHbVi7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5NDgzNA==", "bodyText": "I have a hard time following the wider implications of these changes. Will this mean that in the future when all reference counting is removed, we will flush any Trace with a Span that does work for longer than, or takes longer to  start than FORCE_SEND_DELAY_MS, which is currently 5 ms, and not report any more spans that happen after that or what will happen? I mean work taking more than 5 ms is not uncommon.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r497294834", "createdAt": "2020-09-30T07:23:43Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;\n+    worker.interrupt();\n+  }\n+\n+  public void flush() {\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!closed && !Thread.currentThread().isInterrupted()) {\n+\n+        PendingTrace pendingTrace = queue.take(); // block until available.\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNjYwNg==", "bodyText": "Yes, I think this might be a bit aggressive.  Clearly, we have to cap how long we wait to send, but I don't think 5ms of inactivity is a long enough delay -- and I think it ends up needlessly churning the queue.\nI think what we might want to do is...\n1 - Put trace in a ready state when the root span finishes\n1a - If we're in a ready state and there are no outstanding spans or continuations, we send\n1b - If we're in a ready state and there are outstanding spans or continuations, we delay 1s with up to 3 delays\n2 - Once the root is released, the PendingTrace (or a new PendingTrace for the same trace ID) goes back into a ready state when a span is finished\n2a - the new batch is implicitly a partial batch & should go into the delayed state\n3 - Partial flushes - are a variation on case 2 above, but before the root has been finished\nAs for the delay queue, I think I'm inclined towards a priority queue sorted by the time we should next check the element.  It could also be approximate.  We could create chunks by 250ms time buckets or something similar.\nI'll also repeat that I think is really important that this change documents how the pipeline works.  Both in the PR -- and in comments or a doc in the repository.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498426606", "createdAt": "2020-10-01T18:06:34Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import java.util.concurrent.TimeUnit;\n+import lombok.SneakyThrows;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscBlockingConsumerArrayQueue;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  /** to correspond with DDAgentWriter.BUFFER_SIZE */\n+  private static final int BUFFER_SIZE = 1024;\n+\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final MpscBlockingConsumerArrayQueue<PendingTrace> queue =\n+      new MpscBlockingConsumerArrayQueue<>(BUFFER_SIZE);\n+  private final Thread worker = TRACE_MONITOR.newThread(new Worker());\n+\n+  private volatile boolean closed = false;\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    if (!queue.offer(pendingTrace)) {\n+      // Queue is full, so we can't buffer this trace, write it out directly instead.\n+      pendingTrace.write();\n+    }\n+  }\n+\n+  public void start() {\n+    worker.start();\n+  }\n+\n+  @Override\n+  public void close() {\n+    closed = true;\n+    worker.interrupt();\n+  }\n+\n+  public void flush() {\n+    queue.drain(\n+        new MessagePassingQueue.Consumer<PendingTrace>() {\n+          @Override\n+          public void accept(PendingTrace pendingTrace) {\n+            pendingTrace.write();\n+          }\n+        });\n+  }\n+\n+  private final class Worker implements Runnable {\n+\n+    @SneakyThrows\n+    @Override\n+    public void run() {\n+      while (!closed && !Thread.currentThread().isInterrupted()) {\n+\n+        PendingTrace pendingTrace = queue.take(); // block until available.\n+\n+        DDSpan rootSpan = pendingTrace.getRootSpan();\n+\n+        long finishTimestampMillis =\n+            TimeUnit.NANOSECONDS.toMillis(rootSpan.getStartTime() + rootSpan.getDurationNano());\n+        if (finishTimestampMillis + FORCE_SEND_DELAY_MS <= System.currentTimeMillis()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5NDgzNA=="}, "originalCommit": {"oid": "d67779f990f36957ed9109f21abc18faabcb61dc"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDI2ODk4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNzozNjo0OFrOHbUkHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMDo0NjowOFrOHbaQQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDUyNg==", "bodyText": "I suppose we only have one but I think AtomicReference might overkill.  volatile + double checking would be sufficient.  We can leave this as is.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498410526", "createdAt": "2020-10-01T17:36:48Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwMzc0NA==", "bodyText": "This is out of date... I updated this a few days ago.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498503744", "createdAt": "2020-10-01T20:46:08Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTraceBuffer.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package datadog.trace.core;\n+\n+import static datadog.common.exec.DaemonThreadFactory.TRACE_MONITOR;\n+\n+import datadog.trace.core.util.Clock;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.SneakyThrows;\n+\n+class PendingTraceBuffer implements AutoCloseable {\n+  private final long FORCE_SEND_DELAY_MS = TimeUnit.SECONDS.toMillis(5);\n+  private final long SEND_DELAY_NS = TimeUnit.MILLISECONDS.toNanos(5);\n+  private final long SLEEP_TIME_MS = 1;\n+\n+  private final ConcurrentLinkedQueue<PendingTrace> queue = new ConcurrentLinkedQueue<>();\n+  private final AtomicReference<Thread> thread = new AtomicReference<>();\n+\n+  public void enqueue(PendingTrace pendingTrace) {\n+    queue.add(pendingTrace);\n+  }\n+\n+  public void start() {\n+    if (thread.get() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQxMDUyNg=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMDYxNzc3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyODo1OVrOHbYFuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMToxNjozMFrOHbbGew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODI4MQ==", "bodyText": "I think the raciness of lastReferenced is fine, but I think this warrants a comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498468281", "createdAt": "2020-10-01T19:28:59Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNzYyNw==", "bodyText": "could you be more specific?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r498517627", "createdAt": "2020-10-01T21:16:30Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -99,7 +111,17 @@ private PendingTrace(final CoreTracer tracer, final DDId traceId) {\n    * @return timestamp in nanoseconds\n    */\n   public long getCurrentTimeNano() {\n-    return startTimeNano + Math.max(0, Clock.currentNanoTicks() - startNanoTicks);\n+    long nanoTicks = Clock.currentNanoTicks();\n+    lastReferenced = nanoTicks;\n+    return startTimeNano + Math.max(0, nanoTicks - startNanoTicks);\n+  }\n+\n+  public void touch() {\n+    lastReferenced = Clock.currentNanoTicks();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODI4MQ=="}, "originalCommit": {"oid": "376a716c454a5bcbd86272f595c185513a019b13"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTIzOTI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/HttpServletResponseTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMDoyMFrOHcoN0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMDoyMFrOHcoN0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTA3NQ==", "bodyText": "Having to wait & clear everywhere is a code smell for me, but we'll leave improved testing for another PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499781075", "createdAt": "2020-10-05T18:10:20Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/HttpServletResponseTest.groovy", "diffHunk": "@@ -29,6 +29,7 @@ class HttpServletResponseTest extends AgentTestRunner {\n     // We need to call service so HttpServletAdvice can link the request to the response.\n     servlet.service((ServletRequest) request, (ServletResponse) response)\n     assert response.__datadogContext$javax$servlet$http$HttpServletResponse != null\n+    TEST_WRITER.waitForTraces(1)\n     TEST_WRITER.clear()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI0Mzc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxMTo0MlrOHcoQmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODo1OTo1NlrOHcp1Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTc4NQ==", "bodyText": "Does this need a try / finally?  What's expected to happen with the writer if PendingTraceBuffer.flush raises an exception.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499781785", "createdAt": "2020-10-05T18:11:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -494,10 +499,17 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNzU1NA==", "bodyText": "It doesn't declare any exceptions to be thrown (unless the drain destination is null, which is hardcoded so it shouldn't).  I don't have a problem adding one just in case though.\nDo you want me to add that?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499807554", "createdAt": "2020-10-05T18:59:56Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -494,10 +499,17 @@ public void addScopeListener(final ScopeListener listener) {\n \n   @Override\n   public void close() {\n-    PendingTrace.close();\n+    // FIXME: can't close PENDING_TRACE_BUFFER since it is a static/shared instance.\n+    // PENDING_TRACE_BUFFER.close();\n     writer.close();\n   }\n \n+  @Override\n+  public void flush() {\n+    PENDING_TRACE_BUFFER.flush();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4MTc4NQ=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI2NDUyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/CoreSpanBuilderTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxNzo1MlrOHcodjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowNTowOVrOHcqAHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTEwMQ==", "bodyText": "What is being changed here?  Is this a non-functional change?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499785101", "createdAt": "2020-10-05T18:17:52Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/CoreSpanBuilderTest.groovy", "diffHunk": "@@ -269,25 +269,24 @@ class CoreSpanBuilderTest extends DDSpecification {\n     // others are just for fun\n \n     def root = tracer.buildSpan(\"fake_O\").withServiceName(\"foo\").start()\n-    spans.add(root)\n \n-    final long tickEnd = System.currentTimeMillis()\n+    def lastSpan = root", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMDMzNA==", "bodyText": "I had to change this to avoid the root span getting finished in order to maintain the spirit of the test, otherwise all the spans get reported and the expect is much different.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499810334", "createdAt": "2020-10-05T19:05:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/CoreSpanBuilderTest.groovy", "diffHunk": "@@ -269,25 +269,24 @@ class CoreSpanBuilderTest extends DDSpecification {\n     // others are just for fun\n \n     def root = tracer.buildSpan(\"fake_O\").withServiceName(\"foo\").start()\n-    spans.add(root)\n \n-    final long tickEnd = System.currentTimeMillis()\n+    def lastSpan = root", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTEwMQ=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI2ODk3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceBufferTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoxOToxMVrOHcogYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowNzoxOVrOHcqE5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTgyNA==", "bodyText": "I think we should get out the habit of poking into the internals as part of tests.\nAdmittedly, this case is borderline, since it is in the same package.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499785824", "createdAt": "2020-10-05T18:19:11Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceBufferTest.groovy", "diffHunk": "@@ -0,0 +1,303 @@\n+package datadog.trace.core\n+\n+import com.timgroup.statsd.NoOpStatsDClient\n+import datadog.trace.api.DDId\n+import datadog.trace.bootstrap.instrumentation.api.ScopeSource\n+import datadog.trace.context.TraceScope\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory\n+import datadog.trace.core.monitor.Monitoring\n+import datadog.trace.core.scopemanager.ContinuableScopeManager\n+import datadog.trace.util.test.DDSpecification\n+import spock.lang.Subject\n+import spock.lang.Timeout\n+\n+import java.util.concurrent.CountDownLatch\n+\n+import static datadog.trace.core.PendingTraceBuffer.BUFFER_SIZE\n+import static datadog.trace.core.SpanFactory.newSpanOf\n+\n+@Timeout(5)\n+class PendingTraceBufferTest extends DDSpecification {\n+  @Subject\n+  def buffer = new PendingTraceBuffer()\n+  def bufferSpy = Spy(buffer)\n+\n+  def tracer = Mock(CoreTracer)\n+  def scopeManager = new ContinuableScopeManager(10, new DDNoopScopeEventFactory(), new NoOpStatsDClient(), true, true)\n+  def factory = new PendingTrace.Factory(tracer, bufferSpy)\n+  List<TraceScope.Continuation> continuations = []\n+\n+  def cleanup() {\n+    buffer.close()\n+    buffer.worker.join(1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMTU1Nw==", "bodyText": "I think this is important to ensure the thread is stopped properly.  Previously I had close as a blocking call, but Richard asked me to remove that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499811557", "createdAt": "2020-10-05T19:07:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceBufferTest.groovy", "diffHunk": "@@ -0,0 +1,303 @@\n+package datadog.trace.core\n+\n+import com.timgroup.statsd.NoOpStatsDClient\n+import datadog.trace.api.DDId\n+import datadog.trace.bootstrap.instrumentation.api.ScopeSource\n+import datadog.trace.context.TraceScope\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory\n+import datadog.trace.core.monitor.Monitoring\n+import datadog.trace.core.scopemanager.ContinuableScopeManager\n+import datadog.trace.util.test.DDSpecification\n+import spock.lang.Subject\n+import spock.lang.Timeout\n+\n+import java.util.concurrent.CountDownLatch\n+\n+import static datadog.trace.core.PendingTraceBuffer.BUFFER_SIZE\n+import static datadog.trace.core.SpanFactory.newSpanOf\n+\n+@Timeout(5)\n+class PendingTraceBufferTest extends DDSpecification {\n+  @Subject\n+  def buffer = new PendingTraceBuffer()\n+  def bufferSpy = Spy(buffer)\n+\n+  def tracer = Mock(CoreTracer)\n+  def scopeManager = new ContinuableScopeManager(10, new DDNoopScopeEventFactory(), new NoOpStatsDClient(), true, true)\n+  def factory = new PendingTrace.Factory(tracer, bufferSpy)\n+  List<TraceScope.Continuation> continuations = []\n+\n+  def cleanup() {\n+    buffer.close()\n+    buffer.worker.join(1000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NTgyNA=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI4MDgxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMjozOVrOHcontA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMjozOVrOHcontA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NzcwMA==", "bodyText": "Yes, to solve that, I think you'd have to have a way to get reference directly to the Task.  I'm not sure it is worth the trouble, so this is fine for now.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499787700", "createdAt": "2020-10-05T18:22:39Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceTest.groovy", "diffHunk": "@@ -283,28 +261,37 @@ class PendingTraceTest extends DDSpecification {\n     then:\n     trace.pendingReferenceCount.get() == 2\n     trace.weakSpans.size() == 2\n-    trace.asList() == [child1]\n+    trace.finishedSpans.asList() == [child1]\n     writer == []\n     writer.traceCount.get() == 0\n \n     when:\n     child2.finish()\n+    writer.waitForTraces(1)\n \n     then:\n     trace.pendingReferenceCount.get() == 1\n     trace.weakSpans.size() == 1\n-    trace.asList() == []\n+    trace.finishedSpans.isEmpty()\n     writer == [[child2, child1]]\n     writer.traceCount.get() == 1\n \n     when:\n     rootSpan.finish()\n+    writer.waitForTraces(2)\n \n     then:\n     trace.pendingReferenceCount.get() == 0\n     trace.weakSpans.size() == 0\n-    trace.asList() == [rootSpan]\n+    trace.finishedSpans.isEmpty()\n     writer == [[child2, child1], [rootSpan]]\n     writer.traceCount.get() == 2\n   }\n+\n+  boolean cleaningScheduled(PendingTrace trace) {\n+    // This might be racy if the task is in progress and not rescheduled.\n+    return AgentTaskScheduler.INSTANCE.workQueue.any { task ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI4MzMxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyMzoyNlrOHcopVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowODo0N1rOHcqH1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODExOQ==", "bodyText": "I'm assuming this change is just clean-up.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499788119", "createdAt": "2020-10-05T18:23:26Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "diffHunk": "@@ -27,7 +31,7 @@ class TraceInterceptorTest extends DDSpecification {\n     tracer.interceptors.add(new TraceInterceptor() {\n       @Override\n       Collection<? extends MutableSpan> onTraceComplete(Collection<? extends MutableSpan> trace) {\n-        return null\n+        return []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMjMxMA==", "bodyText": "The code that calls onTraceComplete expects a non-null response.  I was getting an NPE at one point when I ran the tests, so I changed all of them to be safe.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499812310", "createdAt": "2020-10-05T19:08:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "diffHunk": "@@ -27,7 +31,7 @@ class TraceInterceptorTest extends DDSpecification {\n     tracer.interceptors.add(new TraceInterceptor() {\n       @Override\n       Collection<? extends MutableSpan> onTraceComplete(Collection<? extends MutableSpan> trace) {\n-        return null\n+        return []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODExOQ=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI4NjEzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNDoyNFrOHcorQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNDoyNFrOHcorQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODYwOA==", "bodyText": "This code isn't immediately obvious.  I think some comments would help.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499788608", "createdAt": "2020-10-05T18:24:24Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/TraceInterceptorTest.groovy", "diffHunk": "@@ -70,20 +74,27 @@ class TraceInterceptorTest extends DDSpecification {\n   def \"interceptor can discard a trace (p=#score)\"() {\n     setup:\n     def called = new AtomicBoolean(false)\n+    def latch = new CountDownLatch(1)\n     def priority = score\n     tracer.interceptors.add(new TraceInterceptor() {\n       @Override\n       Collection<? extends MutableSpan> onTraceComplete(Collection<? extends MutableSpan> trace) {\n         called.set(true)\n-        return Collections.emptyList()\n+        latch.countDown()\n+        return []\n       }\n \n       @Override\n       int priority() {\n         return priority\n       }\n     })\n-    tracer.buildSpan(\"test\").start().finish()\n+    tracer.buildSpan(\"test \" + score).start().finish()\n+    if (score == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI5MDIxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/taginterceptor/TagInterceptorTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyNTo0MlrOHcot-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToxMDowOVrOHcqKoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4OTMwNQ==", "bodyText": "These are cumulative?  That seems bad from composability perspective, but again, test clean-up can come later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499789305", "createdAt": "2020-10-05T18:25:42Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/taginterceptor/TagInterceptorTest.groovy", "diffHunk": "@@ -370,13 +380,15 @@ class TagInterceptorTest extends DDSpecification {\n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(\"error\", \"true\").start()\n     span.finish()\n+    writer.waitForTraces(2)\n \n     then:\n     span.error\n \n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(Tags.DB_STATEMENT, \"some-statement\").start()\n     span.finish()\n+    writer.waitForTraces(3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMzAyNQ==", "bodyText": "It's cumulative until the writer is cleared.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499813025", "createdAt": "2020-10-05T19:10:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/taginterceptor/TagInterceptorTest.groovy", "diffHunk": "@@ -370,13 +380,15 @@ class TagInterceptorTest extends DDSpecification {\n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(\"error\", \"true\").start()\n     span.finish()\n+    writer.waitForTraces(2)\n \n     then:\n     span.error\n \n     when:\n     span = tracer.buildSpan(\"decorator.test\").withTag(Tags.DB_STATEMENT, \"some-statement\").start()\n     span.finish()\n+    writer.waitForTraces(3)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4OTMwNQ=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTI5ODQ2OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/ot31CompatabilityTest/groovy/OT31ApiTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxODoyODoxM1rOHcozIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToxMToyMlrOHcqNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MDYyNg==", "bodyText": "Non-functional?", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499790626", "createdAt": "2020-10-05T18:28:13Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/ot31CompatabilityTest/groovy/OT31ApiTest.groovy", "diffHunk": "@@ -13,10 +13,10 @@ import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n \n // This test focuses on things that are different between OpenTracing API 0.31.0 and 0.32.0\n class OT31ApiTest extends DDSpecification {\n-  static final WRITER = new ListWriter()\n+  def writer = new ListWriter()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMzY4MQ==", "bodyText": "this is a functional change.  previously the writer was shared across all test executions, so late arriving spans could impact other tests.  With this change, the writer is recreated for each test so that is not a problem.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499813681", "createdAt": "2020-10-05T19:11:22Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/ot31CompatabilityTest/groovy/OT31ApiTest.groovy", "diffHunk": "@@ -13,10 +13,10 @@ import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n \n // This test focuses on things that are different between OpenTracing API 0.31.0 and 0.32.0\n class OT31ApiTest extends DDSpecification {\n-  static final WRITER = new ListWriter()\n+  def writer = new ListWriter()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MDYyNg=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTQwNjA3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTowMDo0OFrOHcp3Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMDozNzoyMFrOHcs5rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwODA2Nw==", "bodyText": "I think this probably needs some elaboration -- not necessarily as header doc, but I'm expect more documentation inside PendingTrace & PendingTraceBuffer.  I'd like a better high-level view of the overall flow that someone can read without reading over all the code to understand what's happening.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499808067", "createdAt": "2020-10-05T19:00:48Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -23,6 +23,24 @@\n import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * This class implements the following data flow rules when a Span is finished:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NzgzNg==", "bodyText": "That's what I tried to do with this comment.  Provide enough context at the conditions to understand what is going on.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r499857836", "createdAt": "2020-10-05T20:37:20Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -23,6 +23,24 @@\n import java.util.concurrent.atomic.AtomicReference;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * This class implements the following data flow rules when a Span is finished:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwODA2Nw=="}, "originalCommit": {"oid": "7678312cfab45090d2fbd460c30c803ef87a57c2"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDg2NjExOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoyODoyNVrOHc3mJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMToxMjozNFrOHdBUeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMzA2Mw==", "bodyText": "I know I'm late to the game, but I noticed this while rebasing my branch on top of latest master, and you can most definitely have a continuation on a root span, so this is not correct. The effect is that a number of tests run noticeably slower (as in I can see it on the test counter incrementing slowly), and the new tests that didn't wait now needs to wait for the tracer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r500033063", "createdAt": "2020-10-06T06:28:25Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -203,45 +269,34 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n     synchronized (continuation) {\n       if (continuation.isRegistered()) {\n         continuation.cancel(weakContinuations);\n-        expireReference();\n+        expireReference(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MjM3Ng==", "bodyText": "Opened a PR #1955", "url": "https://github.com/DataDog/dd-trace-java/pull/1916#discussion_r500192376", "createdAt": "2020-10-06T11:12:34Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -203,45 +269,34 @@ public void cancelContinuation(final AgentScope.Continuation continuation) {\n     synchronized (continuation) {\n       if (continuation.isRegistered()) {\n         continuation.cancel(weakContinuations);\n-        expireReference();\n+        expireReference(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAzMzA2Mw=="}, "originalCommit": {"oid": "4fd9d71140df330d2dc1018a5b35e1c341829fd1"}, "originalPosition": 239}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4854, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}