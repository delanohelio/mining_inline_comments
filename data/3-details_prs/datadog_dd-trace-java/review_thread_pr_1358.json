{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNTUzMjY2", "number": 1358, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Mzo0N1rODwgMKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjoxNzozNlrODy9odw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg1NjQxOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Mzo0N1rOGDi4_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1MTo0MVrOGDjLJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDU1Ng==", "bodyText": "nit this should either be before end, or startCpuTime should be before begin", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r406370556", "createdAt": "2020-04-09T17:43:47Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -46,12 +53,16 @@\n   public void start() {\n     if (isEnabled()) {\n       begin();\n+      startCpuTime = ThreadCpuTime.get();\n     }\n   }\n \n   @Override\n   public void finish() {\n     end();\n+    if (startCpuTime > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d0d36e29ebd063b6938b8ae41b025f7a82f9da8"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTIwNA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r406375204", "createdAt": "2020-04-09T17:51:41Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -46,12 +53,16 @@\n   public void start() {\n     if (isEnabled()) {\n       begin();\n+      startCpuTime = ThreadCpuTime.get();\n     }\n   }\n \n   @Override\n   public void finish() {\n     end();\n+    if (startCpuTime > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDU1Ng=="}, "originalCommit": {"oid": "4d0d36e29ebd063b6938b8ae41b025f7a82f9da8"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTc4MjY4OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOToyNjozMVrOGGIVqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwODowMToxM1rOGGZQCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MTI1Ng==", "bodyText": "My impression is that scopes are locked to given thread - is there any point in this being volatile?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409081256", "createdAt": "2020-04-15T19:26:31Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -38,13 +39,18 @@\n   @Label(\"Operation Name\")\n   private String operationName;\n \n+  @Label(\"Thread CPU Time\")\n+  @Timespan\n+  private volatile long cpuTime = 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1ODM0NQ==", "bodyText": "If it is guaranteed that the event is created and committed from the same thread then this does not need to be volatile. I just wasn't sure there was such a guarantee.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409358345", "createdAt": "2020-04-16T08:01:13Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -38,13 +39,18 @@\n   @Label(\"Operation Name\")\n   private String operationName;\n \n+  @Label(\"Thread CPU Time\")\n+  @Timespan\n+  private volatile long cpuTime = 0L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MTI1Ng=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTc5NTcwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozMDoyNVrOGGId_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjowMTozNlrOGGsY6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzM4OA==", "bodyText": "Please move this code into separate package/class like we have for jmx, profiling and the agent - or maybe reuse something existing.\nIn fact maybe this whole thing can go into initialize method.\nThis class is already way overloaded and no need for odd jmx interactions here", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409083388", "createdAt": "2020-04-15T19:30:25Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM5MDg0Mw==", "bodyText": "We (me and you) were discussing the class resolution rules in JVM and came to the conclusion that JLS does not forbid eagerly resolving all classes from the runtime constant pool - which would include JMX classes in ThreadCpuTime in this case - although it is quite improbable and none of the widely used JVM implementations are doing that.\nAnd since such resolution might cause JMX initialization at a wrong moment I came up with all this 'trampoline-like' stuff to be able to inject JMX code only when we are sure it is safe to do so. So, in short, this code can not go to ThreadCpuTime.initialize()\nNot sure what would be gained by putting this into a different package/class. The reflection code would be as complex as it is now - we would only add one level of indirection there.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409390843", "createdAt": "2020-04-16T08:52:47Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzM4OA=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3MTkxNQ==", "bodyText": "This is now solved slightly differently. It is ok for ThreadCpuTime to stay in Java 7 source set.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409671915", "createdAt": "2020-04-16T16:01:36Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzM4OA=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTc5OTAwOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozMToyOVrOGGIgJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjowMDo1OVrOGGsXVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4Mzk0MA==", "bodyText": "Please add tests for this, especially considering that we already have ScopeEventTest", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409083940", "createdAt": "2020-04-15T19:31:29Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -53,6 +59,9 @@ public void start() {\n   public void finish() {\n     end();\n     if (shouldCommit()) {\n+      if (cpuTime > 0) {\n+        cpuTime = ThreadCpuTime.get() - cpuTime;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3MTUwOQ==", "bodyText": "Added", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409671509", "createdAt": "2020-04-16T16:00:59Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -53,6 +59,9 @@ public void start() {\n   public void finish() {\n     end();\n     if (shouldCommit()) {\n+      if (cpuTime > 0) {\n+        cpuTime = ThreadCpuTime.get() - cpuTime;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4Mzk0MA=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTgwMDMxOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozMTo1MlrOGGIg-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjowMDo1MVrOGGsW-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDE1Mw==", "bodyText": "This class should be unit-tested", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409084153", "createdAt": "2020-04-15T19:31:52Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =\n+      new Callable<Long>() {\n+        @Override\n+        public Long call() throws Exception {\n+          return Long.MIN_VALUE;\n+        }\n+      };\n+\n+  // must use Callable here since initialization is invoked from Agent which needs to be Java 7\n+  // compatible\n+  static void initialize(Callable<Long> provider) {\n+    CPU_TIME_PROVIDER = provider;\n+  }\n+\n+  static long get() {\n+    try {\n+      return CPU_TIME_PROVIDER.call();\n+    } catch (Exception ignored) {\n+    }\n+    return Long.MIN_VALUE;\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3MTQxNw==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409671417", "createdAt": "2020-04-16T16:00:51Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =\n+      new Callable<Long>() {\n+        @Override\n+        public Long call() throws Exception {\n+          return Long.MIN_VALUE;\n+        }\n+      };\n+\n+  // must use Callable here since initialization is invoked from Agent which needs to be Java 7\n+  // compatible\n+  static void initialize(Callable<Long> provider) {\n+    CPU_TIME_PROVIDER = provider;\n+  }\n+\n+  static long get() {\n+    try {\n+      return CPU_TIME_PROVIDER.call();\n+    } catch (Exception ignored) {\n+    }\n+    return Long.MIN_VALUE;\n+  }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDE1Mw=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTgxMDA3OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozNDo1MlrOGGInUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwODowNDo1NVrOGGZYZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NTc3Ng==", "bodyText": "nit: I think convention is to use ALL_CAPS only for constants.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409085776", "createdAt": "2020-04-15T19:34:52Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM2MDQ4Nw==", "bodyText": "\ud83d\udc46", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409360487", "createdAt": "2020-04-16T08:04:55Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NTc3Ng=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTgzOTgzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTo0Mzo1MVrOGGI6DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNjowMjowMVrOGGsaJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU3Mw==", "bodyText": "The whole datadog.trace.agent.ot.jfr.openjdk is compiled for java8 - so this will throw some form of ClassFormatError on java7 - please consider catching it separately like we do for profiling startup to provide more specific error message.\nAlternatively you could move whole datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime into java7 compatible module since it in of itself doesn't need java8.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409090573", "createdAt": "2020-04-15T19:43:51Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });\n+      log.debug(\"Thread CPU time provider enabled\");\n+    } catch (final Throwable ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1OTY1Mg==", "bodyText": "Let me think about the best place to put this. I was trying to find a good place without introducing new dependencies (which usually result in more transitive dependencies being pulled in and end up with something breaking compatibility ...).", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409359652", "createdAt": "2020-04-16T08:03:34Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });\n+      log.debug(\"Thread CPU time provider enabled\");\n+    } catch (final Throwable ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU3Mw=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3MjIyOA==", "bodyText": "I think I found the place. This is already outdated.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409672228", "createdAt": "2020-04-16T16:02:01Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +265,36 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void initializeScopeThreadCpuTime() {\n+    if (AGENT_CLASSLOADER == null) {\n+      throw new IllegalStateException(\"Datadog agent should have been started already\");\n+    }\n+    try {\n+      final Class<?> threadCpuTimeClass =\n+          AGENT_CLASSLOADER.loadClass(\"datadog.trace.agent.ot.jfr.openjdk.ThreadCpuTime\");\n+      final Method initializeMethod =\n+          threadCpuTimeClass.getDeclaredMethod(\"initialize\", Callable.class);\n+      final ThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n+      initializeMethod.setAccessible(true);\n+      initializeMethod.invoke(\n+          null,\n+          new Callable<Long>() {\n+            @Override\n+            public Long call() throws Exception {\n+              return mxBean.getCurrentThreadCpuTime();\n+            }\n+          });\n+      log.debug(\"Thread CPU time provider enabled\");\n+    } catch (final Throwable ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDU3Mw=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MjQ2OTE4OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMTo1OTozMFrOGGh2wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTo1ODoxNVrOGGsP0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5OTMzMA==", "bodyText": "If we are not expecting something happening here all the time maybe we should consider logging it on debug level?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409499330", "createdAt": "2020-04-16T11:59:30Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =\n+      new Callable<Long>() {\n+        @Override\n+        public Long call() throws Exception {\n+          return Long.MIN_VALUE;\n+        }\n+      };\n+\n+  // must use Callable here since initialization is invoked from Agent which needs to be Java 7\n+  // compatible\n+  static void initialize(Callable<Long> provider) {\n+    CPU_TIME_PROVIDER = provider;\n+  }\n+\n+  static long get() {\n+    try {\n+      return CPU_TIME_PROVIDER.call();\n+    } catch (Exception ignored) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2OTU4NA==", "bodyText": "This is gone now ...", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409669584", "createdAt": "2020-04-16T15:58:15Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ThreadCpuTime.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package datadog.opentracing.jfr.openjdk;\n+\n+import java.util.concurrent.Callable;\n+\n+public class ThreadCpuTime {\n+  private static volatile Callable<Long> CPU_TIME_PROVIDER =\n+      new Callable<Long>() {\n+        @Override\n+        public Long call() throws Exception {\n+          return Long.MIN_VALUE;\n+        }\n+      };\n+\n+  // must use Callable here since initialization is invoked from Agent which needs to be Java 7\n+  // compatible\n+  static void initialize(Callable<Long> provider) {\n+    CPU_TIME_PROVIDER = provider;\n+  }\n+\n+  static long get() {\n+    try {\n+      return CPU_TIME_PROVIDER.call();\n+    } catch (Exception ignored) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ5OTMzMA=="}, "originalCommit": {"oid": "d283b3ed7e748caad9f1346b9426f61c49608d90"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzQ5MDkwOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNTo1MDo0NFrOGGr7Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDoyMDozOVrOGHQAJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA==", "bodyText": "any chance to have something like a sum here and then making sure that it is greater than zero (at least)?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409664294", "createdAt": "2020-04-16T15:50:44Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2Nzk0OA==", "bodyText": "I though about that - but it is not that easy. Long.MIN_VALUE is really low value.\nCould have separate counters for existing and non-existing CPU time and then have an arbitrary threshold for what number of events with CPU time is still ok.\nAlso, this is testing just that the (JMX) thread cpu time support is enabled eventually. I don't think we will be able to do precise assertions to make sure that the measured CPU time corresponds to the real thread cpu time :/", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r409667948", "createdAt": "2020-04-16T15:55:52Z", "author": {"login": "jbachorik"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4NDkyOQ==", "bodyText": "I do not think this test is working: when I replace 100_000_000L with 100_000L in app code it doesn't fail.\nIn fact it will not fail if there are no events without cpu time.\nIt is also somewhat confusing to read - I feel that finding max of all cpuTimes (there is an aggregation API, isn't there?) would make it a bit more readable", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410184929", "createdAt": "2020-04-17T12:19:54Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4NzcyMA==", "bodyText": "I do not think this test is working: when I replace 100_000_000L with 100_000L in app code it doesn't fail.\n\nNm this, wrong number of zeros.\nthe max thing still stands, however.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410187720", "createdAt": "2020-04-17T12:25:42Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4NzkxNg==", "bodyText": "You may also want to consider changing this to 10ms - to get more events.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410187916", "createdAt": "2020-04-17T12:26:08Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5MTc2OA==", "bodyText": "scopeEvents.getAggregate(Aggregators.max(\"datadog.Scope\", Attribute.attr(\"cpuTime\", \"cpuTime\", UnitLookup.TIMESPAN))).longValue() >= 10_000_000L - something like this should work", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410191768", "createdAt": "2020-04-17T12:34:06Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI1NTM5Ng==", "bodyText": "The aggregation looks ok. But I would run also min and filter the event collection first to exclude the events without valid cpu time", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410255396", "createdAt": "2020-04-17T14:20:39Z", "author": {"login": "jbachorik"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,30 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    def hasCpuTime = false\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      hasCpuTime = hasCpuTime || accessor.getMember(scopeEvent).toLong()\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY2NDI5NA=="}, "originalCommit": {"oid": "e43088e5bd10adf737873bd1d64252296a0c6f87"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjY4NjA4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0OToxMVrOGHK3LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo1NDoxOVrOGHK_oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTE4MQ==", "bodyText": "We do not use Config here - and IIRC there are awkward implications for doing that. Could you please move this check into datadog.trace.common.util.ThreadCpuTimeAccess#enableJmx?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410171181", "createdAt": "2020-04-17T11:49:11Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +263,33 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void startJmx(final URL bootstrapURL) {\n+    startJmxFetch(bootstrapURL);\n+    /*\n+     * Initialize the thread cpu time provider only if profiling is enabled.\n+     * ATTENTION! If ever is the thread cpu time provider used outside of profiler this check should be revisited.\n+     */\n+    if (Config.get().isProfilingEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MzM0NQ==", "bodyText": "Well, I thought the idea was to avoid loading that class at all :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410173345", "createdAt": "2020-04-17T11:54:19Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/Agent.java", "diffHunk": "@@ -262,6 +263,33 @@ private static synchronized void installDatadogTracer() {\n     }\n   }\n \n+  private static synchronized void startJmx(final URL bootstrapURL) {\n+    startJmxFetch(bootstrapURL);\n+    /*\n+     * Initialize the thread cpu time provider only if profiling is enabled.\n+     * ATTENTION! If ever is the thread cpu time provider used outside of profiler this check should be revisited.\n+     */\n+    if (Config.get().isProfilingEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTE4MQ=="}, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Njc2NTk0OnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjoxNzozMFrOGHLodg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMzo0OTo0M1rOGHOxhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4Mzc5OA==", "bodyText": "Would def accessor = Attribute.attr(\"cpuTime\", UnitLookup.TIMESPAN).getAccessor(scopeEventIterable.type) work instead of this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410183798", "createdAt": "2020-04-17T12:17:30Z", "author": {"login": "mar-kolya"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,29 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      def cpuTime = accessor.getMember(scopeEvent).toLong()\n+      // cpu time is either not provided or must be >=100ms\n+      cpuTime == Long.MIN_VALUE || cpuTime >= 100_000_000L\n+    }\n+  }\n+\n+  private static Attribute<?> findCpuTimeAttribute(IType<IItem> type) {\n+    def attribute = null\n+    type.accessorKeys.forEach {\n+      k, v ->\n+        if (k.identifier == \"cpuTime\") {\n+          attribute = k\n+        }\n+    }\n+    return attribute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzNTI2OA==", "bodyText": "D'oh ... Yes, it works.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410235268", "createdAt": "2020-04-17T13:49:43Z", "author": {"login": "jbachorik"}, "path": "dd-smoke-tests/profiling-integration-tests/src/test/groovy/datadog/smoketest/ProfilingIntegrationContinuousProfilesTest.groovy", "diffHunk": "@@ -101,6 +104,29 @@ class ProfilingIntegrationContinuousProfilesTest extends AbstractSmokeTest {\n     IItemCollection scopeEvents = events.apply(ItemFilters.type(\"datadog.Scope\"))\n \n     scopeEvents.size() > 0\n+    // only one event type in filtered collection - can just grab the first item from iterator\n+    def scopeEventIterable = scopeEvents.iterator().next()\n+    def attribute = findCpuTimeAttribute(scopeEventIterable.type)\n+    attribute != null\n+\n+    def accessor = scopeEventIterable.type.getAccessor(attribute)\n+    scopeEventIterable.every {\n+      scopeEvent ->\n+      def cpuTime = accessor.getMember(scopeEvent).toLong()\n+      // cpu time is either not provided or must be >=100ms\n+      cpuTime == Long.MIN_VALUE || cpuTime >= 100_000_000L\n+    }\n+  }\n+\n+  private static Attribute<?> findCpuTimeAttribute(IType<IItem> type) {\n+    def attribute = null\n+    type.accessorKeys.forEach {\n+      k, v ->\n+        if (k.identifier == \"cpuTime\") {\n+          attribute = k\n+        }\n+    }\n+    return attribute", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE4Mzc5OA=="}, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjgzNjA4OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo0MDoxM1rOGHMT7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDowNDoyN1rOGHPX9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5NDkyNA==", "bodyText": "Nit: you do not really need instance there, instead you can call constructor here", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410194924", "createdAt": "2020-04-17T12:40:13Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.common.util;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Thread CPU time accessor.<br>\n+ * This class abstracts away the actual method used to get the current thread CPU time.\n+ */\n+@Slf4j\n+public final class ThreadCpuTimeAccess {\n+  private static volatile ThreadCpuTimeProvider cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+\n+  /**\n+   * Disable JMX based thread CPU time. Will flip back to the {@linkplain\n+   * ThreadCpuTimeProvider#DEFAULT} implementation.\n+   */\n+  public static void disableJmx() {\n+    log.debug(\"Disabling JMX thread CPU time provider\");\n+    cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+  }\n+\n+  /** Enable JMX based thread CPU time */\n+  public static void enableJmx() {\n+    try {\n+      log.debug(\"Enabling JMX thread CPU time provider\");\n+      /*\n+       * Can not use direct class reference to JmxThreadCpuTimeProvider since on some rare JVM implementations\n+       * using eager class resolution that class could be resolved at the moment when ThreadCpuTime is being loaded,\n+       * potentially triggering j.u.l initialization which is potentially dangerous and can be done only at certain\n+       * point in time.\n+       * Using reflection should alleviate this problem - no class constant to resolve during class load. The JMX\n+       * thread cpu time provider will be loaded at exact moment when the reflection code is executed. Then it is up\n+       * to the caller to ensure that it is safe to use JMX.\n+       */\n+      cpuTimeProvider =\n+          (ThreadCpuTimeProvider)\n+              Class.forName(\"datadog.trace.common.util.JmxThreadCpuTimeProvider\")\n+                  .getField(\"INSTANCE\")\n+                  .get(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIzNTc1NQ==", "bodyText": "I don't want to create multiple instances if enableJmx() is called more times.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410235755", "createdAt": "2020-04-17T13:50:31Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.common.util;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Thread CPU time accessor.<br>\n+ * This class abstracts away the actual method used to get the current thread CPU time.\n+ */\n+@Slf4j\n+public final class ThreadCpuTimeAccess {\n+  private static volatile ThreadCpuTimeProvider cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+\n+  /**\n+   * Disable JMX based thread CPU time. Will flip back to the {@linkplain\n+   * ThreadCpuTimeProvider#DEFAULT} implementation.\n+   */\n+  public static void disableJmx() {\n+    log.debug(\"Disabling JMX thread CPU time provider\");\n+    cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+  }\n+\n+  /** Enable JMX based thread CPU time */\n+  public static void enableJmx() {\n+    try {\n+      log.debug(\"Enabling JMX thread CPU time provider\");\n+      /*\n+       * Can not use direct class reference to JmxThreadCpuTimeProvider since on some rare JVM implementations\n+       * using eager class resolution that class could be resolved at the moment when ThreadCpuTime is being loaded,\n+       * potentially triggering j.u.l initialization which is potentially dangerous and can be done only at certain\n+       * point in time.\n+       * Using reflection should alleviate this problem - no class constant to resolve during class load. The JMX\n+       * thread cpu time provider will be loaded at exact moment when the reflection code is executed. Then it is up\n+       * to the caller to ensure that it is safe to use JMX.\n+       */\n+      cpuTimeProvider =\n+          (ThreadCpuTimeProvider)\n+              Class.forName(\"datadog.trace.common.util.JmxThreadCpuTimeProvider\")\n+                  .getField(\"INSTANCE\")\n+                  .get(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5NDkyNA=="}, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI0NTEwOA==", "bodyText": "\ud83e\udd37", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410245108", "createdAt": "2020-04-17T14:04:27Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.common.util;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Thread CPU time accessor.<br>\n+ * This class abstracts away the actual method used to get the current thread CPU time.\n+ */\n+@Slf4j\n+public final class ThreadCpuTimeAccess {\n+  private static volatile ThreadCpuTimeProvider cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+\n+  /**\n+   * Disable JMX based thread CPU time. Will flip back to the {@linkplain\n+   * ThreadCpuTimeProvider#DEFAULT} implementation.\n+   */\n+  public static void disableJmx() {\n+    log.debug(\"Disabling JMX thread CPU time provider\");\n+    cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+  }\n+\n+  /** Enable JMX based thread CPU time */\n+  public static void enableJmx() {\n+    try {\n+      log.debug(\"Enabling JMX thread CPU time provider\");\n+      /*\n+       * Can not use direct class reference to JmxThreadCpuTimeProvider since on some rare JVM implementations\n+       * using eager class resolution that class could be resolved at the moment when ThreadCpuTime is being loaded,\n+       * potentially triggering j.u.l initialization which is potentially dangerous and can be done only at certain\n+       * point in time.\n+       * Using reflection should alleviate this problem - no class constant to resolve during class load. The JMX\n+       * thread cpu time provider will be loaded at exact moment when the reflection code is executed. Then it is up\n+       * to the caller to ensure that it is safe to use JMX.\n+       */\n+      cpuTimeProvider =\n+          (ThreadCpuTimeProvider)\n+              Class.forName(\"datadog.trace.common.util.JmxThreadCpuTimeProvider\")\n+                  .getField(\"INSTANCE\")\n+                  .get(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5NDkyNA=="}, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Njg0MTAwOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo0MTozOFrOGHMW6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMjo0MTozOFrOGHMW6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE5NTY4OA==", "bodyText": "You are creating instance of an abstract class: I think it is not so abstract then... I think this abstract can be dropped.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410195688", "createdAt": "2020-04-17T12:41:38Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeProvider.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package datadog.trace.common.util;\n+\n+/**\n+ * A pluggable thread CPU time provider used by {@linkplain ThreadCpuTimeAccess}. {@linkplain\n+ * ThreadCpuTimeAccess} may not use JMX classes (even via transitive dependencies) due to potential\n+ * race in j.u.l initialization. Therefore it uses an abstract {@linkplain ThreadCpuTimeProvider}\n+ * type to hold the actual implementation which may be switched between the {@linkplain\n+ * ThreadCpuTimeProvider#DEFAULT} and {@linkplain JmxThreadCpuTimeProvider} on-the-fly once JMX is\n+ * safe to use.\n+ */\n+abstract class ThreadCpuTimeProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a992b167d053c565066d79a13be176b2c2e1795f"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzIzOTQ1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDoyOTowM1rOGHQVbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDoyOTowM1rOGHQVbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2MDg0NA==", "bodyText": "Let's do this on debug level, please - this seems irrelevant for clients that have profiling disabled.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410260844", "createdAt": "2020-04-17T14:29:03Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/util/ThreadCpuTimeAccess.java", "diffHunk": "@@ -8,19 +9,23 @@\n  */\n @Slf4j\n public final class ThreadCpuTimeAccess {\n-  private static volatile ThreadCpuTimeProvider cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+  private static volatile ThreadCpuTimeProvider cpuTimeProvider = ThreadCpuTimeProvider.NONE;\n \n   /**\n    * Disable JMX based thread CPU time. Will flip back to the {@linkplain\n-   * ThreadCpuTimeProvider#DEFAULT} implementation.\n+   * ThreadCpuTimeProvider#NONE} implementation.\n    */\n   public static void disableJmx() {\n     log.debug(\"Disabling JMX thread CPU time provider\");\n-    cpuTimeProvider = ThreadCpuTimeProvider.DEFAULT;\n+    cpuTimeProvider = ThreadCpuTimeProvider.NONE;\n   }\n \n   /** Enable JMX based thread CPU time */\n   public static void enableJmx() {\n+    if (!Config.get().isProfilingEnabled()) {\n+      log.info(\"Will not enable thread CPU time access. Profiling is disabled.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17c01c64b76a644bb9c41fdb6f9b08bacf986362"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzY1MTc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjoxNzozNlrOGHUdwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozMzo0OFrOGHW_Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyODUxNA==", "bodyText": "Any risk of finish() being called more than once?", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410328514", "createdAt": "2020-04-17T16:17:36Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -53,6 +61,9 @@ public void start() {\n   public void finish() {\n     end();\n     if (shouldCommit()) {\n+      if (cpuTime > 0) {\n+        cpuTime = ThreadCpuTimeAccess.getCurrentThreadCpuTime() - cpuTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea821f0e763db75c72907fd00ba3f54e2399cb2d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMzNDQ3NA==", "bodyText": "It is called solely from ContinuableScope.close() so as long as that scope is not closed multiple times we are fine.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410334474", "createdAt": "2020-04-17T16:27:52Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -53,6 +61,9 @@ public void start() {\n   public void finish() {\n     end();\n     if (shouldCommit()) {\n+      if (cpuTime > 0) {\n+        cpuTime = ThreadCpuTimeAccess.getCurrentThreadCpuTime() - cpuTime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyODUxNA=="}, "originalCommit": {"oid": "ea821f0e763db75c72907fd00ba3f54e2399cb2d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTg0Ng==", "bodyText": "I'd say that if this happens things will not blow up but data we produce would be off. But arguably this is the best we can do in this situation anyway.", "url": "https://github.com/DataDog/dd-trace-java/pull/1358#discussion_r410369846", "createdAt": "2020-04-17T17:33:48Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/jfr-openjdk/src/main/java/datadog/opentracing/jfr/openjdk/ScopeEvent.java", "diffHunk": "@@ -53,6 +61,9 @@ public void start() {\n   public void finish() {\n     end();\n     if (shouldCommit()) {\n+      if (cpuTime > 0) {\n+        cpuTime = ThreadCpuTimeAccess.getCurrentThreadCpuTime() - cpuTime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMyODUxNA=="}, "originalCommit": {"oid": "ea821f0e763db75c72907fd00ba3f54e2399cb2d"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 447, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}