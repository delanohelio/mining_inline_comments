{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MTk3Mzgx", "number": 1528, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NToyM1rOECMOOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NToyM1rOECMOOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzMyODU4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/CallDepthThreadLocalMap.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NToyM1rOGefwRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyNzowNlrOGehMqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDcyNA==", "bodyText": "Crazy idea, but instead of removing, should we just reset the depth to 0?", "url": "https://github.com/DataDog/dd-trace-java/pull/1528#discussion_r434630724", "createdAt": "2020-06-03T14:55:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/CallDepthThreadLocalMap.java", "diffHunk": "@@ -1,36 +1,45 @@\n package datadog.trace.bootstrap;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n /**\n  * Utility to track nested instrumentation.\n  *\n  * <p>For example, this can be used to track nested calls to super() in constructors by calling\n  * #incrementCallDepth at the beginning of each constructor.\n  */\n public class CallDepthThreadLocalMap {\n-  private static final ThreadLocal<Map<Object, Integer>> TLS =\n-      new ThreadLocal<Map<Object, Integer>>() {\n+\n+  private static final ClassValue<ThreadLocalDepth> TLS =\n+      new ClassValue<ThreadLocalDepth>() {\n         @Override\n-        public Map<Object, Integer> initialValue() {\n-          return new HashMap<>();\n+        protected ThreadLocalDepth computeValue(Class<?> type) {\n+          return new ThreadLocalDepth();\n         }\n       };\n \n-  public static int incrementCallDepth(final Object k) {\n-    final Map<Object, Integer> map = TLS.get();\n-    Integer depth = map.get(k);\n-    if (depth == null) {\n-      depth = 0;\n-    } else {\n-      depth += 1;\n+  public static int incrementCallDepth(final Class<?> k) {\n+    return TLS.get(k).get().increment();\n+  }\n+\n+  public static void reset(final Class<?> k) {\n+    TLS.get(k).remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f69a124432c26e5a8fc679cba2af0d598a471f5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0ODIxMw==", "bodyText": "@bantonsson what do you think? On the one hand, this is a recipe for a memory leak with non cached threads, on the other it's a parsimonious approach when threads are cached.", "url": "https://github.com/DataDog/dd-trace-java/pull/1528#discussion_r434648213", "createdAt": "2020-06-03T15:18:49Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/CallDepthThreadLocalMap.java", "diffHunk": "@@ -1,36 +1,45 @@\n package datadog.trace.bootstrap;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n /**\n  * Utility to track nested instrumentation.\n  *\n  * <p>For example, this can be used to track nested calls to super() in constructors by calling\n  * #incrementCallDepth at the beginning of each constructor.\n  */\n public class CallDepthThreadLocalMap {\n-  private static final ThreadLocal<Map<Object, Integer>> TLS =\n-      new ThreadLocal<Map<Object, Integer>>() {\n+\n+  private static final ClassValue<ThreadLocalDepth> TLS =\n+      new ClassValue<ThreadLocalDepth>() {\n         @Override\n-        public Map<Object, Integer> initialValue() {\n-          return new HashMap<>();\n+        protected ThreadLocalDepth computeValue(Class<?> type) {\n+          return new ThreadLocalDepth();\n         }\n       };\n \n-  public static int incrementCallDepth(final Object k) {\n-    final Map<Object, Integer> map = TLS.get();\n-    Integer depth = map.get(k);\n-    if (depth == null) {\n-      depth = 0;\n-    } else {\n-      depth += 1;\n+  public static int incrementCallDepth(final Class<?> k) {\n+    return TLS.get(k).get().increment();\n+  }\n+\n+  public static void reset(final Class<?> k) {\n+    TLS.get(k).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDcyNA=="}, "originalCommit": {"oid": "5f69a124432c26e5a8fc679cba2af0d598a471f5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDY0Nw==", "bodyText": "I actually think that it's fine to leave the Depth in there. I mean if people are creating threads and they don't run to completion, they have other issues.", "url": "https://github.com/DataDog/dd-trace-java/pull/1528#discussion_r434650647", "createdAt": "2020-06-03T15:22:11Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/CallDepthThreadLocalMap.java", "diffHunk": "@@ -1,36 +1,45 @@\n package datadog.trace.bootstrap;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n /**\n  * Utility to track nested instrumentation.\n  *\n  * <p>For example, this can be used to track nested calls to super() in constructors by calling\n  * #incrementCallDepth at the beginning of each constructor.\n  */\n public class CallDepthThreadLocalMap {\n-  private static final ThreadLocal<Map<Object, Integer>> TLS =\n-      new ThreadLocal<Map<Object, Integer>>() {\n+\n+  private static final ClassValue<ThreadLocalDepth> TLS =\n+      new ClassValue<ThreadLocalDepth>() {\n         @Override\n-        public Map<Object, Integer> initialValue() {\n-          return new HashMap<>();\n+        protected ThreadLocalDepth computeValue(Class<?> type) {\n+          return new ThreadLocalDepth();\n         }\n       };\n \n-  public static int incrementCallDepth(final Object k) {\n-    final Map<Object, Integer> map = TLS.get();\n-    Integer depth = map.get(k);\n-    if (depth == null) {\n-      depth = 0;\n-    } else {\n-      depth += 1;\n+  public static int incrementCallDepth(final Class<?> k) {\n+    return TLS.get(k).get().increment();\n+  }\n+\n+  public static void reset(final Class<?> k) {\n+    TLS.get(k).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDcyNA=="}, "originalCommit": {"oid": "5f69a124432c26e5a8fc679cba2af0d598a471f5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDM3Nw==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1528#discussion_r434654377", "createdAt": "2020-06-03T15:27:06Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/CallDepthThreadLocalMap.java", "diffHunk": "@@ -1,36 +1,45 @@\n package datadog.trace.bootstrap;\n \n-import java.util.HashMap;\n-import java.util.Map;\n-\n /**\n  * Utility to track nested instrumentation.\n  *\n  * <p>For example, this can be used to track nested calls to super() in constructors by calling\n  * #incrementCallDepth at the beginning of each constructor.\n  */\n public class CallDepthThreadLocalMap {\n-  private static final ThreadLocal<Map<Object, Integer>> TLS =\n-      new ThreadLocal<Map<Object, Integer>>() {\n+\n+  private static final ClassValue<ThreadLocalDepth> TLS =\n+      new ClassValue<ThreadLocalDepth>() {\n         @Override\n-        public Map<Object, Integer> initialValue() {\n-          return new HashMap<>();\n+        protected ThreadLocalDepth computeValue(Class<?> type) {\n+          return new ThreadLocalDepth();\n         }\n       };\n \n-  public static int incrementCallDepth(final Object k) {\n-    final Map<Object, Integer> map = TLS.get();\n-    Integer depth = map.get(k);\n-    if (depth == null) {\n-      depth = 0;\n-    } else {\n-      depth += 1;\n+  public static int incrementCallDepth(final Class<?> k) {\n+    return TLS.get(k).get().increment();\n+  }\n+\n+  public static void reset(final Class<?> k) {\n+    TLS.get(k).remove();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDcyNA=="}, "originalCommit": {"oid": "5f69a124432c26e5a8fc679cba2af0d598a471f5"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 196, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}