{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDgzMzk4", "number": 2215, "title": "Single-interface Field-injection", "bodyText": "Field-injection is a technique used in the Java Tracer to associate trace-related data with objects being traced. The original field-injection design generates a lot of interfaces and helper classes at runtime, taking up metadata space. These types must be injected into the bootstrap classloader using the file-system, slowing down startup.\nThis PR proposes replacing these generated types with a single non-generated interface, plus a few helper classes.\nThe original field-injection approach has been marked as deprecated for removal, but can be re-enabled for now with:\n-Ddd.trace.legacy.context.field.injection=true\n\nor by setting this environment variable:\nDD_TRACE_LEGACY_CONTEXT_FIELD_INJECTION=true\n\nPerformance results\nInitial performance testing was complicated by the fact that even though we tried to avoid dead-code elimination of the benchmark method by using side-effects/blackholes the JIT was still able to do some speculative elimination of the trace advice itself. To avoid this a single JIT command was used to exclude the instrumented method from compilation while still allowing the context store code itself to be JIT'd.\n\n\n\nConfig\nTime per call (ns)\n\n\n\n\nuntraced\n90\n\n\nlegacy field-injection\n425\n\n\nsingle-interface field-injection\n411\n\n\nlegacy weak-map\n449\n\n\nsingle-interface weak-map.\n437\n\n\n\nThis shows a slight improvement in the new approach for both field-injection and weak-map context access. This is a very simple benchmark involving just one instrumented type. The larger advantage comes from not having to generate all the extra classes at runtime, and not having to inject them onto the bootclasspath (which involves use of a temporary jar file on the file-system.)\nWith full compilation there's more variability in results depending how long you run it, and the old approach can be a little bit faster. This suggests that the JIT might find it easier to optimize away the advice and context request when more specific interfaces are involved.\n\n\n\nConfig\nTime per call (ns)\n\n\n\n\nuntraced\n11\n\n\nlegacy field-injection\n12\n\n\nsingle-interface field-injection\n13\n\n\nlegacy weak-map\n42\n\n\nsingle-interface weak-map.\n41\n\n\n\nBenchmark code:\npackage fieldinjection;\n\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.openjdk.jmh.annotations.*;\n\npublic class FieldInjectionBenchmark {\n  static AtomicLong count = new AtomicLong();\n\n  @State(Scope.Benchmark)\n  public static class TestRunnable implements Runnable {\n    @TearDown(Level.Trial)\n    public void doTearDown() {\n      System.out.println(\"Total invocations: \" + count.get());\n    }\n\n    public void run() {\n      count.getAndIncrement();\n    }\n  }\n\n  @Fork(jvmArgsAppend = {\n    // avoid speculative JIT elimination of the Runnable advice\n    \"-XX:CompileCommand=exclude,fieldinjection/FieldInjectionBenchmark$TestRunnable.run\",\n    \"-Ddd.jmxfetch.enabled=false\",\n    \"-Ddd.profiling.enabled=false\"\n  })\n\n  @Benchmark\n  public long testRunnable(TestRunnable runnable) {\n    runnable.run();\n    return count.get();\n  }\n}", "createdAt": "2020-12-16T22:44:46Z", "url": "https://github.com/DataDog/dd-trace-java/pull/2215", "merged": true, "mergeCommit": {"oid": "9d6abde9c281582679d626d35397415dec2dd820"}, "closed": true, "closedAt": "2021-01-20T17:34:35Z", "author": {"login": "mcculls"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdm3EPVAFqTU1NDE1MjA0NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyBFgVABqjQyMjgzMDA4NDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTUyMDQ1", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-554152045", "createdAt": "2020-12-16T22:55:45Z", "commit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1NTo0NVrOIHcz2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1NTo0NVrOIHcz2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ==", "bodyText": "tableswitches are generally not faster than array accesses unless the targets are very predictable.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544682969", "createdAt": "2020-12-16T22:55:45Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTgyODYz", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-554182863", "createdAt": "2020-12-17T00:04:33Z", "commit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNDozM1rOIHekog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNDozM1rOIHekog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMTg0Mg==", "bodyText": "An important improvement here is that the instanceof check will only be done once, because it's here rather than having been generated in the accessors, this also makes implementing new methods such as getAndSet much easier to do.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544711842", "createdAt": "2020-12-17T00:04:33Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStore.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package datadog.trace.bootstrap;\n+\n+/**\n+ * {@link ContextStore} that attempts to store context in its keys by using bytecode-injected\n+ * fields. Delegates to a lazy {@link WeakMap} for keys that don't have a field for this store.\n+ */\n+public final class FieldBackedContextStore implements ContextStore<Object, Object> {\n+  final int storeId;\n+\n+  FieldBackedContextStore(final int storeId) {\n+    this.storeId = storeId;\n+  }\n+\n+  @Override\n+  public Object get(final Object key) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      return ((FieldBackedContextAccessor) key).get$__datadogContext$(storeId);\n+    } else {\n+      return weakStore().get(key);\n+    }\n+  }\n+\n+  @Override\n+  public void put(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      ((FieldBackedContextAccessor) key).put$__datadogContext$(storeId, context);\n+    } else {\n+      weakStore().put(key, context);\n+    }\n+  }\n+\n+  @Override\n+  public Object putIfAbsent(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg4MDYy", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-554188062", "createdAt": "2020-12-17T00:17:41Z", "commit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNzo0MVrOIHe4fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNzo0MVrOIHe4fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA==", "bodyText": "If access to the map is concurrent, the BitSet can't be updated safely, unless processing of each type is guaranteed to be on the same thread. There is no JMM support for updating fields narrower than a byte, and this will lead to word tearing, though it would work with a  wrapper around a boolean[] emulating the relevant parts of BitSet's API (with the right memory barriers in place).", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544716924", "createdAt": "2020-12-17T00:17:41Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -21,6 +28,20 @@\n   private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n       new ConcurrentHashMap<>();\n \n+  private static final Class<?> FIELD_INJECTED_MARKER =\n+      Config.get().isLegacyContextFieldInjection()\n+          ? FieldBackedContextStoreAppliedMarker.class\n+          : FieldBackedContextAccessor.class;\n+\n+  private static final boolean TRACK_EXCLUDED_CONTEXT_STORES =\n+      !Config.get().isLegacyContextFieldInjection();\n+\n+  // this map will contain entries for any root type that we wanted to field-inject\n+  // but were not able to - either because it was explicitly excluded, or because we\n+  // failed to field-inject as the type was already loaded\n+  private static final ConcurrentHashMap<String, BitSet> EXCLUDED_STORE_IDS_BY_TYPE =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTg4NzY5", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-554188769", "createdAt": "2020-12-17T00:19:36Z", "commit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxOTozNlrOIHe7Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxOTozNlrOIHe7Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw==", "bodyText": "This seems to be explicitly catering for concurrency (matchedType was missing, but using putIfAbsent in case another thread added it) but the update to the BitSet isn't safe, and updates from competing threads will overwrite each other. See the comment about word tearing.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544717627", "createdAt": "2020-12-17T00:19:36Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba"}, "originalPosition": 100}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70d4ec89a726b083c75a72a2499ab175ff5754ba", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/70d4ec89a726b083c75a72a2499ab175ff5754ba", "committedDate": "2020-12-16T22:42:37Z", "message": "Add tests for the new field-injection strategy"}, "afterCommit": {"oid": "bbdef9dc683eb545e48f203ce4bb12cc8755de31", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/bbdef9dc683eb545e48f203ce4bb12cc8755de31", "committedDate": "2020-12-18T18:13:08Z", "message": "Add tests for the new field-injection strategy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1cb9296be68e3ca0acbba047c236709c043c8ba", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a1cb9296be68e3ca0acbba047c236709c043c8ba", "committedDate": "2020-12-22T12:32:13Z", "message": "Protect against concurrent updates to bitset\n\nThere's only a small number of excluded types and contention on them is low\nduring matching so the simplest approach is to use a synchronized block."}, "afterCommit": {"oid": "e920b376199f26d3fce93d81823274822bed1181", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e920b376199f26d3fce93d81823274822bed1181", "committedDate": "2020-12-22T12:35:32Z", "message": "Protect against concurrent updates to bitset\n\nThere's only a small number of excluded types and contention on them is low\nduring matching so the simplest approach is to use a synchronized block."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "55654dd3f14d5062b641015879f070aa3bd53b35", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/55654dd3f14d5062b641015879f070aa3bd53b35", "committedDate": "2020-12-22T13:22:21Z", "message": "Tweak field accessor names"}, "afterCommit": {"oid": "fbf0eff3f6750e2d5104713c144e959ccf31cf91", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fbf0eff3f6750e2d5104713c144e959ccf31cf91", "committedDate": "2021-01-06T11:45:26Z", "message": "Tweak field accessor names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fbf0eff3f6750e2d5104713c144e959ccf31cf91", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fbf0eff3f6750e2d5104713c144e959ccf31cf91", "committedDate": "2021-01-06T11:45:26Z", "message": "Tweak field accessor names"}, "afterCommit": {"oid": "fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "committedDate": "2021-01-06T13:33:54Z", "message": "Tweak field accessor names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "committedDate": "2021-01-06T13:33:54Z", "message": "Tweak field accessor names"}, "afterCommit": {"oid": "6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "committedDate": "2021-01-07T16:27:00Z", "message": "Tweak field accessor names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "committedDate": "2021-01-07T16:27:00Z", "message": "Tweak field accessor names"}, "afterCommit": {"oid": "713c4ac599d3c37db63e49658745092577250845", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/713c4ac599d3c37db63e49658745092577250845", "committedDate": "2021-01-07T22:38:10Z", "message": "Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\nThis reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\ninvolving injection of generated helper interfaces cannot happen when using a single common\ninterface for field-injection."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "713c4ac599d3c37db63e49658745092577250845", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/713c4ac599d3c37db63e49658745092577250845", "committedDate": "2021-01-07T22:38:10Z", "message": "Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\nThis reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\ninvolving injection of generated helper interfaces cannot happen when using a single common\ninterface for field-injection."}, "afterCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/16ad8e8e95a56a75d3521771899e38feca51aeaf", "committedDate": "2021-01-11T12:44:51Z", "message": "Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\nThis reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\ninvolving injection of generated helper interfaces cannot happen when using a single common\ninterface for field-injection."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjEyOTgx", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565612981", "createdAt": "2021-01-11T18:08:17Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODowODoxOFrOIRhS9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODowODoxOFrOIRhS9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA==", "bodyText": "I don't think this is thread safe with concurrent updates since extraStores is volatile, and two threads could get inside the block at the same time, and the second one to expand the array can read the updated length, so quadruple the size. The second updater could also overwrite the result of extraStores[arrayIndex] = store; below. It's probably worth making this synchronized on a private lock.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555242230", "createdAt": "2021-01-11T18:08:18Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjE1ODA5", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565615809", "createdAt": "2021-01-11T18:12:06Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxMjowN1rOIRhbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxMjowN1rOIRhbEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDMwNw==", "bodyText": "Since this method is used for looking up the weak stores (is this a correct reading?), I would suggest removing the large switch statement and putting the 32 stores into the extraStores  array  and replace this with an array lookup to reduce the bytecode weight of the method when the fallback is required. It also just simplifies the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555244307", "createdAt": "2021-01-11T18:12:07Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjE4MTI4", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565618128", "createdAt": "2021-01-11T18:15:07Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNTowOFrOIRhh2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNTowOFrOIRhh2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjA0Mg==", "bodyText": "Can you add a comment that making it clear that this class should be instantiated lazily (it is lazily instantiated in FieldBackedContextStore) because it triggers background cleanup work?", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555246042", "createdAt": "2021-01-11T18:15:08Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/WeakMapContextStore.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package datadog.trace.bootstrap;\n+\n+final class WeakMapContextStore implements ContextStore<Object, Object> {\n+  private static final int MAX_SIZE = 50_000;\n+\n+  private final WeakMap<Object, Object> map = WeakMap.Provider.newWeakMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjE5ODI4", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565619828", "createdAt": "2021-01-11T18:17:28Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNzoyOFrOIRhnMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODoxNzoyOFrOIRhnMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NzQwOA==", "bodyText": "I would be tempted to add another test to go a little way beyond 64 since the store ids are stored in a bitset, to make sure more than the first word is used, and run the test concurrently", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555247408", "createdAt": "2021-01-11T18:17:28Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/test/groovy/datadog/trace/bootstrap/FieldBackedContextStoresTest.groovy", "diffHunk": "@@ -0,0 +1,18 @@\n+package datadog.trace.bootstrap\n+\n+import datadog.trace.test.util.DDSpecification\n+\n+class FieldBackedContextStoresTest extends DDSpecification {\n+\n+  def \"test FieldBackedContextStore id allocation (#storeId)\"() {\n+    setup:\n+      int allocatedId = FieldBackedContextStores.getContextStoreId(\"key${storeId}\", \"value${storeId}\")\n+\n+    expect:\n+      storeId == allocatedId\n+      storeId == FieldBackedContextStores.getContextStore(storeId).storeId\n+\n+    where:\n+      storeId << (0..64)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjM1NTgy", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565635582", "createdAt": "2021-01-11T18:39:08Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NjM3ODQ1", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565637845", "createdAt": "2021-01-11T18:42:21Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODo0MjoyMVrOIRidcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODo0MjoyMVrOIRidcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng==", "bodyText": "I'm wary of trusting that equality will have been implemented properly for ElementMatcher", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555261296", "createdAt": "2021-01-11T18:42:21Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.safeHasSuperType;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.unpackContextStore;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.wrapVisitor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.Instrumenter.Default;\n+import datadog.trace.api.Config;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * InstrumentationContextProvider which stores context in a field that is injected into a class and\n+ * falls back to tracking the context association in a global weak-map if the field wasn't injected.\n+ *\n+ * <p>This is accomplished by\n+ *\n+ * <ol>\n+ *   <li>Rewriting calls to {@link InstrumentationContext} to access stores based on numeric ids\n+ *   <li>Injecting fields in the earliest holder class that matches the context key\n+ *   <li>Injecting a getter and setter that retrieves context stored in the injected fields\n+ *   <li>Delegating to the superclass getter and setter if a superclass is also a context holder\n+ *   <li>Delegating to weak-map if neither this class or superclass have a field for the context\n+ * </ol>\n+ */\n+@Slf4j\n+public final class FieldBackedContextProvider implements InstrumentationContextProvider {\n+\n+  /*\n+   * Mapping from the instrumentations contextClassLoaderMatcher to a set of pairs (context holder, context class)\n+   * for which we have matchers installed. We use this to make sure we do not install matchers repeatedly for cases\n+   * when same context class is used by multiple instrumentations.\n+   */\n+  private static final HashMap<ElementMatcher<ClassLoader>, Set<Map.Entry<String, String>>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NTU2NTQx", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-565556541", "createdAt": "2021-01-11T16:59:31Z", "commit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNzowNDoxOFrOIRe0ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMTowMzo0OVrOIRnJOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIwMTYzNw==", "bodyText": "interesting... \ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555201637", "createdAt": "2021-01-11T17:04:18Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "diffHunk": "@@ -72,11 +74,16 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     addByteBuddyRawSetting();\n \n-    FieldBackedProvider.resetContextMatchers();\n+    if (Config.get().isLegacyContextFieldInjection()) {\n+      FieldBackedProvider.resetContextMatchers();\n+    } else {\n+      FieldBackedContextProvider.resetContextMatchers();\n+    }\n \n     AgentBuilder.Ignored ignoredAgentBuilder =\n         new AgentBuilder.Default()\n             .disableClassFormatChanges()\n+            .assureReadEdgeTo(INSTRUMENTATION, FieldBackedContextAccessor.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMjM0Mw==", "bodyText": "Please add a class comment explaining what this does.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555332343", "createdAt": "2021-01-11T20:56:47Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextRequestRewriter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextRequestRewriter implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMzQ5Ng==", "bodyText": "We try to avoid * imports. You should have a config set in your IDE to increase the threshold.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555333496", "createdAt": "2021-01-11T20:58:27Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/testing/src/test/groovy/context/FieldInjectionLegacyForkedTest.groovy", "diffHunk": "@@ -19,20 +18,14 @@ import java.lang.reflect.Method\n import java.lang.reflect.Modifier\n import java.util.concurrent.atomic.AtomicReference\n \n-import static context.ContextTestInstrumentation.DisabledKeyClass\n-import static context.ContextTestInstrumentation.IncorrectCallUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectContextClassUsageKeyClass\n-import static context.ContextTestInstrumentation.IncorrectKeyClassUsageKeyClass\n-import static context.ContextTestInstrumentation.InvalidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.InvalidSerializableKeyClass\n-import static context.ContextTestInstrumentation.KeyClass\n-import static context.ContextTestInstrumentation.UntransformableKeyClass\n-import static context.ContextTestInstrumentation.ValidInheritsSerializableKeyClass\n-import static context.ContextTestInstrumentation.ValidSerializableKeyClass\n-import static datadog.trace.bootstrap.config.provider.SystemPropertiesConfigSource.PREFIX\n+import static context.FieldInjectionTestInstrumentation.*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzODA0Mg==", "bodyText": "Class doc please.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555338042", "createdAt": "2021-01-11T21:03:49Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextInjector.java", "diffHunk": "@@ -0,0 +1,505 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.context.ShouldInjectFieldsMatcher.hasInjectedField;\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.FieldBackedContextAccessor;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.ClassFileVersion;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.FieldVisitor;\n+import net.bytebuddy.jar.asm.Label;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextInjector implements AsmVisitorWrapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNDE2NDgz", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-570416483", "createdAt": "2021-01-18T11:47:30Z", "commit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNDc1Njgy", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-570475682", "createdAt": "2021-01-18T13:10:17Z", "commit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxNTU2MjQ2", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#pullrequestreview-571556246", "createdAt": "2021-01-19T19:00:22Z", "commit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowMDoyMlrOIWc3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxOTowMDoyMlrOIWc3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMjYxNQ==", "bodyText": "An example of code that wouldn't need to exist if we dropped java 7.", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r560412615", "createdAt": "2021-01-19T19:00:22Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** Allocates {@link ContextStore} ids and keeps track of allocated stores. */\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  // these fields will be accessed directly from field-injected instrumentation\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // keep track of all allocated stores so far\n+  private static volatile FieldBackedContextStore[] stores = {\n+    contextStore0,\n+    contextStore1,\n+    contextStore2,\n+    contextStore3,\n+    contextStore4,\n+    contextStore5,\n+    contextStore6,\n+    contextStore7,\n+    contextStore8,\n+    contextStore9,\n+    contextStore10,\n+    contextStore11,\n+    contextStore12,\n+    contextStore13,\n+    contextStore14,\n+    contextStore15,\n+    contextStore16,\n+    contextStore17,\n+    contextStore18,\n+    contextStore19,\n+    contextStore20,\n+    contextStore21,\n+    contextStore22,\n+    contextStore23,\n+    contextStore24,\n+    contextStore25,\n+    contextStore26,\n+    contextStore27,\n+    contextStore28,\n+    contextStore29,\n+    contextStore30,\n+    contextStore31\n+  };\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    return stores[storeId]; // createStore ensures array is big enough for allocated storeIds\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf"}, "originalPosition": 106}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9584661c878b9db3fec9341bea97b6e32a1c8ecf", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9584661c878b9db3fec9341bea97b6e32a1c8ecf", "committedDate": "2021-01-18T11:44:35Z", "message": "Commentary"}, "afterCommit": {"oid": "e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "committedDate": "2021-01-19T21:18:27Z", "message": "Copy heap settings to new smoke test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "committedDate": "2021-01-19T21:18:27Z", "message": "Copy heap settings to new smoke test"}, "afterCommit": {"oid": "7d3f65364724b1be37e4964b2782ebd20ba8d88e", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7d3f65364724b1be37e4964b2782ebd20ba8d88e", "committedDate": "2021-01-20T14:41:07Z", "message": "* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26eb63158100a554f3b79172ad5f5d264a4f6084", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/26eb63158100a554f3b79172ad5f5d264a4f6084", "committedDate": "2021-01-20T14:48:49Z", "message": "Use a single-interface for field-injection:\n\n* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d3f65364724b1be37e4964b2782ebd20ba8d88e", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7d3f65364724b1be37e4964b2782ebd20ba8d88e", "committedDate": "2021-01-20T14:41:07Z", "message": "* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily"}, "afterCommit": {"oid": "26eb63158100a554f3b79172ad5f5d264a4f6084", "author": {"user": {"login": "mcculls", "name": "Stuart McCulloch"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/26eb63158100a554f3b79172ad5f5d264a4f6084", "committedDate": "2021-01-20T14:48:49Z", "message": "Use a single-interface for field-injection:\n\n* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2775, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}