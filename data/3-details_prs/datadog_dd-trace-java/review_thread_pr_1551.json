{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTI1NjMw", "number": 1551, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MDowOVrOEDAS8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDo0OTo1N1rOEDZIHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTg2MDMyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MDowOVrOGfznWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MDowOVrOGfznWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNDY5OA==", "bodyText": "Please add a comment describing this class.  It seems rather complex.", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436004698", "createdAt": "2020-06-05T15:40:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -21,79 +25,143 @@\n   @Override\n   public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n+    if (context.isResourceNameSet()) {\n+      return;\n+    }\n     final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || span.getTag(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(span.getTag(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(span.getTag(Tags.HTTP_METHOD), normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) {\n+            resourceName.append('/');\n+          } else { // need to scrub out sensitive info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to scrub out sensitive looking info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean first = true;\n+    boolean last = false;\n+    int end = 0;\n+    for (int i = start; i < url.length() && !last; i = end) {\n+      if (url.charAt(i) == '/') {\n+        resourceName.append('/');\n+        ++i;\n+        first = false;\n+      }\n+      end = url.indexOf('/', i);\n+      if (end == -1) {\n+        if (first) {\n+          resourceName.append('/');\n+        }\n+        end = url.indexOf('?', i);\n+        if (end == -1) {\n+          end = url.indexOf('#', i);\n+          if (end == -1) {\n+            end = url.length();\n+          }\n+        }\n+        last = true;\n+      }\n+      if (i < end) {\n+        char c = url.charAt(i);\n+        boolean isVersion = !last & (c == 'v' | c == 'V') & (end - i) <= 3;\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        for (int j = i + 1; j < end && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+        }\n+\n+        if (containsNumerics && !isVersion) {\n+          resourceName.append('?');\n+        } else if (!isBlank) {\n+          resourceName.append(url, i, end);\n+        }\n+        first = false;\n+      }\n     }\n+  }\n \n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n-    }\n+  private static class BitSlicedBYG {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTg2NjQwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MTo0N1rOGfzrRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MTo0N1rOGfzrRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNTcwMg==", "bodyText": "Perhaps rename to StatusUrlResourceNameRule since now it's renaming off of both of those?", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436005702", "createdAt": "2020-06-05T15:41:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -5,13 +5,17 @@\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n \n-import java.util.regex.Pattern;\n-\n public class URLAsResourceNameRule implements TraceProcessor.Rule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjA4NjUzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0OTowM1rOGf143A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0OTowM1rOGf143A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MTk0OA==", "bodyText": "A method comment here describing the algorithm would be helpful.", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436041948", "createdAt": "2020-06-05T16:49:03Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,164 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBYG PROTOCOL_SEARCH = new BitSlicedBYG(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n     return new String[] {\"URLAsResourceName\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) {\n+            resourceName.append('/');\n+          } else { // need to scrub out sensitive info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to scrub out sensitive looking info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxOTkyODYxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDo0OTo1N1rOGgYjCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMjowODowNlrOGgatmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwOTgwMg==", "bodyText": "Shouldn't we break out of the loop here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436609802", "createdAt": "2020-06-08T10:49:57Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,204 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBitapSearch PROTOCOL_SEARCH = new BitSlicedBitapSearch(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n-    return new String[] {\"URLAsResourceName\"};\n+    return new String[] {\"URLAsResourceName\", \"Status404Rule\", \"Status404Decorator\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) { // then this is just a hostname\n+            resourceName.append('/');\n+          } else { // ignore the hostname and remove any high cardinality info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to remove any high cardinality info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n-    }\n-\n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean lastSegment = false;\n+    int segmentEnd;\n+    for (int i = start; i < url.length() && !lastSegment; i = segmentEnd) {\n+      if (url.charAt(i) == '/') { // always keep forward slashes\n+        resourceName.append('/');\n+        ++i;\n+      }\n+      // find the end of the current section as quickly as possible,\n+      // meaning we process each character at most twice. Even if\n+      // we do, each segment is expected to be short, say, at most\n+      // 50 characters\n+      segmentEnd = url.indexOf('/', i);\n+      if (segmentEnd == -1) {\n+        // according to https://tools.ietf.org/html/rfc3986#section-3\n+        // fragments come after query parts, so ? should be closer than #\n+        segmentEnd = url.indexOf('?', i);\n+        if (segmentEnd == -1) {\n+          segmentEnd = url.indexOf('#', i);\n+          if (segmentEnd == -1) {\n+            segmentEnd = url.length();\n+          }\n+        }\n+        lastSegment = true;\n+      }\n+      if (i < segmentEnd) {\n+        // now check if what's in the current section should be scrubbed or\n+        // appended to the output\n+        int snapshot = resourceName.length();\n+        char c = url.charAt(i);\n+        resourceName.append(c);\n+        // versions can start with v, V, up to 2 numbers, and can't be the last segment\n+        // in the URL\n+        boolean isVersion = !lastSegment & (c == 'v' | c == 'V') & (segmentEnd - i) <= 3;\n+        // if we find numeric characters which aren't part of a version, the segment will\n+        // be removed\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        // most of the time, will get out of this loop quickly,\n+        // except when accumulating characters we need to keep\n+        for (int j = i + 1; j < segmentEnd && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+          resourceName.append(c); // append speculatively\n+        }\n+        // check if this section should be ignored\n+        if (containsNumerics && !isVersion) {\n+          resourceName.setLength(snapshot);\n+          resourceName.append('?');\n+        } else if (isBlank) {\n+          resourceName.setLength(snapshot);\n+        }\n+      }\n     }\n-\n-    if (queryLoc < 0) {\n-      return url.substring(pathLoc);\n-    } else {\n-      return url.substring(pathLoc, endLoc);\n+    if (resourceName.length() == 0) {\n+      resourceName.append('/');\n     }\n   }\n \n-  // Method to normalise the url string\n-  private String normalizePath(final String path) {\n-    if (path.isEmpty() || path.equals(\"/\")) {\n-      return \"/\";\n+  /**\n+   * This class does substring search on latin 1 strings of up to 32 characters, and will inspect\n+   * each character at most once in the input.\n+   *\n+   * <p>This class uses the bitap algorithm (https://en.wikipedia.org/wiki/Bitap_algorithm) but\n+   * adapted slightly in bit slicing the masks into high and low nibbles, which reduces spatial\n+   * overhead by a factor of 8.\n+   *\n+   * <p>This is only implemented because it's a compact, efficient, and easy to implement string\n+   * search algorithm, and the JDK's String.indexOf(String) doesn't allow specification of a limit.\n+   * This class allows searching within a range of the string.\n+   */\n+  private static class BitSlicedBitapSearch {\n+    private final int[] high;\n+    private final int[] low;\n+    private final int termination;\n+\n+    BitSlicedBitapSearch(String term) {\n+      if (term.length() > 32) {\n+        throw new IllegalArgumentException(\"term must be shorter than 32 characters\");\n+      }\n+      // these arrays each index the position of the character\n+      // by nibble. So if we have a character 'a' = 0b01100001\n+      // at position 0, we mark the first bit in high[0b0110]\n+      // and the first bit in low[0b1]. During matching, these\n+      // masks are intersected, so if get character 'b' = 0b01100010,\n+      // we match the high mask but not the low and disregard\n+      // the input.\n+      this.high = new int[16];\n+      this.low = new int[16];\n+      int mask = 1;\n+      for (char c : term.toCharArray()) {\n+        if (c >= 256) {\n+          throw new IllegalStateException(\"term must be latin 1\");\n+        }\n+        low[c & 0xF] |= mask;\n+        high[(c >>> 4) & 0xF] |= mask;\n+        mask <<= 1;\n+      }\n+      this.termination = 1 << (term.length() - 1);\n     }\n \n-    return PATH_MIXED_ALPHANUMERICS.matcher(path).replaceAll(\"?\");\n-  }\n-\n-  private String addMethodIfAvailable(final Map<String, Object> meta, String path) {\n-    // if the method (GET, POST ...) is present, add it\n-    final Object method = meta.get(Tags.HTTP_METHOD);\n-    if (method != null) {\n-      final String verb = method.toString().toUpperCase().trim();\n-      if (!verb.isEmpty()) {\n-        path = verb + \" \" + path;\n+    public int indexOf(String text, int from, int to) {\n+      int state = 0;\n+      to = Math.min(to, text.length());\n+      for (int i = from; i < to; ++i) {\n+        char c = text.charAt(i);\n+        if (c >= 256) { // oops, not latin 1 input\n+          state = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYyMTk5MQ==", "bodyText": "no, unless to - i < Integer.numberOfTrailingZeros(termination), there could still be a match after this character, so we just start again and forget any partial matches so far.", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436621991", "createdAt": "2020-06-08T11:16:15Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,204 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBitapSearch PROTOCOL_SEARCH = new BitSlicedBitapSearch(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n-    return new String[] {\"URLAsResourceName\"};\n+    return new String[] {\"URLAsResourceName\", \"Status404Rule\", \"Status404Decorator\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) { // then this is just a hostname\n+            resourceName.append('/');\n+          } else { // ignore the hostname and remove any high cardinality info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to remove any high cardinality info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n-    }\n-\n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean lastSegment = false;\n+    int segmentEnd;\n+    for (int i = start; i < url.length() && !lastSegment; i = segmentEnd) {\n+      if (url.charAt(i) == '/') { // always keep forward slashes\n+        resourceName.append('/');\n+        ++i;\n+      }\n+      // find the end of the current section as quickly as possible,\n+      // meaning we process each character at most twice. Even if\n+      // we do, each segment is expected to be short, say, at most\n+      // 50 characters\n+      segmentEnd = url.indexOf('/', i);\n+      if (segmentEnd == -1) {\n+        // according to https://tools.ietf.org/html/rfc3986#section-3\n+        // fragments come after query parts, so ? should be closer than #\n+        segmentEnd = url.indexOf('?', i);\n+        if (segmentEnd == -1) {\n+          segmentEnd = url.indexOf('#', i);\n+          if (segmentEnd == -1) {\n+            segmentEnd = url.length();\n+          }\n+        }\n+        lastSegment = true;\n+      }\n+      if (i < segmentEnd) {\n+        // now check if what's in the current section should be scrubbed or\n+        // appended to the output\n+        int snapshot = resourceName.length();\n+        char c = url.charAt(i);\n+        resourceName.append(c);\n+        // versions can start with v, V, up to 2 numbers, and can't be the last segment\n+        // in the URL\n+        boolean isVersion = !lastSegment & (c == 'v' | c == 'V') & (segmentEnd - i) <= 3;\n+        // if we find numeric characters which aren't part of a version, the segment will\n+        // be removed\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        // most of the time, will get out of this loop quickly,\n+        // except when accumulating characters we need to keep\n+        for (int j = i + 1; j < segmentEnd && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+          resourceName.append(c); // append speculatively\n+        }\n+        // check if this section should be ignored\n+        if (containsNumerics && !isVersion) {\n+          resourceName.setLength(snapshot);\n+          resourceName.append('?');\n+        } else if (isBlank) {\n+          resourceName.setLength(snapshot);\n+        }\n+      }\n     }\n-\n-    if (queryLoc < 0) {\n-      return url.substring(pathLoc);\n-    } else {\n-      return url.substring(pathLoc, endLoc);\n+    if (resourceName.length() == 0) {\n+      resourceName.append('/');\n     }\n   }\n \n-  // Method to normalise the url string\n-  private String normalizePath(final String path) {\n-    if (path.isEmpty() || path.equals(\"/\")) {\n-      return \"/\";\n+  /**\n+   * This class does substring search on latin 1 strings of up to 32 characters, and will inspect\n+   * each character at most once in the input.\n+   *\n+   * <p>This class uses the bitap algorithm (https://en.wikipedia.org/wiki/Bitap_algorithm) but\n+   * adapted slightly in bit slicing the masks into high and low nibbles, which reduces spatial\n+   * overhead by a factor of 8.\n+   *\n+   * <p>This is only implemented because it's a compact, efficient, and easy to implement string\n+   * search algorithm, and the JDK's String.indexOf(String) doesn't allow specification of a limit.\n+   * This class allows searching within a range of the string.\n+   */\n+  private static class BitSlicedBitapSearch {\n+    private final int[] high;\n+    private final int[] low;\n+    private final int termination;\n+\n+    BitSlicedBitapSearch(String term) {\n+      if (term.length() > 32) {\n+        throw new IllegalArgumentException(\"term must be shorter than 32 characters\");\n+      }\n+      // these arrays each index the position of the character\n+      // by nibble. So if we have a character 'a' = 0b01100001\n+      // at position 0, we mark the first bit in high[0b0110]\n+      // and the first bit in low[0b1]. During matching, these\n+      // masks are intersected, so if get character 'b' = 0b01100010,\n+      // we match the high mask but not the low and disregard\n+      // the input.\n+      this.high = new int[16];\n+      this.low = new int[16];\n+      int mask = 1;\n+      for (char c : term.toCharArray()) {\n+        if (c >= 256) {\n+          throw new IllegalStateException(\"term must be latin 1\");\n+        }\n+        low[c & 0xF] |= mask;\n+        high[(c >>> 4) & 0xF] |= mask;\n+        mask <<= 1;\n+      }\n+      this.termination = 1 << (term.length() - 1);\n     }\n \n-    return PATH_MIXED_ALPHANUMERICS.matcher(path).replaceAll(\"?\");\n-  }\n-\n-  private String addMethodIfAvailable(final Map<String, Object> meta, String path) {\n-    // if the method (GET, POST ...) is present, add it\n-    final Object method = meta.get(Tags.HTTP_METHOD);\n-    if (method != null) {\n-      final String verb = method.toString().toUpperCase().trim();\n-      if (!verb.isEmpty()) {\n-        path = verb + \" \" + path;\n+    public int indexOf(String text, int from, int to) {\n+      int state = 0;\n+      to = Math.min(to, text.length());\n+      for (int i = from; i < to; ++i) {\n+        char c = text.charAt(i);\n+        if (c >= 256) { // oops, not latin 1 input\n+          state = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwOTgwMg=="}, "originalCommit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY0NTI3NQ==", "bodyText": "Doh. I read this completely backwards. Reminder to self. Never review code on an empty stomach \ud83d\ude09", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436645275", "createdAt": "2020-06-08T12:08:06Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,204 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBitapSearch PROTOCOL_SEARCH = new BitSlicedBitapSearch(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n-    return new String[] {\"URLAsResourceName\"};\n+    return new String[] {\"URLAsResourceName\", \"Status404Rule\", \"Status404Decorator\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) { // then this is just a hostname\n+            resourceName.append('/');\n+          } else { // ignore the hostname and remove any high cardinality info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to remove any high cardinality info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n-    }\n-\n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean lastSegment = false;\n+    int segmentEnd;\n+    for (int i = start; i < url.length() && !lastSegment; i = segmentEnd) {\n+      if (url.charAt(i) == '/') { // always keep forward slashes\n+        resourceName.append('/');\n+        ++i;\n+      }\n+      // find the end of the current section as quickly as possible,\n+      // meaning we process each character at most twice. Even if\n+      // we do, each segment is expected to be short, say, at most\n+      // 50 characters\n+      segmentEnd = url.indexOf('/', i);\n+      if (segmentEnd == -1) {\n+        // according to https://tools.ietf.org/html/rfc3986#section-3\n+        // fragments come after query parts, so ? should be closer than #\n+        segmentEnd = url.indexOf('?', i);\n+        if (segmentEnd == -1) {\n+          segmentEnd = url.indexOf('#', i);\n+          if (segmentEnd == -1) {\n+            segmentEnd = url.length();\n+          }\n+        }\n+        lastSegment = true;\n+      }\n+      if (i < segmentEnd) {\n+        // now check if what's in the current section should be scrubbed or\n+        // appended to the output\n+        int snapshot = resourceName.length();\n+        char c = url.charAt(i);\n+        resourceName.append(c);\n+        // versions can start with v, V, up to 2 numbers, and can't be the last segment\n+        // in the URL\n+        boolean isVersion = !lastSegment & (c == 'v' | c == 'V') & (segmentEnd - i) <= 3;\n+        // if we find numeric characters which aren't part of a version, the segment will\n+        // be removed\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        // most of the time, will get out of this loop quickly,\n+        // except when accumulating characters we need to keep\n+        for (int j = i + 1; j < segmentEnd && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+          resourceName.append(c); // append speculatively\n+        }\n+        // check if this section should be ignored\n+        if (containsNumerics && !isVersion) {\n+          resourceName.setLength(snapshot);\n+          resourceName.append('?');\n+        } else if (isBlank) {\n+          resourceName.setLength(snapshot);\n+        }\n+      }\n     }\n-\n-    if (queryLoc < 0) {\n-      return url.substring(pathLoc);\n-    } else {\n-      return url.substring(pathLoc, endLoc);\n+    if (resourceName.length() == 0) {\n+      resourceName.append('/');\n     }\n   }\n \n-  // Method to normalise the url string\n-  private String normalizePath(final String path) {\n-    if (path.isEmpty() || path.equals(\"/\")) {\n-      return \"/\";\n+  /**\n+   * This class does substring search on latin 1 strings of up to 32 characters, and will inspect\n+   * each character at most once in the input.\n+   *\n+   * <p>This class uses the bitap algorithm (https://en.wikipedia.org/wiki/Bitap_algorithm) but\n+   * adapted slightly in bit slicing the masks into high and low nibbles, which reduces spatial\n+   * overhead by a factor of 8.\n+   *\n+   * <p>This is only implemented because it's a compact, efficient, and easy to implement string\n+   * search algorithm, and the JDK's String.indexOf(String) doesn't allow specification of a limit.\n+   * This class allows searching within a range of the string.\n+   */\n+  private static class BitSlicedBitapSearch {\n+    private final int[] high;\n+    private final int[] low;\n+    private final int termination;\n+\n+    BitSlicedBitapSearch(String term) {\n+      if (term.length() > 32) {\n+        throw new IllegalArgumentException(\"term must be shorter than 32 characters\");\n+      }\n+      // these arrays each index the position of the character\n+      // by nibble. So if we have a character 'a' = 0b01100001\n+      // at position 0, we mark the first bit in high[0b0110]\n+      // and the first bit in low[0b1]. During matching, these\n+      // masks are intersected, so if get character 'b' = 0b01100010,\n+      // we match the high mask but not the low and disregard\n+      // the input.\n+      this.high = new int[16];\n+      this.low = new int[16];\n+      int mask = 1;\n+      for (char c : term.toCharArray()) {\n+        if (c >= 256) {\n+          throw new IllegalStateException(\"term must be latin 1\");\n+        }\n+        low[c & 0xF] |= mask;\n+        high[(c >>> 4) & 0xF] |= mask;\n+        mask <<= 1;\n+      }\n+      this.termination = 1 << (term.length() - 1);\n     }\n \n-    return PATH_MIXED_ALPHANUMERICS.matcher(path).replaceAll(\"?\");\n-  }\n-\n-  private String addMethodIfAvailable(final Map<String, Object> meta, String path) {\n-    // if the method (GET, POST ...) is present, add it\n-    final Object method = meta.get(Tags.HTTP_METHOD);\n-    if (method != null) {\n-      final String verb = method.toString().toUpperCase().trim();\n-      if (!verb.isEmpty()) {\n-        path = verb + \" \" + path;\n+    public int indexOf(String text, int from, int to) {\n+      int state = 0;\n+      to = Math.min(to, text.length());\n+      for (int i = from; i < to; ++i) {\n+        char c = text.charAt(i);\n+        if (c >= 256) { // oops, not latin 1 input\n+          state = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwOTgwMg=="}, "originalCommit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267"}, "originalPosition": 247}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 212, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}