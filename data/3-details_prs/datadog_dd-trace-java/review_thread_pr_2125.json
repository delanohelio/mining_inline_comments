{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MjgxMTY5", "number": 2125, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoyMTo0OVrOE9xWtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNzo1MjoxOFrOE95Azg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjA3MjIyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/muzzle/Reference.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoyMTo0OVrOH6oVug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQyMjoyMTo0OVrOH6oVug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI0MDM3OA==", "bodyText": "This merge algorithm is a bit fishy and has quadratic complexity. I haven't fully understood this subsystem - I just wanted to introduce LinkedHashSet and LinkedHashMap for collections we iterate over - but I suspect that this could all be improved by defining comparability and maintaining sorted sets for linear time merges.", "url": "https://github.com/DataDog/dd-trace-java/pull/2125#discussion_r531240378", "createdAt": "2020-11-26T22:21:49Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/muzzle/Reference.java", "diffHunk": "@@ -106,7 +106,7 @@ public Reference merge(final Reference anotherReference) {\n         merged.set(i, merged.get(i).merge(method));\n       }\n     }\n-    return new HashSet<>(merged);\n+    return new LinkedHashSet<>(merged);\n   }\n \n   private static Set<Field> mergeFields(final Set<Field> fields1, final Set<Field> fields2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c2d177a7e3e450ffe1dba69d1c07d06cfea749a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMzMyNjg2OnYy", "diffSide": "LEFT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/muzzle/MuzzleVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNzo1MjoxOFrOH60CGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNzo1MjoxOFrOH60CGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzMTk2MQ==", "bodyText": "\ud83d\udc4d I would like to have a linter rule for this containsKey followed by get pattern.", "url": "https://github.com/DataDog/dd-trace-java/pull/2125#discussion_r531431961", "createdAt": "2020-11-27T07:52:18Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/muzzle/MuzzleVisitor.java", "diffHunk": "@@ -123,25 +123,19 @@ public MethodVisitor visitMethod(\n     public Reference[] generateReferences() {\n       // track sources we've generated references from to avoid recursion\n       final Set<String> referenceSources = new HashSet<>();\n-      final Map<String, Reference> references = new HashMap<>();\n-      final Set<String> adviceClassNames = new HashSet<>();\n+      final Map<String, Reference> references = new LinkedHashMap<>();\n \n-      for (String adviceClassName : instrumenter.transformers().values()) {\n-        adviceClassNames.add(adviceClassName);\n-      }\n-\n-      for (String adviceClass : adviceClassNames) {\n-        if (!referenceSources.contains(adviceClass)) {\n-          referenceSources.add(adviceClass);\n+      for (String adviceClass : instrumenter.transformers().values()) {\n+        if (referenceSources.add(adviceClass)) {\n           for (Map.Entry<String, Reference> entry :\n               ReferenceCreator.createReferencesFrom(\n                       adviceClass, ReferenceMatcher.class.getClassLoader())\n                   .entrySet()) {\n-            if (references.containsKey(entry.getKey())) {\n-              references.put(\n-                  entry.getKey(), references.get(entry.getKey()).merge(entry.getValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1c0dbc1df9d08d3b892e184ebfd6527352abaae"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4629, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}