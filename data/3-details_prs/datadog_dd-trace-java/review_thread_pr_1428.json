{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMDMyOTUy", "number": 1428, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMjowMFrOD5Dh6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTozMjo0MFrOD7m92w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTUzMjU3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMjowMFrOGQHEWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNzo1MjoyNFrOGQ063g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw==", "bodyText": "It is very unclear what is the aim here: is there some sampling going on? If so it is hard to see it in the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419546203", "createdAt": "2020-05-04T16:02:00Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.datadog.profiling.sampler;\n+\n+import com.datadog.profiling.jfr.JfrChunkWriter;\n+import com.datadog.profiling.jfr.JfrWriter;\n+import com.datadog.profiling.jfr.Type;\n+import com.datadog.profiling.jfr.TypedValue;\n+import com.datadog.profiling.jfr.Types;\n+import java.io.IOException;\n+import java.lang.management.ThreadInfo;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SamplerWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3Mjk3OA==", "bodyText": "As another data point, I would expect SampleWriter to write samples, but a SamplingWriter to sample and write, just as I would expect JfrChunkWriter to write JFR chunks, as opposed to applying a chunking operation.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419572978", "createdAt": "2020-05-04T16:42:03Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.datadog.profiling.sampler;\n+\n+import com.datadog.profiling.jfr.JfrChunkWriter;\n+import com.datadog.profiling.jfr.JfrWriter;\n+import com.datadog.profiling.jfr.Type;\n+import com.datadog.profiling.jfr.TypedValue;\n+import com.datadog.profiling.jfr.Types;\n+import java.io.IOException;\n+import java.lang.management.ThreadInfo;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SamplerWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw=="}, "originalCommit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NzQzOA==", "bodyText": "Well, naming is hard \ud83d\ude01\nWhat would be the proper name for something that takes thread info generated by a JMX thread sampler and turns that into JFR events and writes them?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420297438", "createdAt": "2020-05-05T17:52:24Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.datadog.profiling.sampler;\n+\n+import com.datadog.profiling.jfr.JfrChunkWriter;\n+import com.datadog.profiling.jfr.JfrWriter;\n+import com.datadog.profiling.jfr.Type;\n+import com.datadog.profiling.jfr.TypedValue;\n+import com.datadog.profiling.jfr.Types;\n+import java.io.IOException;\n+import java.lang.management.ThreadInfo;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SamplerWriter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw=="}, "originalCommit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTY4NDE5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozNzozNFrOGQIiEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoxMjo1MlrOGQ1rUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA==", "bodyText": "Is it worth using Unsafe.putLong here for efficiency?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419570194", "createdAt": "2020-05-04T16:37:34Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjkyOQ==", "bodyText": "I am a bit afraid of the interplay with various JDK versions :/\nHaving Unsafe in one's codebase is becoming a huge landmine nowadays, unfortunately.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420292929", "createdAt": "2020-05-05T17:45:12Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}, "originalCommit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMzM0Nw==", "bodyText": "Well, if you use ByteBuffer, it will handle this for you without performing this expensive operation.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420303347", "createdAt": "2020-05-05T18:01:56Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}, "originalCommit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTg0Mw==", "bodyText": "Yes, ByteBuffer and/or memory mapped file would be the next step - once we get out of the PoC phase and will decide that we want to really productize this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420309843", "createdAt": "2020-05-05T18:12:52Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}, "originalCommit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDAxNTE2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/BaseJFRType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNzo1NDoyM1rOGQePlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTo1OTozNFrOGUDJ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyNTkxMA==", "bodyText": "why not putting this a static (constant) field?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419925910", "createdAt": "2020-05-05T07:54:23Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/BaseJFRType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/** Common JFR type super-class */\n+abstract class BaseJFRType implements JFRType {\n+  private final long id;\n+  private final String name;\n+  private final String supertype;\n+  private final ConstantPools constantPools;\n+  private final Types types;\n+  private final TypedValue nullValue = TypedValue.of(this, (Object) null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NjQxNA==", "bodyText": "Because it needs a link to the actual type instance. I started with a static field but it didn't work.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423676414", "createdAt": "2020-05-12T11:59:34Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/BaseJFRType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/** Common JFR type super-class */\n+abstract class BaseJFRType implements JFRType {\n+  private final long id;\n+  private final String name;\n+  private final String supertype;\n+  private final ConstantPools constantPools;\n+  private final Types types;\n+  private final TypedValue nullValue = TypedValue.of(this, (Object) null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyNTkxMA=="}, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDEwNzEwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODoyMTo0M1rOGQfH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxODoxNjo1NFrOGQ103A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ==", "bodyText": "Could use -EXT_BIT instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419940345", "createdAt": "2020-05-05T08:21:43Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjU3NQ==", "bodyText": "I think it will get messed up by the Java handling of everything as signed :/\nI even tried the suggested change but the files is not loadable afterwards.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420296575", "createdAt": "2020-05-05T17:50:55Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMjY0Ng==", "bodyText": "You mean\nprivate static final long COMPRESSED_INT_MASK = -EXT_BIT;\ndoesn't work? (in 2's complement they are equivalent expressions)", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420302646", "createdAt": "2020-05-05T18:00:42Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxMjI4NA==", "bodyText": "D'oh ... I left the & 0xff part there ... When I remove it the file is not corrupted.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420312284", "createdAt": "2020-05-05T18:16:54Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzY3NDU3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Chunk.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwODozNToyNlrOGT8Bqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNDoxNlrOGUOztw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1OTU5NA==", "bodyText": "This algorithm is present multiple times, could be factored into a static function", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423559594", "createdAt": "2020-05-12T08:35:26Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Chunk.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package com.datadog.profiling.jfr;\n+\n+/** A representation of JFR chunk - self contained set of JFR data. */\n+public final class Chunk {\n+  private static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+  private static final short MAJOR_VERSION = 2;\n+  private static final short MINOR_VERSION = 0;\n+\n+  private static final long CHUNK_SIZE_OFFSET = 8;\n+  private static final long CONSTANT_OFFSET_OFFSET = 16;\n+  private static final long METADATA_OFFSET_OFFSET = 24;\n+  private static final long DURATION_NANOS_OFFSET = 40;\n+\n+  private final ByteArrayWriter writer = new ByteArrayWriter(65536);\n+  private final ConstantPools constantPools;\n+  private final Metadata metadata;\n+  private final long startTicks;\n+  private final long startNanos;\n+\n+  Chunk(Metadata metadata, ConstantPools constantPools) {\n+    this.metadata = metadata;\n+    this.constantPools = constantPools;\n+    this.startTicks = System.nanoTime();\n+    this.startNanos = System.currentTimeMillis() * 1_000_000L;\n+    writeHeader();\n+  }\n+\n+  /**\n+   * Write a custom event\n+   *\n+   * @param event the event value\n+   * @return {@literal this} for chaining\n+   * @throws IllegalArgumentException if the event type has not got 'jdk.jfr.Event' as its super\n+   *     type\n+   */\n+  public Chunk writeEvent(TypedValue event) {\n+    if (!\"jdk.jfr.Event\".equals(event.getType().getSupertype())) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    ByteArrayWriter eventWriter = new ByteArrayWriter(32767);\n+    eventWriter.writeLong(event.getType().getId());\n+    for (TypedFieldValue fieldValue : event.getFieldValues()) {\n+      writeTypedValue(eventWriter, fieldValue.getValue());\n+    }\n+\n+    int len = eventWriter.length();\n+    int extraLen = 0;\n+    do {\n+      extraLen = ByteArrayWriter.getPackedIntLen(len + extraLen);\n+    } while (ByteArrayWriter.getPackedIntLen(len + extraLen) != extraLen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzMxOQ==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423867319", "createdAt": "2020-05-12T16:24:16Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Chunk.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package com.datadog.profiling.jfr;\n+\n+/** A representation of JFR chunk - self contained set of JFR data. */\n+public final class Chunk {\n+  private static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+  private static final short MAJOR_VERSION = 2;\n+  private static final short MINOR_VERSION = 0;\n+\n+  private static final long CHUNK_SIZE_OFFSET = 8;\n+  private static final long CONSTANT_OFFSET_OFFSET = 16;\n+  private static final long METADATA_OFFSET_OFFSET = 24;\n+  private static final long DURATION_NANOS_OFFSET = 40;\n+\n+  private final ByteArrayWriter writer = new ByteArrayWriter(65536);\n+  private final ConstantPools constantPools;\n+  private final Metadata metadata;\n+  private final long startTicks;\n+  private final long startNanos;\n+\n+  Chunk(Metadata metadata, ConstantPools constantPools) {\n+    this.metadata = metadata;\n+    this.constantPools = constantPools;\n+    this.startTicks = System.nanoTime();\n+    this.startNanos = System.currentTimeMillis() * 1_000_000L;\n+    writeHeader();\n+  }\n+\n+  /**\n+   * Write a custom event\n+   *\n+   * @param event the event value\n+   * @return {@literal this} for chaining\n+   * @throws IllegalArgumentException if the event type has not got 'jdk.jfr.Event' as its super\n+   *     type\n+   */\n+  public Chunk writeEvent(TypedValue event) {\n+    if (!\"jdk.jfr.Event\".equals(event.getType().getSupertype())) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    ByteArrayWriter eventWriter = new ByteArrayWriter(32767);\n+    eventWriter.writeLong(event.getType().getId());\n+    for (TypedFieldValue fieldValue : event.getFieldValues()) {\n+      writeTypedValue(eventWriter, fieldValue.getValue());\n+    }\n+\n+    int len = eventWriter.length();\n+    int extraLen = 0;\n+    do {\n+      extraLen = ByteArrayWriter.getPackedIntLen(len + extraLen);\n+    } while (ByteArrayWriter.getPackedIntLen(len + extraLen) != extraLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1OTU5NA=="}, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzgxMjkyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwOToxMDoxMFrOGT9bZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNToyMVrOGUO2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng==", "bodyText": "Could it be resolve now?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423582566", "createdAt": "2020-05-12T09:10:10Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/** JFR type repository class. */\n+final class Metadata {\n+  private static final String CLASS_KEY = \"class\";\n+  private static final String FIELD_KEY = \"field\";\n+  private static final String NAME_KEY = \"name\";\n+  private static final String ID_KEY = \"id\";\n+  private static final String VALUE_KEY = \"value\";\n+  private static final String SUPER_TYPE_KEY = \"superType\";\n+  private static final String CONSTANT_POOL_KEY = \"constantPool\";\n+  private static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+  private static final String ROOT_KEY = \"root\";\n+  private static final String METADATA_KEY = \"metadata\";\n+  private static final String TRUE_VALUE = \"true\";\n+  private static final String REGION_KEY = \"region\";\n+  private static final String DIMENSION_KEY = \"dimension\";\n+  private static final String ANNOTATION_KEY = \"annotation\";\n+  private static final String VAL_1_VALUE = \"1\";\n+\n+  private final AtomicLong typeCounter = new AtomicLong(1);\n+  private final ConstantPools constantPools;\n+  private final Map<String, Type> metadata = new HashMap<>();\n+  private final Map<String, Integer> stringTable = new HashMap<>();\n+  private final Map<Integer, String> reverseStringTable = new TreeMap<>();\n+  private final Set<ResolvableType> unresolvedTypes = new HashSet<>();\n+\n+  Metadata(ConstantPools constantPools) {\n+    this.constantPools = constantPools;\n+    fillStrings();\n+  }\n+\n+  /** Pre-fill the string constant pool with all used constant strings */\n+  private void fillStrings() {\n+    storeString(VAL_1_VALUE);\n+    storeString(CLASS_KEY);\n+    storeString(FIELD_KEY);\n+    storeString(NAME_KEY);\n+    storeString(ID_KEY);\n+    storeString(VALUE_KEY);\n+    storeString(SUPER_TYPE_KEY);\n+    storeString(CONSTANT_POOL_KEY);\n+    storeString(SIMPLE_TYPE_KEY);\n+    storeString(ROOT_KEY);\n+    storeString(METADATA_KEY);\n+    storeString(TRUE_VALUE);\n+    storeString(REGION_KEY);\n+    storeString(DIMENSION_KEY);\n+    storeString(ANNOTATION_KEY);\n+  }\n+\n+  /**\n+   * Register a built-in type\n+   *\n+   * @param typeDef a {@link com.datadog.profiling.jfr.Types.Builtin built-in} type\n+   */\n+  void registerBuiltin(Types.Builtin typeDef) {\n+    Type type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+    storeTypeStrings(type);\n+  }\n+\n+  /**\n+   * Register a {@linkplain Type} instance\n+   *\n+   * @param typeName the type name\n+   * @param supertype super type; may be {@literal null}\n+   * @param typeStructureProvider type structure provider to be called lazily when a new type is\n+   *     created\n+   * @return registered type - either a new type or or a previously registered with the same name\n+   */\n+  Type registerType(\n+      String typeName, String supertype, Supplier<TypeStructure> typeStructureProvider) {\n+    Type type = metadata.get(typeName);\n+    if (type == null) {\n+      type =\n+          createCustomType(\n+              typeName,\n+              supertype,\n+              typeStructureProvider != null ? typeStructureProvider.get() : TypeStructure.EMPTY);\n+      metadata.put(typeName, type);\n+    }\n+    storeTypeStrings(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Retrieve a type with the given name.\n+   *\n+   * @param name the type name\n+   * @param asResolvable if the type is not found to be registered should a {@link ResolvableType\n+   *     resolvable} wrapper be returned instead?\n+   * @return the type of the given name\n+   */\n+  Type getType(String name, boolean asResolvable) {\n+    Type found = metadata.get(name);\n+    if (found == null) {\n+      if (asResolvable) {\n+        found = new ResolvableType(name, this);\n+      }\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Create a new built-in type of the given name. !Package visibility only because of unit testing!\n+   *\n+   * @param name the type name\n+   * @return new built-in type\n+   * @throws IllegalArgumentException if a the type name is not representing a built-in\n+   */\n+  Type createBuiltinType(String name) {\n+    if (!Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    Types.Builtin type = Types.Builtin.ofName(name);\n+    return new BuiltinType(\n+        typeCounter.getAndIncrement(),\n+        type,\n+        type == Types.Builtin.STRING ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Create a new custom type of the given name and structure. !Package visibility only because of\n+   * unit testing!\n+   *\n+   * @param name the type name\n+   * @param supertype the super type name - may be {@literal null}\n+   * @param structure the type structure - fields, annotations\n+   * @return new custom type\n+   * @throws IllegalArgumentException if the name belongs to one of the built-in types\n+   */\n+  Type createCustomType(String name, String supertype, TypeStructure structure) {\n+    if (Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    return new CompositeType(\n+        typeCounter.getAndIncrement(),\n+        name,\n+        supertype,\n+        structure,\n+        // TODO hack for event types not to go to constant pool\n+        !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Retrieve a type from the metadata storage\n+   *\n+   * @param type the (enumerated) type to retrieve from the metadata storage\n+   * @param asResolvable should a {@linkplain ResolvableType} wrapper be returned if the requested\n+   *     type is not present in the metadata storage yet?\n+   * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+   *     the metadata storage yet and 'asResolvable' was {@literal false}\n+   */\n+  Type getType(NamedType type, boolean asResolvable) {\n+    return getType(type.getTypeName(), asResolvable);\n+  }\n+\n+  /**\n+   * Add a new unresolved {@linkplain ResolvableType} instance.\n+   *\n+   * @param type unresolved type\n+   */\n+  void addUnresolved(ResolvableType type) {\n+    unresolvedTypes.add(type);\n+  }\n+\n+  /**\n+   * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be done\n+   * if some of the type definitions are using forward references to not yet registered types.\n+   */\n+  void resolveTypes() {\n+    unresolvedTypes.removeIf(ResolvableType::resolve);\n+  }\n+\n+  private void storeTypeStrings(Type type) {\n+    storeString(type.getTypeName());\n+    if (type.getSupertype() != null) {\n+      storeString(type.getSupertype());\n+    }\n+    storeString(String.valueOf(type.getId()));\n+    for (TypedField field : type.getFields()) {\n+      storeString(field.getName());\n+      storeAnnotationStrings(field.getAnnotations());\n+    }\n+    storeAnnotationStrings(type.getAnnotations());\n+  }\n+\n+  private void storeAnnotationStrings(List<Annotation> annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.value != null) {\n+        storeString(annotation.value);\n+      }\n+    }\n+  }\n+\n+  private void storeString(String value) {\n+    stringTable.computeIfAbsent(\n+        value,\n+        k -> {\n+          int pointer = stringTable.size();\n+          reverseStringTable.put(pointer, k);\n+          return pointer;\n+        });\n+  }\n+\n+  private int stringIndex(String value) {\n+    // TODO handle NPE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3Njg2MQ==", "bodyText": "Well, may be. I don't think that TODO is even valid any more. Will check.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423676861", "createdAt": "2020-05-12T12:00:23Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/** JFR type repository class. */\n+final class Metadata {\n+  private static final String CLASS_KEY = \"class\";\n+  private static final String FIELD_KEY = \"field\";\n+  private static final String NAME_KEY = \"name\";\n+  private static final String ID_KEY = \"id\";\n+  private static final String VALUE_KEY = \"value\";\n+  private static final String SUPER_TYPE_KEY = \"superType\";\n+  private static final String CONSTANT_POOL_KEY = \"constantPool\";\n+  private static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+  private static final String ROOT_KEY = \"root\";\n+  private static final String METADATA_KEY = \"metadata\";\n+  private static final String TRUE_VALUE = \"true\";\n+  private static final String REGION_KEY = \"region\";\n+  private static final String DIMENSION_KEY = \"dimension\";\n+  private static final String ANNOTATION_KEY = \"annotation\";\n+  private static final String VAL_1_VALUE = \"1\";\n+\n+  private final AtomicLong typeCounter = new AtomicLong(1);\n+  private final ConstantPools constantPools;\n+  private final Map<String, Type> metadata = new HashMap<>();\n+  private final Map<String, Integer> stringTable = new HashMap<>();\n+  private final Map<Integer, String> reverseStringTable = new TreeMap<>();\n+  private final Set<ResolvableType> unresolvedTypes = new HashSet<>();\n+\n+  Metadata(ConstantPools constantPools) {\n+    this.constantPools = constantPools;\n+    fillStrings();\n+  }\n+\n+  /** Pre-fill the string constant pool with all used constant strings */\n+  private void fillStrings() {\n+    storeString(VAL_1_VALUE);\n+    storeString(CLASS_KEY);\n+    storeString(FIELD_KEY);\n+    storeString(NAME_KEY);\n+    storeString(ID_KEY);\n+    storeString(VALUE_KEY);\n+    storeString(SUPER_TYPE_KEY);\n+    storeString(CONSTANT_POOL_KEY);\n+    storeString(SIMPLE_TYPE_KEY);\n+    storeString(ROOT_KEY);\n+    storeString(METADATA_KEY);\n+    storeString(TRUE_VALUE);\n+    storeString(REGION_KEY);\n+    storeString(DIMENSION_KEY);\n+    storeString(ANNOTATION_KEY);\n+  }\n+\n+  /**\n+   * Register a built-in type\n+   *\n+   * @param typeDef a {@link com.datadog.profiling.jfr.Types.Builtin built-in} type\n+   */\n+  void registerBuiltin(Types.Builtin typeDef) {\n+    Type type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+    storeTypeStrings(type);\n+  }\n+\n+  /**\n+   * Register a {@linkplain Type} instance\n+   *\n+   * @param typeName the type name\n+   * @param supertype super type; may be {@literal null}\n+   * @param typeStructureProvider type structure provider to be called lazily when a new type is\n+   *     created\n+   * @return registered type - either a new type or or a previously registered with the same name\n+   */\n+  Type registerType(\n+      String typeName, String supertype, Supplier<TypeStructure> typeStructureProvider) {\n+    Type type = metadata.get(typeName);\n+    if (type == null) {\n+      type =\n+          createCustomType(\n+              typeName,\n+              supertype,\n+              typeStructureProvider != null ? typeStructureProvider.get() : TypeStructure.EMPTY);\n+      metadata.put(typeName, type);\n+    }\n+    storeTypeStrings(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Retrieve a type with the given name.\n+   *\n+   * @param name the type name\n+   * @param asResolvable if the type is not found to be registered should a {@link ResolvableType\n+   *     resolvable} wrapper be returned instead?\n+   * @return the type of the given name\n+   */\n+  Type getType(String name, boolean asResolvable) {\n+    Type found = metadata.get(name);\n+    if (found == null) {\n+      if (asResolvable) {\n+        found = new ResolvableType(name, this);\n+      }\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Create a new built-in type of the given name. !Package visibility only because of unit testing!\n+   *\n+   * @param name the type name\n+   * @return new built-in type\n+   * @throws IllegalArgumentException if a the type name is not representing a built-in\n+   */\n+  Type createBuiltinType(String name) {\n+    if (!Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    Types.Builtin type = Types.Builtin.ofName(name);\n+    return new BuiltinType(\n+        typeCounter.getAndIncrement(),\n+        type,\n+        type == Types.Builtin.STRING ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Create a new custom type of the given name and structure. !Package visibility only because of\n+   * unit testing!\n+   *\n+   * @param name the type name\n+   * @param supertype the super type name - may be {@literal null}\n+   * @param structure the type structure - fields, annotations\n+   * @return new custom type\n+   * @throws IllegalArgumentException if the name belongs to one of the built-in types\n+   */\n+  Type createCustomType(String name, String supertype, TypeStructure structure) {\n+    if (Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    return new CompositeType(\n+        typeCounter.getAndIncrement(),\n+        name,\n+        supertype,\n+        structure,\n+        // TODO hack for event types not to go to constant pool\n+        !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Retrieve a type from the metadata storage\n+   *\n+   * @param type the (enumerated) type to retrieve from the metadata storage\n+   * @param asResolvable should a {@linkplain ResolvableType} wrapper be returned if the requested\n+   *     type is not present in the metadata storage yet?\n+   * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+   *     the metadata storage yet and 'asResolvable' was {@literal false}\n+   */\n+  Type getType(NamedType type, boolean asResolvable) {\n+    return getType(type.getTypeName(), asResolvable);\n+  }\n+\n+  /**\n+   * Add a new unresolved {@linkplain ResolvableType} instance.\n+   *\n+   * @param type unresolved type\n+   */\n+  void addUnresolved(ResolvableType type) {\n+    unresolvedTypes.add(type);\n+  }\n+\n+  /**\n+   * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be done\n+   * if some of the type definitions are using forward references to not yet registered types.\n+   */\n+  void resolveTypes() {\n+    unresolvedTypes.removeIf(ResolvableType::resolve);\n+  }\n+\n+  private void storeTypeStrings(Type type) {\n+    storeString(type.getTypeName());\n+    if (type.getSupertype() != null) {\n+      storeString(type.getSupertype());\n+    }\n+    storeString(String.valueOf(type.getId()));\n+    for (TypedField field : type.getFields()) {\n+      storeString(field.getName());\n+      storeAnnotationStrings(field.getAnnotations());\n+    }\n+    storeAnnotationStrings(type.getAnnotations());\n+  }\n+\n+  private void storeAnnotationStrings(List<Annotation> annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.value != null) {\n+        storeString(annotation.value);\n+      }\n+    }\n+  }\n+\n+  private void storeString(String value) {\n+    stringTable.computeIfAbsent(\n+        value,\n+        k -> {\n+          int pointer = stringTable.size();\n+          reverseStringTable.put(pointer, k);\n+          return pointer;\n+        });\n+  }\n+\n+  private int stringIndex(String value) {\n+    // TODO handle NPE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng=="}, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODA3Ng==", "bodyText": "null argument is an error and should not ever happen.\nAdded @Nonnull annotation and a test to assert that NPE is properly thrown.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423868076", "createdAt": "2020-05-12T16:25:21Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/** JFR type repository class. */\n+final class Metadata {\n+  private static final String CLASS_KEY = \"class\";\n+  private static final String FIELD_KEY = \"field\";\n+  private static final String NAME_KEY = \"name\";\n+  private static final String ID_KEY = \"id\";\n+  private static final String VALUE_KEY = \"value\";\n+  private static final String SUPER_TYPE_KEY = \"superType\";\n+  private static final String CONSTANT_POOL_KEY = \"constantPool\";\n+  private static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+  private static final String ROOT_KEY = \"root\";\n+  private static final String METADATA_KEY = \"metadata\";\n+  private static final String TRUE_VALUE = \"true\";\n+  private static final String REGION_KEY = \"region\";\n+  private static final String DIMENSION_KEY = \"dimension\";\n+  private static final String ANNOTATION_KEY = \"annotation\";\n+  private static final String VAL_1_VALUE = \"1\";\n+\n+  private final AtomicLong typeCounter = new AtomicLong(1);\n+  private final ConstantPools constantPools;\n+  private final Map<String, Type> metadata = new HashMap<>();\n+  private final Map<String, Integer> stringTable = new HashMap<>();\n+  private final Map<Integer, String> reverseStringTable = new TreeMap<>();\n+  private final Set<ResolvableType> unresolvedTypes = new HashSet<>();\n+\n+  Metadata(ConstantPools constantPools) {\n+    this.constantPools = constantPools;\n+    fillStrings();\n+  }\n+\n+  /** Pre-fill the string constant pool with all used constant strings */\n+  private void fillStrings() {\n+    storeString(VAL_1_VALUE);\n+    storeString(CLASS_KEY);\n+    storeString(FIELD_KEY);\n+    storeString(NAME_KEY);\n+    storeString(ID_KEY);\n+    storeString(VALUE_KEY);\n+    storeString(SUPER_TYPE_KEY);\n+    storeString(CONSTANT_POOL_KEY);\n+    storeString(SIMPLE_TYPE_KEY);\n+    storeString(ROOT_KEY);\n+    storeString(METADATA_KEY);\n+    storeString(TRUE_VALUE);\n+    storeString(REGION_KEY);\n+    storeString(DIMENSION_KEY);\n+    storeString(ANNOTATION_KEY);\n+  }\n+\n+  /**\n+   * Register a built-in type\n+   *\n+   * @param typeDef a {@link com.datadog.profiling.jfr.Types.Builtin built-in} type\n+   */\n+  void registerBuiltin(Types.Builtin typeDef) {\n+    Type type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+    storeTypeStrings(type);\n+  }\n+\n+  /**\n+   * Register a {@linkplain Type} instance\n+   *\n+   * @param typeName the type name\n+   * @param supertype super type; may be {@literal null}\n+   * @param typeStructureProvider type structure provider to be called lazily when a new type is\n+   *     created\n+   * @return registered type - either a new type or or a previously registered with the same name\n+   */\n+  Type registerType(\n+      String typeName, String supertype, Supplier<TypeStructure> typeStructureProvider) {\n+    Type type = metadata.get(typeName);\n+    if (type == null) {\n+      type =\n+          createCustomType(\n+              typeName,\n+              supertype,\n+              typeStructureProvider != null ? typeStructureProvider.get() : TypeStructure.EMPTY);\n+      metadata.put(typeName, type);\n+    }\n+    storeTypeStrings(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Retrieve a type with the given name.\n+   *\n+   * @param name the type name\n+   * @param asResolvable if the type is not found to be registered should a {@link ResolvableType\n+   *     resolvable} wrapper be returned instead?\n+   * @return the type of the given name\n+   */\n+  Type getType(String name, boolean asResolvable) {\n+    Type found = metadata.get(name);\n+    if (found == null) {\n+      if (asResolvable) {\n+        found = new ResolvableType(name, this);\n+      }\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Create a new built-in type of the given name. !Package visibility only because of unit testing!\n+   *\n+   * @param name the type name\n+   * @return new built-in type\n+   * @throws IllegalArgumentException if a the type name is not representing a built-in\n+   */\n+  Type createBuiltinType(String name) {\n+    if (!Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    Types.Builtin type = Types.Builtin.ofName(name);\n+    return new BuiltinType(\n+        typeCounter.getAndIncrement(),\n+        type,\n+        type == Types.Builtin.STRING ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Create a new custom type of the given name and structure. !Package visibility only because of\n+   * unit testing!\n+   *\n+   * @param name the type name\n+   * @param supertype the super type name - may be {@literal null}\n+   * @param structure the type structure - fields, annotations\n+   * @return new custom type\n+   * @throws IllegalArgumentException if the name belongs to one of the built-in types\n+   */\n+  Type createCustomType(String name, String supertype, TypeStructure structure) {\n+    if (Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    return new CompositeType(\n+        typeCounter.getAndIncrement(),\n+        name,\n+        supertype,\n+        structure,\n+        // TODO hack for event types not to go to constant pool\n+        !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Retrieve a type from the metadata storage\n+   *\n+   * @param type the (enumerated) type to retrieve from the metadata storage\n+   * @param asResolvable should a {@linkplain ResolvableType} wrapper be returned if the requested\n+   *     type is not present in the metadata storage yet?\n+   * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+   *     the metadata storage yet and 'asResolvable' was {@literal false}\n+   */\n+  Type getType(NamedType type, boolean asResolvable) {\n+    return getType(type.getTypeName(), asResolvable);\n+  }\n+\n+  /**\n+   * Add a new unresolved {@linkplain ResolvableType} instance.\n+   *\n+   * @param type unresolved type\n+   */\n+  void addUnresolved(ResolvableType type) {\n+    unresolvedTypes.add(type);\n+  }\n+\n+  /**\n+   * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be done\n+   * if some of the type definitions are using forward references to not yet registered types.\n+   */\n+  void resolveTypes() {\n+    unresolvedTypes.removeIf(ResolvableType::resolve);\n+  }\n+\n+  private void storeTypeStrings(Type type) {\n+    storeString(type.getTypeName());\n+    if (type.getSupertype() != null) {\n+      storeString(type.getSupertype());\n+    }\n+    storeString(String.valueOf(type.getId()));\n+    for (TypedField field : type.getFields()) {\n+      storeString(field.getName());\n+      storeAnnotationStrings(field.getAnnotations());\n+    }\n+    storeAnnotationStrings(type.getAnnotations());\n+  }\n+\n+  private void storeAnnotationStrings(List<Annotation> annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.value != null) {\n+        storeString(annotation.value);\n+      }\n+    }\n+  }\n+\n+  private void storeString(String value) {\n+    stringTable.computeIfAbsent(\n+        value,\n+        k -> {\n+          int pointer = stringTable.size();\n+          reverseStringTable.put(pointer, k);\n+          return pointer;\n+        });\n+  }\n+\n+  private int stringIndex(String value) {\n+    // TODO handle NPE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng=="}, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODMwODk2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTozMjoyMlrOGUCTMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMjowMTowOVrOGUDNWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjM4Ng==", "bodyText": "should return Collections.emptyList()\nas all other implementation of BaseType expect to return non-null\nsee BuiltinType", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662386", "createdAt": "2020-05-12T11:32:22Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NzI3NA==", "bodyText": "Rather, all the methods should throw an UnsupportedOperationException as this type is only a placeholder and never should escape to be used directly.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423677274", "createdAt": "2020-05-12T12:01:09Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjM4Ng=="}, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzODMxMDAzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTozMjo0MFrOGUCT1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoyNDozMVrOGUO0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjU0OA==", "bodyText": "same as above", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662548", "createdAt": "2020-05-12T11:32:40Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;\n+  }\n+\n+  @Override\n+  public TypedField getField(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<Annotation> getAnnotations() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzQ3OA==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423867478", "createdAt": "2020-05-12T16:24:31Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;\n+  }\n+\n+  @Override\n+  public TypedField getField(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<Annotation> getAnnotations() {\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjU0OA=="}, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 291, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}