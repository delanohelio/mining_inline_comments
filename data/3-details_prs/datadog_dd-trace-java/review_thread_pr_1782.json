{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5Mzg2MDIx", "number": 1782, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjozNjo1NVrOEZdFCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODoxMTo0MVrOEZ3RpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTI2MjgzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/common/writer/SpecifyPrioritization.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjozNjo1NVrOHCRdxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjozNjo1NVrOHCRdxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0NTM0OQ==", "bodyText": "s/sends drops/drops/", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472145349", "createdAt": "2020-08-18T12:36:55Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/common/writer/SpecifyPrioritization.groovy", "diffHunk": "@@ -0,0 +1,66 @@\n+package datadog.trace.common.writer\n+\n+\n+import datadog.trace.common.writer.ddagent.Prioritization\n+import datadog.trace.common.writer.ddagent.PrioritizationStrategy\n+import datadog.trace.util.test.DDSpecification\n+import org.jctools.queues.MessagePassingQueue\n+\n+import static datadog.trace.api.sampling.PrioritySampling.SAMPLER_DROP\n+import static datadog.trace.api.sampling.PrioritySampling.SAMPLER_KEEP\n+import static datadog.trace.api.sampling.PrioritySampling.UNSET\n+import static datadog.trace.api.sampling.PrioritySampling.USER_KEEP\n+\n+class SpecifyPrioritization extends DDSpecification {\n+\n+\n+  def \"fast lane strategy sends kept and unset priority traces to the primary queue, dropped traces to the secondary queue\" () {\n+    setup:\n+    MessagePassingQueue<Object> primary = Mock(MessagePassingQueue)\n+    MessagePassingQueue<Object> secondary = Mock(MessagePassingQueue)\n+    PrioritizationStrategy fastLane =  Prioritization.FAST_LANE.create(primary, secondary)\n+\n+    when:\n+    fastLane.published(priority, trace)\n+\n+    then:\n+    primaryOffers * primary.offer(trace)\n+    secondaryOffers * secondary.offer(trace)\n+\n+    where:\n+    trace    |     priority      |   primaryOffers   | secondaryOffers\n+    []       |     UNSET         |       1           |      0\n+    []       |     SAMPLER_DROP  |       0           |      1\n+    []       |     SAMPLER_KEEP  |       1           |      0\n+    []       |     SAMPLER_DROP  |       0           |      1\n+    []       |     USER_KEEP     |       1           |      0\n+  }\n+\n+\n+  def \"dead letters strategy sends drops unkept traces if the primary queue is full\" () {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ad6a443ec28442ba7aebe96ebc6a7656279441"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTI3MDE1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjozODowN1rOHCRiWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMjo0NDo1OFrOHCR8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0NjUyMA==", "bodyText": "So are we calling yeild 50 times before we poll the second queue?", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472146520", "createdAt": "2020-08-18T12:38:07Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -196,26 +220,62 @@ private boolean shouldFlush() {\n     @Override\n     public void run() {\n       Thread thread = Thread.currentThread();\n-      int retries = 100;\n-      int polls = retries;\n       while (!thread.isInterrupted()) {\n-        Object event = primaryQueue.relaxedPoll();\n+        consumeFromPrimaryQueue();\n+      }\n+      log.info(\"datadog trace processor exited\");\n+    }\n+\n+    private void consumeFromPrimaryQueue() {\n+      int polls = 50;\n+      while (true) {\n+        Object event = primaryQueue.poll();\n         if (null != event) {\n+          // there's a high priority trace, consume it,\n+          // and then drain whatever's in the queue now\n           onEvent(event);\n-          polls = retries;\n+          consumeBatch(primaryQueue);\n         } else {\n-          if (polls > 50) {\n-            onSpinWait();\n-            --polls;\n-          } else if (polls > 0) {\n+          if (polls > 0) {\n+            // this is probably better than spinning when there\n+            // is a low number of CPUs, perhaps should do this instead of spinning above?\n+            // needs measurement in a low core environment\n             Thread.yield();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20ad6a443ec28442ba7aebe96ebc6a7656279441"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0OTI1NA==", "bodyText": "This needs refinement", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472149254", "createdAt": "2020-08-18T12:40:53Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -196,26 +220,62 @@ private boolean shouldFlush() {\n     @Override\n     public void run() {\n       Thread thread = Thread.currentThread();\n-      int retries = 100;\n-      int polls = retries;\n       while (!thread.isInterrupted()) {\n-        Object event = primaryQueue.relaxedPoll();\n+        consumeFromPrimaryQueue();\n+      }\n+      log.info(\"datadog trace processor exited\");\n+    }\n+\n+    private void consumeFromPrimaryQueue() {\n+      int polls = 50;\n+      while (true) {\n+        Object event = primaryQueue.poll();\n         if (null != event) {\n+          // there's a high priority trace, consume it,\n+          // and then drain whatever's in the queue now\n           onEvent(event);\n-          polls = retries;\n+          consumeBatch(primaryQueue);\n         } else {\n-          if (polls > 50) {\n-            onSpinWait();\n-            --polls;\n-          } else if (polls > 0) {\n+          if (polls > 0) {\n+            // this is probably better than spinning when there\n+            // is a low number of CPUs, perhaps should do this instead of spinning above?\n+            // needs measurement in a low core environment\n             Thread.yield();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0NjUyMA=="}, "originalCommit": {"oid": "20ad6a443ec28442ba7aebe96ebc6a7656279441"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE1MzE1OA==", "bodyText": "I've changed it slightly, but it might be worth discussing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472153158", "createdAt": "2020-08-18T12:44:58Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -196,26 +220,62 @@ private boolean shouldFlush() {\n     @Override\n     public void run() {\n       Thread thread = Thread.currentThread();\n-      int retries = 100;\n-      int polls = retries;\n       while (!thread.isInterrupted()) {\n-        Object event = primaryQueue.relaxedPoll();\n+        consumeFromPrimaryQueue();\n+      }\n+      log.info(\"datadog trace processor exited\");\n+    }\n+\n+    private void consumeFromPrimaryQueue() {\n+      int polls = 50;\n+      while (true) {\n+        Object event = primaryQueue.poll();\n         if (null != event) {\n+          // there's a high priority trace, consume it,\n+          // and then drain whatever's in the queue now\n           onEvent(event);\n-          polls = retries;\n+          consumeBatch(primaryQueue);\n         } else {\n-          if (polls > 50) {\n-            onSpinWait();\n-            --polls;\n-          } else if (polls > 0) {\n+          if (polls > 0) {\n+            // this is probably better than spinning when there\n+            // is a low number of CPUs, perhaps should do this instead of spinning above?\n+            // needs measurement in a low core environment\n             Thread.yield();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0NjUyMA=="}, "originalCommit": {"oid": "20ad6a443ec28442ba7aebe96ebc6a7656279441"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjQxMzI4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/Prioritization.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjozNzo0N1rOHCc0zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjozNzo0N1rOHCc0zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzMTQ3MA==", "bodyText": "the countdown latch works nicely here...", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472331470", "createdAt": "2020-08-18T16:37:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/Prioritization.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.common.sampling.PrioritySampling.SAMPLER_DROP;\n+import static datadog.trace.common.sampling.PrioritySampling.USER_DROP;\n+\n+import datadog.trace.core.DDSpan;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import org.jctools.queues.MessagePassingQueue;\n+\n+public enum Prioritization {\n+  FAST_LANE {\n+    @Override\n+    public PrioritizationStrategy create(\n+        MessagePassingQueue<Object> primary, MessagePassingQueue<Object> secondary) {\n+      return new FastLaneStrategy(primary, secondary);\n+    }\n+  },\n+  DEAD_LETTERS {\n+    @Override\n+    public PrioritizationStrategy create(\n+        MessagePassingQueue<Object> primary, MessagePassingQueue<Object> secondary) {\n+      return new DeadLettersStrategy(primary, secondary);\n+    }\n+  };\n+\n+  public abstract PrioritizationStrategy create(\n+      MessagePassingQueue<Object> primary, MessagePassingQueue<Object> secondary);\n+\n+  private static final class FastLaneStrategy implements PrioritizationStrategy {\n+\n+    private final MessagePassingQueue<Object> primary;\n+    private final MessagePassingQueue<Object> secondary;\n+\n+    private FastLaneStrategy(\n+        MessagePassingQueue<Object> primary, MessagePassingQueue<Object> secondary) {\n+      this.primary = primary;\n+      this.secondary = secondary;\n+    }\n+\n+    @Override\n+    public boolean publish(int priority, List<DDSpan> trace) {\n+      switch (priority) {\n+        case SAMPLER_DROP:\n+        case USER_DROP:\n+          return secondary.offer(trace);\n+        default:\n+          return primary.offer(trace);\n+      }\n+    }\n+\n+    @Override\n+    public boolean flush(long timeout, TimeUnit timeUnit) {\n+      // ok not to flush the secondary\n+      CountDownLatch latch = new CountDownLatch(1);\n+      FlushEvent event = new FlushEvent(latch);\n+      offer(primary, event);\n+      try {\n+        return latch.await(timeout, timeUnit);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        return false;\n+      }\n+    }\n+\n+    private void offer(MessagePassingQueue<Object> queue, FlushEvent event) {\n+      boolean offered;\n+      do {\n+        offered = queue.offer(event);\n+      } while (!offered);\n+    }\n+  }\n+\n+  private static final class DeadLettersStrategy implements PrioritizationStrategy {\n+\n+    private final MessagePassingQueue<Object> primary;\n+    private final MessagePassingQueue<Object> secondary;\n+\n+    private DeadLettersStrategy(\n+        MessagePassingQueue<Object> primary, MessagePassingQueue<Object> secondary) {\n+      this.primary = primary;\n+      this.secondary = secondary;\n+    }\n+\n+    @Override\n+    public boolean publish(int priority, List<DDSpan> trace) {\n+      if (!primary.offer(trace)) {\n+        switch (priority) {\n+          case SAMPLER_DROP:\n+          case USER_DROP:\n+            return false;\n+          default:\n+            return secondary.offer(trace);\n+        }\n+      }\n+      return true;\n+    }\n+\n+    @Override\n+    public boolean flush(long timeout, TimeUnit timeUnit) {\n+      // both queues need to be flushed\n+      CountDownLatch latch = new CountDownLatch(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef779b8fb1fdc8bb8f5c943c63dae7da08ff8a0e"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTQ4NTgzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzo1ODozMVrOHC7RBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwNzo1ODozMVrOHC7RBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgzMDIxNQ==", "bodyText": "Maybe just me, but I would love to have some comment that explains the intended flow.\nAFAICS, as long as we can consume from primary or secondary we spin around and continue to consume, but if we fail to consume from both we yield at most 50 times and then we parkNanos a millisecond before we go back to the outer loop, to hopefully let other threads in.", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472830215", "createdAt": "2020-08-19T07:58:31Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -196,26 +218,53 @@ private boolean shouldFlush() {\n     @Override\n     public void run() {\n       Thread thread = Thread.currentThread();\n-      int retries = 100;\n-      int polls = retries;\n       while (!thread.isInterrupted()) {\n-        Object event = primaryQueue.relaxedPoll();\n+        consumeFromPrimaryQueue();\n+      }\n+      log.info(\"datadog trace processor exited\");\n+    }\n+\n+    private void consumeFromPrimaryQueue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef779b8fb1fdc8bb8f5c943c63dae7da08ff8a0e"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTU1NDkzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/FlushEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODoxMTo0MVrOHC7-pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwOTozODoyMlrOHC_dtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0MTg5Mw==", "bodyText": "So there seems to be two FlushEvent classes. This one and one at TraceProcessingWorker.FlushEvent. We never seem to check for this one.", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472841893", "createdAt": "2020-08-19T08:11:41Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/FlushEvent.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+final class FlushEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef779b8fb1fdc8bb8f5c943c63dae7da08ff8a0e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5ODk5OQ==", "bodyText": "There can be only one...", "url": "https://github.com/DataDog/dd-trace-java/pull/1782#discussion_r472898999", "createdAt": "2020-08-19T09:38:22Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/FlushEvent.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+final class FlushEvent {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg0MTg5Mw=="}, "originalCommit": {"oid": "ef779b8fb1fdc8bb8f5c943c63dae7da08ff8a0e"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 37, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}