{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMTkwMTU3", "number": 2204, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo1MDoxNVrOFFjCTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODowMToyOFrOFFusEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzYxMjI4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo1MDoxNVrOIGHCxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo1MDoxNVrOIGHCxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3Nzc2Ng==", "bodyText": "I'm not really sure why this isn't just a final field required for construction. No doubt it's motivated by code reuse.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543277766", "createdAt": "2020-12-15T11:50:15Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -143,8 +140,12 @@ public void registerSpan(final DDSpan span) {\n       return;\n     }\n \n-    if (!rootSpanWritten.get()) {\n-      rootSpan.compareAndSet(null, new WeakReference<>(span));\n+    if (null == rootSpan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "927380c394f6b61177f760e03e3cb592b09c3f5e"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzY5NzIxOnYy", "diffSide": "LEFT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxMToyNVrOIGHzvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxNTowNFrOIGH8gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5MDMwMA==", "bodyText": "The comment above about Use a weak ref because... can also be removed now", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543290300", "createdAt": "2020-12-15T12:11:25Z", "author": {"login": "mcculls"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -85,9 +82,9 @@ PendingTrace create(final DDId traceId) {\n    * <p>The root span will be available in non-buggy cases because it has either finished and\n    * strongly ref'd in this queue or is unfinished and ref'd in a ContinuableScope.\n    */\n-  private final AtomicReference<WeakReference<DDSpan>> rootSpan = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "927380c394f6b61177f760e03e3cb592b09c3f5e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5MjU0Nw==", "bodyText": "Yeah, SpanCleaner no longer exists either, so I think most of this comment can go.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543292547", "createdAt": "2020-12-15T12:15:04Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -85,9 +82,9 @@ PendingTrace create(final DDId traceId) {\n    * <p>The root span will be available in non-buggy cases because it has either finished and\n    * strongly ref'd in this queue or is unfinished and ref'd in a ContinuableScope.\n    */\n-  private final AtomicReference<WeakReference<DDSpan>> rootSpan = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5MDMwMA=="}, "originalCommit": {"oid": "927380c394f6b61177f760e03e3cb592b09c3f5e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzc0Mjk5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoyMjozNlrOIGIOyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoyMjozNlrOIGIOyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5NzIyNA==", "bodyText": "I think this should be inside the synchronized block and I don't understand how\nif (!rootSpanWritten.get()) {\n      rootSpan.compareAndSet(null, new WeakReference<>(span));\n}\n...\nrootSpanWritten.set(true);\nweren't just racing anyway.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543297224", "createdAt": "2020-12-15T12:22:36Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -247,7 +234,7 @@ private void partialFlush() {\n \n   /** Important to note: may be called multiple times. */\n   void write() {\n-    rootSpanWritten.set(true);\n+    rootSpanWritten = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fed89b91665313d6d3f7fb2adc6e430fab5683b"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzc3NzczOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjozMToyMlrOIGIjKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjo1ODo0MlrOIGJopg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMwMjQ0MA==", "bodyText": "previously this was only set on a full write, now it is set on partial and full writes - is this ok?\nie. does any write end up writing the root span?", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543302440", "createdAt": "2020-12-15T12:31:22Z", "author": {"login": "mcculls"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -259,6 +245,7 @@ private int write(boolean isPartial) {\n       try (Recording recording = tracer.writeTimer()) {\n         // Only one writer at a time\n         synchronized (this) {\n+          rootSpanWritten = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d168b9f3595a67fe6ac3fe523baa91c1b724e858"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMxOTAzNg==", "bodyText": "good point, I hadn't noticed that.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543319036", "createdAt": "2020-12-15T12:57:01Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -259,6 +245,7 @@ private int write(boolean isPartial) {\n       try (Recording recording = tracer.writeTimer()) {\n         // Only one writer at a time\n         synchronized (this) {\n+          rootSpanWritten = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMwMjQ0MA=="}, "originalCommit": {"oid": "d168b9f3595a67fe6ac3fe523baa91c1b724e858"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMyMDIzMA==", "bodyText": "the motivation was to move this inside the synchronized block so it doesn't race. I check for !isPartialWrite now.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543320230", "createdAt": "2020-12-15T12:58:42Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -259,6 +245,7 @@ private int write(boolean isPartial) {\n       try (Recording recording = tracer.writeTimer()) {\n         // Only one writer at a time\n         synchronized (this) {\n+          rootSpanWritten = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzMwMjQ0MA=="}, "originalCommit": {"oid": "d168b9f3595a67fe6ac3fe523baa91c1b724e858"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTUxNjUwOnYy", "diffSide": "LEFT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODowMDoyN1rOIGYlkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODowMDoyN1rOIGYlkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2NTIwMQ==", "bodyText": "Thanks for removing that.  We should probably should have done that during the prior round of PendingTraces.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543565201", "createdAt": "2020-12-15T18:00:27Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -61,33 +58,20 @@ PendingTrace create(final DDId traceId) {\n   /** Nano second ticks value at trace start */\n   private final long startNanoTicks;\n \n-  private final ConcurrentLinkedDeque<DDSpan> finishedSpans = new ConcurrentLinkedDeque();\n+  private final ConcurrentLinkedDeque<DDSpan> finishedSpans = new ConcurrentLinkedDeque<>();\n \n   // We must maintain a separate count because ConcurrentLinkedDeque.size() is a linear operation.\n   private final AtomicInteger completedSpanCount = new AtomicInteger(0);\n \n   private final AtomicInteger pendingReferenceCount = new AtomicInteger(0);\n \n-  // FIXME: In async frameworks we may have situations where traces do not report due to references", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c91f2a1e8cedfa337091880fd4879972f73e78"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTUyMTQ3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODowMToyOFrOIGYocg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODowMToyOFrOIGYocg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2NTkzOA==", "bodyText": "Yes, we seemed to have used Atomic* in a lot places where its overkill.  Thanks for cleaning this up.", "url": "https://github.com/DataDog/dd-trace-java/pull/2204#discussion_r543565938", "createdAt": "2020-12-15T18:01:28Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -61,33 +58,20 @@ PendingTrace create(final DDId traceId) {\n   /** Nano second ticks value at trace start */\n   private final long startNanoTicks;\n \n-  private final ConcurrentLinkedDeque<DDSpan> finishedSpans = new ConcurrentLinkedDeque();\n+  private final ConcurrentLinkedDeque<DDSpan> finishedSpans = new ConcurrentLinkedDeque<>();\n \n   // We must maintain a separate count because ConcurrentLinkedDeque.size() is a linear operation.\n   private final AtomicInteger completedSpanCount = new AtomicInteger(0);\n \n   private final AtomicInteger pendingReferenceCount = new AtomicInteger(0);\n \n-  // FIXME: In async frameworks we may have situations where traces do not report due to references\n-  //  being held by async operators. In order to support testing in these cases we should have a way\n-  //  to keep track of the fact that this trace is ready to report but is still pending. This would\n-  //  likely require a change to the writer interface to allow signaling this intent. This could\n-  //  also give us the benefit of being able to recover for reporting traces that get stuck due to\n-  //  references being held for long periods of time.\n-\n   /**\n    * During a trace there are cases where the root span must be accessed (e.g. priority sampling and\n-   * trace-search tags).\n-   *\n-   * <p>Use a weak ref because we still need to handle buggy cases where the root span is not\n-   * correctly closed (see SpanCleaner).\n-   *\n-   * <p>The root span will be available in non-buggy cases because it has either finished and\n-   * strongly ref'd in this queue or is unfinished and ref'd in a ContinuableScope.\n+   * trace-search tags). These use cases are an obstacle to span-streaming.\n    */\n-  private final AtomicReference<WeakReference<DDSpan>> rootSpan = new AtomicReference<>();\n+  private volatile DDSpan rootSpan = null;\n \n-  private final AtomicBoolean rootSpanWritten = new AtomicBoolean(false);\n+  private volatile boolean rootSpanWritten = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5c91f2a1e8cedfa337091880fd4879972f73e78"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4545, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}