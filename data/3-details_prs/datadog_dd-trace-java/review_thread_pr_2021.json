{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4MTk4NDU5", "number": 2021, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTo1Mjo1OFrOEw1WQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo1ODo1MlrOEw8SBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjQxMTUzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTo1Mjo1OFrOHmonhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTo1Mjo1OFrOHmonhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MzQxMg==", "bodyText": "Excellent!", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510273412", "createdAt": "2020-10-22T15:52:58Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {\n+  public WrapRunnableAsNewTaskInstrumentation() {\n+    super(\"java_concurrent\", \"new-task-for\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return namedOneOf(\n+        \"io.netty.channel.epoll.EpollEventLoop\",\n+        \"io.netty.channel.epoll.EpollEventLoopGroup\",\n+        \"io.netty.channel.MultithreadEventLoopGroup\",\n+        \"io.netty.channel.nio.NioEventLoop\",\n+        \"io.netty.channel.nio.NioEventLoopGroup\",\n+        \"io.netty.channel.SingleThreadEventLoop\",\n+        \"io.netty.util.concurrent.AbstractEventExecutor\",\n+        \"io.netty.util.concurrent.AbstractEventExecutorGroup\",\n+        \"io.netty.util.concurrent.AbstractScheduledEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutorGroup\",\n+        \"io.netty.util.concurrent.GlobalEventExecutor\",\n+        \"io.netty.util.concurrent.MultithreadEventExecutorGroup\",\n+        \"io.netty.util.concurrent.SingleThreadEventExecutor\",\n+        \"java.util.concurrent.AbstractExecutorService\",\n+        \"java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.ThreadPoolExecutor\",\n+        \"org.glassfish.grizzly.threadpool.GrizzlyExecutorService\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {packageName + \".NewTaskFor\"};\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(\n+                named(\"execute\")\n+                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n+        getClass().getName() + \"$Wrap\");\n+  }\n+\n+  public static final class Wrap {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      task = newTaskFor(executor, task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db05f62bd6e11536febcf5d6c912abaa480a8c3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjQzNzYxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTo1ODoyNVrOHmo3cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjowMjowMVrOHmpCLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NzQ4OQ==", "bodyText": "Returning the favor, this looks like the same pattern that you suggested ClassValue for", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510277489", "createdAt": "2020-10-22T15:58:25Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final Method NEW_TASK_FOR_RUNNABLE = lookupNewTaskForRunnable();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Runnable newTaskFor(Executor executor, Runnable runnable) {\n+    // TODO write a slick instrumentation and instrument these types directly\n+    if (runnable instanceof RunnableFuture\n+        || exclude(RUNNABLE, runnable)\n+        || runnable.getClass().getName().startsWith(\"slick.\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db05f62bd6e11536febcf5d6c912abaa480a8c3"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4MDIzOA==", "bodyText": "It's a bit different because we don't know how many distinct types of Runnable an executor will see - in clojure this could be every loaded class - whereas the other case was a library type with (I believe) relatively few implementations. In any case, this is temporary, because I will start work on a slick-specific instrumentation soon.", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510280238", "createdAt": "2020-10-22T16:02:01Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final Method NEW_TASK_FOR_RUNNABLE = lookupNewTaskForRunnable();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Runnable newTaskFor(Executor executor, Runnable runnable) {\n+    // TODO write a slick instrumentation and instrument these types directly\n+    if (runnable instanceof RunnableFuture\n+        || exclude(RUNNABLE, runnable)\n+        || runnable.getClass().getName().startsWith(\"slick.\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NzQ4OQ=="}, "originalCommit": {"oid": "8db05f62bd6e11536febcf5d6c912abaa480a8c3"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjQ1MDEzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjowMTowNFrOHmo_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjowMTowNFrOHmo_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3OTUxMg==", "bodyText": "getDeclaredMethod and setAccessible can also throw SecurityException so I'd include that in the catch", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510279512", "createdAt": "2020-10-22T16:01:04Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final Method NEW_TASK_FOR_RUNNABLE = lookupNewTaskForRunnable();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Runnable newTaskFor(Executor executor, Runnable runnable) {\n+    // TODO write a slick instrumentation and instrument these types directly\n+    if (runnable instanceof RunnableFuture\n+        || exclude(RUNNABLE, runnable)\n+        || runnable.getClass().getName().startsWith(\"slick.\")) {\n+      return runnable;\n+    }\n+    if (null != NEW_TASK_FOR_RUNNABLE && executor instanceof AbstractExecutorService) {\n+      try {\n+        return (RunnableFuture<Void>) NEW_TASK_FOR_RUNNABLE.invoke(executor, runnable, null);\n+      } catch (Throwable t) {\n+        log.debug(\"failed to invoke newTaskFor on {}\", executor, t);\n+      }\n+    }\n+    return new FutureTask<>(runnable, null);\n+  }\n+\n+  private static Method lookupNewTaskForRunnable() {\n+    try {\n+      Method newTaskFor =\n+          AbstractExecutorService.class.getDeclaredMethod(\n+              \"newTaskFor\", Runnable.class, Object.class);\n+      newTaskFor.setAccessible(true);\n+      return newTaskFor;\n+    } catch (NoSuchMethodException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db05f62bd6e11536febcf5d6c912abaa480a8c3"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzM4NzM2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxMTo0MlrOHmyEiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNjo1NToyN1rOHnA_MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw==", "bodyText": "I'm having a hard time understanding when to use Method and when to use Method Handles.  Why use one over the other?", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510428297", "createdAt": "2020-10-22T20:11:42Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final boolean SAFE_TO_PROPAGATE;\n+  private static final Method NEW_TASK_FOR_RUNNABLE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyOTY0MQ==", "bodyText": "Ah, I think I get it... Here you must use reflection because newTaskFor is not accessible, so you can't use Method Handles or call it directly.", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510429641", "createdAt": "2020-10-22T20:14:06Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final boolean SAFE_TO_PROPAGATE;\n+  private static final Method NEW_TASK_FOR_RUNNABLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw=="}, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MjY4OA==", "bodyText": "Yes, exactly. We could unreflect the method to get a MethodHandle, but then we need to use invokeWithArguments and would have no benefit over just using reflection.", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510672688", "createdAt": "2020-10-23T06:55:27Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final boolean SAFE_TO_PROPAGATE;\n+  private static final Method NEW_TASK_FOR_RUNNABLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw=="}, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzQ4NjI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo0MToxNVrOHmzAtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo0MToxNVrOHmzAtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MzcwMA==", "bodyText": "I think a class comment describing the benefits of this approach would be useful for posterity.", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510443700", "createdAt": "2020-10-22T20:41:15Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzU0NzU4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo1ODo1MlrOHmzl1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNjo1NzowNlrOHnBB2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzIwNQ==", "bodyText": "In the future, it might be possible to replace this with a direct method call:\nraphw/byte-buddy#484\nMeanwhile, you may be able to avoid the reflection with MemberSubstitution raphw/byte-buddy#483", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510453205", "createdAt": "2020-10-22T20:58:52Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {\n+  public WrapRunnableAsNewTaskInstrumentation() {\n+    super(\"java_concurrent\", \"new-task-for\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return namedOneOf(\n+        \"io.netty.channel.epoll.EpollEventLoop\",\n+        \"io.netty.channel.epoll.EpollEventLoopGroup\",\n+        \"io.netty.channel.MultithreadEventLoopGroup\",\n+        \"io.netty.channel.nio.NioEventLoop\",\n+        \"io.netty.channel.nio.NioEventLoopGroup\",\n+        \"io.netty.channel.SingleThreadEventLoop\",\n+        \"io.netty.util.concurrent.AbstractEventExecutor\",\n+        \"io.netty.util.concurrent.AbstractEventExecutorGroup\",\n+        \"io.netty.util.concurrent.AbstractScheduledEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutorGroup\",\n+        \"io.netty.util.concurrent.GlobalEventExecutor\",\n+        \"io.netty.util.concurrent.MultithreadEventExecutorGroup\",\n+        \"io.netty.util.concurrent.SingleThreadEventExecutor\",\n+        \"java.util.concurrent.AbstractExecutorService\",\n+        \"java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.ThreadPoolExecutor\",\n+        \"org.glassfish.grizzly.threadpool.GrizzlyExecutorService\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {packageName + \".NewTaskFor\"};\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(\n+                named(\"execute\")\n+                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n+        getClass().getName() + \"$Wrap\");\n+  }\n+\n+  public static final class Wrap {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      task = newTaskFor(executor, task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MzM3MA==", "bodyText": "I will look into using MemberSubstitution here, but we'd need reorganise things a bit to be able to do it without action-at-a-distance dependencies, so I'll do it as part of a PR to make that possible in a sensible way.", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510673370", "createdAt": "2020-10-23T06:57:06Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {\n+  public WrapRunnableAsNewTaskInstrumentation() {\n+    super(\"java_concurrent\", \"new-task-for\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return namedOneOf(\n+        \"io.netty.channel.epoll.EpollEventLoop\",\n+        \"io.netty.channel.epoll.EpollEventLoopGroup\",\n+        \"io.netty.channel.MultithreadEventLoopGroup\",\n+        \"io.netty.channel.nio.NioEventLoop\",\n+        \"io.netty.channel.nio.NioEventLoopGroup\",\n+        \"io.netty.channel.SingleThreadEventLoop\",\n+        \"io.netty.util.concurrent.AbstractEventExecutor\",\n+        \"io.netty.util.concurrent.AbstractEventExecutorGroup\",\n+        \"io.netty.util.concurrent.AbstractScheduledEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutorGroup\",\n+        \"io.netty.util.concurrent.GlobalEventExecutor\",\n+        \"io.netty.util.concurrent.MultithreadEventExecutorGroup\",\n+        \"io.netty.util.concurrent.SingleThreadEventExecutor\",\n+        \"java.util.concurrent.AbstractExecutorService\",\n+        \"java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.ThreadPoolExecutor\",\n+        \"org.glassfish.grizzly.threadpool.GrizzlyExecutorService\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {packageName + \".NewTaskFor\"};\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(\n+                named(\"execute\")\n+                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n+        getClass().getName() + \"$Wrap\");\n+  }\n+\n+  public static final class Wrap {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      task = newTaskFor(executor, task);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzIwNQ=="}, "originalCommit": {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4746, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}