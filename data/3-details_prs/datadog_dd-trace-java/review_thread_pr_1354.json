{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5NzAyNzQw", "number": 1354, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNToyMTowMFrODvnMpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODozMzo0NlrOD4KPSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjUxODc4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/dd-java-agent.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNToyMTowMFrOGCI1Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNToyMTowMFrOGCI1Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg5NTA2Mw==", "bodyText": "There should probably be a new package datadog.trace.core that all these (DDSpan, DDTracer, etc) classes should be put into.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r404895063", "createdAt": "2020-04-07T15:21:00Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/dd-java-agent.gradle", "diffHunk": "@@ -39,6 +39,8 @@ ext.generalShadowJarConfig = {\n   if (!project.hasProperty(\"disableShadowRelocate\") || !disableShadowRelocate) {\n     // shadow OT impl to prevent casts to implementation\n     relocate 'datadog.trace.common', 'datadog.trace.agent.common'\n+\n+    // FIXME figure out the best way to keep doing this\n     relocate 'datadog.opentracing', 'datadog.trace.agent.ot'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "447c83e7baefb6112990754666a00773f1ffdc04"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzA4MTc3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/dd-trace-core.gradle", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyODoxN1rOGCOYjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOToxMjo0OFrOGC9OwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NTk5Nw==", "bodyText": "I don't think core should depend on agent-bootstrap...", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r404985997", "createdAt": "2020-04-07T17:28:17Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,73 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\" version \"5.2.0\"\n+  id \"me.champeau.gradle.jmh\" version \"0.5.0\"\n+}\n+\n+description = 'dd-trace-ot'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':utils:thread-utils')\n+  compileOnly project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbddee426bc97a86e30f04e6032155913de640b5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4ODMyNQ==", "bodyText": "Maybe the better way to handle this is to move all instrumentation api (Agent*) classes into core also and have bootstrap depend on core.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r404988325", "createdAt": "2020-04-07T17:31:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,73 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\" version \"5.2.0\"\n+  id \"me.champeau.gradle.jmh\" version \"0.5.0\"\n+}\n+\n+description = 'dd-trace-ot'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':utils:thread-utils')\n+  compileOnly project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NTk5Nw=="}, "originalCommit": {"oid": "bbddee426bc97a86e30f04e6032155913de640b5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyNzUzNA==", "bodyText": "I agree.  I left a FIXME in one of the places I added the dependency but not all.  Putting the Agent* classes into core wouldn't work because we don't want to have all of core in the bootstrap classpath.\nI think the two options are:\n\nMoving those classes to dd-trace-api since everything already depends on api and api is already in the bootstrap classpath\nCreating a new project (internal-api or something) that bootstrap and core can depend on", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405027534", "createdAt": "2020-04-07T18:35:23Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,73 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\" version \"5.2.0\"\n+  id \"me.champeau.gradle.jmh\" version \"0.5.0\"\n+}\n+\n+description = 'dd-trace-ot'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':utils:thread-utils')\n+  compileOnly project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NTk5Nw=="}, "originalCommit": {"oid": "bbddee426bc97a86e30f04e6032155913de640b5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAzMzAwMA==", "bodyText": "I think I'd be more in favor of an \"internal api\"...", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405033000", "createdAt": "2020-04-07T18:44:11Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,73 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\" version \"5.2.0\"\n+  id \"me.champeau.gradle.jmh\" version \"0.5.0\"\n+}\n+\n+description = 'dd-trace-ot'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':utils:thread-utils')\n+  compileOnly project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NTk5Nw=="}, "originalCommit": {"oid": "bbddee426bc97a86e30f04e6032155913de640b5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MzUzNw==", "bodyText": "Created internal-api project", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405753537", "createdAt": "2020-04-08T19:12:48Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,73 @@\n+plugins {\n+  id \"com.github.johnrengelman.shadow\" version \"5.2.0\"\n+  id \"me.champeau.gradle.jmh\" version \"0.5.0\"\n+}\n+\n+description = 'dd-trace-ot'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':utils:thread-utils')\n+  compileOnly project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NTk5Nw=="}, "originalCommit": {"oid": "bbddee426bc97a86e30f04e6032155913de640b5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzA4NjY3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/propagation/HttpCodec.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyOToyNVrOGCObrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoyOToyNVrOGCObrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4Njc5Nw==", "bodyText": "See my fix here: #1356", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r404986797", "createdAt": "2020-04-07T17:29:25Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/propagation/HttpCodec.java", "diffHunk": "@@ -148,4 +146,13 @@ static String decode(final String value) {\n     }\n     return decoded;\n   }\n+\n+  static String firstHeaderValue(final String value) {\n+    if (value == null || value.isEmpty()) {\n+      return value;\n+    }\n+\n+    // in case of multiple values in the header, need to parse\n+    return value.split(\",\")[0].trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43338c1a21ecc381cf2147087da3bdeb1a3ffd5a"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE1NzQ4OnYy", "diffSide": "LEFT", "path": "dd-trace-ot/dd-trace-ot.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0Nzo1MVrOGCPJDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxOToxMjoyMVrOGC9NuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODQxNQ==", "bodyText": "This isn't \"unused\"... I used this for benchmarking various perf changes recently.  I'd appreciate if we could keep this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r404998415", "createdAt": "2020-04-07T17:47:51Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -91,56 +91,4 @@ jar {\n \n shadowJar {\n   archiveClassifier = ''\n-\n-  dependencies {\n-    include(project(':utils:thread-utils'))\n-  }\n-}\n-\n-// We don't want bundled dependencies to show up in the pom.\n-modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }\n-}\n-\n-jmh {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0db05b2fc2ad1c8d1260d38bbd8d31cc751e44"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MzI3Mg==", "bodyText": "added back in", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405753272", "createdAt": "2020-04-08T19:12:21Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -91,56 +91,4 @@ jar {\n \n shadowJar {\n   archiveClassifier = ''\n-\n-  dependencies {\n-    include(project(':utils:thread-utils'))\n-  }\n-}\n-\n-// We don't want bundled dependencies to show up in the pom.\n-modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }\n-}\n-\n-jmh {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5ODQxNQ=="}, "originalCommit": {"oid": "5a0db05b2fc2ad1c8d1260d38bbd8d31cc751e44"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE3MDg1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracerOT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1MToyNlrOGCPRng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODowNTo1OVrOGCP11A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMDYwNg==", "bodyText": "Suggestion: leave this class as DDTracer and rename the other to CoreTracer", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405000606", "createdAt": "2020-04-07T17:51:26Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracerOT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package datadog.opentracing;\n+\n+import datadog.trace.DDTracer;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.propagation.HttpCodec;\n+import datadog.trace.scopemanager.DDScopeManager;\n+import io.opentracing.ScopeManager;\n+import io.opentracing.Tracer;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class DDTracerOT implements Tracer {\n+  private final DDTracer coreTracer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "056d530de21c1ecefeef20305afe750b072d6aca"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwOTg3Ng==", "bodyText": "oops, didn't see your todo above...", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405009876", "createdAt": "2020-04-07T18:05:59Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracerOT.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package datadog.opentracing;\n+\n+import datadog.trace.DDTracer;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.propagation.HttpCodec;\n+import datadog.trace.scopemanager.DDScopeManager;\n+import io.opentracing.ScopeManager;\n+import io.opentracing.Tracer;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class DDTracerOT implements Tracer {\n+  private final DDTracer coreTracer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwMDYwNg=="}, "originalCommit": {"oid": "056d530de21c1ecefeef20305afe750b072d6aca"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzE5NjY4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/jfr-openjdk/jfr-openjdk.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1ODoyMFrOGCPizw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODoyOTozNVrOGCQtHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNTAwNw==", "bodyText": "Why does this need to depend on the agent-bootstrap?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405005007", "createdAt": "2020-04-07T17:58:20Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/jfr-openjdk/jfr-openjdk.gradle", "diffHunk": "@@ -9,7 +9,7 @@ apply plugin: 'idea'\n dependencies {\n   compile deps.slf4j\n   compile project(':dd-trace-core')\n-  compileOnly project(':dd-java-agent:agent-bootstrap')\n+  compile project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b20b74cbe6e5533ccb3bc28c269830d3fb3982c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyNDAzMQ==", "bodyText": "ScopeEvent references DDSpanContext references AgentSpan.  In core, the dependency isn't transitive.  I'll fix this when the core->bootstrap dependency is figured out.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r405024031", "createdAt": "2020-04-07T18:29:35Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/jfr-openjdk/jfr-openjdk.gradle", "diffHunk": "@@ -9,7 +9,7 @@ apply plugin: 'idea'\n dependencies {\n   compile deps.slf4j\n   compile project(':dd-trace-core')\n-  compileOnly project(':dd-java-agent:agent-bootstrap')\n+  compile project(':dd-java-agent:agent-bootstrap')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNTAwNw=="}, "originalCommit": {"oid": "5b20b74cbe6e5533ccb3bc28c269830d3fb3982c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjI2OTUxOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxOTo0NjozM1rOGDm9KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTozODo0NVrOGDqVuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzE2MQ==", "bodyText": "I would expect to see a constructor here that takes a CoreTracer so we don't have to create multiple copies", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r406437161", "createdAt": "2020-04-09T19:46:33Z", "author": {"login": "devinsba"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -109,100 +53,66 @@ public DDTracerBuilder() {\n     public DDTracerBuilder withProperties(final Properties properties) {\n       return config(Config.get(properties));\n     }\n-\n-    public DDTracerBuilder config(final Config config) {\n-      this.config = config;\n-      serviceName(config.getServiceName());\n-      // Explicitly skip setting writer to avoid allocating resources prematurely.\n-      sampler(Sampler.Builder.forConfig(config));\n-      injector(HttpCodec.createInjector(config));\n-      extractor(HttpCodec.createExtractor(config, config.getHeaderTags()));\n-      scopeManager(\n-          new ContextualScopeManager(config.getScopeDepthLimit(), createScopeEventFactory()));\n-      localRootSpanTags(config.getLocalRootSpanTags());\n-      defaultSpanTags(config.getMergedSpanTags());\n-      serviceNameMappings(config.getServiceMapping());\n-      taggedHeaders(config.getHeaderTags());\n-      partialFlushMinSpans(config.getPartialFlushMinSpans());\n-      return this;\n-    }\n   }\n \n-  /** By default, report to local agent and collect all traces. */\n   @Deprecated\n   public DDTracer() {\n-    this(Config.get());\n+    coreTracer = CoreTracer.builder().build();\n+    scopeManager = new OTScopeManager();\n   }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f1fa8f00ceeb0206d884d9078a15b0b1603fef6"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5MjYwMw==", "bodyText": "Done", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r406492603", "createdAt": "2020-04-09T21:38:45Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -109,100 +53,66 @@ public DDTracerBuilder() {\n     public DDTracerBuilder withProperties(final Properties properties) {\n       return config(Config.get(properties));\n     }\n-\n-    public DDTracerBuilder config(final Config config) {\n-      this.config = config;\n-      serviceName(config.getServiceName());\n-      // Explicitly skip setting writer to avoid allocating resources prematurely.\n-      sampler(Sampler.Builder.forConfig(config));\n-      injector(HttpCodec.createInjector(config));\n-      extractor(HttpCodec.createExtractor(config, config.getHeaderTags()));\n-      scopeManager(\n-          new ContextualScopeManager(config.getScopeDepthLimit(), createScopeEventFactory()));\n-      localRootSpanTags(config.getLocalRootSpanTags());\n-      defaultSpanTags(config.getMergedSpanTags());\n-      serviceNameMappings(config.getServiceMapping());\n-      taggedHeaders(config.getHeaderTags());\n-      partialFlushMinSpans(config.getPartialFlushMinSpans());\n-      return this;\n-    }\n   }\n \n-  /** By default, report to local agent and collect all traces. */\n   @Deprecated\n   public DDTracer() {\n-    this(Config.get());\n+    coreTracer = CoreTracer.builder().build();\n+    scopeManager = new OTScopeManager();\n   }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQzNzE2MQ=="}, "originalCommit": {"oid": "4f1fa8f00ceeb0206d884d9078a15b0b1603fef6"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjMyOTMzOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDowNToyMFrOGDnjQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMTo0NjozOVrOGDqj3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NjkxMg==", "bodyText": "Is it possible to only have one scope type?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r406446912", "createdAt": "2020-04-09T20:05:20Z", "author": {"login": "devinsba"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -0,0 +1,711 @@\n+package datadog.trace.core;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.api.interceptor.MutableSpan;\n+import datadog.trace.api.interceptor.TraceInterceptor;\n+import datadog.trace.api.sampling.PrioritySampling;\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.common.sampling.PrioritySampler;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.DDAgentWriter;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.common.writer.ddagent.DDAgentResponseListener;\n+import datadog.trace.context.ScopeListener;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.decorators.AbstractDecorator;\n+import datadog.trace.core.decorators.DDDecoratorsFactory;\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory;\n+import datadog.trace.core.jfr.DDScopeEventFactory;\n+import datadog.trace.core.propagation.ExtractedContext;\n+import datadog.trace.core.propagation.HttpCodec;\n+import datadog.trace.core.propagation.TagContext;\n+import datadog.trace.core.scopemanager.ContextualScopeManager;\n+import datadog.trace.core.scopemanager.DDScopeManager;\n+import java.io.Closeable;\n+import java.lang.ref.WeakReference;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ThreadLocalRandom;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** DDTracer makes it easy to send traces and span to DD using the OpenTracing API. */\n+@Slf4j\n+public class CoreTracer\n+    implements Closeable, datadog.trace.api.Tracer, AgentTracer.TracerAPI, AgentPropagation {\n+  // UINT64 max value\n+  public static final BigInteger TRACE_ID_MAX =\n+      BigInteger.valueOf(2).pow(64).subtract(BigInteger.ONE);\n+  public static final BigInteger TRACE_ID_MIN = BigInteger.ZERO;\n+\n+  /** Default service name if none provided on the trace or span */\n+  final String serviceName;\n+  /** Writer is an charge of reporting traces and spans to the desired endpoint */\n+  final Writer writer;\n+  /** Sampler defines the sampling policy in order to reduce the number of traces for instance */\n+  final Sampler sampler;\n+  /** Scope manager is in charge of managing the scopes from which spans are created */\n+  final DDScopeManager scopeManager;\n+\n+  /** A set of tags that are added only to the application's root span */\n+  private final Map<String, String> localRootSpanTags;\n+  /** A set of tags that are added to every span */\n+  private final Map<String, String> defaultSpanTags;\n+  /** A configured mapping of service names to update with new values */\n+  private final Map<String, String> serviceNameMappings;\n+\n+  /** number of spans in a pending trace before they get flushed */\n+  @lombok.Getter private final int partialFlushMinSpans;\n+\n+  /**\n+   * JVM shutdown callback, keeping a reference to it to remove this if DDTracer gets destroyed\n+   * earlier\n+   */\n+  private final Thread shutdownCallback;\n+\n+  /** Span context decorators */\n+  private final Map<String, List<AbstractDecorator>> spanContextDecorators =\n+      new ConcurrentHashMap<>();\n+\n+  private final SortedSet<TraceInterceptor> interceptors =\n+      new ConcurrentSkipListSet<>(\n+          new Comparator<TraceInterceptor>() {\n+            @Override\n+            public int compare(final TraceInterceptor o1, final TraceInterceptor o2) {\n+              return Integer.compare(o1.priority(), o2.priority());\n+            }\n+          });\n+\n+  private final HttpCodec.Injector injector;\n+  private final HttpCodec.Extractor extractor;\n+\n+  @Override\n+  public TraceScope.Continuation capture() {\n+    final TraceScope activeScope = activeScope();\n+\n+    return activeScope == null ? null : activeScope.capture();\n+  }\n+\n+  public static class CoreTracerBuilder {\n+\n+    public CoreTracerBuilder() {\n+      // Apply the default values from config.\n+      config(Config.get());\n+    }\n+\n+    public CoreTracerBuilder withProperties(final Properties properties) {\n+      return config(Config.get(properties));\n+    }\n+\n+    public CoreTracerBuilder config(final Config config) {\n+      this.config = config;\n+      serviceName(config.getServiceName());\n+      // Explicitly skip setting writer to avoid allocating resources prematurely.\n+      sampler(Sampler.Builder.forConfig(config));\n+      injector(HttpCodec.createInjector(config));\n+      extractor(HttpCodec.createExtractor(config, config.getHeaderTags()));\n+      scopeManager(\n+          new ContextualScopeManager(config.getScopeDepthLimit(), createScopeEventFactory()));\n+      localRootSpanTags(config.getLocalRootSpanTags());\n+      defaultSpanTags(config.getMergedSpanTags());\n+      serviceNameMappings(config.getServiceMapping());\n+      taggedHeaders(config.getHeaderTags());\n+      partialFlushMinSpans(config.getPartialFlushMinSpans());\n+      return this;\n+    }\n+  }\n+\n+  @Builder\n+  // These field names must be stable to ensure the builder api is stable.\n+  private CoreTracer(\n+      final Config config,\n+      final String serviceName,\n+      final Writer writer,\n+      final Sampler sampler,\n+      final HttpCodec.Injector injector,\n+      final HttpCodec.Extractor extractor,\n+      final DDScopeManager scopeManager,\n+      final Map<String, String> localRootSpanTags,\n+      final Map<String, String> defaultSpanTags,\n+      final Map<String, String> serviceNameMappings,\n+      final Map<String, String> taggedHeaders,\n+      final int partialFlushMinSpans) {\n+\n+    assert localRootSpanTags != null;\n+    assert defaultSpanTags != null;\n+    assert serviceNameMappings != null;\n+    assert taggedHeaders != null;\n+\n+    this.serviceName = serviceName;\n+    if (writer == null) {\n+      this.writer = Writer.Builder.forConfig(config);\n+    } else {\n+      this.writer = writer;\n+    }\n+    this.sampler = sampler;\n+    this.injector = injector;\n+    this.extractor = extractor;\n+    this.scopeManager = scopeManager;\n+    this.localRootSpanTags = localRootSpanTags;\n+    this.defaultSpanTags = defaultSpanTags;\n+    this.serviceNameMappings = serviceNameMappings;\n+    this.partialFlushMinSpans = partialFlushMinSpans;\n+\n+    this.writer.start();\n+\n+    shutdownCallback = new ShutdownHook(this);\n+    try {\n+      Runtime.getRuntime().addShutdownHook(shutdownCallback);\n+    } catch (final IllegalStateException ex) {\n+      // The JVM is already shutting down.\n+    }\n+\n+    if (this.writer instanceof DDAgentWriter && sampler instanceof DDAgentResponseListener) {\n+      ((DDAgentWriter) this.writer).addResponseListener((DDAgentResponseListener) this.sampler);\n+    }\n+\n+    log.info(\"New instance: {}\", this);\n+\n+    final List<AbstractDecorator> decorators = DDDecoratorsFactory.createBuiltinDecorators();\n+    for (final AbstractDecorator decorator : decorators) {\n+      addDecorator(decorator);\n+    }\n+\n+    registerClassLoader(ClassLoader.getSystemClassLoader());\n+\n+    // Ensure that PendingTrace.SPAN_CLEANER is initialized in this thread:\n+    // FIXME: add test to verify the span cleaner thread is started with this call.\n+    PendingTrace.initialize();\n+  }\n+\n+  @Override\n+  public void finalize() {\n+    try {\n+      Runtime.getRuntime().removeShutdownHook(shutdownCallback);\n+      shutdownCallback.run();\n+    } catch (final Exception e) {\n+      log.error(\"Error while finalizing DDTracer.\", e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of span context decorators\n+   *\n+   * @return the list of span context decorators\n+   */\n+  public List<AbstractDecorator> getSpanContextDecorators(final String tag) {\n+    return spanContextDecorators.get(tag);\n+  }\n+\n+  /**\n+   * Add a new decorator in the list ({@link AbstractDecorator})\n+   *\n+   * @param decorator The decorator in the list\n+   */\n+  public void addDecorator(final AbstractDecorator decorator) {\n+\n+    List<AbstractDecorator> list = spanContextDecorators.get(decorator.getMatchingTag());\n+    if (list == null) {\n+      list = new ArrayList<>();\n+    }\n+    list.add(decorator);\n+\n+    spanContextDecorators.put(decorator.getMatchingTag(), list);\n+    log.debug(\n+        \"Decorator added: '{}' -> {}\", decorator.getMatchingTag(), decorator.getClass().getName());\n+  }\n+\n+  /**\n+   * If an application is using a non-system classloader, that classloader should be registered\n+   * here. Due to the way Spring Boot structures its' executable jar, this might log some warnings.\n+   *\n+   * @param classLoader to register.\n+   */\n+  public void registerClassLoader(final ClassLoader classLoader) {\n+    try {\n+      for (final TraceInterceptor interceptor :\n+          ServiceLoader.load(TraceInterceptor.class, classLoader)) {\n+        addTraceInterceptor(interceptor);\n+      }\n+    } catch (final ServiceConfigurationError e) {\n+      log.warn(\"Problem loading TraceInterceptor for classLoader: \" + classLoader, e);\n+    }\n+  }\n+\n+  public CoreSpanBuilder buildSpan(final String operationName) {\n+    return new CoreSpanBuilder(operationName);\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName) {\n+    return buildSpan(spanName).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName, final long startTimeMicros) {\n+    return buildSpan(spanName).withStartTimestamp(startTimeMicros).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName, final AgentSpan.Context parent) {\n+    return buildSpan(spanName).ignoreActiveSpan().asChildOf(parent).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(\n+      final String spanName, final AgentSpan.Context parent, final long startTimeMicros) {\n+    return buildSpan(spanName)\n+        .ignoreActiveSpan()\n+        .asChildOf(parent)\n+        .withStartTimestamp(startTimeMicros)\n+        .start();\n+  }\n+\n+  @Override\n+  public AgentScope activateSpan(final AgentSpan span, final boolean finishSpanOnClose) {\n+    return scopeManager.activate(span, finishSpanOnClose);\n+  }\n+\n+  @Override\n+  public AgentSpan activeSpan() {\n+    return scopeManager.activeSpan();\n+  }\n+\n+  @Override\n+  public TraceScope activeScope() {\n+    // FIXME: [API] the fact that this returns null for SimpleScope is problematic\n+    final AgentScope scope = scopeManager.active();\n+    if (scope instanceof TraceScope) {\n+      return (TraceScope) scope;\n+    }\n+\n+    return null;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f1fa8f00ceeb0206d884d9078a15b0b1603fef6"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5NjIyMA==", "bodyText": "No.  TraceScope is public and slightly incompatible with AgentScope.  I did look at this again and clean it up by having SimpleScope implement TraceScope.  Though OpenTracing32.activeScope() previously returned null when the scope was not a TraceScope, I think this is a bug.  There are many places in the code that assume activeScope() never returns null (relying on scope.capture() to return null).\nI also noticed SimpleScope and ContinuableScope can be merged into a single class but I'll leave that for another pull request.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r406496220", "createdAt": "2020-04-09T21:46:39Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -0,0 +1,711 @@\n+package datadog.trace.core;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.api.interceptor.MutableSpan;\n+import datadog.trace.api.interceptor.TraceInterceptor;\n+import datadog.trace.api.sampling.PrioritySampling;\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.common.sampling.PrioritySampler;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.DDAgentWriter;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.common.writer.ddagent.DDAgentResponseListener;\n+import datadog.trace.context.ScopeListener;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.decorators.AbstractDecorator;\n+import datadog.trace.core.decorators.DDDecoratorsFactory;\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory;\n+import datadog.trace.core.jfr.DDScopeEventFactory;\n+import datadog.trace.core.propagation.ExtractedContext;\n+import datadog.trace.core.propagation.HttpCodec;\n+import datadog.trace.core.propagation.TagContext;\n+import datadog.trace.core.scopemanager.ContextualScopeManager;\n+import datadog.trace.core.scopemanager.DDScopeManager;\n+import java.io.Closeable;\n+import java.lang.ref.WeakReference;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ThreadLocalRandom;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** DDTracer makes it easy to send traces and span to DD using the OpenTracing API. */\n+@Slf4j\n+public class CoreTracer\n+    implements Closeable, datadog.trace.api.Tracer, AgentTracer.TracerAPI, AgentPropagation {\n+  // UINT64 max value\n+  public static final BigInteger TRACE_ID_MAX =\n+      BigInteger.valueOf(2).pow(64).subtract(BigInteger.ONE);\n+  public static final BigInteger TRACE_ID_MIN = BigInteger.ZERO;\n+\n+  /** Default service name if none provided on the trace or span */\n+  final String serviceName;\n+  /** Writer is an charge of reporting traces and spans to the desired endpoint */\n+  final Writer writer;\n+  /** Sampler defines the sampling policy in order to reduce the number of traces for instance */\n+  final Sampler sampler;\n+  /** Scope manager is in charge of managing the scopes from which spans are created */\n+  final DDScopeManager scopeManager;\n+\n+  /** A set of tags that are added only to the application's root span */\n+  private final Map<String, String> localRootSpanTags;\n+  /** A set of tags that are added to every span */\n+  private final Map<String, String> defaultSpanTags;\n+  /** A configured mapping of service names to update with new values */\n+  private final Map<String, String> serviceNameMappings;\n+\n+  /** number of spans in a pending trace before they get flushed */\n+  @lombok.Getter private final int partialFlushMinSpans;\n+\n+  /**\n+   * JVM shutdown callback, keeping a reference to it to remove this if DDTracer gets destroyed\n+   * earlier\n+   */\n+  private final Thread shutdownCallback;\n+\n+  /** Span context decorators */\n+  private final Map<String, List<AbstractDecorator>> spanContextDecorators =\n+      new ConcurrentHashMap<>();\n+\n+  private final SortedSet<TraceInterceptor> interceptors =\n+      new ConcurrentSkipListSet<>(\n+          new Comparator<TraceInterceptor>() {\n+            @Override\n+            public int compare(final TraceInterceptor o1, final TraceInterceptor o2) {\n+              return Integer.compare(o1.priority(), o2.priority());\n+            }\n+          });\n+\n+  private final HttpCodec.Injector injector;\n+  private final HttpCodec.Extractor extractor;\n+\n+  @Override\n+  public TraceScope.Continuation capture() {\n+    final TraceScope activeScope = activeScope();\n+\n+    return activeScope == null ? null : activeScope.capture();\n+  }\n+\n+  public static class CoreTracerBuilder {\n+\n+    public CoreTracerBuilder() {\n+      // Apply the default values from config.\n+      config(Config.get());\n+    }\n+\n+    public CoreTracerBuilder withProperties(final Properties properties) {\n+      return config(Config.get(properties));\n+    }\n+\n+    public CoreTracerBuilder config(final Config config) {\n+      this.config = config;\n+      serviceName(config.getServiceName());\n+      // Explicitly skip setting writer to avoid allocating resources prematurely.\n+      sampler(Sampler.Builder.forConfig(config));\n+      injector(HttpCodec.createInjector(config));\n+      extractor(HttpCodec.createExtractor(config, config.getHeaderTags()));\n+      scopeManager(\n+          new ContextualScopeManager(config.getScopeDepthLimit(), createScopeEventFactory()));\n+      localRootSpanTags(config.getLocalRootSpanTags());\n+      defaultSpanTags(config.getMergedSpanTags());\n+      serviceNameMappings(config.getServiceMapping());\n+      taggedHeaders(config.getHeaderTags());\n+      partialFlushMinSpans(config.getPartialFlushMinSpans());\n+      return this;\n+    }\n+  }\n+\n+  @Builder\n+  // These field names must be stable to ensure the builder api is stable.\n+  private CoreTracer(\n+      final Config config,\n+      final String serviceName,\n+      final Writer writer,\n+      final Sampler sampler,\n+      final HttpCodec.Injector injector,\n+      final HttpCodec.Extractor extractor,\n+      final DDScopeManager scopeManager,\n+      final Map<String, String> localRootSpanTags,\n+      final Map<String, String> defaultSpanTags,\n+      final Map<String, String> serviceNameMappings,\n+      final Map<String, String> taggedHeaders,\n+      final int partialFlushMinSpans) {\n+\n+    assert localRootSpanTags != null;\n+    assert defaultSpanTags != null;\n+    assert serviceNameMappings != null;\n+    assert taggedHeaders != null;\n+\n+    this.serviceName = serviceName;\n+    if (writer == null) {\n+      this.writer = Writer.Builder.forConfig(config);\n+    } else {\n+      this.writer = writer;\n+    }\n+    this.sampler = sampler;\n+    this.injector = injector;\n+    this.extractor = extractor;\n+    this.scopeManager = scopeManager;\n+    this.localRootSpanTags = localRootSpanTags;\n+    this.defaultSpanTags = defaultSpanTags;\n+    this.serviceNameMappings = serviceNameMappings;\n+    this.partialFlushMinSpans = partialFlushMinSpans;\n+\n+    this.writer.start();\n+\n+    shutdownCallback = new ShutdownHook(this);\n+    try {\n+      Runtime.getRuntime().addShutdownHook(shutdownCallback);\n+    } catch (final IllegalStateException ex) {\n+      // The JVM is already shutting down.\n+    }\n+\n+    if (this.writer instanceof DDAgentWriter && sampler instanceof DDAgentResponseListener) {\n+      ((DDAgentWriter) this.writer).addResponseListener((DDAgentResponseListener) this.sampler);\n+    }\n+\n+    log.info(\"New instance: {}\", this);\n+\n+    final List<AbstractDecorator> decorators = DDDecoratorsFactory.createBuiltinDecorators();\n+    for (final AbstractDecorator decorator : decorators) {\n+      addDecorator(decorator);\n+    }\n+\n+    registerClassLoader(ClassLoader.getSystemClassLoader());\n+\n+    // Ensure that PendingTrace.SPAN_CLEANER is initialized in this thread:\n+    // FIXME: add test to verify the span cleaner thread is started with this call.\n+    PendingTrace.initialize();\n+  }\n+\n+  @Override\n+  public void finalize() {\n+    try {\n+      Runtime.getRuntime().removeShutdownHook(shutdownCallback);\n+      shutdownCallback.run();\n+    } catch (final Exception e) {\n+      log.error(\"Error while finalizing DDTracer.\", e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of span context decorators\n+   *\n+   * @return the list of span context decorators\n+   */\n+  public List<AbstractDecorator> getSpanContextDecorators(final String tag) {\n+    return spanContextDecorators.get(tag);\n+  }\n+\n+  /**\n+   * Add a new decorator in the list ({@link AbstractDecorator})\n+   *\n+   * @param decorator The decorator in the list\n+   */\n+  public void addDecorator(final AbstractDecorator decorator) {\n+\n+    List<AbstractDecorator> list = spanContextDecorators.get(decorator.getMatchingTag());\n+    if (list == null) {\n+      list = new ArrayList<>();\n+    }\n+    list.add(decorator);\n+\n+    spanContextDecorators.put(decorator.getMatchingTag(), list);\n+    log.debug(\n+        \"Decorator added: '{}' -> {}\", decorator.getMatchingTag(), decorator.getClass().getName());\n+  }\n+\n+  /**\n+   * If an application is using a non-system classloader, that classloader should be registered\n+   * here. Due to the way Spring Boot structures its' executable jar, this might log some warnings.\n+   *\n+   * @param classLoader to register.\n+   */\n+  public void registerClassLoader(final ClassLoader classLoader) {\n+    try {\n+      for (final TraceInterceptor interceptor :\n+          ServiceLoader.load(TraceInterceptor.class, classLoader)) {\n+        addTraceInterceptor(interceptor);\n+      }\n+    } catch (final ServiceConfigurationError e) {\n+      log.warn(\"Problem loading TraceInterceptor for classLoader: \" + classLoader, e);\n+    }\n+  }\n+\n+  public CoreSpanBuilder buildSpan(final String operationName) {\n+    return new CoreSpanBuilder(operationName);\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName) {\n+    return buildSpan(spanName).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName, final long startTimeMicros) {\n+    return buildSpan(spanName).withStartTimestamp(startTimeMicros).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(final String spanName, final AgentSpan.Context parent) {\n+    return buildSpan(spanName).ignoreActiveSpan().asChildOf(parent).start();\n+  }\n+\n+  @Override\n+  public AgentSpan startSpan(\n+      final String spanName, final AgentSpan.Context parent, final long startTimeMicros) {\n+    return buildSpan(spanName)\n+        .ignoreActiveSpan()\n+        .asChildOf(parent)\n+        .withStartTimestamp(startTimeMicros)\n+        .start();\n+  }\n+\n+  @Override\n+  public AgentScope activateSpan(final AgentSpan span, final boolean finishSpanOnClose) {\n+    return scopeManager.activate(span, finishSpanOnClose);\n+  }\n+\n+  @Override\n+  public AgentSpan activeSpan() {\n+    return scopeManager.activeSpan();\n+  }\n+\n+  @Override\n+  public TraceScope activeScope() {\n+    // FIXME: [API] the fact that this returns null for SimpleScope is problematic\n+    final AgentScope scope = scopeManager.active();\n+    if (scope instanceof TraceScope) {\n+      return (TraceScope) scope;\n+    }\n+\n+    return null;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0NjkxMg=="}, "originalCommit": {"oid": "4f1fa8f00ceeb0206d884d9078a15b0b1603fef6"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDUwNjM1OnYy", "diffSide": "LEFT", "path": "dd-trace-ot/dd-trace-ot.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTo0OTozNFrOGFVQwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowMzozMVrOGFe1DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NDQxOA==", "bodyText": "I think we still need this, otherwise it shadows all the dependencies, including opentracing-api.  If you prefer, you can move thread-utils into the internal-api project.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r408244418", "createdAt": "2020-04-14T15:49:34Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -91,15 +70,6 @@ jar {\n \n shadowJar {\n   archiveClassifier = ''\n-\n-  dependencies {\n-    include(project(':utils:thread-utils'))\n-  }\n-}\n-\n-// We don't want bundled dependencies to show up in the pom.\n-modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88aa33c115f6999ec5add9e88a0e284e25a66710"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NTc3Mg==", "bodyText": "Good catch.  I think the correct thing here is to remove the shadow plugin and just publish a regular jar.  Looking at the file history, that's how it was before the thread-utils was added.  (Thread-utils is shadowed into dd-trace-core which dd-trace-ot has a dependency on)", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r408265772", "createdAt": "2020-04-14T16:19:16Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -91,15 +70,6 @@ jar {\n \n shadowJar {\n   archiveClassifier = ''\n-\n-  dependencies {\n-    include(project(':utils:thread-utils'))\n-  }\n-}\n-\n-// We don't want bundled dependencies to show up in the pom.\n-modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NDQxOA=="}, "originalCommit": {"oid": "88aa33c115f6999ec5add9e88a0e284e25a66710"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMTE2NQ==", "bodyText": "but we aren't planning on publishing dd-trace-core are we?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r408401165", "createdAt": "2020-04-14T20:03:31Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -91,15 +70,6 @@ jar {\n \n shadowJar {\n   archiveClassifier = ''\n-\n-  dependencies {\n-    include(project(':utils:thread-utils'))\n-  }\n-}\n-\n-// We don't want bundled dependencies to show up in the pom.\n-modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NDQxOA=="}, "originalCommit": {"oid": "88aa33c115f6999ec5add9e88a0e284e25a66710"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM2NzQ0OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/LogHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxMTozNFrOGHbqFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjoyMjoyNFrOGLfYjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjM1OQ==", "bodyText": "Maybe this class and implementations of it should be made to work with a generic Span class instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r410446359", "createdAt": "2020-04-17T20:11:34Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/LogHandler.java", "diffHunk": "@@ -1,5 +1,6 @@\n package datadog.opentracing;\n \n+import datadog.trace.core.DDSpan;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e261483ca383a64c394d243cc4492c3236edd909"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMTcwOA==", "bodyText": "DefaultLogHandler needs to call AgentSpan.addThrowable() so it would just result in instanceof and casts.  Regardless, I didn't want to mess with the API in this pull request", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414701708", "createdAt": "2020-04-24T16:22:24Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/LogHandler.java", "diffHunk": "@@ -1,5 +1,6 @@\n package datadog.opentracing;\n \n+import datadog.trace.core.DDSpan;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjM1OQ=="}, "originalCommit": {"oid": "e261483ca383a64c394d243cc4492c3236edd909"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODEwMjg5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/dd-java-agent.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNjo1NzowNVrOGLgtgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyMTo1MVrOGLn1uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyMzQ1OA==", "bodyText": "Do we still have datadog.opentracing packages?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414723458", "createdAt": "2020-04-24T16:57:05Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/dd-java-agent.gradle", "diffHunk": "@@ -39,6 +39,7 @@ ext.generalShadowJarConfig = {\n   if (!project.hasProperty(\"disableShadowRelocate\") || !disableShadowRelocate) {\n     // shadow OT impl to prevent casts to implementation\n     relocate 'datadog.trace.common', 'datadog.trace.agent.common'\n+    relocate 'datadog.trace.core', 'datadog.trace.agent.core'\n     relocate 'datadog.opentracing', 'datadog.trace.agent.ot'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MDI0OQ==", "bodyText": "Yes, until we completely remove the dd-trace-ot dependency from the agent", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414840249", "createdAt": "2020-04-24T20:21:51Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/dd-java-agent.gradle", "diffHunk": "@@ -39,6 +39,7 @@ ext.generalShadowJarConfig = {\n   if (!project.hasProperty(\"disableShadowRelocate\") || !disableShadowRelocate) {\n     // shadow OT impl to prevent casts to implementation\n     relocate 'datadog.trace.common', 'datadog.trace.agent.common'\n+    relocate 'datadog.trace.core', 'datadog.trace.agent.core'\n     relocate 'datadog.opentracing', 'datadog.trace.agent.ot'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyMzQ1OA=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODEyMjQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/RequestDispatcherTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzowMTo1OVrOGLg5ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyMDoxNlrOGLnyMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjUyMw==", "bodyText": "Why this change?  Maybe we should have an internal interface for span?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414726523", "createdAt": "2020-04-24T17:01:59Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/RequestDispatcherTest.groovy", "diffHunk": "@@ -1,22 +1,22 @@\n-import datadog.opentracing.DDSpan\n import datadog.trace.agent.test.AgentTestRunner\n+import datadog.trace.core.DDSpan\n \n import javax.servlet.ServletException\n import javax.servlet.http.HttpServletRequest\n import javax.servlet.http.HttpServletResponse\n \n-import static datadog.opentracing.propagation.DatadogHttpCodec.SAMPLING_PRIORITY_KEY\n-import static datadog.opentracing.propagation.DatadogHttpCodec.SPAN_ID_KEY\n-import static datadog.opentracing.propagation.DatadogHttpCodec.TRACE_ID_KEY\n import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n import static datadog.trace.agent.test.utils.TraceUtils.runUnderTrace\n import static datadog.trace.bootstrap.instrumentation.decorator.HttpServerDecorator.DD_SPAN_ATTRIBUTE\n+import static datadog.trace.core.propagation.DatadogHttpCodec.SAMPLING_PRIORITY_KEY\n+import static datadog.trace.core.propagation.DatadogHttpCodec.SPAN_ID_KEY\n+import static datadog.trace.core.propagation.DatadogHttpCodec.TRACE_ID_KEY\n \n class RequestDispatcherTest extends AgentTestRunner {\n \n   def request = Mock(HttpServletRequest)\n   def response = Mock(HttpServletResponse)\n-  def mockSpan = Mock(DDSpan)\n+  def mockSpan = Stub(DDSpan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzOTM0Nw==", "bodyText": "The tests broke because of 0 * _ in the then blocks.  There's an errant call to getSpanName() somewhere.  I figured this test was about the interactions of requests and responses so I changed mockSpan to a stub.\nAlternatively, I could add a 1 * mockSpan.getSpanName() everywhere.\nI'm all for an internal span interface (or changing AgentSpan to be better) but that should wait for the overall API redesign effort scheduled for later.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414839347", "createdAt": "2020-04-24T20:20:16Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/instrumentation/servlet/src/test/groovy/RequestDispatcherTest.groovy", "diffHunk": "@@ -1,22 +1,22 @@\n-import datadog.opentracing.DDSpan\n import datadog.trace.agent.test.AgentTestRunner\n+import datadog.trace.core.DDSpan\n \n import javax.servlet.ServletException\n import javax.servlet.http.HttpServletRequest\n import javax.servlet.http.HttpServletResponse\n \n-import static datadog.opentracing.propagation.DatadogHttpCodec.SAMPLING_PRIORITY_KEY\n-import static datadog.opentracing.propagation.DatadogHttpCodec.SPAN_ID_KEY\n-import static datadog.opentracing.propagation.DatadogHttpCodec.TRACE_ID_KEY\n import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n import static datadog.trace.agent.test.utils.TraceUtils.runUnderTrace\n import static datadog.trace.bootstrap.instrumentation.decorator.HttpServerDecorator.DD_SPAN_ATTRIBUTE\n+import static datadog.trace.core.propagation.DatadogHttpCodec.SAMPLING_PRIORITY_KEY\n+import static datadog.trace.core.propagation.DatadogHttpCodec.SPAN_ID_KEY\n+import static datadog.trace.core.propagation.DatadogHttpCodec.TRACE_ID_KEY\n \n class RequestDispatcherTest extends AgentTestRunner {\n \n   def request = Mock(HttpServletRequest)\n   def response = Mock(HttpServletResponse)\n-  def mockSpan = Mock(DDSpan)\n+  def mockSpan = Stub(DDSpan)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjUyMw=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODE1MTMyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzowOTozNlrOGLhLDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMzozOTo0MFrOGLsuVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczMTAyMQ==", "bodyText": "Updated javadoc?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414731021", "createdAt": "2020-04-24T17:09:36Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -0,0 +1,700 @@\n+package datadog.trace.core;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.api.interceptor.MutableSpan;\n+import datadog.trace.api.interceptor.TraceInterceptor;\n+import datadog.trace.api.sampling.PrioritySampling;\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.common.sampling.PrioritySampler;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.DDAgentWriter;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.common.writer.ddagent.DDAgentResponseListener;\n+import datadog.trace.context.ScopeListener;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.decorators.AbstractDecorator;\n+import datadog.trace.core.decorators.DDDecoratorsFactory;\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory;\n+import datadog.trace.core.jfr.DDScopeEventFactory;\n+import datadog.trace.core.propagation.ExtractedContext;\n+import datadog.trace.core.propagation.HttpCodec;\n+import datadog.trace.core.propagation.TagContext;\n+import datadog.trace.core.scopemanager.ContextualScopeManager;\n+import datadog.trace.core.scopemanager.DDScopeManager;\n+import java.io.Closeable;\n+import java.lang.ref.WeakReference;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ThreadLocalRandom;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** DDTracer makes it easy to send traces and span to DD using the OpenTracing API. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDI3Nw==", "bodyText": "Updated", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414920277", "createdAt": "2020-04-24T23:39:40Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/CoreTracer.java", "diffHunk": "@@ -0,0 +1,700 @@\n+package datadog.trace.core;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.api.interceptor.MutableSpan;\n+import datadog.trace.api.interceptor.TraceInterceptor;\n+import datadog.trace.api.sampling.PrioritySampling;\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.common.sampling.PrioritySampler;\n+import datadog.trace.common.sampling.Sampler;\n+import datadog.trace.common.writer.DDAgentWriter;\n+import datadog.trace.common.writer.Writer;\n+import datadog.trace.common.writer.ddagent.DDAgentResponseListener;\n+import datadog.trace.context.ScopeListener;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.decorators.AbstractDecorator;\n+import datadog.trace.core.decorators.DDDecoratorsFactory;\n+import datadog.trace.core.jfr.DDNoopScopeEventFactory;\n+import datadog.trace.core.jfr.DDScopeEventFactory;\n+import datadog.trace.core.propagation.ExtractedContext;\n+import datadog.trace.core.propagation.HttpCodec;\n+import datadog.trace.core.propagation.TagContext;\n+import datadog.trace.core.scopemanager.ContextualScopeManager;\n+import datadog.trace.core.scopemanager.DDScopeManager;\n+import java.io.Closeable;\n+import java.lang.ref.WeakReference;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.ServiceConfigurationError;\n+import java.util.ServiceLoader;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.ThreadLocalRandom;\n+import lombok.Builder;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** DDTracer makes it easy to send traces and span to DD using the OpenTracing API. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczMTAyMQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODE1NzE1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoxMTowN1rOGLhOdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoxMTowN1rOGLhOdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczMTg5Mg==", "bodyText": "Should we rename this as CoreSpan to be consistent in naming?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414731892", "createdAt": "2020-04-24T17:11:07Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -19,11 +18,11 @@\n /**\n  * Represents a period of time. Associated information is stored in the SpanContext.\n  *\n- * <p>Spans are created by the {@link DDTracer#buildSpan}. This implementation adds some features\n+ * <p>Spans are created by the {@link CoreTracer#buildSpan}. This implementation adds some features\n  * according to the DD agent.\n  */\n @Slf4j\n-public class DDSpan implements Span, MutableSpan {\n+public class DDSpan implements MutableSpan, AgentSpan {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODE5NTk5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoyMTowM1rOGLhmGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoyMzo1MFrOGLn5hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNzk0NA==", "bodyText": "What if the tag isn't actually set?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414737944", "createdAt": "2020-04-24T17:21:03Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -153,120 +153,87 @@ public void setErrorMeta(final Throwable error) {\n     final StringWriter errorString = new StringWriter();\n     error.printStackTrace(new PrintWriter(errorString));\n     setTag(DDTags.ERROR_STACK, errorString.toString());\n+\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, java.lang.String)\n-   */\n   @Override\n   public final DDSpan setTag(final String tag, final String value) {\n-    context().setTag(tag, (Object) value);\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, boolean)\n-   */\n   @Override\n   public final DDSpan setTag(final String tag, final boolean value) {\n-    context().setTag(tag, (Object) value);\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, java.lang.Number)\n-   */\n   @Override\n-  public final DDSpan setTag(final String tag, final Number value) {\n-    context().setTag(tag, (Object) value);\n+  public AgentSpan setTag(final String tag, final int value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n   @Override\n-  public <T> Span setTag(final Tag<T> tag, final T value) {\n-    context().setTag(tag.getKey(), value);\n+  public AgentSpan setTag(final String tag, final long value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#context()\n-   */\n   @Override\n-  public final DDSpanContext context() {\n-    return context;\n+  public AgentSpan setTag(final String tag, final double value) {\n+    context.setTag(tag, value);\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#getBaggageItem(java.lang.String)\n-   */\n   @Override\n-  public final String getBaggageItem(final String key) {\n-    return context.getBaggageItem(key);\n+  public DDSpan setTag(final String tag, final Number value) {\n+    context.setTag(tag, value);\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setBaggageItem(java.lang.String, java.lang.String)\n-   */\n-  @Override\n-  public final DDSpan setBaggageItem(final String key, final String value) {\n-    context.setBaggageItem(key, value);\n+  // FIXME [API] this is not on AgentSpan or MutableSpan\n+  public DDSpan setTag(final String tag, final Object value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setOperationName(java.lang.String)\n-   */\n-  @Override\n-  public final DDSpan setOperationName(final String operationName) {\n-    context().setOperationName(operationName);\n+  // FIXME [API] this is not on AgentSpan or MutableSpan\n+  public AgentSpan removeTag(final String tag) {\n+    context.setTag(tag, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTIyMQ==", "bodyText": "DDSpanContext already handled that case:\n  public synchronized void setTag(final String tag, final Object value) {\n    if (value == null || (value instanceof String && ((String) value).isEmpty())) {\n      tags.remove(tag);\n      return;\n    }\n    ...\n  }", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414841221", "createdAt": "2020-04-24T20:23:50Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -153,120 +153,87 @@ public void setErrorMeta(final Throwable error) {\n     final StringWriter errorString = new StringWriter();\n     error.printStackTrace(new PrintWriter(errorString));\n     setTag(DDTags.ERROR_STACK, errorString.toString());\n+\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, java.lang.String)\n-   */\n   @Override\n   public final DDSpan setTag(final String tag, final String value) {\n-    context().setTag(tag, (Object) value);\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, boolean)\n-   */\n   @Override\n   public final DDSpan setTag(final String tag, final boolean value) {\n-    context().setTag(tag, (Object) value);\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setTag(java.lang.String, java.lang.Number)\n-   */\n   @Override\n-  public final DDSpan setTag(final String tag, final Number value) {\n-    context().setTag(tag, (Object) value);\n+  public AgentSpan setTag(final String tag, final int value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n   @Override\n-  public <T> Span setTag(final Tag<T> tag, final T value) {\n-    context().setTag(tag.getKey(), value);\n+  public AgentSpan setTag(final String tag, final long value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#context()\n-   */\n   @Override\n-  public final DDSpanContext context() {\n-    return context;\n+  public AgentSpan setTag(final String tag, final double value) {\n+    context.setTag(tag, value);\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#getBaggageItem(java.lang.String)\n-   */\n   @Override\n-  public final String getBaggageItem(final String key) {\n-    return context.getBaggageItem(key);\n+  public DDSpan setTag(final String tag, final Number value) {\n+    context.setTag(tag, value);\n+    return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setBaggageItem(java.lang.String, java.lang.String)\n-   */\n-  @Override\n-  public final DDSpan setBaggageItem(final String key, final String value) {\n-    context.setBaggageItem(key, value);\n+  // FIXME [API] this is not on AgentSpan or MutableSpan\n+  public DDSpan setTag(final String tag, final Object value) {\n+    context.setTag(tag, value);\n     return this;\n   }\n \n-  /* (non-Javadoc)\n-   * @see io.opentracing.BaseSpan#setOperationName(java.lang.String)\n-   */\n-  @Override\n-  public final DDSpan setOperationName(final String operationName) {\n-    context().setOperationName(operationName);\n+  // FIXME [API] this is not on AgentSpan or MutableSpan\n+  public AgentSpan removeTag(final String tag) {\n+    context.setTag(tag, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDczNzk0NA=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODIyNzQ3OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/DDScopeManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzoyODo0MlrOGLh4-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMToxNjoyNFrOGLpiKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0Mjc3OQ==", "bodyText": "why an interface?  Should we use the concrete type directly instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414742779", "createdAt": "2020-04-24T17:28:42Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/DDScopeManager.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package datadog.trace.core.scopemanager;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+\n+public interface DDScopeManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2NzQ3NA==", "bodyText": "It's necessary because we recently allowed custom io.opentracing.ScopeManager implementations, otherwise CoreTracer could use ContextualScopeManager directly.\nInstead:\nCoreTracer references DDScopeManager interface\nNormal case:\nCoreTracer.scopeManager = ContextualScopeManager\nDDTracer.scopeManager = OTScopeManager wrapping CoreTracer.scopeManager\nCustom case:\nCoreTracer.scopeManager = CustomScopeManager wrapping passed in scopemanager\nDDTracer.scopeManager = passed in scopemanager\nI'll add the above to javadoc to make it clearer", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414867474", "createdAt": "2020-04-24T21:15:24Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/DDScopeManager.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package datadog.trace.core.scopemanager;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+\n+public interface DDScopeManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0Mjc3OQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg2ODAxMQ==", "bodyText": "ah, ok thanks.  I forgot about that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414868011", "createdAt": "2020-04-24T21:16:24Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/DDScopeManager.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package datadog.trace.core.scopemanager;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+\n+public interface DDScopeManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0Mjc3OQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODI2MjAwOnYy", "diffSide": "RIGHT", "path": "internal-api/internal-api.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzozNzozN1rOGLiN0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMzozOTo0OFrOGLsubA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0ODExMw==", "bodyText": "Maybe a comment for why this module is here would be good", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414748113", "createdAt": "2020-04-24T17:37:37Z", "author": {"login": "devinsba"}, "path": "internal-api/internal-api.gradle", "diffHunk": "@@ -0,0 +1,5 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+dependencies {\n+  compile project(':dd-trace-api')\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDMwMA==", "bodyText": "added", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414920300", "createdAt": "2020-04-24T23:39:48Z", "author": {"login": "randomanderson"}, "path": "internal-api/internal-api.gradle", "diffHunk": "@@ -0,0 +1,5 @@\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+dependencies {\n+  compile project(':dd-trace-api')\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0ODExMw=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODI3MzU4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo0MDoyOFrOGLiUiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMzozOToxN1rOGLst_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0OTgzNQ==", "bodyText": "This got reverted...", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414749835", "createdAt": "2020-04-24T17:40:28Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanTest.groovy", "diffHunk": "@@ -169,6 +171,29 @@ class DDSpanTest extends DDSpecification {\n     span.durationNano == 1\n   }\n \n+  @Ignore\n+  def \"stacktrace captured when duration exceeds average + configured threshold\"() {\n+    setup:\n+    // Get the part of the stack before this test is called.\n+    def acceptRemaining = false\n+    def originalStack = Thread.currentThread().stackTrace\n+    def stackTraceElements = originalStack.dropWhile {\n+      if (it.className == ReflectionUtil.name) {\n+        acceptRemaining = true\n+      }\n+      return !acceptRemaining\n+    }\n+    def stack = \"\\tat \" + stackTraceElements.join(\"\\n\\tat \") + \"\\n\"\n+\n+    def span = tracer.buildSpan(\"test\").start()\n+    span.finish(span.startTimeMicro + DDSpan.AVG_DURATION.get() + TimeUnit.NANOSECONDS.toMicros(Config.get().spanDurationAboveAverageStacktraceNanos) + 1)\n+    def actual = span.tags[\"slow.stack\"].toString()\n+\n+    expect:\n+    !stack.isEmpty()\n+    actual.endsWith(stack)\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDE4OA==", "bodyText": "removed", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414920188", "createdAt": "2020-04-24T23:39:17Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/DDSpanTest.groovy", "diffHunk": "@@ -169,6 +171,29 @@ class DDSpanTest extends DDSpecification {\n     span.durationNano == 1\n   }\n \n+  @Ignore\n+  def \"stacktrace captured when duration exceeds average + configured threshold\"() {\n+    setup:\n+    // Get the part of the stack before this test is called.\n+    def acceptRemaining = false\n+    def originalStack = Thread.currentThread().stackTrace\n+    def stackTraceElements = originalStack.dropWhile {\n+      if (it.className == ReflectionUtil.name) {\n+        acceptRemaining = true\n+      }\n+      return !acceptRemaining\n+    }\n+    def stack = \"\\tat \" + stackTraceElements.join(\"\\n\\tat \") + \"\\n\"\n+\n+    def span = tracer.buildSpan(\"test\").start()\n+    span.finish(span.startTimeMicro + DDSpan.AVG_DURATION.get() + TimeUnit.NANOSECONDS.toMicros(Config.get().spanDurationAboveAverageStacktraceNanos) + 1)\n+    def actual = span.tags[\"slow.stack\"].toString()\n+\n+    expect:\n+    !stack.isEmpty()\n+    actual.endsWith(stack)\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0OTgzNQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODI4MzQ5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/dd-trace-core.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo0Mjo0OVrOGLiaYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMToyMDo1OVrOGLpqrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1MTMyOQ==", "bodyText": "I wonder if this is needed in the core or not. Could we put a noop interface here and provide this in the agent jar instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414751329", "createdAt": "2020-04-24T17:42:49Z", "author": {"login": "devinsba"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+description = 'dd-trace-core'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.core.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':internal-api')\n+  compile project(':utils:thread-utils')\n+\n+  compile group: 'com.datadoghq', name: 'java-dogstatsd-client', version: \"${versions.dogstatsd}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg3MDE4OA==", "bodyText": "I think it's necessary.  We probably want Writer stats whether or not the agent is install.  I know there are plans to add more statistics", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414870188", "createdAt": "2020-04-24T21:20:59Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/dd-trace-core.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+description = 'dd-trace-core'\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+apply from: \"${rootDir}/gradle/publish.gradle\"\n+\n+minimumBranchCoverage = 0.5\n+minimumInstructionCoverage = 0.6\n+excludedClassesCoverage += [\n+  'datadog.trace.common.writer.ListWriter',\n+  'datadog.trace.common.writer.LoggingWriter',\n+  'datadog.trace.common.writer.DDAgentWriter.DDAgentWriterBuilder',\n+  'datadog.trace.common.sampling.PrioritySampling',\n+  // This code is copied from okHttp samples and we have integration tests to verify that it works.\n+  'datadog.trace.common.writer.unixdomainsockets.TunnelingUnixSocket',\n+  'datadog.trace.common.writer.unixdomainsockets.UnixDomainSocketFactory',\n+  'datadog.trace.core.StringCachingBigInteger'\n+]\n+\n+apply plugin: 'org.unbroken-dome.test-sets'\n+\n+testSets {\n+  traceAgentTest\n+}\n+\n+dependencies {\n+  annotationProcessor deps.autoservice\n+  implementation deps.autoservice\n+\n+  compile project(':dd-trace-api')\n+  compile project(':internal-api')\n+  compile project(':utils:thread-utils')\n+\n+  compile group: 'com.datadoghq', name: 'java-dogstatsd-client', version: \"${versions.dogstatsd}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1MTMyOQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODMxMjI4OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/dd-trace-ot.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo0OTo1NlrOGLirLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoxMjozMVrOGLnjJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1NTYyOQ==", "bodyText": "Not really sure how this works, but it seems ok... I assume you've reviewed a diff of the resulting pom to be sure?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414755629", "createdAt": "2020-04-24T17:49:56Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -93,13 +73,36 @@ shadowJar {\n   archiveClassifier = ''\n \n   dependencies {\n+    include(project(':dd-trace-core'))\n+    include(project(':internal-api'))\n     include(project(':utils:thread-utils'))\n   }\n }\n \n-// We don't want bundled dependencies to show up in the pom.\n modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }\n+  // We're bundling the internal dependencies.  So we need to add the transitive dependencies\n+  // of those projects. Directly adding to the XML is the only way to prevent the shadowJar plugin\n+  // from removing them", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNTQ5Mw==", "bodyText": "Yes, I reviewed the generated pom.  No amount of config wrangling could get the final pom to the correct state so I resorted to writing the dependency nodes manually.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414835493", "createdAt": "2020-04-24T20:12:31Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/dd-trace-ot.gradle", "diffHunk": "@@ -93,13 +73,36 @@ shadowJar {\n   archiveClassifier = ''\n \n   dependencies {\n+    include(project(':dd-trace-core'))\n+    include(project(':internal-api'))\n     include(project(':utils:thread-utils'))\n   }\n }\n \n-// We don't want bundled dependencies to show up in the pom.\n modifyPom {\n-  dependencies.removeAll { it.artifactId == \"thread-utils\" }\n+  // We're bundling the internal dependencies.  So we need to add the transitive dependencies\n+  // of those projects. Directly adding to the XML is the only way to prevent the shadowJar plugin\n+  // from removing them", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1NTYyOQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODMyMDMyOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/jmh/java/datadog/trace/DDTraceBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo1MTo1MlrOGLiv0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo1MTo1MlrOGLiv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1NjgxOA==", "bodyText": "The problem with this is it breaks backwards compatibility of the test.  We can't test older versions.  Not a deal breaker, just something to consider.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414756818", "createdAt": "2020-04-24T17:51:52Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/jmh/java/datadog/trace/DDTraceBenchmark.java", "diffHunk": "@@ -13,7 +13,7 @@\n   @State(org.openjdk.jmh.annotations.Scope.Thread)\n   public static class TraceState {\n     public ListWriter traceCollector = new ListWriter();\n-    public Tracer tracer = new DDTracer(traceCollector);\n+    public Tracer tracer = DDTracer.builder().writer(traceCollector).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODM1MjgyOnYy", "diffSide": "LEFT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo1OTo0NFrOGLjCtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMDoxMTowM1rOGLngBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2MTY1NQ==", "bodyText": "Why remove this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414761655", "createdAt": "2020-04-24T17:59:44Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -109,100 +55,57 @@ public DDTracerBuilder() {\n     public DDTracerBuilder withProperties(final Properties properties) {\n       return config(Config.get(properties));\n     }\n-\n-    public DDTracerBuilder config(final Config config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDY5NA==", "bodyText": "A default config(...) still exists on the builder from the Lombok.  The custom config(..) is still on CoreTracer.  Since the DDTracer constructor just calls the CoreTracer builder, the custom code only needs to be in one place.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414834694", "createdAt": "2020-04-24T20:11:03Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -109,100 +55,57 @@ public DDTracerBuilder() {\n     public DDTracerBuilder withProperties(final Properties properties) {\n       return config(Config.get(properties));\n     }\n-\n-    public DDTracerBuilder config(final Config config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2MTY1NQ=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3ODM3NjY4OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODowNTo0OFrOGLjQ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMzo0MTo0N1rOGLswxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2NTI4OA==", "bodyText": "DDTracer is a pretty large file.  Do these need to be nested classes?  It might make sense to split some of them out into separate files (but still package private).", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414765288", "createdAt": "2020-04-24T18:05:48Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -411,466 +305,668 @@ public Scope activateSpan(final Span span) {\n   }\n \n   @Override\n-  public SpanBuilder buildSpan(final String operationName) {\n-    return new DDSpanBuilder(operationName, scopeManager);\n+  public DDSpanBuilder buildSpan(final String operationName) {\n+    return new DDSpanBuilder(operationName);\n   }\n \n   @Override\n-  public <T> void inject(final SpanContext spanContext, final Format<T> format, final T carrier) {\n+  public <C> void inject(final SpanContext spanContext, final Format<C> format, final C carrier) {\n     if (carrier instanceof TextMapInject) {\n-      final DDSpanContext ddSpanContext = (DDSpanContext) spanContext;\n+      final AgentSpan.Context context = converter.toContext(spanContext);\n \n-      final DDSpan rootSpan = ddSpanContext.getTrace().getRootSpan();\n-      setSamplingPriorityIfNecessary(rootSpan);\n-\n-      injector.inject(ddSpanContext, (TextMapInject) carrier);\n+      coreTracer.inject(context, (TextMapInject) carrier, TextMapInjectSetter.INSTANCE);\n     } else {\n       log.debug(\"Unsupported format for propagation - {}\", format.getClass().getName());\n     }\n   }\n \n   @Override\n-  public <T> SpanContext extract(final Format<T> format, final T carrier) {\n+  public <C> SpanContext extract(final Format<C> format, final C carrier) {\n     if (carrier instanceof TextMapExtract) {\n-      return extractor.extract((TextMapExtract) carrier);\n+      final TagContext tagContext =\n+          coreTracer.extract(\n+              (TextMapExtract) carrier, new TextMapExtractGetter((TextMapExtract) carrier));\n+\n+      return converter.toSpanContext(tagContext);\n     } else {\n       log.debug(\"Unsupported format for propagation - {}\", format.getClass().getName());\n       return null;\n     }\n   }\n \n-  /**\n-   * We use the sampler to know if the trace has to be reported/written. The sampler is called on\n-   * the first span (root span) of the trace. If the trace is marked as a sample, we report it.\n-   *\n-   * @param trace a list of the spans related to the same trace\n-   */\n-  void write(final Collection<DDSpan> trace) {\n-    if (trace.isEmpty()) {\n-      return;\n-    }\n-    final ArrayList<DDSpan> writtenTrace;\n-    if (interceptors.isEmpty()) {\n-      writtenTrace = new ArrayList<>(trace);\n-    } else {\n-      Collection<? extends MutableSpan> interceptedTrace = new ArrayList<>(trace);\n-      for (final TraceInterceptor interceptor : interceptors) {\n-        interceptedTrace = interceptor.onTraceComplete(interceptedTrace);\n-      }\n-      writtenTrace = new ArrayList<>(interceptedTrace.size());\n-      for (final MutableSpan span : interceptedTrace) {\n-        if (span instanceof DDSpan) {\n-          writtenTrace.add((DDSpan) span);\n-        }\n-      }\n-    }\n-    incrementTraceCount();\n+  @Override\n+  public void close() {\n+    coreTracer.close();\n+  }\n \n-    if (!writtenTrace.isEmpty()) {\n-      final DDSpan rootSpan = (DDSpan) writtenTrace.get(0).getLocalRootSpan();\n-      setSamplingPriorityIfNecessary(rootSpan);\n+  private static class TextMapInjectSetter implements AgentPropagation.Setter<TextMapInject> {\n+    static final TextMapInjectSetter INSTANCE = new TextMapInjectSetter();\n \n-      final DDSpan spanToSample = rootSpan == null ? writtenTrace.get(0) : rootSpan;\n-      if (sampler.sample(spanToSample)) {\n-        writer.write(writtenTrace);\n-      }\n+    @Override\n+    public void set(final TextMapInject carrier, final String key, final String value) {\n+      carrier.put(key, value);\n     }\n   }\n \n-  void setSamplingPriorityIfNecessary(final DDSpan rootSpan) {\n-    // There's a race where multiple threads can see PrioritySampling.UNSET here\n-    // This check skips potential complex sampling priority logic when we know its redundant\n-    // Locks inside DDSpanContext ensure the correct behavior in the race case\n+  private static class TextMapExtractGetter implements AgentPropagation.Getter<TextMapExtract> {\n+    private final Map<String, String> extracted = new HashMap<>();\n \n-    if (sampler instanceof PrioritySampler\n-        && rootSpan != null\n-        && rootSpan.context().getSamplingPriority() == PrioritySampling.UNSET) {\n+    private TextMapExtractGetter(final TextMapExtract carrier) {\n+      for (final Entry<String, String> entry : carrier) {\n+        extracted.put(entry.getKey(), entry.getValue());\n+      }\n+    }\n \n-      ((PrioritySampler) sampler).setSamplingPriority(rootSpan);\n+    @Override\n+    public Iterable<String> keys(final TextMapExtract carrier) {\n+      return extracted.keySet();\n     }\n-  }\n \n-  /** Increment the reported trace count, but do not write a trace. */\n-  void incrementTraceCount() {\n-    writer.incrementTraceCount();\n+    @Override\n+    public String get(final TextMapExtract carrier, final String key) {\n+      // This is the same as the one passed into the constructor\n+      // So using \"extracted\" is valid\n+      return extracted.get(key);\n+    }\n   }\n \n-  @Override\n-  public String getTraceId() {\n-    final Span activeSpan = activeSpan();\n-    if (activeSpan instanceof DDSpan) {\n-      return ((DDSpan) activeSpan).getTraceId().toString();\n+  // Centralized place to do conversions\n+  private class Converter {\n+    // TODO maybe add caching to reduce new objects being created\n+\n+    public AgentSpan toAgentSpan(final Span span) {\n+      if (span instanceof OTSpan) {\n+        return ((OTSpan) span).delegate;\n+      } else {\n+        // NOOP Span\n+        return NoopAgentSpan.INSTANCE;\n+      }\n     }\n-    return \"0\";\n-  }\n \n-  @Override\n-  public String getSpanId() {\n-    final Span activeSpan = activeSpan();\n-    if (activeSpan instanceof DDSpan) {\n-      return ((DDSpan) activeSpan).getSpanId().toString();\n+    public Span toSpan(final AgentSpan agentSpan) {\n+      if (agentSpan instanceof DDSpan) {\n+        return new OTSpan((DDSpan) agentSpan);\n+      } else {\n+        // NOOP AgentSpans\n+        return NoopSpan.INSTANCE;\n+      }\n     }\n-    return \"0\";\n-  }\n \n-  @Override\n-  public boolean addTraceInterceptor(final TraceInterceptor interceptor) {\n-    return interceptors.add(interceptor);\n-  }\n+    // FIXME [API] Need to use the runtime type not compile-time type so \"Object\" is used\n+    // That fact that some methods return AgentScope and other TraceScope even though its the same\n+    // underlying object needs to be cleaned up\n+    public Scope toScope(final Object scope) {\n+      if (scope instanceof CustomScopeManagerScope) {\n+        return ((CustomScopeManagerScope) scope).delegate;\n+      } else if (scope instanceof TraceScope) {\n+        return new OTTraceScope((TraceScope) scope);\n+      } else {\n+        return new OTScope((AgentScope) scope);\n+      }\n+    }\n \n-  @Override\n-  public void addScopeListener(final ScopeListener listener) {\n-    if (scopeManager instanceof ContextualScopeManager) {\n-      ((ContextualScopeManager) scopeManager).addScopeListener(listener);\n+    public SpanContext toSpanContext(final DDSpanContext context) {\n+      return new OTGenericContext(context);\n     }\n-  }\n \n-  @Override\n-  public void close() {\n-    PendingTrace.close();\n-    writer.close();\n-  }\n+    public SpanContext toSpanContext(final TagContext tagContext) {\n+      if (tagContext instanceof ExtractedContext) {\n+        return new OTExtractedContext((ExtractedContext) tagContext);\n+      } else {\n+        return new OTTagContext(tagContext);\n+      }\n+    }\n \n-  @Override\n-  public String toString() {\n-    return \"DDTracer-\"\n-        + Integer.toHexString(hashCode())\n-        + \"{ serviceName=\"\n-        + serviceName\n-        + \", writer=\"\n-        + writer\n-        + \", sampler=\"\n-        + sampler\n-        + \", defaultSpanTags=\"\n-        + defaultSpanTags\n-        + '}';\n+    public AgentSpan.Context toContext(final SpanContext spanContext) {\n+      // FIXME: [API] DDSpanContext, ExtractedContext, TagContext, AgentSpan.Context\n+      // don't share a meaningful hierarchy\n+      if (spanContext instanceof OTGenericContext) {\n+        return ((OTGenericContext) spanContext).delegate;\n+      } else if (spanContext instanceof OTExtractedContext) {\n+        return ((OTExtractedContext) spanContext).extractedContext;\n+      } else if (spanContext instanceof OTTagContext) {\n+        return ((OTTagContext) spanContext).delegate;\n+      } else {\n+        return AgentTracer.NoopContext.INSTANCE;\n+      }\n+    }\n   }\n \n-  @Deprecated\n-  private static Map<String, String> customRuntimeTags(\n-      final String runtimeId, final Map<String, String> applicationRootSpanTags) {\n-    final Map<String, String> runtimeTags = new HashMap<>(applicationRootSpanTags);\n-    runtimeTags.put(Config.RUNTIME_ID_TAG, runtimeId);\n-    return Collections.unmodifiableMap(runtimeTags);\n-  }\n+  public class DDSpanBuilder implements SpanBuilder {\n+    private final CoreSpanBuilder delegate;\n \n-  private static DDScopeEventFactory createScopeEventFactory() {\n-    try {\n-      return (DDScopeEventFactory)\n-          Class.forName(\"datadog.opentracing.jfr.openjdk.ScopeEventFactory\").newInstance();\n-    } catch (final ClassFormatError | ReflectiveOperationException | NoClassDefFoundError e) {\n-      log.debug(\"Cannot create Openjdk JFR scope event factory\", e);\n+    public DDSpanBuilder(final String operationName) {\n+      delegate = coreTracer.buildSpan(operationName);\n     }\n-    return new DDNoopScopeEventFactory();\n-  }\n \n-  /** Spans are built using this builder */\n-  public class DDSpanBuilder implements SpanBuilder {\n-    private final ScopeManager scopeManager;\n-\n-    /** Each span must have an operationName according to the opentracing specification */\n-    private final String operationName;\n-\n-    // Builder attributes\n-    private final Map<String, Object> tags = new LinkedHashMap<String, Object>(defaultSpanTags);\n-    private long timestampMicro;\n-    private SpanContext parent;\n-    private String serviceName;\n-    private String resourceName;\n-    private boolean errorFlag;\n-    private String spanType;\n-    private boolean ignoreScope = false;\n-    private LogHandler logHandler = new DefaultLogHandler();\n-\n-    public DDSpanBuilder(final String operationName, final ScopeManager scopeManager) {\n-      this.operationName = operationName;\n-      this.scopeManager = scopeManager;\n+    @Override\n+    public DDSpanBuilder asChildOf(final SpanContext parent) {\n+      delegate.asChildOf(converter.toContext(parent));\n+      return this;\n     }\n \n     @Override\n-    public SpanBuilder ignoreActiveSpan() {\n-      ignoreScope = true;\n+    public DDSpanBuilder asChildOf(final Span parent) {\n+      if (parent != null) {\n+        delegate.asChildOf(converter.toAgentSpan(parent).context());\n+      }\n       return this;\n     }\n \n-    private Span startSpan() {\n-      return new DDSpan(timestampMicro, buildSpanContext(), logHandler);\n+    @Override\n+    public DDSpanBuilder addReference(\n+        final String referenceType, final SpanContext referencedContext) {\n+      if (referencedContext == null) {\n+        return this;\n+      }\n+\n+      final AgentSpan.Context context = converter.toContext(referencedContext);\n+      if (!(context instanceof ExtractedContext) && !(context instanceof DDSpanContext)) {\n+        log.debug(\n+            \"Expected to have a DDSpanContext or ExtractedContext but got \"\n+                + context.getClass().getName());\n+        return this;\n+      }\n+\n+      if (References.CHILD_OF.equals(referenceType)\n+          || References.FOLLOWS_FROM.equals(referenceType)) {\n+        delegate.asChildOf(context);\n+      } else {\n+        log.debug(\"Only support reference type of CHILD_OF and FOLLOWS_FROM\");\n+      }\n+\n+      return this;\n     }\n \n     @Override\n-    public Scope startActive(final boolean finishSpanOnClose) {\n-      final Span span = startSpan();\n-      final Scope scope = scopeManager.activate(span, finishSpanOnClose);\n-      log.debug(\"Starting a new active span: {}\", span);\n-      return scope;\n+    public DDSpanBuilder ignoreActiveSpan() {\n+      delegate.ignoreActiveSpan();\n+      return this;\n     }\n \n     @Override\n-    @Deprecated\n-    public Span startManual() {\n-      return start();\n+    public DDSpanBuilder withTag(final String key, final String value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public Span start() {\n-      final Span span = startSpan();\n-      log.debug(\"Starting a new span: {}\", span);\n-      return span;\n+    public DDSpanBuilder withTag(final String key, final boolean value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final Number number) {\n-      return withTag(tag, (Object) number);\n+    public DDSpanBuilder withTag(final String key, final Number value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final String string) {\n-      return withTag(tag, (Object) string);\n+    public <T> DDSpanBuilder withTag(final Tag<T> tag, final T value) {\n+      delegate.withTag(tag.getKey(), value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final boolean bool) {\n-      return withTag(tag, (Object) bool);\n+    public DDSpanBuilder withStartTimestamp(final long microseconds) {\n+      delegate.withStartTimestamp(microseconds);\n+      return this;\n     }\n \n     @Override\n-    public <T> SpanBuilder withTag(final Tag<T> tag, final T value) {\n-      return withTag(tag.getKey(), value);\n+    public Span startManual() {\n+      return start();\n     }\n \n     @Override\n-    public DDSpanBuilder withStartTimestamp(final long timestampMicroseconds) {\n-      timestampMicro = timestampMicroseconds;\n-      return this;\n+    public Span start() {\n+      final AgentSpan agentSpan = delegate.start();\n+      return converter.toSpan(agentSpan);\n+    }\n+\n+    @Override\n+    public Scope startActive(final boolean finishSpanOnClose) {\n+      final AgentScope agentScope = delegate.startActive(finishSpanOnClose);\n+      return converter.toScope(agentScope);\n     }\n \n     public DDSpanBuilder withServiceName(final String serviceName) {\n-      this.serviceName = serviceName;\n+      delegate.withServiceName(serviceName);\n       return this;\n     }\n \n     public DDSpanBuilder withResourceName(final String resourceName) {\n-      this.resourceName = resourceName;\n+      delegate.withResourceName(resourceName);\n       return this;\n     }\n \n     public DDSpanBuilder withErrorFlag() {\n-      errorFlag = true;\n+      delegate.withErrorFlag();\n       return this;\n     }\n \n     public DDSpanBuilder withSpanType(final String spanType) {\n-      this.spanType = spanType;\n+      delegate.withSpanType(spanType);\n       return this;\n     }\n \n-    public Iterable<Map.Entry<String, String>> baggageItems() {\n-      if (parent == null) {\n-        return Collections.emptyList();\n-      }\n-      return parent.baggageItems();\n-    }\n-\n     public DDSpanBuilder withLogHandler(final LogHandler logHandler) {\n       if (logHandler != null) {\n-        this.logHandler = logHandler;\n+        DDTracer.this.logHandler = logHandler;\n       }\n       return this;\n     }\n+  }\n+\n+  /** Allows custom scope managers to be passed in to constructor */\n+  private class CustomScopeManager implements DDScopeManager {\n+    private final ScopeManager delegate;\n+\n+    private CustomScopeManager(final ScopeManager scopeManager) {\n+      this.delegate = scopeManager;\n+    }\n \n     @Override\n-    public DDSpanBuilder asChildOf(final Span span) {\n-      return asChildOf(span == null ? null : span.context());\n+    public AgentScope activate(final AgentSpan agentSpan, final boolean finishOnClose) {\n+      final Span span = converter.toSpan(agentSpan);\n+      final Scope scope = delegate.activate(span, finishOnClose);\n+\n+      return new CustomScopeManagerScope(scope);\n     }\n \n     @Override\n-    public DDSpanBuilder asChildOf(final SpanContext spanContext) {\n-      parent = spanContext;\n-      return this;\n+    public TraceScope active() {\n+      return new CustomScopeManagerScope(delegate.active());\n     }\n \n     @Override\n-    public DDSpanBuilder addReference(final String referenceType, final SpanContext spanContext) {\n-      if (spanContext == null) {\n-        return this;\n-      }\n-      if (!(spanContext instanceof ExtractedContext) && !(spanContext instanceof DDSpanContext)) {\n-        log.debug(\n-            \"Expected to have a DDSpanContext or ExtractedContext but got \"\n-                + spanContext.getClass().getName());\n-        return this;\n+    public AgentSpan activeSpan() {\n+      return converter.toAgentSpan(delegate.activeSpan());\n+    }\n+  }\n+\n+  private class CustomScopeManagerScope implements AgentScope, TraceScope {\n+    private final Scope delegate;\n+    private final boolean traceScope;\n+\n+    private CustomScopeManagerScope(final Scope delegate) {\n+      this.delegate = delegate;\n+\n+      // Handle case where the custom scope manager returns TraceScopes\n+      traceScope = delegate instanceof TraceScope;\n+    }\n+\n+    @Override\n+    public AgentSpan span() {\n+      return converter.toAgentSpan(delegate.span());\n+    }\n+\n+    @Override\n+    public void setAsyncPropagation(final boolean value) {\n+      if (traceScope) {\n+        ((TraceScope) delegate).setAsyncPropagation(value);\n       }\n-      if (References.CHILD_OF.equals(referenceType)\n-          || References.FOLLOWS_FROM.equals(referenceType)) {\n-        return asChildOf(spanContext);\n+    }\n+\n+    @Override\n+    public boolean isAsyncPropagating() {\n+      return traceScope && ((TraceScope) delegate).isAsyncPropagating();\n+    }\n+\n+    @Override\n+    public Continuation capture() {\n+      if (traceScope) {\n+        return ((TraceScope) delegate).capture();\n       } else {\n-        log.debug(\"Only support reference type of CHILD_OF and FOLLOWS_FROM\");\n+        return null;\n       }\n-      return this;\n     }\n \n-    // Private methods\n-    private DDSpanBuilder withTag(final String tag, final Object value) {\n-      if (value == null || (value instanceof String && ((String) value).isEmpty())) {\n-        tags.remove(tag);\n-      } else {\n-        tags.put(tag, value);\n+    @Override\n+    public void close() {\n+      delegate.close();\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+      if (this == o) {\n+        return true;\n       }\n-      return this;\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      final CustomScopeManagerScope that = (CustomScopeManagerScope) o;\n+      return delegate.equals(that.delegate);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(delegate);\n+    }\n+  }\n+\n+  private class OTScopeManager implements ScopeManager {\n+    @Override\n+    public Scope activate(final Span span) {\n+      return activate(span, false);\n+    }\n+\n+    @Override\n+    public Scope activate(final Span span, final boolean finishSpanOnClose) {\n+      final AgentSpan agentSpan = converter.toAgentSpan(span);\n+      final AgentScope agentScope = coreTracer.activateSpan(agentSpan, finishSpanOnClose);\n+\n+      return converter.toScope(agentScope);\n+    }\n+\n+    @Override\n+    public Scope active() {\n+      return converter.toScope(coreTracer.activeScope());\n+    }\n+\n+    @Override\n+    public Span activeSpan() {\n+      return converter.toSpan(coreTracer.activeSpan());\n+    }\n+  }\n+\n+  private class OTGenericContext implements SpanContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 1082}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMDkwMw==", "bodyText": "I pulled most of the classes out.  Still a big class though. ~200 lines of just constructors", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r414920903", "createdAt": "2020-04-24T23:41:47Z", "author": {"login": "randomanderson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -411,466 +305,668 @@ public Scope activateSpan(final Span span) {\n   }\n \n   @Override\n-  public SpanBuilder buildSpan(final String operationName) {\n-    return new DDSpanBuilder(operationName, scopeManager);\n+  public DDSpanBuilder buildSpan(final String operationName) {\n+    return new DDSpanBuilder(operationName);\n   }\n \n   @Override\n-  public <T> void inject(final SpanContext spanContext, final Format<T> format, final T carrier) {\n+  public <C> void inject(final SpanContext spanContext, final Format<C> format, final C carrier) {\n     if (carrier instanceof TextMapInject) {\n-      final DDSpanContext ddSpanContext = (DDSpanContext) spanContext;\n+      final AgentSpan.Context context = converter.toContext(spanContext);\n \n-      final DDSpan rootSpan = ddSpanContext.getTrace().getRootSpan();\n-      setSamplingPriorityIfNecessary(rootSpan);\n-\n-      injector.inject(ddSpanContext, (TextMapInject) carrier);\n+      coreTracer.inject(context, (TextMapInject) carrier, TextMapInjectSetter.INSTANCE);\n     } else {\n       log.debug(\"Unsupported format for propagation - {}\", format.getClass().getName());\n     }\n   }\n \n   @Override\n-  public <T> SpanContext extract(final Format<T> format, final T carrier) {\n+  public <C> SpanContext extract(final Format<C> format, final C carrier) {\n     if (carrier instanceof TextMapExtract) {\n-      return extractor.extract((TextMapExtract) carrier);\n+      final TagContext tagContext =\n+          coreTracer.extract(\n+              (TextMapExtract) carrier, new TextMapExtractGetter((TextMapExtract) carrier));\n+\n+      return converter.toSpanContext(tagContext);\n     } else {\n       log.debug(\"Unsupported format for propagation - {}\", format.getClass().getName());\n       return null;\n     }\n   }\n \n-  /**\n-   * We use the sampler to know if the trace has to be reported/written. The sampler is called on\n-   * the first span (root span) of the trace. If the trace is marked as a sample, we report it.\n-   *\n-   * @param trace a list of the spans related to the same trace\n-   */\n-  void write(final Collection<DDSpan> trace) {\n-    if (trace.isEmpty()) {\n-      return;\n-    }\n-    final ArrayList<DDSpan> writtenTrace;\n-    if (interceptors.isEmpty()) {\n-      writtenTrace = new ArrayList<>(trace);\n-    } else {\n-      Collection<? extends MutableSpan> interceptedTrace = new ArrayList<>(trace);\n-      for (final TraceInterceptor interceptor : interceptors) {\n-        interceptedTrace = interceptor.onTraceComplete(interceptedTrace);\n-      }\n-      writtenTrace = new ArrayList<>(interceptedTrace.size());\n-      for (final MutableSpan span : interceptedTrace) {\n-        if (span instanceof DDSpan) {\n-          writtenTrace.add((DDSpan) span);\n-        }\n-      }\n-    }\n-    incrementTraceCount();\n+  @Override\n+  public void close() {\n+    coreTracer.close();\n+  }\n \n-    if (!writtenTrace.isEmpty()) {\n-      final DDSpan rootSpan = (DDSpan) writtenTrace.get(0).getLocalRootSpan();\n-      setSamplingPriorityIfNecessary(rootSpan);\n+  private static class TextMapInjectSetter implements AgentPropagation.Setter<TextMapInject> {\n+    static final TextMapInjectSetter INSTANCE = new TextMapInjectSetter();\n \n-      final DDSpan spanToSample = rootSpan == null ? writtenTrace.get(0) : rootSpan;\n-      if (sampler.sample(spanToSample)) {\n-        writer.write(writtenTrace);\n-      }\n+    @Override\n+    public void set(final TextMapInject carrier, final String key, final String value) {\n+      carrier.put(key, value);\n     }\n   }\n \n-  void setSamplingPriorityIfNecessary(final DDSpan rootSpan) {\n-    // There's a race where multiple threads can see PrioritySampling.UNSET here\n-    // This check skips potential complex sampling priority logic when we know its redundant\n-    // Locks inside DDSpanContext ensure the correct behavior in the race case\n+  private static class TextMapExtractGetter implements AgentPropagation.Getter<TextMapExtract> {\n+    private final Map<String, String> extracted = new HashMap<>();\n \n-    if (sampler instanceof PrioritySampler\n-        && rootSpan != null\n-        && rootSpan.context().getSamplingPriority() == PrioritySampling.UNSET) {\n+    private TextMapExtractGetter(final TextMapExtract carrier) {\n+      for (final Entry<String, String> entry : carrier) {\n+        extracted.put(entry.getKey(), entry.getValue());\n+      }\n+    }\n \n-      ((PrioritySampler) sampler).setSamplingPriority(rootSpan);\n+    @Override\n+    public Iterable<String> keys(final TextMapExtract carrier) {\n+      return extracted.keySet();\n     }\n-  }\n \n-  /** Increment the reported trace count, but do not write a trace. */\n-  void incrementTraceCount() {\n-    writer.incrementTraceCount();\n+    @Override\n+    public String get(final TextMapExtract carrier, final String key) {\n+      // This is the same as the one passed into the constructor\n+      // So using \"extracted\" is valid\n+      return extracted.get(key);\n+    }\n   }\n \n-  @Override\n-  public String getTraceId() {\n-    final Span activeSpan = activeSpan();\n-    if (activeSpan instanceof DDSpan) {\n-      return ((DDSpan) activeSpan).getTraceId().toString();\n+  // Centralized place to do conversions\n+  private class Converter {\n+    // TODO maybe add caching to reduce new objects being created\n+\n+    public AgentSpan toAgentSpan(final Span span) {\n+      if (span instanceof OTSpan) {\n+        return ((OTSpan) span).delegate;\n+      } else {\n+        // NOOP Span\n+        return NoopAgentSpan.INSTANCE;\n+      }\n     }\n-    return \"0\";\n-  }\n \n-  @Override\n-  public String getSpanId() {\n-    final Span activeSpan = activeSpan();\n-    if (activeSpan instanceof DDSpan) {\n-      return ((DDSpan) activeSpan).getSpanId().toString();\n+    public Span toSpan(final AgentSpan agentSpan) {\n+      if (agentSpan instanceof DDSpan) {\n+        return new OTSpan((DDSpan) agentSpan);\n+      } else {\n+        // NOOP AgentSpans\n+        return NoopSpan.INSTANCE;\n+      }\n     }\n-    return \"0\";\n-  }\n \n-  @Override\n-  public boolean addTraceInterceptor(final TraceInterceptor interceptor) {\n-    return interceptors.add(interceptor);\n-  }\n+    // FIXME [API] Need to use the runtime type not compile-time type so \"Object\" is used\n+    // That fact that some methods return AgentScope and other TraceScope even though its the same\n+    // underlying object needs to be cleaned up\n+    public Scope toScope(final Object scope) {\n+      if (scope instanceof CustomScopeManagerScope) {\n+        return ((CustomScopeManagerScope) scope).delegate;\n+      } else if (scope instanceof TraceScope) {\n+        return new OTTraceScope((TraceScope) scope);\n+      } else {\n+        return new OTScope((AgentScope) scope);\n+      }\n+    }\n \n-  @Override\n-  public void addScopeListener(final ScopeListener listener) {\n-    if (scopeManager instanceof ContextualScopeManager) {\n-      ((ContextualScopeManager) scopeManager).addScopeListener(listener);\n+    public SpanContext toSpanContext(final DDSpanContext context) {\n+      return new OTGenericContext(context);\n     }\n-  }\n \n-  @Override\n-  public void close() {\n-    PendingTrace.close();\n-    writer.close();\n-  }\n+    public SpanContext toSpanContext(final TagContext tagContext) {\n+      if (tagContext instanceof ExtractedContext) {\n+        return new OTExtractedContext((ExtractedContext) tagContext);\n+      } else {\n+        return new OTTagContext(tagContext);\n+      }\n+    }\n \n-  @Override\n-  public String toString() {\n-    return \"DDTracer-\"\n-        + Integer.toHexString(hashCode())\n-        + \"{ serviceName=\"\n-        + serviceName\n-        + \", writer=\"\n-        + writer\n-        + \", sampler=\"\n-        + sampler\n-        + \", defaultSpanTags=\"\n-        + defaultSpanTags\n-        + '}';\n+    public AgentSpan.Context toContext(final SpanContext spanContext) {\n+      // FIXME: [API] DDSpanContext, ExtractedContext, TagContext, AgentSpan.Context\n+      // don't share a meaningful hierarchy\n+      if (spanContext instanceof OTGenericContext) {\n+        return ((OTGenericContext) spanContext).delegate;\n+      } else if (spanContext instanceof OTExtractedContext) {\n+        return ((OTExtractedContext) spanContext).extractedContext;\n+      } else if (spanContext instanceof OTTagContext) {\n+        return ((OTTagContext) spanContext).delegate;\n+      } else {\n+        return AgentTracer.NoopContext.INSTANCE;\n+      }\n+    }\n   }\n \n-  @Deprecated\n-  private static Map<String, String> customRuntimeTags(\n-      final String runtimeId, final Map<String, String> applicationRootSpanTags) {\n-    final Map<String, String> runtimeTags = new HashMap<>(applicationRootSpanTags);\n-    runtimeTags.put(Config.RUNTIME_ID_TAG, runtimeId);\n-    return Collections.unmodifiableMap(runtimeTags);\n-  }\n+  public class DDSpanBuilder implements SpanBuilder {\n+    private final CoreSpanBuilder delegate;\n \n-  private static DDScopeEventFactory createScopeEventFactory() {\n-    try {\n-      return (DDScopeEventFactory)\n-          Class.forName(\"datadog.opentracing.jfr.openjdk.ScopeEventFactory\").newInstance();\n-    } catch (final ClassFormatError | ReflectiveOperationException | NoClassDefFoundError e) {\n-      log.debug(\"Cannot create Openjdk JFR scope event factory\", e);\n+    public DDSpanBuilder(final String operationName) {\n+      delegate = coreTracer.buildSpan(operationName);\n     }\n-    return new DDNoopScopeEventFactory();\n-  }\n \n-  /** Spans are built using this builder */\n-  public class DDSpanBuilder implements SpanBuilder {\n-    private final ScopeManager scopeManager;\n-\n-    /** Each span must have an operationName according to the opentracing specification */\n-    private final String operationName;\n-\n-    // Builder attributes\n-    private final Map<String, Object> tags = new LinkedHashMap<String, Object>(defaultSpanTags);\n-    private long timestampMicro;\n-    private SpanContext parent;\n-    private String serviceName;\n-    private String resourceName;\n-    private boolean errorFlag;\n-    private String spanType;\n-    private boolean ignoreScope = false;\n-    private LogHandler logHandler = new DefaultLogHandler();\n-\n-    public DDSpanBuilder(final String operationName, final ScopeManager scopeManager) {\n-      this.operationName = operationName;\n-      this.scopeManager = scopeManager;\n+    @Override\n+    public DDSpanBuilder asChildOf(final SpanContext parent) {\n+      delegate.asChildOf(converter.toContext(parent));\n+      return this;\n     }\n \n     @Override\n-    public SpanBuilder ignoreActiveSpan() {\n-      ignoreScope = true;\n+    public DDSpanBuilder asChildOf(final Span parent) {\n+      if (parent != null) {\n+        delegate.asChildOf(converter.toAgentSpan(parent).context());\n+      }\n       return this;\n     }\n \n-    private Span startSpan() {\n-      return new DDSpan(timestampMicro, buildSpanContext(), logHandler);\n+    @Override\n+    public DDSpanBuilder addReference(\n+        final String referenceType, final SpanContext referencedContext) {\n+      if (referencedContext == null) {\n+        return this;\n+      }\n+\n+      final AgentSpan.Context context = converter.toContext(referencedContext);\n+      if (!(context instanceof ExtractedContext) && !(context instanceof DDSpanContext)) {\n+        log.debug(\n+            \"Expected to have a DDSpanContext or ExtractedContext but got \"\n+                + context.getClass().getName());\n+        return this;\n+      }\n+\n+      if (References.CHILD_OF.equals(referenceType)\n+          || References.FOLLOWS_FROM.equals(referenceType)) {\n+        delegate.asChildOf(context);\n+      } else {\n+        log.debug(\"Only support reference type of CHILD_OF and FOLLOWS_FROM\");\n+      }\n+\n+      return this;\n     }\n \n     @Override\n-    public Scope startActive(final boolean finishSpanOnClose) {\n-      final Span span = startSpan();\n-      final Scope scope = scopeManager.activate(span, finishSpanOnClose);\n-      log.debug(\"Starting a new active span: {}\", span);\n-      return scope;\n+    public DDSpanBuilder ignoreActiveSpan() {\n+      delegate.ignoreActiveSpan();\n+      return this;\n     }\n \n     @Override\n-    @Deprecated\n-    public Span startManual() {\n-      return start();\n+    public DDSpanBuilder withTag(final String key, final String value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public Span start() {\n-      final Span span = startSpan();\n-      log.debug(\"Starting a new span: {}\", span);\n-      return span;\n+    public DDSpanBuilder withTag(final String key, final boolean value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final Number number) {\n-      return withTag(tag, (Object) number);\n+    public DDSpanBuilder withTag(final String key, final Number value) {\n+      delegate.withTag(key, value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final String string) {\n-      return withTag(tag, (Object) string);\n+    public <T> DDSpanBuilder withTag(final Tag<T> tag, final T value) {\n+      delegate.withTag(tag.getKey(), value);\n+      return this;\n     }\n \n     @Override\n-    public DDSpanBuilder withTag(final String tag, final boolean bool) {\n-      return withTag(tag, (Object) bool);\n+    public DDSpanBuilder withStartTimestamp(final long microseconds) {\n+      delegate.withStartTimestamp(microseconds);\n+      return this;\n     }\n \n     @Override\n-    public <T> SpanBuilder withTag(final Tag<T> tag, final T value) {\n-      return withTag(tag.getKey(), value);\n+    public Span startManual() {\n+      return start();\n     }\n \n     @Override\n-    public DDSpanBuilder withStartTimestamp(final long timestampMicroseconds) {\n-      timestampMicro = timestampMicroseconds;\n-      return this;\n+    public Span start() {\n+      final AgentSpan agentSpan = delegate.start();\n+      return converter.toSpan(agentSpan);\n+    }\n+\n+    @Override\n+    public Scope startActive(final boolean finishSpanOnClose) {\n+      final AgentScope agentScope = delegate.startActive(finishSpanOnClose);\n+      return converter.toScope(agentScope);\n     }\n \n     public DDSpanBuilder withServiceName(final String serviceName) {\n-      this.serviceName = serviceName;\n+      delegate.withServiceName(serviceName);\n       return this;\n     }\n \n     public DDSpanBuilder withResourceName(final String resourceName) {\n-      this.resourceName = resourceName;\n+      delegate.withResourceName(resourceName);\n       return this;\n     }\n \n     public DDSpanBuilder withErrorFlag() {\n-      errorFlag = true;\n+      delegate.withErrorFlag();\n       return this;\n     }\n \n     public DDSpanBuilder withSpanType(final String spanType) {\n-      this.spanType = spanType;\n+      delegate.withSpanType(spanType);\n       return this;\n     }\n \n-    public Iterable<Map.Entry<String, String>> baggageItems() {\n-      if (parent == null) {\n-        return Collections.emptyList();\n-      }\n-      return parent.baggageItems();\n-    }\n-\n     public DDSpanBuilder withLogHandler(final LogHandler logHandler) {\n       if (logHandler != null) {\n-        this.logHandler = logHandler;\n+        DDTracer.this.logHandler = logHandler;\n       }\n       return this;\n     }\n+  }\n+\n+  /** Allows custom scope managers to be passed in to constructor */\n+  private class CustomScopeManager implements DDScopeManager {\n+    private final ScopeManager delegate;\n+\n+    private CustomScopeManager(final ScopeManager scopeManager) {\n+      this.delegate = scopeManager;\n+    }\n \n     @Override\n-    public DDSpanBuilder asChildOf(final Span span) {\n-      return asChildOf(span == null ? null : span.context());\n+    public AgentScope activate(final AgentSpan agentSpan, final boolean finishOnClose) {\n+      final Span span = converter.toSpan(agentSpan);\n+      final Scope scope = delegate.activate(span, finishOnClose);\n+\n+      return new CustomScopeManagerScope(scope);\n     }\n \n     @Override\n-    public DDSpanBuilder asChildOf(final SpanContext spanContext) {\n-      parent = spanContext;\n-      return this;\n+    public TraceScope active() {\n+      return new CustomScopeManagerScope(delegate.active());\n     }\n \n     @Override\n-    public DDSpanBuilder addReference(final String referenceType, final SpanContext spanContext) {\n-      if (spanContext == null) {\n-        return this;\n-      }\n-      if (!(spanContext instanceof ExtractedContext) && !(spanContext instanceof DDSpanContext)) {\n-        log.debug(\n-            \"Expected to have a DDSpanContext or ExtractedContext but got \"\n-                + spanContext.getClass().getName());\n-        return this;\n+    public AgentSpan activeSpan() {\n+      return converter.toAgentSpan(delegate.activeSpan());\n+    }\n+  }\n+\n+  private class CustomScopeManagerScope implements AgentScope, TraceScope {\n+    private final Scope delegate;\n+    private final boolean traceScope;\n+\n+    private CustomScopeManagerScope(final Scope delegate) {\n+      this.delegate = delegate;\n+\n+      // Handle case where the custom scope manager returns TraceScopes\n+      traceScope = delegate instanceof TraceScope;\n+    }\n+\n+    @Override\n+    public AgentSpan span() {\n+      return converter.toAgentSpan(delegate.span());\n+    }\n+\n+    @Override\n+    public void setAsyncPropagation(final boolean value) {\n+      if (traceScope) {\n+        ((TraceScope) delegate).setAsyncPropagation(value);\n       }\n-      if (References.CHILD_OF.equals(referenceType)\n-          || References.FOLLOWS_FROM.equals(referenceType)) {\n-        return asChildOf(spanContext);\n+    }\n+\n+    @Override\n+    public boolean isAsyncPropagating() {\n+      return traceScope && ((TraceScope) delegate).isAsyncPropagating();\n+    }\n+\n+    @Override\n+    public Continuation capture() {\n+      if (traceScope) {\n+        return ((TraceScope) delegate).capture();\n       } else {\n-        log.debug(\"Only support reference type of CHILD_OF and FOLLOWS_FROM\");\n+        return null;\n       }\n-      return this;\n     }\n \n-    // Private methods\n-    private DDSpanBuilder withTag(final String tag, final Object value) {\n-      if (value == null || (value instanceof String && ((String) value).isEmpty())) {\n-        tags.remove(tag);\n-      } else {\n-        tags.put(tag, value);\n+    @Override\n+    public void close() {\n+      delegate.close();\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+      if (this == o) {\n+        return true;\n       }\n-      return this;\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      final CustomScopeManagerScope that = (CustomScopeManagerScope) o;\n+      return delegate.equals(that.delegate);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(delegate);\n+    }\n+  }\n+\n+  private class OTScopeManager implements ScopeManager {\n+    @Override\n+    public Scope activate(final Span span) {\n+      return activate(span, false);\n+    }\n+\n+    @Override\n+    public Scope activate(final Span span, final boolean finishSpanOnClose) {\n+      final AgentSpan agentSpan = converter.toAgentSpan(span);\n+      final AgentScope agentScope = coreTracer.activateSpan(agentSpan, finishSpanOnClose);\n+\n+      return converter.toScope(agentScope);\n+    }\n+\n+    @Override\n+    public Scope active() {\n+      return converter.toScope(coreTracer.activeScope());\n+    }\n+\n+    @Override\n+    public Span activeSpan() {\n+      return converter.toSpan(coreTracer.activeSpan());\n+    }\n+  }\n+\n+  private class OTGenericContext implements SpanContext {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc2NTI4OA=="}, "originalCommit": {"oid": "eb33b99af7d6399fda77a877f8e7e0372d9ce4bf"}, "originalPosition": 1082}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzYzMTEwOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/Converter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyMzozOVrOGMsHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyMzozOVrOGMsHqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk1ODk1NA==", "bodyText": "TypeConversions?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r415958954", "createdAt": "2020-04-27T16:23:39Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/Converter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package datadog.opentracing;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.DDSpanContext;\n+import datadog.trace.core.propagation.ExtractedContext;\n+import datadog.trace.core.propagation.TagContext;\n+import io.opentracing.Scope;\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.noop.NoopSpan;\n+\n+// Centralized place to do conversions\n+class Converter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2152ba920f1326d17f2b7b513dfac1a2ca03582"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzY0MjYzOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/CustomScopeManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyNTo1NlrOGMsOZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyNTo1NlrOGMsOZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MDY3Ng==", "bodyText": "I'm not sure I understand why we need both OTScopeManager and CustomScopeManager... What do they do differently?", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r415960676", "createdAt": "2020-04-27T16:25:56Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/CustomScopeManager.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package datadog.opentracing;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.scopemanager.DDScopeManager;\n+import io.opentracing.Scope;\n+import io.opentracing.ScopeManager;\n+import io.opentracing.Span;\n+import java.util.Objects;\n+\n+/**\n+ * Allows custom OpenTracing scope managers used by CoreTracer\n+ *\n+ * <p>Normal case:\n+ *\n+ * <p>CoreTracer.scopeManager = ContextualScopeManager\n+ *\n+ * <p>DDTracer.scopeManager = OTScopeManager wrapping CoreTracer.scopeManager\n+ *\n+ * <p>Custom case:\n+ *\n+ * <p>CoreTracer.scopeManager = CustomScopeManager wrapping passed in scopemanager\n+ *\n+ * <p>DDTracer.scopeManager = passed in scopemanager\n+ */\n+class CustomScopeManager implements DDScopeManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2152ba920f1326d17f2b7b513dfac1a2ca03582"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzY2NTI2OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjozMDoxN1rOGMsbuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjozMDoxN1rOGMsbuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2NDA4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * DDTracer implements the implements io.opentracing.Tracer API to make it easy to send traces and\n          \n          \n            \n             * DDTracer implements the io.opentracing.Tracer API to make it easy to send traces and", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r415964089", "createdAt": "2020-04-27T16:30:17Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -34,17 +28,23 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Map.Entry;\n-import java.util.Objects;\n import java.util.Properties;\n import lombok.Builder;\n import lombok.extern.slf4j.Slf4j;\n \n+/**\n+ * DDTracer implements the implements io.opentracing.Tracer API to make it easy to send traces and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2152ba920f1326d17f2b7b513dfac1a2ca03582"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzcwMDE1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjozNjo0MFrOGMsvkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjozNjo0MFrOGMsvkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2OTE3MQ==", "bodyText": "It's good that we're teasing this out... I think this is a good thing to follow up on.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r415969171", "createdAt": "2020-04-27T16:36:40Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-ot/src/main/java/datadog/opentracing/DDTracer.java", "diffHunk": "@@ -260,6 +261,13 @@ private DDTracer(\n     }\n \n     coreTracer = builder.build();\n+\n+    // FIXME [API] There's an unfortunate cycle between OTScopeManager and CoreTracer where they\n+    // each depend on eachother so CoreTracer cant be a constructor parameter\n+    // Perhaps api can change so that CoreTracer doesn't need to implement scope methods directly\n+    if (scopeManager == null) {\n+      this.scopeManager = new OTScopeManager(coreTracer, converter);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2152ba920f1326d17f2b7b513dfac1a2ca03582"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMjE0NjAyOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODozMzo0NlrOGO1gpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODozMzo0NlrOGO1gpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIwOTk1OA==", "bodyText": "Nice.  The lack of reporting validation was one of the causes for the classloader issue.", "url": "https://github.com/DataDog/dd-trace-java/pull/1354#discussion_r418209958", "createdAt": "2020-04-30T18:33:46Z", "author": {"login": "tylerbenson"}, "path": "dd-smoke-tests/src/main/groovy/datadog/smoketest/AbstractSmokeTest.groovy", "diffHunk": "@@ -26,6 +33,28 @@ abstract class AbstractSmokeTest extends Specification {\n   @Shared\n   protected Process serverProcess\n \n+  @Shared\n+  protected BlockingQueue<TestHttpServer.HandlerApi.RequestApi> traceRequests = new LinkedBlockingQueue<>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "faa3063b1928623eb469989c044df3fb64bb9642"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 439, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}