{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MjMyOTU0", "number": 2007, "title": "inject fields once at the root of the type hierarchy", "bodyText": "does field injection in the highest concrete type still a subtype of the context store key class, which prevents from adding a field to every class in the hierarchy.", "createdAt": "2020-10-19T19:40:14Z", "url": "https://github.com/DataDog/dd-trace-java/pull/2007", "merged": true, "mergeCommit": {"oid": "c778566e50f23b330e1cca302ec8a99a539eafea"}, "closed": true, "closedAt": "2020-10-20T14:44:25Z", "author": {"login": "richardstartin"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUJlIAgBqjM4OTUyMjgxMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUZw2JAFqTUxMjc5MDQ5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0a1ac350af56dc8d57343f4de0541375e3d64fc", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b0a1ac350af56dc8d57343f4de0541375e3d64fc", "committedDate": "2020-10-19T19:38:32Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "32bb658d71cc3c68ea15878c24a313ce2bbd5336", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/32bb658d71cc3c68ea15878c24a313ce2bbd5336", "committedDate": "2020-10-19T19:45:15Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTA0Nzky", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512104792", "createdAt": "2020-10-19T19:46:53Z", "commit": {"oid": "32bb658d71cc3c68ea15878c24a313ce2bbd5336"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxOTo0Njo1M1rOHkfDSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxOTo0Njo1M1rOHkfDSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAxOTUyOA==", "bodyText": "Are the fields accessed directly or are there generated accessor methods added?", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508019528", "createdAt": "2020-10-19T19:46:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldInjectionVisitor.java", "diffHunk": "@@ -123,7 +123,7 @@ public void visitEnd() {\n         if (!foundField) {\n           cv.visitField(\n               // Field should be transient to avoid being serialized with the object.\n-              Opcodes.ACC_PRIVATE | Opcodes.ACC_TRANSIENT,\n+              Opcodes.ACC_PROTECTED | Opcodes.ACC_TRANSIENT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32bb658d71cc3c68ea15878c24a313ce2bbd5336"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32bb658d71cc3c68ea15878c24a313ce2bbd5336", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/32bb658d71cc3c68ea15878c24a313ce2bbd5336", "committedDate": "2020-10-19T19:45:15Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "committedDate": "2020-10-19T19:49:06Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "committedDate": "2020-10-19T19:49:06Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "fa292ce15a0495cdcea562299f5933637cdb4a6a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fa292ce15a0495cdcea562299f5933637cdb4a6a", "committedDate": "2020-10-19T19:51:41Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa292ce15a0495cdcea562299f5933637cdb4a6a", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/fa292ce15a0495cdcea562299f5933637cdb4a6a", "committedDate": "2020-10-19T19:51:41Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "e4b8620a6259004736932275106155f553bf4853", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e4b8620a6259004736932275106155f553bf4853", "committedDate": "2020-10-19T20:01:45Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e4b8620a6259004736932275106155f553bf4853", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/e4b8620a6259004736932275106155f553bf4853", "committedDate": "2020-10-19T20:01:45Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "committedDate": "2020-10-19T20:59:02Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjAzNjU5", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512203659", "createdAt": "2020-10-19T22:26:37Z", "commit": {"oid": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoyNjozN1rOHkj3tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMjoyNjozN1rOHkj3tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5ODQ4NQ==", "bodyText": "It's a bit difficult for me to understand how this method is able to identify the correct classes to instrument. Perhaps a comment would help?", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508098485", "createdAt": "2020-10-19T22:26:37Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -76,6 +103,32 @@ public boolean matches(\n             valueType);\n       }\n     }\n-    return result;\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "committedDate": "2020-10-19T20:59:02Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "committedDate": "2020-10-20T06:50:20Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/72e27cda53b9cd015d6960f21d7654becc22dbea", "committedDate": "2020-10-20T07:48:17Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "committedDate": "2020-10-20T06:50:20Z", "message": "inject fields once at the root of the type hierarchy"}, "afterCommit": {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/72e27cda53b9cd015d6960f21d7654becc22dbea", "committedDate": "2020-10-20T07:48:17Z", "message": "inject fields once at the root of the type hierarchy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTA4MDg4", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512508088", "createdAt": "2020-10-20T09:25:54Z", "commit": {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyNTo1NFrOHkzFbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwOToyNTo1NFrOHkzFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Nzc1Ng==", "bodyText": "I'm not sure we can short-circuit the search here if you want to get the closest class to Object that implements the key interface. If ByteBuddy's getInterfaces method behaves like reflection then it will only tell you what the class declared as its interfaces at that level, and not all the interfaces it implements.\nFor example:\nclass A implements Runnable {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C {}\n\nWith the above code we'd field-inject D, C, and A.\nThere are also cases where sub-classes re-declare the interfaces they implement:\nclass A implements Runnable {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C implements Runnable {}\n\nNot to mention cases where an interface extends another interface:\ninterface R extends Runnable {}\n\nclass A implements R {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C implements Runnable {}\n\nSince this is an optimization then we don't need to do an exhaustive search - but I think it's worth checking against a few frameworks to see if we miss any chances to skip field injection.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508347756", "createdAt": "2020-10-20T09:25:54Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      boolean implementsInterface = false;\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {\n+        String interfaceName = iface.asRawType().getTypeName();\n+        if (keyType.equals(interfaceName)) {\n+          // then the key type must be an interface\n+          if (null == keyTypeIsClass) {\n+            KEY_TYPE_IS_CLASS.put(keyType, false);\n+            keyTypeIsClass = false;\n+          }\n+          implementingClass = superClassName;\n+          implementsInterface = true;\n+          break;\n+        }\n+      }\n+      if (!implementsInterface) {\n+        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea"}, "originalPosition": 147}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/99dac885e302dd53dc8fdc14db3a396656ead9a2", "committedDate": "2020-10-20T09:34:37Z", "message": "add tests for ShouldInjectFieldsMatcher and remove short circuit optimisation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTQzMjg0", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512543284", "createdAt": "2020-10-20T10:06:51Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDowNjo1MVrOHk0vDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDowNjo1MVrOHk0vDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw==", "bodyText": "We'll still miss a chance to optimize if the class hierarchy implements an interface that extends the key type and doesn't implement the key type directly (since this only checks directly declared interfaces, and not the interfaces they extend) but I think that's OK as widening the search to include transitive interfaces could be expensive.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508374797", "createdAt": "2020-10-20T10:06:51Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTUwMTg1", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512550185", "createdAt": "2020-10-20T10:15:11Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNTkyMjI3", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512592227", "createdAt": "2020-10-20T11:11:00Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMToxMTowMFrOHk3Fmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMToyNzo0N1rOHk3qoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzMzOA==", "bodyText": "I think that the javadoc is very clear:\n\nReturns the interfaces directly implemented by the class or interface represented by this object.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508413338", "createdAt": "2020-10-20T11:11:00Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMTIzNg==", "bodyText": "Do we think that it's common to have a sub-class that is re-implementing and interface? This looks like it will try super-classes even though it found a direct implementation of an interface in the current class.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508421236", "createdAt": "2020-10-20T11:25:01Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {\n+        String interfaceName = iface.asRawType().getTypeName();\n+        if (keyType.equals(interfaceName)) {\n+          // then the key type must be an interface\n+          if (null == keyTypeIsClass) {\n+            KEY_TYPE_IS_CLASS.put(keyType, false);\n+            keyTypeIsClass = false;\n+          }\n+          implementingClass = superClassName;\n+          break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMjgxNw==", "bodyText": "It feels like we are missing to check the typeDescription for interface implementations. This code jumps straight to the superClass.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508422817", "createdAt": "2020-10-20T11:27:47Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNjM0Mjky", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512634292", "createdAt": "2020-10-20T12:08:13Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzgxNjU3", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512781657", "createdAt": "2020-10-20T14:29:02Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoyOTowMlrOHk_6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNDoyOTowMlrOHk_6Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1Nzg5NQ==", "bodyText": "Very slim edge case that is probably not worth considering:  It is possible for this result to be different on different classloaders within a single jvm.", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508557895", "createdAt": "2020-10-20T14:29:02Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzkwNDkw", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#pullrequestreview-512790490", "createdAt": "2020-10-20T14:36:42Z", "commit": {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3007, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}