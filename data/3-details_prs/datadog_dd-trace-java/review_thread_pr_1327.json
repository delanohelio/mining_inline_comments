{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDQwNjQ1", "number": 1327, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjoxNTo0NlrODp7ktw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoyMjowOVrODqgDLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Mjk0MjYzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjoxNTo0NlrOF5aUgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoyODo1OFrOF5e7BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDM4Ng==", "bodyText": "Can this go all the way to 4.0)?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395744386", "createdAt": "2020-03-20T16:15:46Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  maxJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"io.netty\"\n+    module = \"netty\"\n+    versions = \"[3.9.0.Final,3.10)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NTA1MA==", "bodyText": "Any idea why this doesn't work with 3.10?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395745050", "createdAt": "2020-03-20T16:16:55Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  maxJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"io.netty\"\n+    module = \"netty\"\n+    versions = \"[3.9.0.Final,3.10)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDM4Ng=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxOTc4MA==", "bodyText": "See #1327 (comment)", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395819780", "createdAt": "2020-03-20T18:28:58Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  maxJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"io.netty\"\n+    module = \"netty\"\n+    versions = \"[3.9.0.Final,3.10)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDM4Ng=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzA1MDkzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo0NDo1NlrOF5ba3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyOTo0MVrOF6H_-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA==", "bodyText": "Why don't we want it to work with those versions?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395762398", "createdAt": "2020-03-20T16:44:56Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty39;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        \"org.jboss.netty.buffer.EmptyChannelBuffer\", // Not in 3.8\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5ODc3Ng==", "bodyText": "I hadn't run it against 3.8 but from the diff it looked like it wouldn't work, turns out the tests pass against 3.8 so I'll rename to 3.8 and adjust the muzzle checks\nFor 2.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395798776", "createdAt": "2020-03-20T17:49:47Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty39;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        \"org.jboss.netty.buffer.EmptyChannelBuffer\", // Not in 3.8\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5Mjc5NA==", "bodyText": "Turns out 3.10 failure was caused by the version of the client used in the tests. Updated and it works. Updated the description", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396492794", "createdAt": "2020-03-23T14:29:41Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty39;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        \"org.jboss.netty.buffer.EmptyChannelBuffer\", // Not in 3.8\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzA5NDE3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/client/HttpClientRequestTracingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo1Njo0OFrOF5b2Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo1MDowNVrOF5dpmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTQwNw==", "bodyText": "I don't think we need the if here... only on clients actually used by AWS-SDK", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395769407", "createdAt": "2020-03-20T16:56:48Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package datadog.trace.instrumentation.netty39.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty39.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty39.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      // AWS calls are often signed, so we can't add headers without breaking the signature.\n+      if (!request.headers().contains(\"amz-sdk-invocation-id\")) {\n+        propagate().inject(span, request.headers(), SETTER);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5ODkzNw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395798937", "createdAt": "2020-03-20T17:50:05Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package datadog.trace.instrumentation.netty39.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty39.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty39.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      // AWS calls are often signed, so we can't add headers without breaking the signature.\n+      if (!request.headers().contains(\"amz-sdk-invocation-id\")) {\n+        propagate().inject(span, request.headers(), SETTER);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTQwNw=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzczMTMzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDozMDo0N1rOF5iVAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowNjoxN1rOF5jMFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelFutureListener\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n          \n      \n    \n    \n  \n\nYou shouldn't need the manual 3.10 restrictions, muzzle should cover that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395875587", "createdAt": "2020-03-20T20:30:47Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTI4MQ==", "bodyText": "If you need a way to ensure the instrumentation all applies consistently, I suggest doing something like this instead:\nhttps://github.com/DataDog/dd-trace-java/blob/master/dd-java-agent/instrumentation/rabbitmq-amqp-2.7/src/main/java/datadog/trace/instrumentation/rabbitmq/amqp/RabbitCommandInstrumentation.java#L70-L77", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885281", "createdAt": "2020-03-20T20:54:36Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTI4OQ==", "bodyText": "It doesn't, I think because the accesses that would eliminate 3.10 happen outside of the advice class: https://circleci.com/gh/DataDog/dd-trace-java/49282?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889289", "createdAt": "2020-03-20T21:05:07Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTY4Ng==", "bodyText": "Will check that link \ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889686", "createdAt": "2020-03-20T21:06:17Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzczNjY0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDozMjo1MFrOF5iYag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODo0MDowM1rOF6TIdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA==", "bodyText": "Static import...", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395876458", "createdAt": "2020-03-20T20:32:50Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTk1Mg==", "bodyText": "Got lost in the rename I think", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889952", "createdAt": "2020-03-20T21:06:59Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3Mjg3NQ==", "bodyText": "I'm honestly not huge fan of our heavy use of static imports, but I'm not pushing for a change either way.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396672875", "createdAt": "2020-03-23T18:36:15Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NTE4OQ==", "bodyText": "FWIW, in this particular case I think using NettyHttpServerDecorator.DECORATE makes some sense b/c it's not clear whether DECORATE here would refer to the client decorator or the server decorator.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396675189", "createdAt": "2020-03-23T18:40:03Z", "author": {"login": "trask"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Mzc5NjI2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1NjoyM1rOF5i9nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1NjoyM1rOF5i9nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTk4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.Channel\",\n          \n          \n            \n                    // 3.7: cannot find symbol method headers() for type HttpRequest\n          \n          \n            \n                    \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n          \n      \n    \n    \n  \n\nSame as above.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885980", "createdAt": "2020-03-20T20:56:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.Channel\",\n+        // 3.7: cannot find symbol method headers() for type HttpRequest\n+        \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzgwNDQ3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OTozN1rOF5jCsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDo1OTozN1rOF5jCsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzI4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelPipeline\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395887281", "createdAt": "2020-03-20T20:59:37Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelPipeline\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzgwOTc0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/test/groovy/Netty39ClientTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowMTo1M1rOF5jF-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowMTo1M1rOF5jF-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODEyMQ==", "bodyText": "Netty39ClientTest -> Netty38ClientTest\n(Same for server test.)", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395888121", "createdAt": "2020-03-20T21:01:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/test/groovy/Netty39ClientTest.groovy", "diffHunk": "@@ -0,0 +1,103 @@\n+import com.ning.http.client.AsyncCompletionHandler\n+import com.ning.http.client.AsyncHttpClient\n+import com.ning.http.client.AsyncHttpClientConfig\n+import com.ning.http.client.Response\n+import datadog.trace.agent.test.base.HttpClientTest\n+import datadog.trace.bootstrap.instrumentation.api.Tags\n+import datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator\n+import spock.lang.AutoCleanup\n+import spock.lang.Shared\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import static datadog.trace.agent.test.utils.PortUtils.UNUSABLE_PORT\n+import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n+import static datadog.trace.agent.test.utils.TraceUtils.runUnderTrace\n+\n+class Netty39ClientTest extends HttpClientTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODgxNTAzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzowOVrOF6RYTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzowOVrOF6RYTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjQ3OQ==", "bodyText": "Not necessarily for this PR, but now, that having a classLoaderMatcher check is the norm to combat matching costs.  I think we should make the concept of key class for a library a required part of almost every instrumentation.\nI also think we should revisit the idea of a Library as a first class concept as well.  While at first, I think this seems like more work.  I think right now we end up duplicating some classLoaderMatcher code because we lack the concept of a library.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396646479", "createdAt": "2020-03-23T17:57:09Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODgyNDIyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1OTowOFrOF6Rd9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowMToyNFrOF6RjnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzkyNQ==", "bodyText": "ChannelTraceContext.class will trigger a class load in the agent ClassLoader.\nHowever, I'm assuming we should only need ChannelTraceContext in the target ClassLoader.\nThis comes up enough that I'm wondering if we should make doing this the right way easier somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396647925", "createdAt": "2020-03-23T17:59:08Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0OTM3Mw==", "bodyText": "Whoops. Updating.\nI agree on the doing the right thing part. I think a lot of the code in these classes could be generated at compile time, maybe using compile retention annotations", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396649373", "createdAt": "2020-03-23T18:01:24Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzkyNQ=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg1ODQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelTraceContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowNzo0MVrOF6RzvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODozMzo1NlrOF6S56g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1MzUwMA==", "bodyText": "I'm guessing this is idiomatic to our code base.  However, compareAndSet to me evokes a specific atomicity guarantee that this does seem to provide.\nI'm not necessarily suggesting a change -- just that this is confusing to a casual reader.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396653500", "createdAt": "2020-03-23T18:07:41Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelTraceContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import lombok.Data;\n+\n+@Data\n+public class ChannelTraceContext {\n+  public static class Factory implements ContextStore.Factory<ChannelTraceContext> {\n+    public static final Factory INSTANCE = new Factory();\n+\n+    @Override\n+    public ChannelTraceContext create() {\n+      return new ChannelTraceContext();\n+    }\n+  }\n+\n+  TraceScope.Continuation connectionContinuation;\n+  AgentSpan serverSpan;\n+  AgentSpan clientSpan;\n+  AgentSpan clientParentSpan;\n+\n+  public boolean compareAndSet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MTQ2Ng==", "bodyText": "I'll just change the call sites. I don't expect these objects to be used on multiple threads", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396671466", "createdAt": "2020-03-23T18:33:56Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelTraceContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import lombok.Data;\n+\n+@Data\n+public class ChannelTraceContext {\n+  public static class Factory implements ContextStore.Factory<ChannelTraceContext> {\n+    public static final Factory INSTANCE = new Factory();\n+\n+    @Override\n+    public ChannelTraceContext create() {\n+      return new ChannelTraceContext();\n+    }\n+  }\n+\n+  TraceScope.Continuation connectionContinuation;\n+  AgentSpan serverSpan;\n+  AgentSpan clientSpan;\n+  AgentSpan clientParentSpan;\n+\n+  public boolean compareAndSet(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1MzUwMA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg2NjAxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowOTozN1rOF6R4nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNjoxNlrOF6SIAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDc0OA==", "bodyText": "Shouldn't closing be in a finally block?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396654748", "createdAt": "2020-03-23T18:09:37Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.Channel\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"connect\"))\n+            .and(returns(named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        NettyChannelInstrumentation.class.getName() + \"$ChannelConnectAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class ChannelConnectAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static void addConnectContinuation(@Advice.This final Channel channel) {\n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        final TraceScope.Continuation continuation = scope.capture();\n+        if (continuation != null) {\n+          final ContextStore<Channel, ChannelTraceContext> contextStore =\n+              InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+          if (!contextStore\n+              .putIfAbsent(channel, ChannelTraceContext.Factory.INSTANCE)\n+              .compareAndSet(null, continuation)) {\n+            continuation.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODY4OQ==", "bodyText": "This close is only on failure, so when the continuation is not null in the above check. So we close this one as a duplicate", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658689", "createdAt": "2020-03-23T18:16:16Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.Channel\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"connect\"))\n+            .and(returns(named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        NettyChannelInstrumentation.class.getName() + \"$ChannelConnectAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class ChannelConnectAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static void addConnectContinuation(@Advice.This final Channel channel) {\n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        final TraceScope.Continuation continuation = scope.capture();\n+        if (continuation != null) {\n+          final ContextStore<Channel, ChannelTraceContext> contextStore =\n+              InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+          if (!contextStore\n+              .putIfAbsent(channel, ChannelTraceContext.Factory.INSTANCE)\n+              .compareAndSet(null, continuation)) {\n+            continuation.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDc0OA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg3NTA3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMjowMlrOF6R-Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxOToyNlrOF6SR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NjE5NQ==", "bodyText": "Should we log here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656195", "createdAt": "2020-03-23T18:12:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MTIyOQ==", "bodyText": "Oh, this shouldn't be needed anymore. I'm handling this by doing the remove. Removing", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396661229", "createdAt": "2020-03-23T18:19:26Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NjE5NQ=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg3ODYyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMzowMlrOF6SAew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODozNzo0MVrOF6TDFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw==", "bodyText": "Why not just pipeline.remove(handler.getClass().getName())?\nDoes remove fail if it is missing?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656763", "createdAt": "2020-03-23T18:13:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.\n+      } finally {\n+        CallDepthThreadLocalMap.reset(ChannelPipeline.class);\n+      }\n+    }\n+  }\n+\n+  public static class ChannelPipelineAdd2ArgsAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static int checkDepth(\n+        @Advice.This final ChannelPipeline pipeline,\n+        @Advice.Argument(1) final ChannelHandler handler) {\n+      // Pipelines are created once as a factory and then copied multiple times using the same add\n+      // methods as we are hooking. If our handler has already been added we need to remove it so we\n+      // don't end up with duplicates (this throws an exception)\n+      if (pipeline.get(handler.getClass().getName()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODIyMA==", "bodyText": "Yeah it throws: throw new NoSuchElementException(name);", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658220", "createdAt": "2020-03-23T18:15:27Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.\n+      } finally {\n+        CallDepthThreadLocalMap.reset(ChannelPipeline.class);\n+      }\n+    }\n+  }\n+\n+  public static class ChannelPipelineAdd2ArgsAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static int checkDepth(\n+        @Advice.This final ChannelPipeline pipeline,\n+        @Advice.Argument(1) final ChannelHandler handler) {\n+      // Pipelines are created once as a factory and then copied multiple times using the same add\n+      // methods as we are hooking. If our handler has already been added we need to remove it so we\n+      // don't end up with duplicates (this throws an exception)\n+      if (pipeline.get(handler.getClass().getName()) != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MzgxNQ==", "bodyText": "Okay, then I guess the test & remove makes sense.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396673815", "createdAt": "2020-03-23T18:37:41Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.\n+      } finally {\n+        CallDepthThreadLocalMap.reset(ChannelPipeline.class);\n+      }\n+    }\n+  }\n+\n+  public static class ChannelPipelineAdd2ArgsAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static int checkDepth(\n+        @Advice.This final ChannelPipeline pipeline,\n+        @Advice.Argument(1) final ChannelHandler handler) {\n+      // Pipelines are created once as a factory and then copied multiple times using the same add\n+      // methods as we are hooking. If our handler has already been added we need to remove it so we\n+      // don't end up with duplicates (this throws an exception)\n+      if (pipeline.get(handler.getClass().getName()) != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg4NDQwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNDo0OFrOF6SEeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODozOToyNVrOF6THFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA==", "bodyText": "finally block?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396657784", "createdAt": "2020-03-23T18:14:48Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();\n+        throw throwable;\n+      }\n+    }\n+\n+    if (null != parentScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MzkxMA==", "bodyText": "Probably should be, yeah. Should probably fix this in 4.0 also", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396663910", "createdAt": "2020-03-23T18:22:50Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();\n+        throw throwable;\n+      }\n+    }\n+\n+    if (null != parentScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDgzNw==", "bodyText": "Forward porting to 4.0 and 4.1 also", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396674837", "createdAt": "2020-03-23T18:39:25Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();\n+        throw throwable;\n+      }\n+    }\n+\n+    if (null != parentScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg4NTc1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNToxMVrOF6SFeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODozODoyNFrOF6TEzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA==", "bodyText": "Do we not finish the span if there isn't an Exception?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658040", "createdAt": "2020-03-23T18:15:11Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDA0MA==", "bodyText": "It's closed in the response handler if there isn't an error sending downstream", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396660040", "createdAt": "2020-03-23T18:17:57Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDI1Mg==", "bodyText": "Ah, that makes sense.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396674252", "createdAt": "2020-03-23T18:38:24Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg4NzY2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNTozNlrOF6SGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxOTowMTozMFrOF6T5fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw==", "bodyText": "finally?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658323", "createdAt": "2020-03-23T18:15:36Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.noopSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+public class HttpClientResponseTracingHandler extends SimpleChannelUpstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientResponseTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    AgentSpan parent = channelTraceContext.getClientParentSpan();\n+    if (parent == null) {\n+      parent = noopSpan();\n+      channelTraceContext.setClientParentSpan(noopSpan());\n+    }\n+    final AgentSpan span = channelTraceContext.getClientSpan();\n+\n+    final boolean finishSpan = msg.getMessage() instanceof HttpResponse;\n+\n+    if (span != null && finishSpan) {\n+      try (final AgentScope scope = activateSpan(span, false)) {\n+        DECORATE.onResponse(span, (HttpResponse) msg.getMessage());\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4MDI2OA==", "bodyText": "I think the span needs to be finished while it's in scope. Not 100% sure on that with our impl but it's a common pattern I've seen", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396680268", "createdAt": "2020-03-23T18:48:48Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.noopSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+public class HttpClientResponseTracingHandler extends SimpleChannelUpstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientResponseTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    AgentSpan parent = channelTraceContext.getClientParentSpan();\n+    if (parent == null) {\n+      parent = noopSpan();\n+      channelTraceContext.setClientParentSpan(noopSpan());\n+    }\n+    final AgentSpan span = channelTraceContext.getClientSpan();\n+\n+    final boolean finishSpan = msg.getMessage() instanceof HttpResponse;\n+\n+    if (span != null && finishSpan) {\n+      try (final AgentScope scope = activateSpan(span, false)) {\n+        DECORATE.onResponse(span, (HttpResponse) msg.getMessage());\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4Nzc0Mg==", "bodyText": "This code is the same in the other 2 versions of the netty instrumentation", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396687742", "createdAt": "2020-03-23T19:01:30Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.noopSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+public class HttpClientResponseTracingHandler extends SimpleChannelUpstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientResponseTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    AgentSpan parent = channelTraceContext.getClientParentSpan();\n+    if (parent == null) {\n+      parent = noopSpan();\n+      channelTraceContext.setClientParentSpan(noopSpan());\n+    }\n+    final AgentSpan span = channelTraceContext.getClientSpan();\n+\n+    final boolean finishSpan = msg.getMessage() instanceof HttpResponse;\n+\n+    if (span != null && finishSpan) {\n+      try (final AgentScope scope = activateSpan(span, false)) {\n+        DECORATE.onResponse(span, (HttpResponse) msg.getMessage());\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw=="}, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODg5MzE2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNzowMVrOF6SKDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNzowMVrOF6SKDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1OTIxNA==", "bodyText": "Probably not for this PR, but we probably shouldn't build URI just to extract pieces to tags later.\nThat creates a hot allocation point under load.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396659214", "createdAt": "2020-03-23T18:17:01Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODkxODg0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoyMjowOVrOF6SaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoyMjowOVrOF6SaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MzM2Mw==", "bodyText": "Again, probably not this PR.\nBut why does this return Integer rather than int?\nAlso, we might want to create our Integer cache for HttpStatus codes, since most of them lie outside the default cache range.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396663363", "createdAt": "2020-03-23T18:22:09Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());\n+    if ((uri.getHost() == null || uri.getHost().equals(\"\")) && request.headers().contains(HOST)) {\n+      return new URI(\"http://\" + request.headers().get(HOST) + request.getUri());\n+    } else {\n+      return uri;\n+    }\n+  }\n+\n+  @Override\n+  protected Integer status(final HttpResponse httpResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 411, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}