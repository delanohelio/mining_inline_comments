{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NTUwMjE2", "number": 1933, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoyOToxMlrOEpDuMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjoyOTo1OFrOEvZppg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDg4MDUxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoyOToxMlrOHagaLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0MzozN1rOHahG3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NjAxNA==", "bodyText": "There was a memory saving in making these changes, but not a significant improvement in the time to load our classes. I think there is also potential for deadlock. If this is causing problems, I suggest either synchronizing on getClassLoadingLock(name), or completely abandoning the package based classloading logic.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497556014", "createdAt": "2020-09-30T14:29:12Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "diffHunk": "@@ -67,11 +67,16 @@ public boolean hasLoadedClass(final String className) {\n   }\n \n   Class<?> loadFromPackage(String packageName, String name) throws ClassNotFoundException {\n-    Object packageLock = internalJarURLHandler.getPackageLock(packageName);\n+    InternalJarURLHandler.Lock packageLock = internalJarURLHandler.getPackageLock(packageName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NzQ1NQ==", "bodyText": "I haven't seen the locks causing any issues.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497567455", "createdAt": "2020-09-30T14:43:37Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "diffHunk": "@@ -67,11 +67,16 @@ public boolean hasLoadedClass(final String className) {\n   }\n \n   Class<?> loadFromPackage(String packageName, String name) throws ClassNotFoundException {\n-    Object packageLock = internalJarURLHandler.getPackageLock(packageName);\n+    InternalJarURLHandler.Lock packageLock = internalJarURLHandler.getPackageLock(packageName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NjAxNA=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDg4ODkyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozMDo1MVrOHagfcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0NDoxOVrOHahI6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NzM2MA==", "bodyText": "I think the changes made to State were an improvement here, and the assert I added previously was incorrect. I.e. it's better to control which thread gets to set the continuation than try, fail, and then assert/log that something bad happened, when it's a race anyway and the important detail is that there is only one winner.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497557360", "createdAt": "2020-09-30T14:30:51Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {\n+\n+  public static ContextStore.Factory<ConcurrentState> FACTORY =\n+      new ContextStore.Factory<ConcurrentState>() {\n+        @Override\n+        public ConcurrentState create() {\n+          return new ConcurrentState();\n+        }\n+      };\n+\n+  private final AtomicReference<TraceScope.Continuation> continuationRef =\n+      new AtomicReference<>(null);\n+\n+  private ConcurrentState() {}\n+\n+  public static <K> void captureActiveScope(ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final TraceScope scope = activeScope();\n+    captureScope(contextStore, key, scope);\n+  }\n+\n+  public static <K> void captureScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope) {\n+    final ConcurrentState state = contextStore.putIfAbsent(key, FACTORY);\n+    if (scope != null) {\n+      final TraceScope.Continuation continuation = scope.captureConcurrent();\n+      if (continuation != null) {\n+        state.setContinuation(continuation);\n+      }\n+    }\n+  }\n+\n+  public static <K> TraceScope activateAndContinueContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return null;\n+    }\n+    return state.activateAndContinueContinuation();\n+  }\n+\n+  public static <K> void closeScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope, Throwable throwable) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (scope != null) {\n+      scope.close();\n+      return;\n+    }\n+    if (state == null) {\n+      return;\n+    }\n+    if (throwable != null) {\n+      // This might lead to the continuation being consumed early, but it's better to be safe if we\n+      // threw an Exception on entry\n+      state.closeContinuation();\n+    }\n+  }\n+\n+  public static <K> void closeAndClearContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return;\n+    }\n+    state.closeAndClearContinuation();\n+  }\n+\n+  boolean setContinuation(TraceScope.Continuation continuation) {\n+    final boolean result = continuationRef.compareAndSet(null, continuation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2Nzk3Ng==", "bodyText": "Yeah, I forgot to remodel my things in the same way. I'll take a look at it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497567976", "createdAt": "2020-09-30T14:44:19Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {\n+\n+  public static ContextStore.Factory<ConcurrentState> FACTORY =\n+      new ContextStore.Factory<ConcurrentState>() {\n+        @Override\n+        public ConcurrentState create() {\n+          return new ConcurrentState();\n+        }\n+      };\n+\n+  private final AtomicReference<TraceScope.Continuation> continuationRef =\n+      new AtomicReference<>(null);\n+\n+  private ConcurrentState() {}\n+\n+  public static <K> void captureActiveScope(ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final TraceScope scope = activeScope();\n+    captureScope(contextStore, key, scope);\n+  }\n+\n+  public static <K> void captureScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope) {\n+    final ConcurrentState state = contextStore.putIfAbsent(key, FACTORY);\n+    if (scope != null) {\n+      final TraceScope.Continuation continuation = scope.captureConcurrent();\n+      if (continuation != null) {\n+        state.setContinuation(continuation);\n+      }\n+    }\n+  }\n+\n+  public static <K> TraceScope activateAndContinueContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return null;\n+    }\n+    return state.activateAndContinueContinuation();\n+  }\n+\n+  public static <K> void closeScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope, Throwable throwable) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (scope != null) {\n+      scope.close();\n+      return;\n+    }\n+    if (state == null) {\n+      return;\n+    }\n+    if (throwable != null) {\n+      // This might lead to the continuation being consumed early, but it's better to be safe if we\n+      // threw an Exception on entry\n+      state.closeContinuation();\n+    }\n+  }\n+\n+  public static <K> void closeAndClearContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return;\n+    }\n+    state.closeAndClearContinuation();\n+  }\n+\n+  boolean setContinuation(TraceScope.Continuation continuation) {\n+    final boolean result = continuationRef.compareAndSet(null, continuation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1NzM2MA=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkwNzA4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNDo0MFrOHagq7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNTo1M1rOHagunQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MDMwMw==", "bodyText": "Pet peeve - SkipType.values() allocates every time. I'd prefer an EnumSet or SkipType[] VALUES = values() inside the enum.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497560303", "createdAt": "2020-09-30T14:34:40Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;\n+  }\n+\n+  public static boolean skip(SkipType type, String className) {\n+    return blockedClasses.get(type.ordinal()).contains(className);\n+  }\n+\n+  private static final ClassValue<Integer> SKIP =\n+      new ClassValue<Integer>() {\n+        @Override\n+        protected Integer computeValue(Class<?> clazz) {\n+          int result = 0;\n+          String name = clazz.getName();\n+          for (SkipType type : SkipType.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTI0NQ==", "bodyText": "Ah, didn't know that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497561245", "createdAt": "2020-09-30T14:35:53Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;\n+  }\n+\n+  public static boolean skip(SkipType type, String className) {\n+    return blockedClasses.get(type.ordinal()).contains(className);\n+  }\n+\n+  private static final ClassValue<Integer> SKIP =\n+      new ClassValue<Integer>() {\n+        @Override\n+        protected Integer computeValue(Class<?> clazz) {\n+          int result = 0;\n+          String name = clazz.getName();\n+          for (SkipType type : SkipType.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MDMwMw=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkxMjMxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNTo0NFrOHaguGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNTo0NFrOHaguGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTExMw==", "bodyText": "Isn't this mask basically an EnumSet<SkipType>?", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497561113", "createdAt": "2020-09-30T14:35:44Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;\n+  }\n+\n+  public static boolean skip(SkipType type, String className) {\n+    return blockedClasses.get(type.ordinal()).contains(className);\n+  }\n+\n+  private static final ClassValue<Integer> SKIP =\n+      new ClassValue<Integer>() {\n+        @Override\n+        protected Integer computeValue(Class<?> clazz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkxNjQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNjozN1rOHagwwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0MDoxMVrOHag73Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTc5NA==", "bodyText": "Could be EnumSet.contains(type) which reduces to bitwise operations too.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497561794", "createdAt": "2020-09-30T14:36:37Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NDYzNw==", "bodyText": "Yes, you are completely correct. I'll change it to EnumSet and EnumMap", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497564637", "createdAt": "2020-09-30T14:40:11Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTc5NA=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkyMTA5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNzozNFrOHagzwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNzozNFrOHagzwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MjU2MA==", "bodyText": "This could be an EnumMap<SkipType, Set<String>", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497562560", "createdAt": "2020-09-30T14:37:34Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/SkipFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SkipFilter {\n+\n+  public enum SkipType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static SkipType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;\n+      }\n+    }\n+\n+    private final int mask;\n+\n+    private int getMask() {\n+      return mask;\n+    }\n+\n+    SkipType() {\n+      this.mask = 1 << this.ordinal();\n+    }\n+  }\n+\n+  public static boolean skip(SkipType type, Object instance) {\n+    return (SKIP.get(instance.getClass()) & type.getMask()) != 0;\n+  }\n+\n+  public static boolean skip(SkipType type, String className) {\n+    return blockedClasses.get(type.ordinal()).contains(className);\n+  }\n+\n+  private static final ClassValue<Integer> SKIP =\n+      new ClassValue<Integer>() {\n+        @Override\n+        protected Integer computeValue(Class<?> clazz) {\n+          int result = 0;\n+          String name = clazz.getName();\n+          for (SkipType type : SkipType.values()) {\n+            if (skip(type, name)) {\n+              result |= type.getMask();\n+            }\n+          }\n+          return result;\n+        }\n+      };\n+\n+  private static final ArrayList<Set<String>> blockedClasses =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkyODQyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/guava-10/src/test/groovy/ListenableFutureTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozOTowOFrOHag4jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozOTowOFrOHag4jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2Mzc5MA==", "bodyText": "\ud83e\udd47", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497563790", "createdAt": "2020-09-30T14:39:08Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/guava-10/src/test/groovy/ListenableFutureTest.groovy", "diffHunk": "@@ -32,7 +32,7 @@ class ListenableFutureTest extends AbstractPromiseTest<SettableFuture<Boolean>,\n   }\n \n   @Override\n-  Boolean get(SettableFuture<Boolean> promise) {\n+  boolean get(SettableFuture<Boolean> promise) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDkzNTEyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/main/java8/java/util/concurrent/CompletableFutureAdvice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0MDoyNVrOHag8pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzozODo1NlrOHa-HkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NDgzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static void afterInit(@Advice.This UniCompletion thiz) {\n          \n          \n            \n                public static void afterInit(@Advice.This UniCompletion zis) {", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497564838", "createdAt": "2020-09-30T14:40:25Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/main/java8/java/util/concurrent/CompletableFutureAdvice.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package java.util.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.concurrent.CompletableFuture.ASYNC;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ConcurrentState;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.CompletableFuture.UniCompletion;\n+import net.bytebuddy.asm.Advice;\n+\n+// This class is put into java.util.concurrent to allow access to package private classes.\n+public final class CompletableFutureAdvice {\n+\n+  public static final class UniConstructor {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void afterInit(@Advice.This UniCompletion thiz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0Mjc2OA==", "bodyText": "Yes, that is easier to distinguish.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r498042768", "createdAt": "2020-10-01T07:38:56Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/main/java8/java/util/concurrent/CompletableFutureAdvice.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package java.util.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.concurrent.CompletableFuture.ASYNC;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ConcurrentState;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.CompletableFuture.UniCompletion;\n+import net.bytebuddy.asm.Advice;\n+\n+// This class is put into java.util.concurrent to allow access to package private classes.\n+public final class CompletableFutureAdvice {\n+\n+  public static final class UniConstructor {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void afterInit(@Advice.This UniCompletion thiz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NDgzOA=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNDk0MDg5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/test/groovy/CompletableFutureTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDo0MToyN1rOHahAFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzo0MjowOVrOHa-OiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NTcxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                value << (0..((1 << 3) - 1))\n          \n          \n            \n                value << (0..7)", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r497565716", "createdAt": "2020-09-30T14:41:27Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/test/groovy/CompletableFutureTest.groovy", "diffHunk": "@@ -178,26 +232,47 @@ class CompletableFutureTest extends AgentTestRunner {\n         basicSpan(it, \"child\", span(0))\n       }\n     }\n+\n+    where:\n+    value << (0..((1 << 3) - 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0NDU1Mw==", "bodyText": "Yes, that is a bit convoluted. I'll change it and add a comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r498044553", "createdAt": "2020-10-01T07:42:09Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-completablefuture/src/test/groovy/CompletableFutureTest.groovy", "diffHunk": "@@ -178,26 +232,47 @@ class CompletableFutureTest extends AgentTestRunner {\n         basicSpan(it, \"child\", span(0))\n       }\n     }\n+\n+    where:\n+    value << (0..((1 << 3) - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NTcxNg=="}, "originalCommit": {"oid": "c8cb24fb5e8d7c91fb12878403e850ecb5373d80"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzY3OTI3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzo0NjoyNVrOHb2RrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxMDo0OFrOHce3SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2Mjg2MQ==", "bodyText": "Could you update the description explaining why the classloader changes are needed in this PR?", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r498962861", "createdAt": "2020-10-02T17:46:25Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "diffHunk": "@@ -159,11 +164,16 @@ public DelegateClassLoader(\n     @Override\n     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n       String packageName = shared.getPackageName(name);\n-      Object packageLock = internalJarURLHandler.getPackageLock(packageName);\n+      InternalJarURLHandler.Lock packageLock = internalJarURLHandler.getPackageLock(packageName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNzg0OQ==", "bodyText": "Sure. I'll do that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499627849", "createdAt": "2020-10-05T14:10:48Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/DatadogClassLoader.java", "diffHunk": "@@ -159,11 +164,16 @@ public DelegateClassLoader(\n     @Override\n     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n       String packageName = shared.getPackageName(name);\n-      Object packageLock = internalJarURLHandler.getPackageLock(packageName);\n+      InternalJarURLHandler.Lock packageLock = internalJarURLHandler.getPackageLock(packageName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2Mjg2MQ=="}, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDA5MDMwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/ExcludeFilterProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDoxMzo0MFrOHb6XWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowMzo1NlrOHceklg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyOTg1MA==", "bodyText": "and only to... ?", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499029850", "createdAt": "2020-10-02T20:13:40Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/ExcludeFilterProvider.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package datadog.trace.agent.tooling;\n+\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Used to allow an {@link Instrumenter} to opt out of broad instrumentations like {@link Runnable}.\n+ *\n+ * <p>These are looked up in a separate pass before the {@link Instrumenter} is allowed to add\n+ * instrumentations. Note, it is up to the {@link ExcludeFilterProvider} to check if it is enabled\n+ * and only to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMzA2Mg==", "bodyText": "Yeah. Only to...\nThanks. I'll update the comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499623062", "createdAt": "2020-10-05T14:03:56Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/ExcludeFilterProvider.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package datadog.trace.agent.tooling;\n+\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Used to allow an {@link Instrumenter} to opt out of broad instrumentations like {@link Runnable}.\n+ *\n+ * <p>These are looked up in a separate pass before the {@link Instrumenter} is allowed to add\n+ * instrumentations. Note, it is up to the {@link ExcludeFilterProvider} to check if it is enabled\n+ * and only to", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyOTg1MA=="}, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDA5Njg2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDoxNjoxMFrOHb6bQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowNjoyNlrOHcerdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzMDg0OQ==", "bodyText": "I don't follow why this needed in this PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499030849", "createdAt": "2020-10-02T20:16:10Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExcludeFilter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNDgyMQ==", "bodyText": "So it is needed because the normal Runnable and Executor instrumentations get in the way, and do double or triple work, including capturing contexts and adding fields that should never be used, to the UniCompletion instances.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499624821", "createdAt": "2020-10-05T14:06:26Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ExcludeFilter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzMDg0OQ=="}, "originalCommit": {"oid": "9eac612bc566d5051e276092772e1dc2a44296ab"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODEwODcxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzozMjowMVrOHcdNZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowNjozMFrOHcerog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwMDc0Mw==", "bodyText": "Could you add a comment on why this should be a separate iteration loop.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499600743", "createdAt": "2020-10-05T13:32:01Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "diffHunk": "@@ -95,8 +96,23 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n       agentBuilder = agentBuilder.with(listener);\n     }\n     int numInstrumenters = 0;\n-    for (final Instrumenter instrumenter :\n-        ServiceLoader.load(Instrumenter.class, AgentInstaller.class.getClassLoader())) {\n+    ServiceLoader<Instrumenter> loader =\n+        ServiceLoader.load(Instrumenter.class, AgentInstaller.class.getClassLoader());\n+    for (final Instrumenter instrumenter : loader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNDg2Ng==", "bodyText": "Sure.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499624866", "createdAt": "2020-10-05T14:06:30Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "diffHunk": "@@ -95,8 +96,23 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n       agentBuilder = agentBuilder.with(listener);\n     }\n     int numInstrumenters = 0;\n-    for (final Instrumenter instrumenter :\n-        ServiceLoader.load(Instrumenter.class, AgentInstaller.class.getClassLoader())) {\n+    ServiceLoader<Instrumenter> loader =\n+        ServiceLoader.load(Instrumenter.class, AgentInstaller.class.getClassLoader());\n+    for (final Instrumenter instrumenter : loader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwMDc0Mw=="}, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODIzMDY0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo1OTozN1rOHceZEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxMDowMlrOHce1IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMDExNA==", "bodyText": "Why is this needed in addition to State?", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499620114", "createdAt": "2020-10-05T13:59:37Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNzI5Nw==", "bodyText": "It's because it has different semantics, than State since there is a benign race between multiple threads in the tryFire method, that I thought was better to keep separate from the normal State instead of adding other methods onto State that might be used inadvertently.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499627297", "createdAt": "2020-10-05T14:10:02Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMDExNA=="}, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODIzOTI0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDowMTozMlrOHceeVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoyNDo0M1rOHcfe2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMTQ2Mw==", "bodyText": "If there's no scope we should check that first, in case ContextStore is backed by something expensive", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499621463", "createdAt": "2020-10-05T14:01:32Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {\n+\n+  private static final class ContinuationClaim implements TraceScope.Continuation {\n+\n+    @Override\n+    public TraceScope activate() {\n+      throw new IllegalStateException();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private static final TraceScope.Continuation CLAIMED = new ContinuationClaim();\n+\n+  public static ContextStore.Factory<ConcurrentState> FACTORY =\n+      new ContextStore.Factory<ConcurrentState>() {\n+        @Override\n+        public ConcurrentState create() {\n+          return new ConcurrentState();\n+        }\n+      };\n+\n+  private final AtomicReference<TraceScope.Continuation> continuationRef =\n+      new AtomicReference<>(null);\n+\n+  private ConcurrentState() {}\n+\n+  public static <K> void captureScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope) {\n+    final ConcurrentState state = contextStore.putIfAbsent(key, FACTORY);\n+    if (scope != null) {\n+      if (!state.captureAndSetContinuation(scope) && log.isDebugEnabled()) {\n+        log.debug(\n+            \"continuation was already set for {} in scope {}, no continuation captured.\",\n+            key,\n+            scope);\n+      }\n+    }\n+  }\n+\n+  public static <K> TraceScope activateAndContinueContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return null;\n+    }\n+    return state.activateAndContinueContinuation();\n+  }\n+\n+  public static <K> void closeScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope, Throwable throwable) {\n+    final ConcurrentState state = contextStore.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNzY1Mg==", "bodyText": "Ok, I'll look over the code for this pattern.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499627652", "createdAt": "2020-10-05T14:10:30Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {\n+\n+  private static final class ContinuationClaim implements TraceScope.Continuation {\n+\n+    @Override\n+    public TraceScope activate() {\n+      throw new IllegalStateException();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private static final TraceScope.Continuation CLAIMED = new ContinuationClaim();\n+\n+  public static ContextStore.Factory<ConcurrentState> FACTORY =\n+      new ContextStore.Factory<ConcurrentState>() {\n+        @Override\n+        public ConcurrentState create() {\n+          return new ConcurrentState();\n+        }\n+      };\n+\n+  private final AtomicReference<TraceScope.Continuation> continuationRef =\n+      new AtomicReference<>(null);\n+\n+  private ConcurrentState() {}\n+\n+  public static <K> void captureScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope) {\n+    final ConcurrentState state = contextStore.putIfAbsent(key, FACTORY);\n+    if (scope != null) {\n+      if (!state.captureAndSetContinuation(scope) && log.isDebugEnabled()) {\n+        log.debug(\n+            \"continuation was already set for {} in scope {}, no continuation captured.\",\n+            key,\n+            scope);\n+      }\n+    }\n+  }\n+\n+  public static <K> TraceScope activateAndContinueContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return null;\n+    }\n+    return state.activateAndContinueContinuation();\n+  }\n+\n+  public static <K> void closeScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope, Throwable throwable) {\n+    final ConcurrentState state = contextStore.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMTQ2Mw=="}, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNzk3OQ==", "bodyText": "Ok, I'll look over the code for this pattern.\n\nThe mark of a good senior engineer.  \ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r499637979", "createdAt": "2020-10-05T14:24:43Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ConcurrentState.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.context.TraceScope;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class ConcurrentState {\n+\n+  private static final class ContinuationClaim implements TraceScope.Continuation {\n+\n+    @Override\n+    public TraceScope activate() {\n+      throw new IllegalStateException();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+      throw new IllegalStateException();\n+    }\n+  }\n+\n+  private static final TraceScope.Continuation CLAIMED = new ContinuationClaim();\n+\n+  public static ContextStore.Factory<ConcurrentState> FACTORY =\n+      new ContextStore.Factory<ConcurrentState>() {\n+        @Override\n+        public ConcurrentState create() {\n+          return new ConcurrentState();\n+        }\n+      };\n+\n+  private final AtomicReference<TraceScope.Continuation> continuationRef =\n+      new AtomicReference<>(null);\n+\n+  private ConcurrentState() {}\n+\n+  public static <K> void captureScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope) {\n+    final ConcurrentState state = contextStore.putIfAbsent(key, FACTORY);\n+    if (scope != null) {\n+      if (!state.captureAndSetContinuation(scope) && log.isDebugEnabled()) {\n+        log.debug(\n+            \"continuation was already set for {} in scope {}, no continuation captured.\",\n+            key,\n+            scope);\n+      }\n+    }\n+  }\n+\n+  public static <K> TraceScope activateAndContinueContinuation(\n+      ContextStore<K, ConcurrentState> contextStore, K key) {\n+    final ConcurrentState state = contextStore.get(key);\n+    if (state == null) {\n+      return null;\n+    }\n+    return state.activateAndContinueContinuation();\n+  }\n+\n+  public static <K> void closeScope(\n+      ContextStore<K, ConcurrentState> contextStore, K key, TraceScope scope, Throwable throwable) {\n+    final ConcurrentState state = contextStore.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyMTQ2Mw=="}, "originalCommit": {"oid": "d12dea0479840d58c43ec3009a4bb9d43d22ea6a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTM4MDM3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjoyODowNVrOHkXGAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToyODowOFrOHlDFnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4OTE1Mw==", "bodyText": "returning null here is very weird and seems like it could be particularly troublesome in the future.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r507889153", "createdAt": "2020-10-19T16:28:05Z", "author": {"login": "BurgersMcSlopshot"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Enables types to opt out of being wrapped and/or having fields injected for a number of the broad\n+ * instrumentations, i.e. {@code Executor} and {@code Runnable}.\n+ */\n+public class ExcludeFilter {\n+\n+  public enum ExcludeType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static ExcludeType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39c15a78f849ece1c0c0ca43c7128b889166f51f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwOTk0OA==", "bodyText": "So not all types that we inject fields for are types that need to be excluded. There could of course be a special ExcludeType called UNKNOWN, but null was chosen here. Maybe a comment is in order.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r508609948", "createdAt": "2020-10-20T15:28:08Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/instrumentation/java/concurrent/ExcludeFilter.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.bootstrap.instrumentation.java.concurrent;\n+\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Enables types to opt out of being wrapped and/or having fields injected for a number of the broad\n+ * instrumentations, i.e. {@code Executor} and {@code Runnable}.\n+ */\n+public class ExcludeFilter {\n+\n+  public enum ExcludeType {\n+    RUNNABLE,\n+    CALLABLE,\n+    FUTURE,\n+    FORK_JOIN_TASK,\n+    EXECUTOR;\n+\n+    public static ExcludeType fromFieldType(String typeName) {\n+      switch (typeName) {\n+        case \"java.lang.Runnable\":\n+          return RUNNABLE;\n+        case \"java.util.concurrent.Callable\":\n+          return CALLABLE;\n+        case \"java.util.concurrent.Future\":\n+          return FUTURE;\n+        case \"java.util.concurrent.ForkJoinTask\":\n+          return FORK_JOIN_TASK;\n+        default:\n+          return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4OTE1Mw=="}, "originalCommit": {"oid": "39c15a78f849ece1c0c0ca43c7128b889166f51f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4MTM4NzkwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNjoyOTo1OFrOHkXK4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNToyODoxNFrOHlDGDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5MDQwMA==", "bodyText": "to pair with the comment in the ExcludeFilter regarding potentially coercing a string to a null enum value, why not pass keyType directly into the filter and skip the null check here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r507890400", "createdAt": "2020-10-19T16:29:58Z", "author": {"login": "BurgersMcSlopshot"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "diffHunk": "@@ -461,13 +453,27 @@ public static void resetContextMatchers() {\n   private static AgentBuilder.RawMatcher safeToInjectFieldsMatcher(\n       final String keyType, final String valueType) {\n     return new AgentBuilder.RawMatcher() {\n+      private final ExcludeType skipType = ExcludeType.fromFieldType(keyType);\n+\n       @Override\n       public boolean matches(\n           final TypeDescription typeDescription,\n           final ClassLoader classLoader,\n           final JavaModule module,\n           final Class<?> classBeingRedefined,\n           final ProtectionDomain protectionDomain) {\n+\n+        // First check if we should skip injecting the field based on the key type\n+        if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39c15a78f849ece1c0c0ca43c7128b889166f51f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYxMDA2Mw==", "bodyText": "Thanks. That is a very good point.", "url": "https://github.com/DataDog/dd-trace-java/pull/1933#discussion_r508610063", "createdAt": "2020-10-20T15:28:14Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "diffHunk": "@@ -461,13 +453,27 @@ public static void resetContextMatchers() {\n   private static AgentBuilder.RawMatcher safeToInjectFieldsMatcher(\n       final String keyType, final String valueType) {\n     return new AgentBuilder.RawMatcher() {\n+      private final ExcludeType skipType = ExcludeType.fromFieldType(keyType);\n+\n       @Override\n       public boolean matches(\n           final TypeDescription typeDescription,\n           final ClassLoader classLoader,\n           final JavaModule module,\n           final Class<?> classBeingRedefined,\n           final ProtectionDomain protectionDomain) {\n+\n+        // First check if we should skip injecting the field based on the key type\n+        if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5MDQwMA=="}, "originalCommit": {"oid": "39c15a78f849ece1c0c0ca43c7128b889166f51f"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4875, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}