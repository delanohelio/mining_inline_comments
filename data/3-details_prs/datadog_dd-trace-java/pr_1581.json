{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNzMwODE0", "number": 1581, "title": "Easy MLT binary format writer perf fixes", "bodyText": "This PR contains 2 commits:\n\nFrameSequence.length computation fix (non-contentious simple fix)\nA ByteBuffer backed implementation of the LEB128Writer", "createdAt": "2020-06-12T14:57:39Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1581", "merged": true, "mergeCommit": {"oid": "c3b9016426386da197ca999ed59b008aee6df84d"}, "closed": true, "closedAt": "2020-06-16T08:57:10Z", "author": {"login": "jbachorik"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqkEhCgH2gAyNDMzNzMwODE0OjNmOTYyMzg1YTU4YmFjMTZiMGY2MDQyNTcyOWFiZjRiMTlmMWEwOTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrwuCKgFqTQzMTI1OTE3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3f962385a58bac16b0f60425729abf4b19f1a091", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/3f962385a58bac16b0f60425729abf4b19f1a091", "committedDate": "2020-06-12T14:52:25Z", "message": "Do not recompute FrameSequence.length recursively"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ad8e34e5575184cf49b84bed02d109329320ebc", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8ad8e34e5575184cf49b84bed02d109329320ebc", "committedDate": "2020-06-12T14:52:59Z", "message": "Provide a ByteBuffer backed implementation of LEB128Writer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODE2MDU4", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429816058", "createdAt": "2020-06-12T15:02:59Z", "commit": {"oid": "8ad8e34e5575184cf49b84bed02d109329320ebc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTowMjo1OVrOGjHYdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTowMjo1OVrOGjHYdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NDI5NA==", "bodyText": "I can't really figure out how length can become -1", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439474294", "createdAt": "2020-06-12T15:02:59Z", "author": {"login": "bantonsson"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/FrameSequence.java", "diffHunk": "@@ -58,14 +61,16 @@ public FrameSequence(\n   }\n \n   public int length() {\n-    if (isEmpty()) {\n-      return 0;\n-    }\n-    if (isLeaf()) {\n-      return frameCpIndexes.length;\n+    if (length == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad8e34e5575184cf49b84bed02d109329320ebc"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1f30019655279f3c5e37498ede5d7a68fa7be6c0", "committedDate": "2020-06-12T15:04:58Z", "message": "Initialize FrameSequence.length to -1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODUyOTg5", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429852989", "createdAt": "2020-06-12T15:51:59Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1MTo1OVrOGjJCKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1MTo1OVrOGjJCKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTM1NQ==", "bodyText": "We've been caching these in various ways (constants in a poor man's constant pool, variables in an LRU cache) could you take something like a Function<String, byte[]> which intercepts this?\nI was a bit surprised that C2 isn't smart enough to eliminate these, even with compact strings.", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439501355", "createdAt": "2020-06-12T15:51:59Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/AbstractLEB128Writer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+abstract class AbstractLEB128Writer implements LEB128Writer {\n+  @Override\n+  public final LEB128Writer writeChar(char data) {\n+    writeChar(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeChar(long offset, char data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeShort(short data) {\n+    writeShort(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeShort(long offset, short data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeInt(int data) {\n+    writeInt(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeInt(long offset, int data) {\n+    return writeLong(offset, data & 0x00000000ffffffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeLong(long data) {\n+    writeLong(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeLong(long offset, long data) {\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeFloat(float data) {\n+    writeFloat(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeDouble(double data) {\n+    writeDouble(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBoolean(boolean data) {\n+    writeBoolean(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeByte(byte data) {\n+    writeByte(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBytes(byte... data) {\n+    writeBytes(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeUTF(String data) {\n+    writeUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeUTF(long offset, String data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODUzMjEw", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429853210", "createdAt": "2020-06-12T15:52:17Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1MjoxN1rOGjJCxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1MjoxN1rOGjJCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTUwOA==", "bodyText": "ditto", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439501508", "createdAt": "2020-06-12T15:52:17Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/AbstractLEB128Writer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+abstract class AbstractLEB128Writer implements LEB128Writer {\n+  @Override\n+  public final LEB128Writer writeChar(char data) {\n+    writeChar(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeChar(long offset, char data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeShort(short data) {\n+    writeShort(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeShort(long offset, short data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeInt(int data) {\n+    writeInt(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeInt(long offset, int data) {\n+    return writeLong(offset, data & 0x00000000ffffffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeLong(long data) {\n+    writeLong(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeLong(long offset, long data) {\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeFloat(float data) {\n+    writeFloat(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeDouble(double data) {\n+    writeDouble(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBoolean(boolean data) {\n+    writeBoolean(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeByte(byte data) {\n+    writeByte(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBytes(byte... data) {\n+    writeBytes(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeUTF(String data) {\n+    writeUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeUTF(long offset, String data) {\n+    byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n+    long pos = writeInt(offset, bytes.length);\n+    return writeBytes(pos, bytes);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeCompactUTF(String data) {\n+    writeCompactUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeCompactUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODU0MzA2", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429854306", "createdAt": "2020-06-12T15:53:51Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1Mzo1MVrOGjJGBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1Mzo1MVrOGjJGBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMjM0MQ==", "bodyText": "I really think that using a byte[] instead of a ByteBuffer on JDK11 will leave a lot on the table when writing wide integer types (there's no difference if you benchmark on JDK8).", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439502341", "createdAt": "2020-06-12T15:53:51Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteArrayWriter.java", "diffHunk": "@@ -1,167 +1,34 @@\n package com.datadog.mlt.io;\n \n-import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n \n /** Byte-array writer with default support for LEB128 encoded integer types */\n-final class LEB128ByteArrayWriter {\n-  private static final int EXT_BIT = 0x80;\n-  private static final long COMPRESSED_INT_MASK = -EXT_BIT;\n+final class LEB128ByteArrayWriter extends AbstractLEB128Writer {\n   private byte[] array;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODU1NDEy", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429855412", "createdAt": "2020-06-12T15:55:19Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1NToyMFrOGjJJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1NToyMFrOGjJJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMzE1Ng==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439503156", "createdAt": "2020-06-12T15:55:20Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteBufferWriter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class LEB128ByteBufferWriter extends AbstractLEB128Writer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODU2NTg4", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429856588", "createdAt": "2020-06-12T15:56:52Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1Njo1M1rOGjJMqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1Njo1M1rOGjJMqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDA0MA==", "bodyText": "Have you tried using on heap buffers? This is slow, so should probably be pooled if you need direct memory, and makes the copy slower too.", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439504040", "createdAt": "2020-06-12T15:56:53Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteBufferWriter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class LEB128ByteBufferWriter extends AbstractLEB128Writer {\n+  private ByteBuffer buffer;\n+\n+  LEB128ByteBufferWriter(int initialCapacity) {\n+    this.buffer = ByteBuffer.allocateDirect(initialCapacity);\n+  }\n+\n+  @Override\n+  public void reset() {\n+    buffer.clear();\n+  }\n+\n+  @Override\n+  public long writeFloat(long offset, float data) {\n+    ensureCapacity((int) offset, 4);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putFloat(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeDouble(long offset, double data) {\n+    ensureCapacity((int) offset, 8);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putDouble(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeByte(long offset, byte data) {\n+    ensureCapacity((int) offset, 1);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.put(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeBytes(long offset, byte... data) {\n+    ensureCapacity((int) offset, data.length);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.put(data, 0, data.length);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeShortRaw(long offset, short data) {\n+    ensureCapacity((int) offset, 2);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putShort(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeIntRaw(long offset, int data) {\n+    ensureCapacity((int) offset, 4);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putInt(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeLongRaw(long offset, long data) {\n+    ensureCapacity((int) offset, 8);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putLong(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public byte[] toByteArray() {\n+    buffer.flip();\n+    byte[] data = new byte[buffer.remaining()];\n+    buffer.get(data, 0, data.length);\n+    return data;\n+  }\n+\n+  @Override\n+  public int position() {\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public int capacity() {\n+    return buffer.capacity();\n+  }\n+\n+  private void ensureCapacity(int offset, int dataLength) {\n+    if (offset + dataLength > buffer.capacity()) {\n+      int newCapacity = buffer.capacity() * 2;\n+      log.warn(\n+          \"{} capacity ({} bytes) exceeded. Reallocating internal buffer with new capacity {} bytes\",\n+          this.getClass().getName(),\n+          buffer.capacity(),\n+          newCapacity);\n+      ByteBuffer newBuffer = ByteBuffer.allocateDirect(newCapacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODU3NTQy", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-429857542", "createdAt": "2020-06-12T15:58:13Z", "commit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1ODoxNFrOGjJPQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1ODoxNFrOGjJPQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg==", "bodyText": "Have you considered not releasing a new byte[] and taking a Consumer<byte[] which must synchronously consume the data?", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439504706", "createdAt": "2020-06-12T15:58:14Z", "author": {"login": "richardstartin"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -4,38 +4,29 @@\n import it.unimi.dsi.fastutil.ints.IntSet;\n import java.nio.charset.StandardCharsets;\n import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-import lombok.Generated;\n \n /** The MLT binary format writer */\n public final class MLTWriter {\n+  private static final int CHUNK_WRITER_CAPACITY = 512 * 1024; // initial 512kB for chunk writer\n+  private static final int FRAME_STACK_WRITER_CAPACITY =\n+      256 * 1024; // initial 256kB for frame stack writer\n+  private final LEB128Writer chunkWriter = LEB128Writer.getInstance(CHUNK_WRITER_CAPACITY);\n+  private final LEB128Writer frameStackDataWriter =\n+      LEB128Writer.getInstance(FRAME_STACK_WRITER_CAPACITY);\n   /**\n    * Write a single chunk to its binary format\n    *\n    * @param chunk the chunk\n    * @return chunk in its MLT binary format\n    */\n   public byte[] writeChunk(IMLTChunk chunk) {\n-    LEB128ByteArrayWriter writer =\n-        new LEB128ByteArrayWriter(16384); // conservatively pre-allocate 16k byte array\n-    writeChunk(chunk, writer);\n-    return writer.toByteArray();\n+    writeChunk(chunk, chunkWriter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "757fba3fbe334187a55626a71a3ea7d7aa3abe51", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/757fba3fbe334187a55626a71a3ea7d7aa3abe51", "committedDate": "2020-06-15T14:26:49Z", "message": "Add methods accepting UTF8 byte array to LEB128Writer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9228eca3bdffe76c7e967c3888fa721dc02239a9", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9228eca3bdffe76c7e967c3888fa721dc02239a9", "committedDate": "2020-06-15T14:27:19Z", "message": "Allow exporting LEB128Writer contents via a ByteBuffer callback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d6e2263fc04aa43fa3e8c28c787b3701efa688c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2d6e2263fc04aa43fa3e8c28c787b3701efa688c", "committedDate": "2020-06-15T15:43:43Z", "message": "Fix LEB128Writer to byte[] export"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec71430405d322ec410918b21ed1217c7347c94a", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ec71430405d322ec410918b21ed1217c7347c94a", "committedDate": "2020-06-15T16:02:21Z", "message": "Make formatter happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7aad513231cf8cab0b8ad34e398500e0d8253f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0b7aad513231cf8cab0b8ad34e398500e0d8253f", "committedDate": "2020-06-15T17:52:16Z", "message": "Exclude transient implementation classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjU5MTc5", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#pullrequestreview-431259179", "createdAt": "2020-06-16T08:07:42Z", "commit": {"oid": "0b7aad513231cf8cab0b8ad34e398500e0d8253f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODowNzo0MlrOGkQAlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODowNzo0MlrOGkQAlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2NDIxMg==", "bodyText": "So this is the way to work around the final requirement for the lambda. It makes everything so much more readable \ud83d\ude09", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440664212", "createdAt": "2020-06-16T08:07:42Z", "author": {"login": "bantonsson"}, "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "diffHunk": "@@ -269,7 +314,34 @@ static LEB128Writer getInstance(int initialCapacity) {\n    *\n    * @return byte array containing the written data\n    */\n-  byte[] toByteArray();\n+  default byte[] export() {\n+    final byte[][] dataRef = new byte[1][];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7aad513231cf8cab0b8ad34e398500e0d8253f"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2162, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}