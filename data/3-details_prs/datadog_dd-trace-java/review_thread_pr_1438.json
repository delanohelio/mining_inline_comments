{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0OTE1MDY1", "number": 1438, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjowODo1MVrOD93miA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjowODo1MVrOD93miA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjAwNzEyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjowODo1MVrOGXn0_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjoyNToxM1rOGXog-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjk3NA==", "bodyText": "I think these numbers should be config params.  I can imagine in local testing wanting to change them around a bit.", "url": "https://github.com/DataDog/dd-trace-java/pull/1438#discussion_r427422974", "createdAt": "2020-05-19T16:08:51Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package datadog.trace.core.scopemanager;\n+\n+import com.google.common.util.concurrent.RateLimiter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.interceptor.TraceStatsCollector;\n+import datadog.trace.profiling.Profiler;\n+import datadog.trace.profiling.Session;\n+import java.util.concurrent.TimeUnit;\n+import org.HdrHistogram.Histogram;\n+\n+public class TraceProfilingScopeManager extends ScopeInterceptor.DelegatingInterceptor {\n+  private static final long MAX_NANOSECONDS_BETWEEN_ACTIVATIONS = TimeUnit.SECONDS.toNanos(1);\n+  private static final double ACTIVATIONS_PER_SECOND = 5;\n+  private static final ThreadLocal<Boolean> IS_THREAD_PROFILING =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return false;\n+        }\n+      };\n+\n+  private final TraceStatsCollector statsCollector;\n+  private final RateLimiter rateLimiter = RateLimiter.create(ACTIVATIONS_PER_SECOND);\n+  private volatile long lastProfileTimestamp = System.nanoTime();\n+\n+  public TraceProfilingScopeManager(\n+      final TraceStatsCollector statsCollector, final ScopeInterceptor delegate) {\n+    super(delegate);\n+    this.statsCollector = statsCollector;\n+  }\n+\n+  @Override\n+  public Scope handleSpan(final AgentSpan span) {\n+    if (IS_THREAD_PROFILING.get() // don't need to waste a permit if so.\n+        || !(span instanceof DDSpan)\n+        || !maybeInteresting((DDSpan) span)\n+        || !acquireProfilePermit()) {\n+      // We don't want to wrap the scope for profiling.\n+      return delegate.handleSpan(span);\n+    }\n+    lastProfileTimestamp = System.nanoTime();\n+    return new TraceProfilingScope(delegate.handleSpan(span));\n+  }\n+\n+  private boolean maybeInteresting(final DDSpan span) {\n+    final Histogram traceStats = statsCollector.getTraceStats(span);\n+    if (traceStats == null) {\n+      // No historical data for this trace yet.\n+      return false;\n+    }\n+    final Histogram overallStats = statsCollector.getOverallStats();\n+\n+    final long traceAverage = traceStats.getValueAtPercentile(50);\n+    final long overall80 = overallStats.getValueAtPercentile(80);\n+    if (overall80 < traceAverage) {\n+      // This trace is likely to be slower than most, so lets profile it.\n+      return true;\n+    }\n+\n+    final long traceCount = traceStats.getTotalCount();\n+    final long overallCount = overallStats.getTotalCount();\n+    if (3 < traceCount && traceCount < (overallCount * .9)) {\n+      // This is an uncommon trace (but not unique), so lets profile it.\n+      return true;\n+    }\n+\n+    if (lastProfileTimestamp + MAX_NANOSECONDS_BETWEEN_ACTIVATIONS < System.nanoTime()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "585ea5c3c831c4ec1cd655906ad58b5859ff09f1"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNDIzNA==", "bodyText": "good idea.  I'm going to merge this PR, then cover more config and testing separately.", "url": "https://github.com/DataDog/dd-trace-java/pull/1438#discussion_r427434234", "createdAt": "2020-05-19T16:25:13Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/TraceProfilingScopeManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package datadog.trace.core.scopemanager;\n+\n+import com.google.common.util.concurrent.RateLimiter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.interceptor.TraceStatsCollector;\n+import datadog.trace.profiling.Profiler;\n+import datadog.trace.profiling.Session;\n+import java.util.concurrent.TimeUnit;\n+import org.HdrHistogram.Histogram;\n+\n+public class TraceProfilingScopeManager extends ScopeInterceptor.DelegatingInterceptor {\n+  private static final long MAX_NANOSECONDS_BETWEEN_ACTIVATIONS = TimeUnit.SECONDS.toNanos(1);\n+  private static final double ACTIVATIONS_PER_SECOND = 5;\n+  private static final ThreadLocal<Boolean> IS_THREAD_PROFILING =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return false;\n+        }\n+      };\n+\n+  private final TraceStatsCollector statsCollector;\n+  private final RateLimiter rateLimiter = RateLimiter.create(ACTIVATIONS_PER_SECOND);\n+  private volatile long lastProfileTimestamp = System.nanoTime();\n+\n+  public TraceProfilingScopeManager(\n+      final TraceStatsCollector statsCollector, final ScopeInterceptor delegate) {\n+    super(delegate);\n+    this.statsCollector = statsCollector;\n+  }\n+\n+  @Override\n+  public Scope handleSpan(final AgentSpan span) {\n+    if (IS_THREAD_PROFILING.get() // don't need to waste a permit if so.\n+        || !(span instanceof DDSpan)\n+        || !maybeInteresting((DDSpan) span)\n+        || !acquireProfilePermit()) {\n+      // We don't want to wrap the scope for profiling.\n+      return delegate.handleSpan(span);\n+    }\n+    lastProfileTimestamp = System.nanoTime();\n+    return new TraceProfilingScope(delegate.handleSpan(span));\n+  }\n+\n+  private boolean maybeInteresting(final DDSpan span) {\n+    final Histogram traceStats = statsCollector.getTraceStats(span);\n+    if (traceStats == null) {\n+      // No historical data for this trace yet.\n+      return false;\n+    }\n+    final Histogram overallStats = statsCollector.getOverallStats();\n+\n+    final long traceAverage = traceStats.getValueAtPercentile(50);\n+    final long overall80 = overallStats.getValueAtPercentile(80);\n+    if (overall80 < traceAverage) {\n+      // This trace is likely to be slower than most, so lets profile it.\n+      return true;\n+    }\n+\n+    final long traceCount = traceStats.getTotalCount();\n+    final long overallCount = overallStats.getTotalCount();\n+    if (3 < traceCount && traceCount < (overallCount * .9)) {\n+      // This is an uncommon trace (but not unique), so lets profile it.\n+      return true;\n+    }\n+\n+    if (lastProfileTimestamp + MAX_NANOSECONDS_BETWEEN_ACTIVATIONS < System.nanoTime()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjk3NA=="}, "originalCommit": {"oid": "585ea5c3c831c4ec1cd655906ad58b5859ff09f1"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 305, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}