{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NTY1MTcw", "number": 1889, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1Mjo0OFrOElI55A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MDowOFrOEluzDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc4NjYwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo1Mjo0OFrOHUeFtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzozODowMVrOHUeqiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA==", "bodyText": "Can you clarify the difference between topPos starting at 0, with element 0 maintained to be always null, and topPos starting at -1 and returning null whenever topPos is -1?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491226548", "createdAt": "2020-09-18T22:52:48Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNzE2NA==", "bodyText": "I didn't follow the point about topPos being used for two different purposes, leading to off-by-one errors. What else is topPos used for other than accessing the top of the stack?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491227164", "createdAt": "2020-09-18T22:55:18Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}, "originalCommit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDAxMA==", "bodyText": "So, I reverted all the changes to topPos (0 based rather than -1 based) and the new tests all pass. I don't think this change is necessary.\nb18e63f", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491230010", "createdAt": "2020-09-18T23:07:34Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}, "originalCommit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNTk3Nw==", "bodyText": "Oh.  I completely missed that.  I saw sometimes topPos pointed to the active scope and sometimes didn't.  I agree with having it zero based", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491235977", "createdAt": "2020-09-18T23:38:01Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}, "originalCommit": {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk0NjAyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/log/LogContextScopeListener.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTozODo1N1rOHVXDMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTozODo1N1rOHVXDMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1OTc5NA==", "bodyText": "If the first one fails, the second one is going to get run. Perhaps these should have their own try blocks?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492159794", "createdAt": "2020-09-21T15:38:57Z", "author": {"login": "arkban"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/log/LogContextScopeListener.java", "diffHunk": "@@ -45,10 +43,6 @@ public void afterScopeActivated() {\n \n   @Override\n   public void afterScopeClosed() {\n-    if (activeSpan() != null) {\n-      afterScopeActivated();\n-      return;\n-    }\n     try {\n       removeMethod.invoke(null, CorrelationIdentifier.getTraceIdKey());\n       removeMethod.invoke(null, CorrelationIdentifier.getSpanIdKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk1Mjc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0MDoyOFrOHVXHMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMjo1MToyOVrOHV4dAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg==", "bodyText": "Why remove the \"Ignoring!\" phrase? That was a useful canary to check if things went sideways.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492160816", "createdAt": "2020-09-21T15:40:28Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -148,24 +148,15 @@ protected ScopeStack scopeStack() {\n \n     @Override\n     public void close() {\n-      ScopeStack scopeStack = scopeManager.scopeStack();\n-\n-      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n-      // first round of out-of-order handling.\n-      // When reference counts are being used, we don't check the stack top --\n-      // so potentially we undercount errors\n-      // Also we don't report closed until the reference count == 0 which seems\n-      // incorrect given the OpenTracing semantics\n-      // Both these issues should be corrected at a later date\n+      final ScopeStack scopeStack = scopeManager.scopeStack();\n \n-      boolean alive = decrementReferences();\n-      if (alive) return;\n+      final boolean alive = decrementReferences();\n \n-      boolean onTop = scopeStack.checkTop(this);\n+      final boolean onTop = scopeStack.checkTop(this);\n       if (!onTop) {\n         if (log.isDebugEnabled()) {\n-          // Using noFixupTop because I don't want to have code with side effects in logging code\n-          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+          log.debug(\n+              \"Tried to close {} scope when not on top.  Current top: {}\", this, scopeStack.top());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTQzNQ==", "bodyText": "Depending on perspective this isn't ignored anymore.  The close isn't dropped the way that it used to be.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492251435", "createdAt": "2020-09-21T18:07:51Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -148,24 +148,15 @@ protected ScopeStack scopeStack() {\n \n     @Override\n     public void close() {\n-      ScopeStack scopeStack = scopeManager.scopeStack();\n-\n-      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n-      // first round of out-of-order handling.\n-      // When reference counts are being used, we don't check the stack top --\n-      // so potentially we undercount errors\n-      // Also we don't report closed until the reference count == 0 which seems\n-      // incorrect given the OpenTracing semantics\n-      // Both these issues should be corrected at a later date\n+      final ScopeStack scopeStack = scopeManager.scopeStack();\n \n-      boolean alive = decrementReferences();\n-      if (alive) return;\n+      final boolean alive = decrementReferences();\n \n-      boolean onTop = scopeStack.checkTop(this);\n+      final boolean onTop = scopeStack.checkTop(this);\n       if (!onTop) {\n         if (log.isDebugEnabled()) {\n-          // Using noFixupTop because I don't want to have code with side effects in logging code\n-          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+          log.debug(\n+              \"Tried to close {} scope when not on top.  Current top: {}\", this, scopeStack.top());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwNzA3Mw==", "bodyText": "While true, I'm asking from the perspective of a black box user like myself. It was one of the \"canary\" phrases we used to tell when things went sideways.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492707073", "createdAt": "2020-09-22T12:51:29Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -148,24 +148,15 @@ protected ScopeStack scopeStack() {\n \n     @Override\n     public void close() {\n-      ScopeStack scopeStack = scopeManager.scopeStack();\n-\n-      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n-      // first round of out-of-order handling.\n-      // When reference counts are being used, we don't check the stack top --\n-      // so potentially we undercount errors\n-      // Also we don't report closed until the reference count == 0 which seems\n-      // incorrect given the OpenTracing semantics\n-      // Both these issues should be corrected at a later date\n+      final ScopeStack scopeStack = scopeManager.scopeStack();\n \n-      boolean alive = decrementReferences();\n-      if (alive) return;\n+      final boolean alive = decrementReferences();\n \n-      boolean onTop = scopeStack.checkTop(this);\n+      final boolean onTop = scopeStack.checkTop(this);\n       if (!onTop) {\n         if (log.isDebugEnabled()) {\n-          // Using noFixupTop because I don't want to have code with side effects in logging code\n-          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+          log.debug(\n+              \"Tried to close {} scope when not on top.  Current top: {}\", this, scopeStack.top());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk1NjkxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0MToyM1rOHVXJmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMjozMzowMFrOHVkrhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MTQzNA==", "bodyText": "Is it possible for cancelFromContinuedScopeClose() to throw and prevent this from being reached?", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492161434", "createdAt": "2020-09-21T15:41:23Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -177,19 +168,17 @@ public void close() {\n             throw new RuntimeException(\"Tried to close scope when not on top\");\n           }\n         }\n+      }\n \n+      if (alive) {\n         return;\n       }\n \n       if (null != continuation) {\n-        span.context().getTrace().cancelContinuation(continuation);\n+        continuation.cancelFromContinuedScopeClose();\n       }\n-      scopeStack.blindPop();\n \n-      // DQH - As covered above, I feel our close notification semantics are incorrect with\n-      // especially where reference counting is concerned.  Unfortunately, sorting out the\n-      // semantics will also require sorting out the tests which have codified the ill-behavior.\n-      onProperClose();\n+      scopeStack.cleanup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzExMQ==", "bodyText": "Yes.  If a user throws an exception in a TraceInterceptor.  I changed the ordering in #1894 to prevent this", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492383111", "createdAt": "2020-09-21T22:33:00Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -177,19 +168,17 @@ public void close() {\n             throw new RuntimeException(\"Tried to close scope when not on top\");\n           }\n         }\n+      }\n \n+      if (alive) {\n         return;\n       }\n \n       if (null != continuation) {\n-        span.context().getTrace().cancelContinuation(continuation);\n+        continuation.cancelFromContinuedScopeClose();\n       }\n-      scopeStack.blindPop();\n \n-      // DQH - As covered above, I feel our close notification semantics are incorrect with\n-      // especially where reference counting is concerned.  Unfortunately, sorting out the\n-      // semantics will also require sorting out the tests which have codified the ill-behavior.\n-      onProperClose();\n+      scopeStack.cleanup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MTQzNA=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk4MjU4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0NzoxNFrOHVXZgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODowODo1NFrOHVcrkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NTUwNg==", "bodyText": "Does this mean that topPos is 1-indexed? I'm asking because it says here 0 if empty, yet all the calls like stack[topPos] seem to use topPos as if it was 0-indexed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492165506", "createdAt": "2020-09-21T15:47:14Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjA0OQ==", "bodyText": "Originally, I had topPos == -1 when the stack was empty.  I think I preferred it that way.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492252049", "createdAt": "2020-09-21T18:08:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NTUwNg=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk4NjQyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODoxMlrOHVXb7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzo1Nzo1NFrOHVcTmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEyNw==", "bodyText": "Should this be private? Seems like internal state.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492166127", "createdAt": "2020-09-21T15:48:12Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NTkxNQ==", "bodyText": "Originally, I didn't make them private because I didn't want synthetic accessors to be generated.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492245915", "createdAt": "2020-09-21T17:57:54Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEyNw=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk5NTAxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MDowOFrOHVXhZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMzowMjoxNVrOHVlT4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg==", "bodyText": "Why not use an ArrayList? You might do better off with that and calling ArrayList.trimToSize() when it's capacity grows beyond what you want.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492167526", "createdAt": "2020-09-21T15:50:08Z", "author": {"login": "arkban"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty\n     int topPos = 0;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    /** top - accesses the top of the ScopeStack */\n     final ContinuableScope top() {\n-      int priorTopPos = this.topPos;\n-      if (priorTopPos == 0) {\n-        return null;\n-      }\n+      return stack[topPos];\n+    }\n \n+    void cleanup() {\n       // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n       // only bothering to do this here because of the loop below\n-      ContinuableScope[] stack = this.stack;\n-      priorTopPos = Math.min(priorTopPos, stack.length);\n-\n-      // Peel first iteration\n-      ContinuableScope topScope = stack[priorTopPos];\n-      if (topScope.alive()) {\n-        return topScope;\n-      }\n+      final ContinuableScope[] stack = this.stack;\n+      topPos = Math.min(topPos, stack.length);\n \n-      // null out top position, it is no longer alive\n-      stack[topPos] = null;\n-\n-      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n-        ContinuableScope curScope = stack[curPos];\n+      boolean changedTop = false;\n+      while (topPos > 0) {\n+        final ContinuableScope curScope = stack[topPos];\n         if (curScope.alive()) {\n-          // save the position for next time\n-          topPos = curPos;\n-\n-          if (topPos < stack.length / 4) {\n-            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          if (changedTop) {\n+            curScope.afterActivated();\n           }\n-\n-          return curScope;\n+          break;\n         }\n \n         // no longer alive -- trigger listener & null out\n         curScope.onProperClose();\n-        stack[curPos] = null;\n+        stack[topPos] = null;\n+        --topPos;\n+        changedTop = true;\n       }\n \n-      // empty stack -- save topPos for next time\n-      topPos = 0;\n-      return null;\n-    }\n-\n-    /**\n-     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n-     * useful in logging to avoid side effects, but could be used in other places with caution.\n-     */\n-    final ContinuableScope noFixupTop() {\n-      return stack[topPos];\n+      if (topPos < stack.length / 4 && stack.length > MIN_STACK_LENGTH * 4) {\n+        this.stack = Arrays.copyOf(stack, stack.length / 2);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDA4Ng==", "bodyText": "Yes, in retrospect, an ArrayList probably would work fine.  I'm not quite sure why I chose to use an array directly.\nI wanted a stack, but I didn't want Stack since it has sync overhead.\nI think I also wanted to control the contraction, but honestly, I think we could just skip the contraction altogether.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492250086", "createdAt": "2020-09-21T18:05:19Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty\n     int topPos = 0;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    /** top - accesses the top of the ScopeStack */\n     final ContinuableScope top() {\n-      int priorTopPos = this.topPos;\n-      if (priorTopPos == 0) {\n-        return null;\n-      }\n+      return stack[topPos];\n+    }\n \n+    void cleanup() {\n       // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n       // only bothering to do this here because of the loop below\n-      ContinuableScope[] stack = this.stack;\n-      priorTopPos = Math.min(priorTopPos, stack.length);\n-\n-      // Peel first iteration\n-      ContinuableScope topScope = stack[priorTopPos];\n-      if (topScope.alive()) {\n-        return topScope;\n-      }\n+      final ContinuableScope[] stack = this.stack;\n+      topPos = Math.min(topPos, stack.length);\n \n-      // null out top position, it is no longer alive\n-      stack[topPos] = null;\n-\n-      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n-        ContinuableScope curScope = stack[curPos];\n+      boolean changedTop = false;\n+      while (topPos > 0) {\n+        final ContinuableScope curScope = stack[topPos];\n         if (curScope.alive()) {\n-          // save the position for next time\n-          topPos = curPos;\n-\n-          if (topPos < stack.length / 4) {\n-            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          if (changedTop) {\n+            curScope.afterActivated();\n           }\n-\n-          return curScope;\n+          break;\n         }\n \n         // no longer alive -- trigger listener & null out\n         curScope.onProperClose();\n-        stack[curPos] = null;\n+        stack[topPos] = null;\n+        --topPos;\n+        changedTop = true;\n       }\n \n-      // empty stack -- save topPos for next time\n-      topPos = 0;\n-      return null;\n-    }\n-\n-    /**\n-     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n-     * useful in logging to avoid side effects, but could be used in other places with caution.\n-     */\n-    final ContinuableScope noFixupTop() {\n-      return stack[topPos];\n+      if (topPos < stack.length / 4 && stack.length > MIN_STACK_LENGTH * 4) {\n+        this.stack = Arrays.copyOf(stack, stack.length / 2);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MzQ0MQ==", "bodyText": "I remembered the prototype.  I had a bulk clear which was easier to do with an array directly, but that's not really worth the trouble when the listener also needs to be notified.\nIn a separate conversation, @randomanderson proposed an ArrayDeque which I think should work nicely.", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492393441", "createdAt": "2020-09-21T23:02:15Z", "author": {"login": "dougqh"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty\n     int topPos = 0;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    /** top - accesses the top of the ScopeStack */\n     final ContinuableScope top() {\n-      int priorTopPos = this.topPos;\n-      if (priorTopPos == 0) {\n-        return null;\n-      }\n+      return stack[topPos];\n+    }\n \n+    void cleanup() {\n       // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n       // only bothering to do this here because of the loop below\n-      ContinuableScope[] stack = this.stack;\n-      priorTopPos = Math.min(priorTopPos, stack.length);\n-\n-      // Peel first iteration\n-      ContinuableScope topScope = stack[priorTopPos];\n-      if (topScope.alive()) {\n-        return topScope;\n-      }\n+      final ContinuableScope[] stack = this.stack;\n+      topPos = Math.min(topPos, stack.length);\n \n-      // null out top position, it is no longer alive\n-      stack[topPos] = null;\n-\n-      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n-        ContinuableScope curScope = stack[curPos];\n+      boolean changedTop = false;\n+      while (topPos > 0) {\n+        final ContinuableScope curScope = stack[topPos];\n         if (curScope.alive()) {\n-          // save the position for next time\n-          topPos = curPos;\n-\n-          if (topPos < stack.length / 4) {\n-            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          if (changedTop) {\n+            curScope.afterActivated();\n           }\n-\n-          return curScope;\n+          break;\n         }\n \n         // no longer alive -- trigger listener & null out\n         curScope.onProperClose();\n-        stack[curPos] = null;\n+        stack[topPos] = null;\n+        --topPos;\n+        changedTop = true;\n       }\n \n-      // empty stack -- save topPos for next time\n-      topPos = 0;\n-      return null;\n-    }\n-\n-    /**\n-     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n-     * useful in logging to avoid side effects, but could be used in other places with caution.\n-     */\n-    final ContinuableScope noFixupTop() {\n-      return stack[topPos];\n+      if (topPos < stack.length / 4 && stack.length > MIN_STACK_LENGTH * 4) {\n+        this.stack = Arrays.copyOf(stack, stack.length / 2);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg=="}, "originalCommit": {"oid": "b6985538d4d8f485557af5c2a2374128487db093"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4834, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}