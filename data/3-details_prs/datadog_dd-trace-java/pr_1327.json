{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDQwNjQ1", "number": 1327, "title": "Netty 3.8-3.10 instrumentation", "bodyText": "Creates new Netty 3.8 through 3.10 instrumentation, allowing for instrumentation of Play 2.3 which depends on this. Mostly copies the netty 4.0 instrumentation", "createdAt": "2020-03-20T09:52:59Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1327", "merged": true, "mergeCommit": {"oid": "2b5037e2f7d49d69085869ac2afed458557036bc"}, "closed": true, "closedAt": "2020-03-23T19:12:21Z", "author": {"login": "devinsba"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPdJIZAH2gAyMzkxNDQwNjQ1OjQ0OTA1Y2IyZDYyMGJkN2IyZDAyZTE2YzFiYTA3NGI5ZDFjODI2MDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQjNN1gFqTM3OTczODQwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "44905cb2d620bd7b2d02e16c1ba074b9d1c82606", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/44905cb2d620bd7b2d02e16c1ba074b9d1c82606", "committedDate": "2020-03-20T09:32:10Z", "message": "Implement netty 3.9 instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e45aa731f9409bd51d0d1be8a57d515a1b7bef6", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7e45aa731f9409bd51d0d1be8a57d515a1b7bef6", "committedDate": "2020-03-20T09:36:52Z", "message": "Add module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baf02ff526e6c88bee3317bd83896c6afd680560", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/baf02ff526e6c88bee3317bd83896c6afd680560", "committedDate": "2020-03-20T09:41:35Z", "message": "Remove unneccesary checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d84dd7eecf6bc0a006e7783838d59d18066527c", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/2d84dd7eecf6bc0a006e7783838d59d18066527c", "committedDate": "2020-03-20T09:45:09Z", "message": "Add a comment for a special case to this netty version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e4f9c4dc6943ff69f13d27b88c0da37bfa7dcba", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8e4f9c4dc6943ff69f13d27b88c0da37bfa7dcba", "committedDate": "2020-03-20T09:52:16Z", "message": "refine gradle config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb99b410c57cd95140b330588115eb3cd556f606", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/eb99b410c57cd95140b330588115eb3cd556f606", "committedDate": "2020-03-20T10:25:26Z", "message": "gross hack for muzzle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9297ff39f47b797a9990b169692234144e66bfb6", "committedDate": "2020-03-20T12:00:34Z", "message": "Less ambiguous name, also doesn't collide with netty class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjIzOTUx", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-378623951", "createdAt": "2020-03-20T16:15:46Z", "commit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjoxNTo0NlrOF5aUgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjo1Njo0OFrOF5b2Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDM4Ng==", "bodyText": "Can this go all the way to 4.0)?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395744386", "createdAt": "2020-03-20T16:15:46Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  maxJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"io.netty\"\n+    module = \"netty\"\n+    versions = \"[3.9.0.Final,3.10)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NTA1MA==", "bodyText": "Any idea why this doesn't work with 3.10?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395745050", "createdAt": "2020-03-20T16:16:55Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/netty-3.9.gradle", "diffHunk": "@@ -0,0 +1,51 @@\n+// Set properties before any plugins get loaded\n+ext {\n+  minJavaVersionForTests = JavaVersion.VERSION_1_8\n+  maxJavaVersionForTests = JavaVersion.VERSION_1_8\n+}\n+\n+apply from: \"${rootDir}/gradle/java.gradle\"\n+\n+muzzle {\n+  pass {\n+    group = \"io.netty\"\n+    module = \"netty\"\n+    versions = \"[3.9.0.Final,3.10)\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDM4Ng=="}, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA==", "bodyText": "Why don't we want it to work with those versions?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395762398", "createdAt": "2020-03-20T16:44:56Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty39;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        \"org.jboss.netty.buffer.EmptyChannelBuffer\", // Not in 3.8\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTQwNw==", "bodyText": "I don't think we need the if here... only on clients actually used by AWS-SDK", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395769407", "createdAt": "2020-03-20T16:56:48Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package datadog.trace.instrumentation.netty39.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty39.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty39.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      // AWS calls are often signed, so we can't add headers without breaking the signature.\n+      if (!request.headers().contains(\"amz-sdk-invocation-id\")) {\n+        propagate().inject(span, request.headers(), SETTER);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9297ff39f47b797a9990b169692234144e66bfb6"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ae71c8087c84c257690a7631b3ee157098c450b", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/4ae71c8087c84c257690a7631b3ee157098c450b", "committedDate": "2020-03-20T18:12:39Z", "message": "Works with 3.8 also, still need to fix muzzle again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8fc300df0e0bdd1e21978e548e2fcb48e433055", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c8fc300df0e0bdd1e21978e548e2fcb48e433055", "committedDate": "2020-03-20T18:14:41Z", "message": "Not used by aws sdk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59dffa3d5d6e3f19bde08a1cf5a46d79059c9dbd", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/59dffa3d5d6e3f19bde08a1cf5a46d79059c9dbd", "committedDate": "2020-03-20T18:27:47Z", "message": "Minimal change to make muzzle pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "committedDate": "2020-03-20T18:57:08Z", "message": "Clarify muzzle specific checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzkzMjU0", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-378793254", "createdAt": "2020-03-20T20:30:46Z", "commit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDozMDo0N1rOF5iVAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowMTo1M1rOF5jF-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelFutureListener\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n          \n      \n    \n    \n  \n\nYou shouldn't need the manual 3.10 restrictions, muzzle should cover that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395875587", "createdAt": "2020-03-20T20:30:47Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA==", "bodyText": "Static import...", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395876458", "createdAt": "2020-03-20T20:32:50Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTI4MQ==", "bodyText": "If you need a way to ensure the instrumentation all applies consistently, I suggest doing something like this instead:\nhttps://github.com/DataDog/dd-trace-java/blob/master/dd-java-agent/instrumentation/rabbitmq-amqp-2.7/src/main/java/datadog/trace/instrumentation/rabbitmq/amqp/RabbitCommandInstrumentation.java#L70-L77", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885281", "createdAt": "2020-03-20T20:54:36Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTk4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.Channel\",\n          \n          \n            \n                    // 3.7: cannot find symbol method headers() for type HttpRequest\n          \n          \n            \n                    \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n          \n      \n    \n    \n  \n\nSame as above.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885980", "createdAt": "2020-03-20T20:56:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.Channel\",\n+        // 3.7: cannot find symbol method headers() for type HttpRequest\n+        \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzI4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelPipeline\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395887281", "createdAt": "2020-03-20T20:59:37Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelPipeline\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4ODEyMQ==", "bodyText": "Netty39ClientTest -> Netty38ClientTest\n(Same for server test.)", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395888121", "createdAt": "2020-03-20T21:01:53Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/test/groovy/Netty39ClientTest.groovy", "diffHunk": "@@ -0,0 +1,103 @@\n+import com.ning.http.client.AsyncCompletionHandler\n+import com.ning.http.client.AsyncHttpClient\n+import com.ning.http.client.AsyncHttpClientConfig\n+import com.ning.http.client.Response\n+import datadog.trace.agent.test.base.HttpClientTest\n+import datadog.trace.bootstrap.instrumentation.api.Tags\n+import datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator\n+import spock.lang.AutoCleanup\n+import spock.lang.Shared\n+\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import static datadog.trace.agent.test.utils.PortUtils.UNUSABLE_PORT\n+import static datadog.trace.agent.test.utils.TraceUtils.basicSpan\n+import static datadog.trace.agent.test.utils.TraceUtils.runUnderTrace\n+\n+class Netty39ClientTest extends HttpClientTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17f73b6896714f46b754103880e55dde4b16ff28", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/17f73b6896714f46b754103880e55dde4b16ff28", "committedDate": "2020-03-23T14:01:58Z", "message": "Fix small things from review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5ac54ce10d36f5d6ec60e27793802c7899a69365", "committedDate": "2020-03-23T14:30:37Z", "message": "Update to support 3.10 also and make muzzle check less brittle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjgyMzI3", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379682327", "createdAt": "2020-03-23T17:57:09Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzowOVrOF6RYTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzowOVrOF6RYTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjQ3OQ==", "bodyText": "Not necessarily for this PR, but now, that having a classLoaderMatcher check is the norm to combat matching costs.  I think we should make the concept of key class for a library a required part of almost every instrumentation.\nI also think we should revisit the idea of a Library as a first class concept as well.  While at first, I think this seems like more work.  I think right now we end up duplicating some classLoaderMatcher code because we lack the concept of a library.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396646479", "createdAt": "2020-03-23T17:57:09Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjgzOTg5", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379683989", "createdAt": "2020-03-23T17:59:08Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1OTowOFrOF6Rd9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1OTowOFrOF6Rd9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzkyNQ==", "bodyText": "ChannelTraceContext.class will trigger a class load in the agent ClassLoader.\nHowever, I'm assuming we should only need ChannelTraceContext in the target ClassLoader.\nThis comes up enough that I'm wondering if we should make doing this the right way easier somehow.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396647925", "createdAt": "2020-03-23T17:59:08Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4a4c5619c7bc303c73d701b023638b7a51a3913", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d4a4c5619c7bc303c73d701b023638b7a51a3913", "committedDate": "2020-03-23T18:03:00Z", "message": "Less class loads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjkwNzcy", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379690772", "createdAt": "2020-03-23T18:07:41Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowNzo0MVrOF6RzvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowNzo0MVrOF6RzvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1MzUwMA==", "bodyText": "I'm guessing this is idiomatic to our code base.  However, compareAndSet to me evokes a specific atomicity guarantee that this does seem to provide.\nI'm not necessarily suggesting a change -- just that this is confusing to a casual reader.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396653500", "createdAt": "2020-03-23T18:07:41Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelTraceContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import lombok.Data;\n+\n+@Data\n+public class ChannelTraceContext {\n+  public static class Factory implements ContextStore.Factory<ChannelTraceContext> {\n+    public static final Factory INSTANCE = new Factory();\n+\n+    @Override\n+    public ChannelTraceContext create() {\n+      return new ChannelTraceContext();\n+    }\n+  }\n+\n+  TraceScope.Continuation connectionContinuation;\n+  AgentSpan serverSpan;\n+  AgentSpan clientSpan;\n+  AgentSpan clientParentSpan;\n+\n+  public boolean compareAndSet(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjkyMzM0", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379692334", "createdAt": "2020-03-23T18:09:37Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowOTozN1rOF6R4nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODowOTozN1rOF6R4nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDc0OA==", "bodyText": "Shouldn't closing be in a finally block?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396654748", "createdAt": "2020-03-23T18:09:37Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.Channel\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"connect\"))\n+            .and(returns(named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        NettyChannelInstrumentation.class.getName() + \"$ChannelConnectAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class ChannelConnectAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static void addConnectContinuation(@Advice.This final Channel channel) {\n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        final TraceScope.Continuation continuation = scope.capture();\n+        if (continuation != null) {\n+          final ContextStore<Channel, ChannelTraceContext> contextStore =\n+              InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+          if (!contextStore\n+              .putIfAbsent(channel, ChannelTraceContext.Factory.INSTANCE)\n+              .compareAndSet(null, continuation)) {\n+            continuation.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk0MTAy", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379694102", "createdAt": "2020-03-23T18:12:02Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMjowMlrOF6R-Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMjowMlrOF6R-Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NjE5NQ==", "bodyText": "Should we log here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656195", "createdAt": "2020-03-23T18:12:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk0ODIz", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379694823", "createdAt": "2020-03-23T18:13:01Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMzowMlrOF6SAew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxMzowMlrOF6SAew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw==", "bodyText": "Why not just pipeline.remove(handler.getClass().getName())?\nDoes remove fail if it is missing?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656763", "createdAt": "2020-03-23T18:13:02Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.\n+      } finally {\n+        CallDepthThreadLocalMap.reset(ChannelPipeline.class);\n+      }\n+    }\n+  }\n+\n+  public static class ChannelPipelineAdd2ArgsAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static int checkDepth(\n+        @Advice.This final ChannelPipeline pipeline,\n+        @Advice.Argument(1) final ChannelHandler handler) {\n+      // Pipelines are created once as a factory and then copied multiple times using the same add\n+      // methods as we are hooking. If our handler has already been added we need to remove it so we\n+      // don't end up with duplicates (this throws an exception)\n+      if (pipeline.get(handler.getClass().getName()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk2NjAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379696600", "createdAt": "2020-03-23T18:14:47Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNDo0OFrOF6SEeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNDo0OFrOF6SEeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA==", "bodyText": "finally block?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396657784", "createdAt": "2020-03-23T18:14:48Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();\n+        throw throwable;\n+      }\n+    }\n+\n+    if (null != parentScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk3MTM3", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379697137", "createdAt": "2020-03-23T18:15:10Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNToxMVrOF6SFeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNToxMVrOF6SFeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA==", "bodyText": "Do we not finish the span if there isn't an Exception?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658040", "createdAt": "2020-03-23T18:15:11Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk3Njk3", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379697697", "createdAt": "2020-03-23T18:15:35Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNTozNlrOF6SGkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNTozNlrOF6SGkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw==", "bodyText": "finally?", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658323", "createdAt": "2020-03-23T18:15:36Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.noopSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+public class HttpClientResponseTracingHandler extends SimpleChannelUpstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientResponseTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    AgentSpan parent = channelTraceContext.getClientParentSpan();\n+    if (parent == null) {\n+      parent = noopSpan();\n+      channelTraceContext.setClientParentSpan(noopSpan());\n+    }\n+    final AgentSpan span = channelTraceContext.getClientSpan();\n+\n+    final boolean finishSpan = msg.getMessage() instanceof HttpResponse;\n+\n+    if (span != null && finishSpan) {\n+      try (final AgentScope scope = activateSpan(span, false)) {\n+        DECORATE.onResponse(span, (HttpResponse) msg.getMessage());\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5Njk5MzA5", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379699309", "createdAt": "2020-03-23T18:17:01Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNzowMVrOF6SKDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxNzowMVrOF6SKDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1OTIxNA==", "bodyText": "Probably not for this PR, but we probably shouldn't build URI just to extract pieces to tags later.\nThat creates a hot allocation point under load.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396659214", "createdAt": "2020-03-23T18:17:01Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzAzMzg2", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379703386", "createdAt": "2020-03-23T18:22:09Z", "commit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoyMjowOVrOF6SaQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoyMjowOVrOF6SaQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MzM2Mw==", "bodyText": "Again, probably not this PR.\nBut why does this return Integer rather than int?\nAlso, we might want to create our Integer cache for HttpStatus codes, since most of them lie outside the default cache range.", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396663363", "createdAt": "2020-03-23T18:22:09Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());\n+    if ((uri.getHost() == null || uri.getHost().equals(\"\")) && request.headers().contains(HOST)) {\n+      return new URI(\"http://\" + request.headers().get(HOST) + request.getUri());\n+    } else {\n+      return uri;\n+    }\n+  }\n+\n+  @Override\n+  protected Integer status(final HttpResponse httpResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5aa1800bec90358ec10be6b3869dd549409c8dac", "author": {"user": {"login": "devinsba", "name": "Brian Devins-Suresh"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5aa1800bec90358ec10be6b3869dd549409c8dac", "committedDate": "2020-03-23T18:44:11Z", "message": "Get rid of half baked map methods. Close parentScope in a finally block (+forward port)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzM4NDA5", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#pullrequestreview-379738409", "createdAt": "2020-03-23T19:09:59Z", "commit": {"oid": "5aa1800bec90358ec10be6b3869dd549409c8dac"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2588, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}