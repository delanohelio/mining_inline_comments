{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMjI0NTQx", "number": 1735, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTowMDowNlrOEUo-tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjoxOToyMVrOEUq4Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDc4MzkwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNTowMDowNlrOG69APQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjowNDowNFrOG6_baw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDA3Nw==", "bodyText": "What is the chance of this happening on customer deployments?\nWould it be a very rare occasion only?", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464470077", "createdAt": "2020-08-03T15:00:06Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,31 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.warn(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72bc50349be678b2ed5ab2b91f137741a941bbd8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MzYyNw==", "bodyText": "well in fact it's happening in staging for prof-analyzer-java \ud83d\ude01", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464493627", "createdAt": "2020-08-03T15:37:08Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,31 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.warn(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDA3Nw=="}, "originalCommit": {"oid": "72bc50349be678b2ed5ab2b91f137741a941bbd8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5NjU1Nw==", "bodyText": "In that case perhaps INFO and some innocent message :) Customers tend to be quite spooked when seeing WARN and ERROR in their app logs :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464496557", "createdAt": "2020-08-03T15:41:55Z", "author": {"login": "jbachorik"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,31 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.warn(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDA3Nw=="}, "originalCommit": {"oid": "72bc50349be678b2ed5ab2b91f137741a941bbd8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5NzI4Nw==", "bodyText": "noted, right now, I am trying to figure out what is happening :)", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464497287", "createdAt": "2020-08-03T15:43:07Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,31 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.warn(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDA3Nw=="}, "originalCommit": {"oid": "72bc50349be678b2ed5ab2b91f137741a941bbd8"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwOTgwMw==", "bodyText": "done", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464509803", "createdAt": "2020-08-03T16:04:04Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,31 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.warn(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3MDA3Nw=="}, "originalCommit": {"oid": "72bc50349be678b2ed5ab2b91f137741a941bbd8"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMTA5NTMxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjoxOToyMVrOG6_9gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjo0NjozMlrOG7A4Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxODUyOQ==", "bodyText": "This should either be at debug only or rate limited.", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464518529", "createdAt": "2020-08-03T16:19:21Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,34 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        if (threadInfo == null) {\n+          continue;\n+        }\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.info(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "994a0c842c5264e202a1bbbda680e6d99fc4cba5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzMzUzNA==", "bodyText": "done", "url": "https://github.com/DataDog/dd-trace-java/pull/1735#discussion_r464533534", "createdAt": "2020-08-03T16:46:32Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-mlt/src/main/java/com/datadog/mlt/sampler/JMXSampler.java", "diffHunk": "@@ -86,27 +86,34 @@ public void removeThread(long threadId) {\n   }\n \n   private void sample() {\n-    long[] tmpArray = threadIds.get();\n-    if (tmpArray == null || tmpArray.length == 0) {\n-      return;\n-    }\n-    ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n-    if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n-      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n-      providerFirstAccess = false;\n-    }\n-    final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n-    // dispatch to Scopes\n-    for (ThreadInfo threadInfo : threadInfos) {\n-      ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n-      if (scopeManager == null) {\n-        continue;\n+    try {\n+      long[] tmpArray = threadIds.get();\n+      if (tmpArray == null || tmpArray.length == 0) {\n+        return;\n+      }\n+      ThreadStackProvider provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+      if (provider instanceof NoneThreadStackProvider && providerFirstAccess) {\n+        log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+        providerFirstAccess = false;\n       }\n-      ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n-      if (scopeStackCollector == null) {\n-        continue;\n+      final ThreadInfo[] threadInfos = provider.getThreadInfo(tmpArray);\n+      // dispatch to Scopes\n+      for (ThreadInfo threadInfo : threadInfos) {\n+        if (threadInfo == null) {\n+          continue;\n+        }\n+        ScopeManager scopeManager = threadScopeMapper.forThread(threadInfo.getThreadId());\n+        if (scopeManager == null) {\n+          continue;\n+        }\n+        ScopeStackCollector scopeStackCollector = scopeManager.getCurrentScope();\n+        if (scopeStackCollector == null) {\n+          continue;\n+        }\n+        scopeStackCollector.collect(threadInfo.getStackTrace());\n       }\n-      scopeStackCollector.collect(threadInfo.getStackTrace());\n+    } catch (Exception ex) {\n+      log.info(\"Exception thrown during JMX sampling:\", ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxODUyOQ=="}, "originalCommit": {"oid": "994a0c842c5264e202a1bbbda680e6d99fc4cba5"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4978, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}