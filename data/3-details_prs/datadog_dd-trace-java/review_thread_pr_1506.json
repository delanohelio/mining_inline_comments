{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NTM1OTUx", "number": 1506, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0NzoxMFrOEAiw_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozMjo1OVrOEA9Z6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDA1MDU1OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo0NzoxMFrOGb40Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTowMzoyMVrOGb5koA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg==", "bodyText": "Since this is used for tests, can we make it package private or private instead?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431895622", "createdAt": "2020-05-28T14:47:10Z", "author": {"login": "devinsba"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzA5OA==", "bodyText": "It's used for tests from all over the place, but I could also remove it and change the tests to use DDId.from(1) instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431903098", "createdAt": "2020-05-28T14:56:37Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNjkzNw==", "bodyText": "Groovy will automatically do the reflection required to access the field. I'm not sure that it isn't used in the couple Java tests that exist though", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431906937", "createdAt": "2020-05-28T15:01:54Z", "author": {"login": "devinsba"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwODAwMA==", "bodyText": "Thanks, didn't know that.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431908000", "createdAt": "2020-05-28T15:03:21Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTYyMg=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDA2Nzg3OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNDo1MDozMlrOGb4-_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozMTowNlrOGcRzLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw==", "bodyText": "I think the 2 argument nextLong would be correct here. We do support negative signed longs", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431898367", "createdAt": "2020-05-28T14:50:32Z", "author": {"login": "devinsba"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDk2MA==", "bodyText": "Yes, I wasn't sure if there was any other reason than BigInteger not handling a negative long the right way. I'll change it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431904960", "createdAt": "2020-05-28T14:59:07Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyNzM1Mw==", "bodyText": "The old behaviour was to generate a 63 bit, so positive, identifier though.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431927353", "createdAt": "2020-05-28T15:29:53Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDk0Mw==", "bodyText": "I'll keep this as it was before to minimize the materialization of BigInteger, with a comment that it can be changed when msgpack is fixed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432304943", "createdAt": "2020-05-29T07:31:06Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5ODM2Nw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI2MTg0OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozNDoxMlrOGb680w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozMDoxMlrOGcRxfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ==", "bodyText": "Do we really need this? It will be extremely rare to overflow, can't we just materialise when (if) we do", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431930579", "createdAt": "2020-05-28T15:34:12Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMzI3MA==", "bodyText": "Also, we will only ever need it once, so caching is questionable?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431933270", "createdAt": "2020-05-28T15:37:51Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTQxNg==", "bodyText": "Can't we need it multiple times? I mean the ParentId could be used multiple times.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935416", "createdAt": "2020-05-28T15:41:03Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NjkyNg==", "bodyText": "Yes, that can happen, but if the parent span of several spans is remote, the ids won't have been deduplicated.\nIf the parent is in process, the parent id will be the same instance, but until now we generated 63 bit span identifiers, so know we won't need the BigInteger.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431956926", "createdAt": "2020-05-28T16:12:20Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDUxMQ==", "bodyText": "Yes, the 63 bit ids makes sure this doesn't happen for our ids. I'll keep it that way.\nSo we never start more than one span inside a span coming from the outside, but it might have a trace id that has this characteristic, and that will get reused as far as I can see. Can we leave this in until we fix msgpack? It's not that common that it will drag a BigInteger with it, and right now it bumps the object from 40 to 48 bytes on ZGC, and is a lost 4 bytes on G1?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432304511", "createdAt": "2020-05-29T07:30:12Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzMDU3OQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI4Mzk1OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOToxNlrOGb7K6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTozOToxNlrOGb7K6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDE4Nw==", "bodyText": "The cast is unnecessary here, >>> will shift zero into the high bits", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934187", "createdAt": "2020-05-28T15:39:16Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI4NzM2OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDowNVrOGb7NHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDowNVrOGb7NHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNDc1MA==", "bodyText": "Could just mask with 0xFFFFFFFFL to isolate the low bits.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431934750", "createdAt": "2020-05-28T15:40:05Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI4OTA3OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDozMVrOGb7OOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MDozMVrOGb7OOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTAzNQ==", "bodyText": "mask unnecessary here if cast above is removed.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935035", "createdAt": "2020-05-28T15:40:31Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI5MTMyOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MTowMlrOGb7Pqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MTowMlrOGb7Pqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNTQwMg==", "bodyText": "mask unnecessary if just shifted right above without casting on line 200", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431935402", "createdAt": "2020-05-28T15:41:02Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI5NjM2OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MjoxMlrOGb7S3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODowMzowMFrOGcSwXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA==", "bodyText": "I wonder should we be shifting the high bits right and xoring?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936220", "createdAt": "2020-05-28T15:42:12Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzM5Nw==", "bodyText": "Yes, we should probably.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937397", "createdAt": "2020-05-28T15:43:50Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMjU0MA==", "bodyText": "Just call java.lang.Long#hashCode(long)?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432012540", "createdAt": "2020-05-28T17:43:28Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMDYwNQ==", "bodyText": "Well, that was 1.8, so I'll do the shift/xor thing.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432320605", "createdAt": "2020-05-29T08:03:00Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjIyMA=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDI5ODg0OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0Mjo0N1rOGb7Ucw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0NDoxM1rOGb7YfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjYyNw==", "bodyText": "maybe add a comment that the race condition is benign", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431936627", "createdAt": "2020-05-28T15:42:47Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzY2MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937661", "createdAt": "2020-05-28T15:44:13Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNjYyNw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDMwMTkwOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0MzoyN1rOGb7Wdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODoyNDowN1rOGcBTMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw==", "bodyText": "I don't think we will ever need this except at the last possible moment when we serialise", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431937143", "createdAt": "2020-05-28T15:43:27Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzODA3NQ==", "bodyText": "Yes, it's only there AFAIK.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431938075", "createdAt": "2020-05-28T15:44:51Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxNjM1Ng==", "bodyText": "Should we submit a PR for packUnsignedLong?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432016356", "createdAt": "2020-05-28T17:50:19Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNDYwOA==", "bodyText": "Yes I can do that (I already have a fork).", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432034608", "createdAt": "2020-05-28T18:24:07Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {\n+      this.hex = h = Long.toHexString(this.id);\n+    }\n+    return h;\n+  }\n+\n+  /**\n+   * Returns a {@code BigInteger} representation of the 64 bit id. TODO Can be removed if msgpack\n+   * supports packUnsignedLong\n+   *\n+   * @return BigInteger representation of the 64 it id.\n+   */\n+  public BigInteger toBigInteger() {\n+    BigInteger b = this.big;\n+    if (b == null) {\n+      this.big = b = toUnsignedBigInteger(this.id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzNzE0Mw=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDMxODQwOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo0NzoyNlrOGb7hLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNjowMzowNlrOGb8L2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ==", "bodyText": "can we take this off the critical path by marking it in a bitmask and checking the bitmask against zero (meaning valid) at the end?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431939885", "createdAt": "2020-05-28T15:47:26Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MzM5NA==", "bodyText": "Sure, we can just or together the ds, and if it's negative at the end it's broken. No need to say exactly which c is wrong.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431943394", "createdAt": "2020-05-28T15:52:31Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDgwOA==", "bodyText": "even better than what I had in mind", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431950808", "createdAt": "2020-05-28T16:03:06Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTg4NQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDM0NjkwOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NDoxNFrOGb7zpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoyNjoxN1rOGcRqlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDYxMg==", "bodyText": "Can this be implemented the same way as JDK8 Long.compareUnsigned(i.e. add Long.MIN_VALUE to each side?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431944612", "createdAt": "2020-05-28T15:54:14Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java", "diffHunk": "@@ -35,7 +35,12 @@ public boolean sample(final DDSpan span) {\n     } else if (rate == 0) {\n       sampled = false;\n     } else {\n-      sampled = span.getTraceId().multiply(KNUTH_FACTOR).mod(MODULUS).compareTo(cutoff) < 0;\n+      long mod = span.getTraceId().toLong() * KNUTH_FACTOR;\n+      if (cutoff >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMjc0MA==", "bodyText": "I'll take a look at it.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432302740", "createdAt": "2020-05-29T07:26:17Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/sampling/DeterministicSampler.java", "diffHunk": "@@ -35,7 +35,12 @@ public boolean sample(final DDSpan span) {\n     } else if (rate == 0) {\n       sampled = false;\n     } else {\n-      sampled = span.getTraceId().multiply(KNUTH_FACTOR).mod(MODULUS).compareTo(cutoff) < 0;\n+      long mod = span.getTraceId().toLong() * KNUTH_FACTOR;\n+      if (cutoff >= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDYxMg=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDM1MjQ2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/JsonFormatWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNTo1NTozMFrOGb73Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoyNjoyNVrOGcRq1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTUzMQ==", "bodyText": "I believe this is the only time DDId.toBigInteger is called.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r431945531", "createdAt": "2020-05-28T15:55:30Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/JsonFormatWriter.java", "diffHunk": "@@ -97,7 +98,17 @@ public void writeDouble(final byte[] key, final double value, final JsonWriter d\n   }\n \n   @Override\n-  public void writeBigInteger(\n+  public void writeId(byte[] key, DDId id, JsonWriter destination) throws IOException {\n+    // This is to keep the id output compatible with the BigInteger id for tests\n+    long l = id.toLong();\n+    if (l >= 0) {\n+      writeLong(key, l, destination);\n+    } else {\n+      writeBigInteger(key, id.toBigInteger(), destination);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMjgwNA==", "bodyText": "Correct.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432302804", "createdAt": "2020-05-29T07:26:25Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/JsonFormatWriter.java", "diffHunk": "@@ -97,7 +98,17 @@ public void writeDouble(final byte[] key, final double value, final JsonWriter d\n   }\n \n   @Override\n-  public void writeBigInteger(\n+  public void writeId(byte[] key, DDId id, JsonWriter destination) throws IOException {\n+    // This is to keep the id output compatible with the BigInteger id for tests\n+    long l = id.toLong();\n+    if (l >= 0) {\n+      writeLong(key, l, destination);\n+    } else {\n+      writeBigInteger(key, id.toBigInteger(), destination);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTUzMQ=="}, "originalCommit": {"oid": "9400511715b0ff3ca57ad4dc91a531d3c7c06028"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MDc2Mzc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo0NToxMFrOGcAA8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoxMTo1MlrOGcRRQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU1Mw==", "bodyText": "Same comment here about the race condition.", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432013553", "createdAt": "2020-05-28T17:45:10Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b443e579d678d3e37b66b0cf187c085f7c451733"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NjI1OQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432296259", "createdAt": "2020-05-29T07:11:52Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -0,0 +1,266 @@\n+package datadog.trace.api;\n+\n+import java.math.BigInteger;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Class encapsulating the unsigned 64 bit id used for Trace and Span ids.\n+ *\n+ * <p>It contains generation of new ids, parsing, and to string for both decimal and hex\n+ * representations. The strings are either kept from parsing, or generated on demand and cached.\n+ */\n+public class DDId {\n+\n+  public static final DDId ZERO = new DDId(0, \"0\", \"0\");\n+  public static final DDId MAX =\n+      new DDId(-1, \"18446744073709551615\", \"ffffffffffffffff\"); // All bits set\n+\n+  // Convenience constant used from tests\n+  public static final DDId ONE = DDId.from(1);\n+\n+  /**\n+   * Generate a new unsigned 64 bit id.\n+   *\n+   * @return DDId\n+   */\n+  public static DDId generate() {\n+    // TODO should we use the top bit as well here?\n+    // It is **extremely** unlikely to generate the value \"0\" but we still need to handle that\n+    // case\n+    long id;\n+    do {\n+      id = ThreadLocalRandom.current().nextLong(Long.MAX_VALUE);\n+    } while (id == 0);\n+    return DDId.from(id);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code long} interpreted as the bits of the unsigned\n+   * 64 bit id. This means that values larger than Long.MAX_VALUE will be represented as negative\n+   * numbers.\n+   *\n+   * @param id long representing the bits of the unsigned 64 bit id\n+   * @return DDId\n+   */\n+  public static DDId from(long id) {\n+    return DDId.create(id, null, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} representation of the unsigned 64 bit\n+   * id.\n+   *\n+   * @param s String of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId from(String s) throws NumberFormatException {\n+    return DDId.create(parseUnsignedLong(s), s, null);\n+  }\n+\n+  /**\n+   * Create a new {@code DDId} from the given {@code String} hex representation of the unsigned 64\n+   * bit id.\n+   *\n+   * @param s String in hex of unsigned 64 bit id\n+   * @return DDId\n+   * @throws NumberFormatException\n+   */\n+  public static DDId fromHex(String s) throws NumberFormatException {\n+    long id = parseUnsignedLongHex(s);\n+    // The hex string should be lower case and non zero padded\n+    String hex = s.toLowerCase();\n+    int firstNonZero = firstNonZeroCharacter(s);\n+    if (firstNonZero > 0) {\n+      hex = hex.substring(firstNonZero);\n+    }\n+    return DDId.create(id, null, hex);\n+  }\n+\n+  private final long id;\n+  private String str; // cache for string representation\n+  private String hex; // cache for hex string representation\n+  // TODO This is only here since msgpack doesn't support packUnsignedLong\n+  //      so we need to write out \"negative\" longs as a BigInteger\n+  private BigInteger big;\n+\n+  private DDId(long id, String str, String hex) {\n+    this.id = id;\n+    this.str = str;\n+    this.hex = hex;\n+  }\n+\n+  private static DDId create(long id, String str, String hex) {\n+    if (id == 0) return ZERO;\n+    if (id == -1) return MAX;\n+    return new DDId(id, str, hex);\n+  }\n+\n+  private static int firstNonZeroCharacter(String s) {\n+    int firstNonZero = 0;\n+    for (; firstNonZero < s.length(); firstNonZero++) {\n+      if (s.charAt(firstNonZero) != '0') break;\n+    }\n+    return firstNonZero;\n+  }\n+\n+  private static NumberFormatException numberFormatOutOfRange(String s) {\n+    return new NumberFormatException(\n+        String.format(\"String value %s exceeds range of unsigned long.\", s));\n+  }\n+\n+  private static long MAX_FIRST_PART = 0x1999999999999999L; // Max unsigned 64 bits / 10\n+\n+  private static long parseUnsignedLong(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      char firstChar = s.charAt(0);\n+      if (firstChar == '-') {\n+        throw new NumberFormatException(\n+            String.format(\"Illegal leading minus sign on unsigned string %s.\", s));\n+      } else {\n+        if (len <= 18) { // Signed 64 bits max is 19 digits, so this always fits\n+          return Long.parseLong(s);\n+        } else if (len > 20) { // Unsigned 64 bits max is 20 digits, so this always overflows\n+          throw numberFormatOutOfRange(s);\n+        }\n+        // Now do the first part and the last character\n+        long first = 0;\n+        for (int i = 0; i < len - 1; i++) {\n+          char c = s.charAt(i);\n+          int d = Character.digit(c, 10);\n+          if (d < 0) {\n+            throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+          }\n+          first = first * 10 + d;\n+        }\n+        int last = Character.digit(s.charAt(len - 1), 10);\n+        if (last < 0) {\n+          throw new NumberFormatException(\"Bad digit at end of \" + s);\n+        }\n+        if (first > MAX_FIRST_PART) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        long guard = first * 10;\n+        long result = guard + last;\n+        if (guard < 0 && result >= 0) {\n+          throw numberFormatOutOfRange(s);\n+        }\n+        return result;\n+      }\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  private static long parseUnsignedLongHex(String s) throws NumberFormatException {\n+    if (s == null) {\n+      throw new NumberFormatException(\"null\");\n+    }\n+\n+    int len = s.length();\n+    if (len > 0) {\n+      if (len > 16 && (len - firstNonZeroCharacter(s)) > 16) {\n+        // Unsigned 64 bits max is 16 digits, so this always overflows\n+        throw numberFormatOutOfRange(s);\n+      }\n+      long result = 0;\n+      for (int i = 0; i < len; i++) {\n+        char c = s.charAt(i);\n+        int d = Character.digit(c, 16);\n+        if (d < 0) {\n+          throw new NumberFormatException(\"Illegal character '\" + c + \"' in \" + s);\n+        }\n+        result = result << 4 | d;\n+      }\n+      return result;\n+    } else {\n+      throw new NumberFormatException(\"Empty input string\");\n+    }\n+  }\n+\n+  // TODO Can be removed when Java7 support is removed\n+  private static String toUnsignedString(long l) {\n+    if (l >= 0) return Long.toString(l);\n+\n+    // shift left once and divide by 5 results in an unsigned divide by 10\n+    long quot = (l >>> 1) / 5;\n+    long rem = l - quot * 10;\n+    return Long.toString(quot) + rem;\n+  }\n+\n+  // TODO Can be removed when msgpack support packUnsignedLong\n+  private static BigInteger toUnsignedBigInteger(long l) {\n+    if (l >= 0L) return BigInteger.valueOf(l);\n+\n+    int high = (int) (l >>> 32);\n+    int low = (int) l;\n+\n+    return (BigInteger.valueOf(((long) high) & 0xffffffffL))\n+        .shiftLeft(32)\n+        .add(BigInteger.valueOf(((long) low) & 0xffffffffL));\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n+    DDId ddId = (DDId) o;\n+    return this.id == ddId.id;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return (int) this.id;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    String s = this.str;\n+    if (s == null) {\n+      this.str = s = toUnsignedString(this.id);\n+    }\n+    return s;\n+  }\n+\n+  /**\n+   * Returns the no zero padded hex representation, in lower case, of the unsigned 64 bit id.\n+   *\n+   * @return non zero padded hex String\n+   */\n+  public String toHexString() {\n+    String h = this.hex;\n+    if (hex == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU1Mw=="}, "originalCommit": {"oid": "b443e579d678d3e37b66b0cf187c085f7c451733"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDQxNTEzOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozMjo1OVrOGcj6Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzozMjowN1rOGdBUjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTY0Nw==", "bodyText": "Why is this line important?", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r432601647", "createdAt": "2020-05-29T16:32:59Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -215,43 +215,53 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return (int) this.id;\n+    long id = this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA4MzUzMg==", "bodyText": "I don't really trust javac to be smart so I load up the this.id field first, and then use it twice in the calculation below. I double checked the generated byte code, and if I don't do this it will read up the this.id field from the object twice. That double read will most likely be optimized away at some point, but it can't hurt to be proactive.\nWith local variable               | Without local variable\n----------------------------------|----------------------------------\npublic int hashCode();            | public int hashCode();\n  Code:                           |   Code:\n   0: aload_0                     |    0: aload_0\n   1: getfield  #14 // Field id:J |    1: getfield  #14 // Field id:J\n   4: lstore_1                    |    4: aload_0\n   5: lload_1                     |    5: getfield  #14 // Field id:J\n   6: lload_1                     |    8: bipush    32\n   7: bipush    32                |   10: lushr\n   9: lushr                       |   11: lxor\n  10: lxor                        |   12: l2i\n  11: l2i                         |   13: ireturn\n  12: ireturn                     |", "url": "https://github.com/DataDog/dd-trace-java/pull/1506#discussion_r433083532", "createdAt": "2020-06-01T07:32:07Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/DDId.java", "diffHunk": "@@ -215,43 +215,53 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return (int) this.id;\n+    long id = this.id;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTY0Nw=="}, "originalCommit": {"oid": "fc20abc1a2938f53cd08963568ccd399f733d07f"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 176, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}