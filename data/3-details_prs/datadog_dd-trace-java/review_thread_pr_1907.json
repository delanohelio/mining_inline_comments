{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMDU0ODk4", "number": 1907, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoxNToyMVrOEnc2xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoyMDowMFrOEoZ0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODAyNjk1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoxNToyMVrOHYDH6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMjowNzo0OVrOHYU7sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3OTA1MA==", "bodyText": "Can we extract this somewhere it can be reused? This is a good practice we should build on for testability.", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494979050", "createdAt": "2020-09-25T13:15:21Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.core.util;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/** Rate limiter that only supports non-blocking retrieval of a single token */\n+public class SimpleRateLimiter {\n+  private final long capacity;\n+  private long tokens;\n+  private long lastRefillTime;\n+  private final long refillIntervalInNanos;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate, TimeUnit unit) {\n+    this(rate, unit, new SystemNanoTimeSource());\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeUnit unit, TimeSource timeSource) {\n+    refillIntervalInNanos = unit.toNanos(1) / rate;\n+    capacity = rate;\n+    tokens = rate;\n+    this.timeSource = timeSource;\n+    lastRefillTime = timeSource.getTime();\n+  }\n+\n+  public synchronized boolean tryAcquire() {\n+    fill();\n+\n+    if (tokens > 0) {\n+      tokens--;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  private void fill() {\n+    long timeElapsedSinceLastRefill = timeSource.getTime() - lastRefillTime;\n+    long intervals = timeElapsedSinceLastRefill / refillIntervalInNanos;\n+    tokens = Math.min(capacity, tokens + intervals);\n+\n+    lastRefillTime += intervals * refillIntervalInNanos;\n+  }\n+\n+  // This can probably be extracted to be more generic\n+  interface TimeSource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MDgzNA==", "bodyText": "I extracted it.  RatelimitedLogger was using another similar interface", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495270834", "createdAt": "2020-09-25T22:07:49Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.core.util;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/** Rate limiter that only supports non-blocking retrieval of a single token */\n+public class SimpleRateLimiter {\n+  private final long capacity;\n+  private long tokens;\n+  private long lastRefillTime;\n+  private final long refillIntervalInNanos;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate, TimeUnit unit) {\n+    this(rate, unit, new SystemNanoTimeSource());\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeUnit unit, TimeSource timeSource) {\n+    refillIntervalInNanos = unit.toNanos(1) / rate;\n+    capacity = rate;\n+    tokens = rate;\n+    this.timeSource = timeSource;\n+    lastRefillTime = timeSource.getTime();\n+  }\n+\n+  public synchronized boolean tryAcquire() {\n+    fill();\n+\n+    if (tokens > 0) {\n+      tokens--;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  private void fill() {\n+    long timeElapsedSinceLastRefill = timeSource.getTime() - lastRefillTime;\n+    long intervals = timeElapsedSinceLastRefill / refillIntervalInNanos;\n+    tokens = Math.min(capacity, tokens + intervals);\n+\n+    lastRefillTime += intervals * refillIntervalInNanos;\n+  }\n+\n+  // This can probably be extracted to be more generic\n+  interface TimeSource {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3OTA1MA=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODAyOTQxOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoxNjowMFrOHYDJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNzowODo1NVrOHYL3Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3OTQyNg==", "bodyText": "Does this really need to be unmodifiable if we're making a copy anyway?", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494979426", "createdAt": "2020-09-25T13:16:00Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanContext.java", "diffHunk": "@@ -407,7 +406,7 @@ Object unsafeGetAndRemoveTag(final String tag) {\n \n   public Map<String, Object> getTags() {\n     synchronized (unsafeTags) {\n-      return ImmutableMap.copyOf(unsafeTags);\n+      return Collections.unmodifiableMap(new HashMap<>(unsafeTags));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExNDY1NQ==", "bodyText": "Yes. If a user tries to make changes to the map, we want them to know right away that it won't be reflected.", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495114655", "createdAt": "2020-09-25T16:54:58Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanContext.java", "diffHunk": "@@ -407,7 +406,7 @@ Object unsafeGetAndRemoveTag(final String tag) {\n \n   public Map<String, Object> getTags() {\n     synchronized (unsafeTags) {\n-      return ImmutableMap.copyOf(unsafeTags);\n+      return Collections.unmodifiableMap(new HashMap<>(unsafeTags));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3OTQyNg=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEyMjIwNw==", "bodyText": "OK but can't we just put javadoc on the interface to make clear it's a copy? I'm OK with leaving it the way it is though.", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495122207", "createdAt": "2020-09-25T17:08:55Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanContext.java", "diffHunk": "@@ -407,7 +406,7 @@ Object unsafeGetAndRemoveTag(final String tag) {\n \n   public Map<String, Object> getTags() {\n     synchronized (unsafeTags) {\n-      return ImmutableMap.copyOf(unsafeTags);\n+      return Collections.unmodifiableMap(new HashMap<>(unsafeTags));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3OTQyNg=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODA1MjU2OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyMTozOVrOHYDXbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMjoxMDowOVrOHYVBpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4MzAyMg==", "bodyText": "This is called from application threads and could easily create contention. Could we use something based on atomics and check if after decrementing the atomic is still positive, giving an approximate result?\nAlternatively, do we really need this class? Can we just delete it? Sampling rate can be controlled probabilistically without contention by adjusting/controlling distribution parameters", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494983022", "createdAt": "2020-09-25T13:21:39Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.core.util;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/** Rate limiter that only supports non-blocking retrieval of a single token */\n+public class SimpleRateLimiter {\n+  private final long capacity;\n+  private long tokens;\n+  private long lastRefillTime;\n+  private final long refillIntervalInNanos;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate, TimeUnit unit) {\n+    this(rate, unit, new SystemNanoTimeSource());\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeUnit unit, TimeSource timeSource) {\n+    refillIntervalInNanos = unit.toNanos(1) / rate;\n+    capacity = rate;\n+    tokens = rate;\n+    this.timeSource = timeSource;\n+    lastRefillTime = timeSource.getTime();\n+  }\n+\n+  public synchronized boolean tryAcquire() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NzIyNg==", "bodyText": "I collaborated on a Java 6 compatible rate limiting sampler for brave I think we could consider: https://github.com/openzipkin/brave/blob/master/brave/src/main/java/brave/sampler/RateLimitingSampler.java", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494987226", "createdAt": "2020-09-25T13:28:27Z", "author": {"login": "devinsba"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.core.util;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/** Rate limiter that only supports non-blocking retrieval of a single token */\n+public class SimpleRateLimiter {\n+  private final long capacity;\n+  private long tokens;\n+  private long lastRefillTime;\n+  private final long refillIntervalInNanos;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate, TimeUnit unit) {\n+    this(rate, unit, new SystemNanoTimeSource());\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeUnit unit, TimeSource timeSource) {\n+    refillIntervalInNanos = unit.toNanos(1) / rate;\n+    capacity = rate;\n+    tokens = rate;\n+    this.timeSource = timeSource;\n+    lastRefillTime = timeSource.getTime();\n+  }\n+\n+  public synchronized boolean tryAcquire() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4MzAyMg=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MjM1OA==", "bodyText": "I ended up doing something simpler.  Only refilling once per second.  Much easier than dividing up the second and dealing with rounding issues.  If we need something more complex later we can add it (or switch to Java8+ and use one of the many libs available).", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495272358", "createdAt": "2020-09-25T22:10:09Z", "author": {"login": "randomanderson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.core.util;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/** Rate limiter that only supports non-blocking retrieval of a single token */\n+public class SimpleRateLimiter {\n+  private final long capacity;\n+  private long tokens;\n+  private long lastRefillTime;\n+  private final long refillIntervalInNanos;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate, TimeUnit unit) {\n+    this(rate, unit, new SystemNanoTimeSource());\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeUnit unit, TimeSource timeSource) {\n+    refillIntervalInNanos = unit.toNanos(1) / rate;\n+    capacity = rate;\n+    tokens = rate;\n+    this.timeSource = timeSource;\n+    lastRefillTime = timeSource.getTime();\n+  }\n+\n+  public synchronized boolean tryAcquire() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4MzAyMg=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODA1NDM4OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/util/SimpleRateLimiterTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyMjowOFrOHYDYjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyMjowOFrOHYDYjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4MzMwOA==", "bodyText": "This is a nice unit test \ud83e\udd47", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494983308", "createdAt": "2020-09-25T13:22:08Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/core/util/SimpleRateLimiterTest.groovy", "diffHunk": "@@ -0,0 +1,117 @@\n+package datadog.trace.core.util\n+\n+import datadog.trace.util.test.DDSpecification\n+\n+import java.util.concurrent.TimeUnit\n+\n+class SimpleRateLimiterTest extends DDSpecification {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODA2NTMzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/trace-annotation/src/main/java/datadog/trace/instrumentation/trace_annotation/TraceConfigInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyNDo1OFrOHYDfYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyNDo1OFrOHYDfYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NTA1Ng==", "bodyText": "Unrelated to this PR, probably not too important, can we move this one line down and use the classMethods to get an estimate for the size?", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494985056", "createdAt": "2020-09-25T13:24:58Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/trace-annotation/src/main/java/datadog/trace/instrumentation/trace_annotation/TraceConfigInstrumentation.java", "diffHunk": "@@ -68,7 +68,7 @@ public TraceConfigInstrumentation() {\n       classMethodsToTrace = Collections.emptyMap();\n \n     } else {\n-      final Map<String, Set<String>> toTrace = Maps.newHashMap();\n+      final Map<String, Set<String>> toTrace = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODA2ODMyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/trace-annotation/src/main/java/datadog/trace/instrumentation/trace_annotation/TraceAnnotationsInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyNTo0MVrOHYDhMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxMzoyNTo0MVrOHYDhMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NTUyMA==", "bodyText": "I think we could size this one accurately too", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r494985520", "createdAt": "2020-09-25T13:25:41Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/trace-annotation/src/main/java/datadog/trace/instrumentation/trace_annotation/TraceAnnotationsInstrumentation.java", "diffHunk": "@@ -60,7 +60,7 @@ public TraceAnnotationsInstrumentation() {\n           configString);\n       additionalTraceAnnotations = Collections.emptySet();\n     } else {\n-      final Set<String> annotations = Sets.newHashSet();\n+      final Set<String> annotations = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5ODM4NDczOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNDo0MToyM1rOHYGk8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjozMzozMFrOHYKuJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNTYzMw==", "bodyText": "What is this still being used for?  The cache?", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495035633", "createdAt": "2020-09-25T14:41:23Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "diffHunk": "@@ -15,8 +15,10 @@ dependencies {\n   compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.15'\n   compile deps.bytebuddy\n   compile deps.bytebuddyagent\n-  annotationProcessor deps.autoservice\n-  implementation deps.autoservice\n+  compile deps.guava", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwMzUyNA==", "bodyText": "Yes GuavaWeakCache and DDCachingPoolStrategy", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495103524", "createdAt": "2020-09-25T16:33:30Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "diffHunk": "@@ -15,8 +15,10 @@ dependencies {\n   compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.15'\n   compile deps.bytebuddy\n   compile deps.bytebuddyagent\n-  annotationProcessor deps.autoservice\n-  implementation deps.autoservice\n+  compile deps.guava", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNTYzMw=="}, "originalCommit": {"oid": "48993be05430e17ad3cc939d9abe4389aa983338"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDEzMTEyOnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/api/time/TimeSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMzoyNDowMVrOHYXjvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTowNjoxOVrOHZL4Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxMzg1NQ==", "bodyText": "I suggest giving this method a better name that represents the intended precision and clock type (time vs ticks).  Perhaps it could also be combined with datadog.trace.core.util.Clock?", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495313855", "createdAt": "2020-09-25T23:24:01Z", "author": {"login": "tylerbenson"}, "path": "internal-api/src/main/java/datadog/trace/api/time/TimeSource.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package datadog.trace.api.time;\n+\n+public interface TimeSource {\n+  long get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03874dc503a9723ae7ee93722b58963d4faca7c0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxNDIxOA==", "bodyText": "The bigger part of this suggestion might be better in a separate PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r495314218", "createdAt": "2020-09-25T23:24:50Z", "author": {"login": "tylerbenson"}, "path": "internal-api/src/main/java/datadog/trace/api/time/TimeSource.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package datadog.trace.api.time;\n+\n+public interface TimeSource {\n+  long get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxMzg1NQ=="}, "originalCommit": {"oid": "03874dc503a9723ae7ee93722b58963d4faca7c0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3MTEwMg==", "bodyText": "I changed it to getNanoTime().  I initially just pulled up an existing interface from RatelimitedLogger to a toplevel class.  If we want to make a more pervasive change, I think that belongs in a separate PR", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r496171102", "createdAt": "2020-09-28T19:06:19Z", "author": {"login": "randomanderson"}, "path": "internal-api/src/main/java/datadog/trace/api/time/TimeSource.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package datadog.trace.api.time;\n+\n+public interface TimeSource {\n+  long get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxMzg1NQ=="}, "originalCommit": {"oid": "03874dc503a9723ae7ee93722b58963d4faca7c0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwODAxNTA1OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoyMDowMFrOHZeM6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQwNzoyMDowMFrOHZeM6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3MTI3Mw==", "bodyText": "timeSource.getNanoTime() - localRefill is the same as now - localRefill", "url": "https://github.com/DataDog/dd-trace-java/pull/1907#discussion_r496471273", "createdAt": "2020-09-29T07:20:00Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/util/SimpleRateLimiter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package datadog.trace.core.util;\n+\n+import datadog.trace.api.time.SystemTimeSource;\n+import datadog.trace.api.time.TimeSource;\n+import datadog.trace.api.utils.MathUtils;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Rate limiter that only supports non-blocking retrieval of a single token at a minimum rate of 1\n+ * per second. Tokens are not smoothed across the second\n+ */\n+public class SimpleRateLimiter {\n+  private static final long REFILL_INTERVAL = TimeUnit.SECONDS.toNanos(1);\n+  private final long capacity;\n+  private final AtomicLong tokens;\n+  private final AtomicLong lastRefillTime;\n+  private final TimeSource timeSource;\n+\n+  public SimpleRateLimiter(long rate) {\n+    this(rate, SystemTimeSource.INSTANCE);\n+  }\n+\n+  protected SimpleRateLimiter(long rate, TimeSource timeSource) {\n+    this.timeSource = timeSource;\n+\n+    capacity = Math.max(1, rate);\n+\n+    tokens = new AtomicLong(capacity);\n+\n+    lastRefillTime = new AtomicLong(timeSource.getNanoTime());\n+  }\n+\n+  public boolean tryAcquire() {\n+    long now = timeSource.getNanoTime();\n+    long localRefill = lastRefillTime.get();\n+    long timeElapsedSinceLastRefill = timeSource.getNanoTime() - localRefill;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78e5db55a2c53e423bf4087f005e63a4e7ff43be"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4846, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}