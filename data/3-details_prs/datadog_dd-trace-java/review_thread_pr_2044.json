{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMTQwNTQ2", "number": 2044, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1ODo1NVrOEz4O1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOToyMzo0MVrOE315OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM0MTM1OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentTooling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1ODo1NVrOHrX3JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1ODo1NVrOHrX3JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTc2NQ==", "bodyText": "There is no basis for this number.  The alternative is removing newWeakCache() and forcing callers to specify a capacity.", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515241765", "createdAt": "2020-10-30T16:58:55Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentTooling.java", "diffHunk": "@@ -27,27 +27,38 @@ static void registerWeakMapProvider() {\n     }\n   }\n \n-  private static <K, V> Provider loadWeakCacheProvider() {\n-    final Iterator<Provider> providers =\n-        ServiceLoader.load(Provider.class, AgentInstaller.class.getClassLoader()).iterator();\n-    if (providers.hasNext()) {\n-      final Provider provider = providers.next();\n-      if (providers.hasNext()) {\n-        throw new IllegalStateException(\n-            \"Only one implementation of WeakCache.Provider suppose to be in classpath\");\n+  private static Provider loadWeakCacheProvider() {\n+    ClassLoader classLoader = AgentInstaller.class.getClassLoader();\n+    Class<Provider> providerClass;\n+\n+    String version = System.getProperty(\"java.version\");\n+    try {\n+      if (version == null || version.startsWith(\"1.7\")) {\n+        providerClass =\n+            (Class<Provider>)\n+                classLoader.loadClass(\"datadog.trace.agent.tooling.CLHMWeakCache$Provider\");\n+        log.debug(\"Using CLHMWeakCache Provider\");\n+      } else {\n+        providerClass =\n+            (Class<Provider>)\n+                classLoader.loadClass(\"datadog.trace.agent.tooling.CaffeineWeakCache$Provider\");\n+        log.debug(\"Using CaffeineWeakCache Provider\");\n       }\n-      return provider;\n+\n+      return providerClass.getDeclaredConstructor().newInstance();\n+    } catch (ReflectiveOperationException e) {\n+      throw new IllegalStateException(\"Can't load implementation of WeakCache.Provider\", e);\n     }\n-    throw new IllegalStateException(\"Can't load implementation of WeakCache.Provider\");\n   }\n \n+  private static final long DEFAULT_CACHE_CAPACITY = 32;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM2MTc0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/CaffeineWeakCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzowMzo1OVrOHrYEBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoyNDoxMFrOHr6NBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0NTA2MQ==", "bodyText": "I think this assumes that the function is pure (which is a realistic expectation)", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515245061", "createdAt": "2020-10-30T17:03:59Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/CaffeineWeakCache.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package datadog.trace.agent.tooling;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import datadog.trace.api.Function;\n+import datadog.trace.bootstrap.WeakCache;\n+import java.util.concurrent.TimeUnit;\n+\n+public class CaffeineWeakCache<K, V> implements WeakCache<K, V> {\n+  public static final class Provider implements WeakCache.Provider {\n+    @Override\n+    public <K, V> WeakCache<K, V> newWeakCache(long maxSize) {\n+      return new CaffeineWeakCache<>(maxSize);\n+    }\n+  }\n+\n+  private final Cache<K, V> cache;\n+\n+  public CaffeineWeakCache(long maxSize) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .weakKeys()\n+            .maximumSize(maxSize)\n+            .expireAfterAccess(10, TimeUnit.MINUTES)\n+            .build();\n+  }\n+\n+  @Override\n+  public V getIfPresent(K key) {\n+    return cache.getIfPresent(key);\n+  }\n+\n+  @Override\n+  public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n+    // Unable to use cache.get() directly because it relies on java.util.function.Function which is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwNDQyMQ==", "bodyText": "Agree that this is a realistic assumption. The same is true for the implementation in CLHMWeakCache, so maybe there should be a comment in the WeakCache interface so it doesn't come as a surprise to users of the cache.", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515804421", "createdAt": "2020-11-02T08:24:10Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/CaffeineWeakCache.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package datadog.trace.agent.tooling;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import datadog.trace.api.Function;\n+import datadog.trace.bootstrap.WeakCache;\n+import java.util.concurrent.TimeUnit;\n+\n+public class CaffeineWeakCache<K, V> implements WeakCache<K, V> {\n+  public static final class Provider implements WeakCache.Provider {\n+    @Override\n+    public <K, V> WeakCache<K, V> newWeakCache(long maxSize) {\n+      return new CaffeineWeakCache<>(maxSize);\n+    }\n+  }\n+\n+  private final Cache<K, V> cache;\n+\n+  public CaffeineWeakCache(long maxSize) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .weakKeys()\n+            .maximumSize(maxSize)\n+            .expireAfterAccess(10, TimeUnit.MINUTES)\n+            .build();\n+  }\n+\n+  @Override\n+  public V getIfPresent(K key) {\n+    return cache.getIfPresent(key);\n+  }\n+\n+  @Override\n+  public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n+    // Unable to use cache.get() directly because it relies on java.util.function.Function which is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0NTA2MQ=="}, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM3OTY5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzowODo1NFrOHrYPkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToxMzozOFrOHrcu0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODAxNw==", "bodyText": "How does this still provide cache semantics with a max size?", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515248017", "createdAt": "2020-10-30T17:08:54Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -56,23 +59,16 @@\n    *   <li>Allow for quick fast path equivalence check of composite keys\n    * </ul>\n    */\n-  final Cache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n-      CacheBuilder.newBuilder()\n-          .weakKeys()\n-          .concurrencyLevel(CONCURRENCY_LEVEL)\n-          .initialCapacity(LOADER_CAPACITY / 2)\n-          .maximumSize(LOADER_CAPACITY)\n-          .build();\n+  final WeakCache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n+      AgentTooling.newWeakCache(LOADER_CAPACITY);\n \n   /**\n    * Single shared Type.Resolution cache -- uses a composite key -- conceptually of loader & name\n    */\n-  final Cache<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n-      CacheBuilder.newBuilder()\n-          .softValues()\n+  final ConcurrentMap<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n+      new ConcurrentLinkedHashMap.Builder<TypeCacheKey, TypePool.Resolution>()\n+          .maximumWeightedCapacity(TYPE_CAPACITY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI4OTM5Ng==", "bodyText": "ConcurrentLinkedHashMap is a bounded concurrent map with least-recently-used eviction: https://github.com/ben-manes/concurrentlinkedhashmap/blob/master/src/main/java/com/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java#L108", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515289396", "createdAt": "2020-10-30T18:07:04Z", "author": {"login": "randomanderson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -56,23 +59,16 @@\n    *   <li>Allow for quick fast path equivalence check of composite keys\n    * </ul>\n    */\n-  final Cache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n-      CacheBuilder.newBuilder()\n-          .weakKeys()\n-          .concurrencyLevel(CONCURRENCY_LEVEL)\n-          .initialCapacity(LOADER_CAPACITY / 2)\n-          .maximumSize(LOADER_CAPACITY)\n-          .build();\n+  final WeakCache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n+      AgentTooling.newWeakCache(LOADER_CAPACITY);\n \n   /**\n    * Single shared Type.Resolution cache -- uses a composite key -- conceptually of loader & name\n    */\n-  final Cache<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n-      CacheBuilder.newBuilder()\n-          .softValues()\n+  final ConcurrentMap<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n+      new ConcurrentLinkedHashMap.Builder<TypeCacheKey, TypePool.Resolution>()\n+          .maximumWeightedCapacity(TYPE_CAPACITY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODAxNw=="}, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTU1NA==", "bodyText": "Ah, ok.  I was getting this confused with ConcurrentHashMap.", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515321554", "createdAt": "2020-10-30T19:13:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -56,23 +59,16 @@\n    *   <li>Allow for quick fast path equivalence check of composite keys\n    * </ul>\n    */\n-  final Cache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n-      CacheBuilder.newBuilder()\n-          .weakKeys()\n-          .concurrencyLevel(CONCURRENCY_LEVEL)\n-          .initialCapacity(LOADER_CAPACITY / 2)\n-          .maximumSize(LOADER_CAPACITY)\n-          .build();\n+  final WeakCache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n+      AgentTooling.newWeakCache(LOADER_CAPACITY);\n \n   /**\n    * Single shared Type.Resolution cache -- uses a composite key -- conceptually of loader & name\n    */\n-  final Cache<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n-      CacheBuilder.newBuilder()\n-          .softValues()\n+  final ConcurrentMap<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n+      new ConcurrentLinkedHashMap.Builder<TypeCacheKey, TypePool.Resolution>()\n+          .maximumWeightedCapacity(TYPE_CAPACITY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODAxNw=="}, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM4NDkxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentTooling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoxMDowN1rOHrYStA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoxMDowN1rOHrYStA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODgyMA==", "bodyText": "@devinsba mentioned encapsulating this in a Platform class before, I think there are probably enough instances of this to do it now", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515248820", "createdAt": "2020-10-30T17:10:07Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentTooling.java", "diffHunk": "@@ -27,27 +27,38 @@ static void registerWeakMapProvider() {\n     }\n   }\n \n-  private static <K, V> Provider loadWeakCacheProvider() {\n-    final Iterator<Provider> providers =\n-        ServiceLoader.load(Provider.class, AgentInstaller.class.getClassLoader()).iterator();\n-    if (providers.hasNext()) {\n-      final Provider provider = providers.next();\n-      if (providers.hasNext()) {\n-        throw new IllegalStateException(\n-            \"Only one implementation of WeakCache.Provider suppose to be in classpath\");\n+  private static Provider loadWeakCacheProvider() {\n+    ClassLoader classLoader = AgentInstaller.class.getClassLoader();\n+    Class<Provider> providerClass;\n+\n+    String version = System.getProperty(\"java.version\");\n+    try {\n+      if (version == null || version.startsWith(\"1.7\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODQxMTg5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoxNTo1OFrOHrYjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoyMjoxOFrOHrYy2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI1MzA2Nw==", "bodyText": "Why do we need this at all if we have the dependencies below? Based partially on seeing the huge benefits from removing WeakMap wherever possible, I don't feel good about the weak-map-as-a-cache approach.", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515253067", "createdAt": "2020-10-30T17:15:58Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "diffHunk": "@@ -12,13 +12,11 @@ dependencies {\n   compile(project(':dd-java-agent:agent-bootstrap')) {\n     exclude group: 'com.datadoghq', module: 'agent-logging'\n   }\n-  compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.15'\n+  compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.17'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI1NzA1MQ==", "bodyText": "I see why, the JDK7 implementation requires both.", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r515257051", "createdAt": "2020-10-30T17:22:18Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-tooling/agent-tooling.gradle", "diffHunk": "@@ -12,13 +12,11 @@ dependencies {\n   compile(project(':dd-java-agent:agent-bootstrap')) {\n     exclude group: 'com.datadoghq', module: 'agent-logging'\n   }\n-  compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.15'\n+  compile group: 'com.blogspot.mydailyjava', name: 'weak-lock-free', version: '0.17'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI1MzA2Nw=="}, "originalCommit": {"oid": "037ebf90ad0752a937c6824f6926e8ee6bc62277"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTkwMTM3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOToyMzo0MVrOHxbFZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOToyMzo0MVrOHxbFZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NjAyMw==", "bodyText": "Worth doing a perf test before/after this change?", "url": "https://github.com/DataDog/dd-trace-java/pull/2044#discussion_r521586023", "createdAt": "2020-11-11T19:23:41Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -56,23 +59,16 @@\n    *   <li>Allow for quick fast path equivalence check of composite keys\n    * </ul>\n    */\n-  final Cache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n-      CacheBuilder.newBuilder()\n-          .weakKeys()\n-          .concurrencyLevel(CONCURRENCY_LEVEL)\n-          .initialCapacity(LOADER_CAPACITY / 2)\n-          .maximumSize(LOADER_CAPACITY)\n-          .build();\n+  final WeakCache<ClassLoader, WeakReference<ClassLoader>> loaderRefCache =\n+      AgentTooling.newWeakCache(LOADER_CAPACITY);\n \n   /**\n    * Single shared Type.Resolution cache -- uses a composite key -- conceptually of loader & name\n    */\n-  final Cache<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n-      CacheBuilder.newBuilder()\n-          .softValues()\n+  final ConcurrentMap<TypeCacheKey, TypePool.Resolution> sharedResolutionCache =\n+      new ConcurrentLinkedHashMap.Builder<TypeCacheKey, TypePool.Resolution>()\n+          .maximumWeightedCapacity(TYPE_CAPACITY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1252b4eddf62a572a9da1916f43b722e9549d67b"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4774, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}