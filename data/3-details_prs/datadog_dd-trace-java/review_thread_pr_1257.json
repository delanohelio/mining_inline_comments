{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTM3MDE2", "number": 1257, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToxOTowN1rODi6b0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNjowN1rODjExTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTM1NTY5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToxOTowN1rOFubSdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoyNzozMFrOFuh8cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNTkwOQ==", "bodyText": "Do these need to be volatile?", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384225909", "createdAt": "2020-02-26T01:19:07Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzNDk2Mw==", "bodyText": "no need", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384334963", "createdAt": "2020-02-26T08:27:30Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNTkwOQ=="}, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTM1NjQ2OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMToxOTozNlrOFubS9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzo1NTozNlrOFusX8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw==", "bodyText": "And this?", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384226037", "createdAt": "2020-02-26T01:19:36Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyODMwMw==", "bodyText": "No need, worst case you have created 2 CachingTypeDescriptions on concurrent calls", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384328303", "createdAt": "2020-02-26T08:11:37Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw=="}, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNTg0MA==", "bodyText": "Yes, each thread will null -> non-null transition, so this is safe.\nString.hashCode does exactly this some strategy.\nIt may create additional objects, but that's usually better than the coordination overhead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384505840", "createdAt": "2020-02-26T13:55:36Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw=="}, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDAyNTEwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoxNDo0M1rOFuhnSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzo1NDowMVrOFusUYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyOTU0Nw==", "bodyText": "to help you reason about concurrency here, you can use local vars:\nTypeDescription localResolution = cachedResolution; // read field\nif (localResolution == null) {\n    localResolution = new CachingTypeDescription(delegate.resolve());\n}\ncachedResolution = localResolution; // write field\nreturn localResolution;\n\nIn any case you won't return null, that's the most important.", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384329547", "createdAt": "2020-02-26T08:14:43Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNDkyOQ==", "bodyText": "Yes, local variables are especially helpful in these situations.  I'd also like using an explicit this, since I think it makes the shared read/writes more obvious -- but I know, I'm in the minority on that one.", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384504929", "createdAt": "2020-02-26T13:54:01Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyOTU0Nw=="}, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTA0NTA0OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNDo1OFrOFurU9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNDo1OFrOFurU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4ODY5Mg==", "bodyText": "Looks like this either needs to be addressed, or removed - or maybe expanded with more explanation for posterity", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384488692", "createdAt": "2020-02-26T13:24:58Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTA0OTA5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzoyNjowN1rOFurXVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzo1ODo1NlrOFusfdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTMwMA==", "bodyText": "SuperClass can be null for things that do not have it... but I guess it's ok to call getSuperClass again in this case - however you may want to add a comment.", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384489300", "createdAt": "2020-02-26T13:26:07Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;\n+\n+    public CachingTypeDescription(final TypeDescription delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    protected TypeDescription delegate() {\n+      return delegate;\n+    }\n+\n+    @Override\n+    public Generic getSuperClass() {\n+      if (superClass == null) {\n+        superClass = delegate.getSuperClass();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzc2NQ==", "bodyText": "I think for us to get much value from the wrapping.  We need to extend our wrapper to have additional capabilities that we need.\nFor instance -- adding getSafeSuperClass, getSafeInterfaces, etc.  That would save heavier repeat work.\nWe can also make our extended TypeDescription store Matcher results, etc. as well.", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384507765", "createdAt": "2020-02-26T13:58:56Z", "author": {"login": "dougqh"}, "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;\n+\n+    public CachingTypeDescription(final TypeDescription delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    protected TypeDescription delegate() {\n+      return delegate;\n+    }\n+\n+    @Override\n+    public Generic getSuperClass() {\n+      if (superClass == null) {\n+        superClass = delegate.getSuperClass();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTMwMA=="}, "originalCommit": {"oid": "8a8bdefcdf6407d163a029625c85482450f3f3b1"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 343, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}