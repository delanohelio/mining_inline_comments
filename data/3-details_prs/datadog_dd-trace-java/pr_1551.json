{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTI1NjMw", "number": 1551, "title": "Improve trace rule processing performance", "bodyText": "Allows tag to be retrieved from span by name, meaning unmodifiable view unnecessary\nRemoves tags from Rule.processSpan\nRemoves unused traces from Rule.processSpan\nRemoves duplicated tag lookups\nInlines \"not found\" logic into URLAsResourceNameRule as this was repeated\nSignificantly reduces allocation and CPU usage during scrubbing sensitive info in URLAsResourceNameRule", "createdAt": "2020-06-05T15:22:23Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1551", "merged": true, "mergeCommit": {"oid": "d082bf52f1a2cc691b48b8a3730d3631c099c17d"}, "closed": true, "closedAt": "2020-06-08T18:33:49Z", "author": {"login": "richardstartin"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoUAZJgH2gAyNDI4NTI1NjMwOjA0NmNlY2U1MzIxZGU2MWY4YTcxNjI3ZDA4YThjZDIzZTI5Yzc1YzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpUhBkgFqTQyNjQ5MjI4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "046cece5321de61f8a71627d08a8cd23e29c75c1", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/046cece5321de61f8a71627d08a8cd23e29c75c1", "committedDate": "2020-06-05T15:01:35Z", "message": "simplifying trace processing rule interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c315696017086f68202b73fed472768e5474a3f", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8c315696017086f68202b73fed472768e5474a3f", "committedDate": "2020-06-05T15:27:14Z", "message": "inline Status404Rule into URLAsResourceNameRule, improve URLAsResourceNameRule efficiency"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8380e787902d63dd0dadedd0c2657c4fef852b67", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8380e787902d63dd0dadedd0c2657c4fef852b67", "committedDate": "2020-06-05T15:17:33Z", "message": "inline Status404Rule into URLAsResourceNameRule, improve URLAsResourceNameRule efficiency"}, "afterCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/8c315696017086f68202b73fed472768e5474a3f", "committedDate": "2020-06-05T15:27:14Z", "message": "inline Status404Rule into URLAsResourceNameRule, improve URLAsResourceNameRule efficiency"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NDEzODE4", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#pullrequestreview-425413818", "createdAt": "2020-06-05T15:40:08Z", "commit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MDowOVrOGfznWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjo0OTowM1rOGf143A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNDY5OA==", "bodyText": "Please add a comment describing this class.  It seems rather complex.", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436004698", "createdAt": "2020-06-05T15:40:09Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -21,79 +25,143 @@\n   @Override\n   public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n+    if (context.isResourceNameSet()) {\n+      return;\n+    }\n     final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || span.getTag(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(span.getTag(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(span.getTag(Tags.HTTP_METHOD), normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) {\n+            resourceName.append('/');\n+          } else { // need to scrub out sensitive info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to scrub out sensitive looking info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean first = true;\n+    boolean last = false;\n+    int end = 0;\n+    for (int i = start; i < url.length() && !last; i = end) {\n+      if (url.charAt(i) == '/') {\n+        resourceName.append('/');\n+        ++i;\n+        first = false;\n+      }\n+      end = url.indexOf('/', i);\n+      if (end == -1) {\n+        if (first) {\n+          resourceName.append('/');\n+        }\n+        end = url.indexOf('?', i);\n+        if (end == -1) {\n+          end = url.indexOf('#', i);\n+          if (end == -1) {\n+            end = url.length();\n+          }\n+        }\n+        last = true;\n+      }\n+      if (i < end) {\n+        char c = url.charAt(i);\n+        boolean isVersion = !last & (c == 'v' | c == 'V') & (end - i) <= 3;\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        for (int j = i + 1; j < end && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+        }\n+\n+        if (containsNumerics && !isVersion) {\n+          resourceName.append('?');\n+        } else if (!isBlank) {\n+          resourceName.append(url, i, end);\n+        }\n+        first = false;\n+      }\n     }\n+  }\n \n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n-    }\n+  private static class BitSlicedBYG {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNTcwMg==", "bodyText": "Perhaps rename to StatusUrlResourceNameRule since now it's renaming off of both of those?", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436005702", "createdAt": "2020-06-05T15:41:47Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -5,13 +5,17 @@\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n \n-import java.util.regex.Pattern;\n-\n public class URLAsResourceNameRule implements TraceProcessor.Rule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MTk0OA==", "bodyText": "A method comment here describing the algorithm would be helpful.", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436041948", "createdAt": "2020-06-05T16:49:03Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,164 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBYG PROTOCOL_SEARCH = new BitSlicedBYG(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n     return new String[] {\"URLAsResourceName\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) {\n+            resourceName.append('/');\n+          } else { // need to scrub out sensitive info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to scrub out sensitive looking info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c315696017086f68202b73fed472768e5474a3f"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e82ca706b328d312d208f5a701fe72ed3e627d5", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/9e82ca706b328d312d208f5a701fe72ed3e627d5", "committedDate": "2020-06-08T08:51:57Z", "message": "add comments to URL processing, add Status404Rule aliases to URLAsResourceNameRule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/da5e59aca437b6283a7932552d21c3647aac5267", "committedDate": "2020-06-08T09:41:59Z", "message": "update revapi"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75f3a6a46efb35b8bb010bd7702ed376f9092d9c", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/75f3a6a46efb35b8bb010bd7702ed376f9092d9c", "committedDate": "2020-06-08T08:54:38Z", "message": "update revapi"}, "afterCommit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267", "author": {"user": {"login": "richardstartin", "name": "Richard Startin"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/da5e59aca437b6283a7932552d21c3647aac5267", "committedDate": "2020-06-08T09:41:59Z", "message": "update revapi"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MTE0Mzg5", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#pullrequestreview-426114389", "createdAt": "2020-06-08T10:49:09Z", "commit": {"oid": "75f3a6a46efb35b8bb010bd7702ed376f9092d9c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDo0OTo1N1rOGgYjCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMDo0OTo1N1rOGgYjCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjYwOTgwMg==", "bodyText": "Shouldn't we break out of the loop here?", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#discussion_r436609802", "createdAt": "2020-06-08T10:49:57Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/main/java/datadog/trace/core/processor/rule/URLAsResourceNameRule.java", "diffHunk": "@@ -4,99 +4,204 @@\n import datadog.trace.core.DDSpan;\n import datadog.trace.core.DDSpanContext;\n import datadog.trace.core.processor.TraceProcessor;\n-import java.util.Collection;\n-import java.util.Map;\n-import java.util.regex.Pattern;\n \n public class URLAsResourceNameRule implements TraceProcessor.Rule {\n \n-  // Matches any path segments with numbers in them. (exception for versioning: \"/v1/\")\n-  public static final Pattern PATH_MIXED_ALPHANUMERICS =\n-      Pattern.compile(\"(?<=/)(?![vV]\\\\d{1,2}/)(?:[^\\\\/\\\\d\\\\?]*[\\\\d]+[^\\\\/\\\\?]*)\");\n+  private static final BitSlicedBitapSearch PROTOCOL_SEARCH = new BitSlicedBitapSearch(\"://\");\n+\n+  private final ThreadLocal<StringBuilder> resourceNameBuilder =\n+      new ThreadLocal<StringBuilder>() {\n+        @Override\n+        protected StringBuilder initialValue() {\n+          return new StringBuilder(100);\n+        }\n+      };\n \n   @Override\n   public String[] aliases() {\n-    return new String[] {\"URLAsResourceName\"};\n+    return new String[] {\"URLAsResourceName\", \"Status404Rule\", \"Status404Decorator\"};\n   }\n \n   @Override\n-  public void processSpan(\n-      final DDSpan span, final Map<String, Object> tags, final Collection<DDSpan> trace) {\n+  public void processSpan(final DDSpan span) {\n     final DDSpanContext context = span.context();\n-    final Object httpStatus = tags.get(Tags.HTTP_STATUS);\n-    if (context.isResourceNameSet()\n-        || tags.get(Tags.HTTP_URL) == null\n-        || (httpStatus != null && (httpStatus.equals(404) || httpStatus.equals(\"404\")))) {\n+    if (context.isResourceNameSet()) {\n       return;\n     }\n-\n-    final String rawPath = rawPathFromUrlString(tags.get(Tags.HTTP_URL).toString().trim());\n-    final String normalizedPath = normalizePath(rawPath);\n-    final String resourceName = addMethodIfAvailable(tags, normalizedPath);\n-\n-    context.setResourceName(resourceName);\n-  }\n-\n-  private String rawPathFromUrlString(final String url) {\n-    // Get the path without host:port\n-    // url may already be just the path.\n-\n-    if (url.isEmpty()) {\n-      return \"/\";\n+    final Object httpStatus = span.getTag(Tags.HTTP_STATUS);\n+    if (null != httpStatus && (httpStatus.equals(404) || \"404\".equals(httpStatus))) {\n+      span.setResourceName(\"404\");\n+      return;\n+    }\n+    final Object url = span.getTag(Tags.HTTP_URL);\n+    if (null == url) {\n+      return;\n     }\n+    context.setResourceName(\n+        extractResourceNameFromURL(span.getTag(Tags.HTTP_METHOD), url.toString()));\n+  }\n \n-    final int queryLoc = url.indexOf(\"?\");\n-    final int fragmentLoc = url.indexOf(\"#\");\n-    final int endLoc;\n-    if (queryLoc < 0) {\n-      if (fragmentLoc < 0) {\n-        endLoc = url.length();\n-      } else {\n-        endLoc = fragmentLoc;\n+  private String extractResourceNameFromURL(final Object method, final String url) {\n+    StringBuilder resourceName = resourceNameBuilder.get();\n+    try {\n+      if (method != null) {\n+        final String verb = method.toString().toUpperCase().trim();\n+        resourceName.append(verb).append(' ');\n       }\n-    } else {\n-      if (fragmentLoc < 0) {\n-        endLoc = queryLoc;\n+      if (url.isEmpty()) {\n+        resourceName.append('/');\n       } else {\n-        endLoc = Math.min(queryLoc, fragmentLoc);\n+        // skip the protocol info if present\n+        int start = protocolPosition(url);\n+        boolean hasProtocol = start >= 0;\n+        start += hasProtocol ? 3 : 1;\n+        if (hasProtocol) { // then we need to terminate when an ? or # is found\n+          start = url.indexOf('/', start);\n+          if (start == -1) { // then this is just a hostname\n+            resourceName.append('/');\n+          } else { // ignore the hostname and remove any high cardinality info\n+            cleanResourceName(url, resourceName, start);\n+          }\n+        } else { // just need to remove any high cardinality info\n+          cleanResourceName(url, resourceName, start);\n+        }\n       }\n+      return resourceName.toString();\n+    } finally {\n+      resourceName.setLength(0);\n     }\n+  }\n \n-    final int protoLoc = url.indexOf(\"://\");\n-    if (protoLoc < 0) {\n-      return url.substring(0, endLoc);\n-    }\n-\n-    final int pathLoc = url.indexOf(\"/\", protoLoc + 3);\n-    if (pathLoc < 0) {\n-      return \"/\";\n+  private void cleanResourceName(String url, StringBuilder resourceName, int start) {\n+    boolean lastSegment = false;\n+    int segmentEnd;\n+    for (int i = start; i < url.length() && !lastSegment; i = segmentEnd) {\n+      if (url.charAt(i) == '/') { // always keep forward slashes\n+        resourceName.append('/');\n+        ++i;\n+      }\n+      // find the end of the current section as quickly as possible,\n+      // meaning we process each character at most twice. Even if\n+      // we do, each segment is expected to be short, say, at most\n+      // 50 characters\n+      segmentEnd = url.indexOf('/', i);\n+      if (segmentEnd == -1) {\n+        // according to https://tools.ietf.org/html/rfc3986#section-3\n+        // fragments come after query parts, so ? should be closer than #\n+        segmentEnd = url.indexOf('?', i);\n+        if (segmentEnd == -1) {\n+          segmentEnd = url.indexOf('#', i);\n+          if (segmentEnd == -1) {\n+            segmentEnd = url.length();\n+          }\n+        }\n+        lastSegment = true;\n+      }\n+      if (i < segmentEnd) {\n+        // now check if what's in the current section should be scrubbed or\n+        // appended to the output\n+        int snapshot = resourceName.length();\n+        char c = url.charAt(i);\n+        resourceName.append(c);\n+        // versions can start with v, V, up to 2 numbers, and can't be the last segment\n+        // in the URL\n+        boolean isVersion = !lastSegment & (c == 'v' | c == 'V') & (segmentEnd - i) <= 3;\n+        // if we find numeric characters which aren't part of a version, the segment will\n+        // be removed\n+        boolean containsNumerics = Character.isDigit(c);\n+        boolean isBlank = Character.isWhitespace(c);\n+        // most of the time, will get out of this loop quickly,\n+        // except when accumulating characters we need to keep\n+        for (int j = i + 1; j < segmentEnd && (!containsNumerics || isVersion || isBlank); ++j) {\n+          c = url.charAt(j);\n+          isVersion &= Character.isDigit(c);\n+          containsNumerics |= Character.isDigit(c);\n+          isBlank &= Character.isWhitespace(c);\n+          resourceName.append(c); // append speculatively\n+        }\n+        // check if this section should be ignored\n+        if (containsNumerics && !isVersion) {\n+          resourceName.setLength(snapshot);\n+          resourceName.append('?');\n+        } else if (isBlank) {\n+          resourceName.setLength(snapshot);\n+        }\n+      }\n     }\n-\n-    if (queryLoc < 0) {\n-      return url.substring(pathLoc);\n-    } else {\n-      return url.substring(pathLoc, endLoc);\n+    if (resourceName.length() == 0) {\n+      resourceName.append('/');\n     }\n   }\n \n-  // Method to normalise the url string\n-  private String normalizePath(final String path) {\n-    if (path.isEmpty() || path.equals(\"/\")) {\n-      return \"/\";\n+  /**\n+   * This class does substring search on latin 1 strings of up to 32 characters, and will inspect\n+   * each character at most once in the input.\n+   *\n+   * <p>This class uses the bitap algorithm (https://en.wikipedia.org/wiki/Bitap_algorithm) but\n+   * adapted slightly in bit slicing the masks into high and low nibbles, which reduces spatial\n+   * overhead by a factor of 8.\n+   *\n+   * <p>This is only implemented because it's a compact, efficient, and easy to implement string\n+   * search algorithm, and the JDK's String.indexOf(String) doesn't allow specification of a limit.\n+   * This class allows searching within a range of the string.\n+   */\n+  private static class BitSlicedBitapSearch {\n+    private final int[] high;\n+    private final int[] low;\n+    private final int termination;\n+\n+    BitSlicedBitapSearch(String term) {\n+      if (term.length() > 32) {\n+        throw new IllegalArgumentException(\"term must be shorter than 32 characters\");\n+      }\n+      // these arrays each index the position of the character\n+      // by nibble. So if we have a character 'a' = 0b01100001\n+      // at position 0, we mark the first bit in high[0b0110]\n+      // and the first bit in low[0b1]. During matching, these\n+      // masks are intersected, so if get character 'b' = 0b01100010,\n+      // we match the high mask but not the low and disregard\n+      // the input.\n+      this.high = new int[16];\n+      this.low = new int[16];\n+      int mask = 1;\n+      for (char c : term.toCharArray()) {\n+        if (c >= 256) {\n+          throw new IllegalStateException(\"term must be latin 1\");\n+        }\n+        low[c & 0xF] |= mask;\n+        high[(c >>> 4) & 0xF] |= mask;\n+        mask <<= 1;\n+      }\n+      this.termination = 1 << (term.length() - 1);\n     }\n \n-    return PATH_MIXED_ALPHANUMERICS.matcher(path).replaceAll(\"?\");\n-  }\n-\n-  private String addMethodIfAvailable(final Map<String, Object> meta, String path) {\n-    // if the method (GET, POST ...) is present, add it\n-    final Object method = meta.get(Tags.HTTP_METHOD);\n-    if (method != null) {\n-      final String verb = method.toString().toUpperCase().trim();\n-      if (!verb.isEmpty()) {\n-        path = verb + \" \" + path;\n+    public int indexOf(String text, int from, int to) {\n+      int state = 0;\n+      to = Math.min(to, text.length());\n+      for (int i = from; i < to; ++i) {\n+        char c = text.charAt(i);\n+        if (c >= 256) { // oops, not latin 1 input\n+          state = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267"}, "originalPosition": 247}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDkyMjg2", "url": "https://github.com/DataDog/dd-trace-java/pull/1551#pullrequestreview-426492286", "createdAt": "2020-06-08T18:11:09Z", "commit": {"oid": "da5e59aca437b6283a7932552d21c3647aac5267"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2370, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}