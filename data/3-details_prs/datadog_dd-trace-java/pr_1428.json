{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMDMyOTUy", "number": 1428, "title": "Implementation of JFR binary format writer", "bodyText": "Implementation of a JFR binary format writer which provides somewhat nice Java API to build up the type definitions and write custom events.", "createdAt": "2020-05-04T15:47:34Z", "url": "https://github.com/DataDog/dd-trace-java/pull/1428", "merged": true, "mergeCommit": {"oid": "78b61e97561865eb633c18bc5043647f5f11aff6"}, "closed": true, "closedAt": "2020-05-13T16:32:58Z", "author": {"login": "jbachorik"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceBVi_gH2gAyNDEzMDMyOTUyOmE5Y2UzNjFiYzg5ZTcwMDE5ZTNiNGNkYjc4MDU5MGJkYjNmOGUwODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcg7NriAFqTQxMTA4MzAzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a9ce361bc89e70019e3b4cdb780590bdb3f8e088", "committedDate": "2020-05-04T15:37:15Z", "message": "Minimum viable implementation of JFR binary format writer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTI3MTE0", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#pullrequestreview-405127114", "createdAt": "2020-05-04T16:02:00Z", "commit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMjowMFrOGQHEWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjowMjowMFrOGQHEWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw==", "bodyText": "It is very unclear what is the aim here: is there some sampling going on? If so it is hard to see it in the code.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419546203", "createdAt": "2020-05-04T16:02:00Z", "author": {"login": "mar-kolya"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.datadog.profiling.sampler;\n+\n+import com.datadog.profiling.jfr.JfrChunkWriter;\n+import com.datadog.profiling.jfr.JfrWriter;\n+import com.datadog.profiling.jfr.Type;\n+import com.datadog.profiling.jfr.TypedValue;\n+import com.datadog.profiling.jfr.Types;\n+import java.io.IOException;\n+import java.lang.management.ThreadInfo;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SamplerWriter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/651b02e07f40b00f5017c94799d24e989562b068", "committedDate": "2020-05-04T16:30:51Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTU2ODAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#pullrequestreview-405156800", "createdAt": "2020-05-04T16:37:34Z", "commit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozNzozNFrOGQIiEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozNzozNFrOGQIiEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA==", "bodyText": "Is it worth using Unsafe.putLong here for efficiency?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419570194", "createdAt": "2020-05-04T16:37:34Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "651b02e07f40b00f5017c94799d24e989562b068"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/892c581fb0d3dfec657954a630c8e9c98475cfe2", "committedDate": "2020-05-04T18:24:59Z", "message": "Add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NTgxNTQy", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#pullrequestreview-405581542", "createdAt": "2020-05-05T08:21:43Z", "commit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODoyMTo0M1rOGQfH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODoyMTo0M1rOGQfH-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ==", "bodyText": "Could use -EXT_BIT instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419940345", "createdAt": "2020-05-05T08:21:43Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0423be9bf5a82feed23c136641bba82c39dc3b12", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/0423be9bf5a82feed23c136641bba82c39dc3b12", "committedDate": "2020-05-05T14:17:50Z", "message": "Add support for annotation elements.\nWithout annotation elements the JMC parser gets confused when parsing timestamps, time spans etc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "091e25510c93e46345aca97a80f692e81df607c6", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/091e25510c93e46345aca97a80f692e81df607c6", "committedDate": "2020-05-05T16:12:58Z", "message": "Remove the cyclical dependency between Metadata-Types-TypeFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd0a3b6ef33a6c7881465b05eba05096b36492c", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/5cd0a3b6ef33a6c7881465b05eba05096b36492c", "committedDate": "2020-05-05T17:45:45Z", "message": "Add annotation registration support method to JFRWriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97188b2007f9a9c413b97dc32324b67fc4b58688", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/97188b2007f9a9c413b97dc32324b67fc4b58688", "committedDate": "2020-05-05T17:53:00Z", "message": "First batch of unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af00f3fa8c919f8068acecb4d873e2f90890115f", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/af00f3fa8c919f8068acecb4d873e2f90890115f", "committedDate": "2020-05-05T18:17:43Z", "message": "Simplify the the COMPRESSED_INT_MASK calculation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7930576fc85e341ecea634b56de0a655fcd60efd", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7930576fc85e341ecea634b56de0a655fcd60efd", "committedDate": "2020-05-06T17:52:37Z", "message": "Another batch of unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c96bd9d1aedb54397d83a90017d2dd59452073a1", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/c96bd9d1aedb54397d83a90017d2dd59452073a1", "committedDate": "2020-05-07T18:31:25Z", "message": "Another batch of unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c9e3993954373014400cd2c1a6af21613769c77", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/6c9e3993954373014400cd2c1a6af21613769c77", "committedDate": "2020-05-07T18:37:33Z", "message": "Move ChunkTest to the right place"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44a0fc70631d19c08af61acb2912b3e491a8c6be", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/44a0fc70631d19c08af61acb2912b3e491a8c6be", "committedDate": "2020-05-11T13:27:25Z", "message": "Next batch of tests and cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/62e9580ff90901b27ce18820336cb772d87a6d2b", "committedDate": "2020-05-11T13:56:29Z", "message": "Make IBM Java8 happy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NTY0MzAw", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#pullrequestreview-405564300", "createdAt": "2020-05-05T07:54:23Z", "commit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNzo1NDoyM1rOGQePlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTozMjo0MFrOGUCT1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyNTkxMA==", "bodyText": "why not putting this a static (constant) field?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419925910", "createdAt": "2020-05-05T07:54:23Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/BaseJFRType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/** Common JFR type super-class */\n+abstract class BaseJFRType implements JFRType {\n+  private final long id;\n+  private final String name;\n+  private final String supertype;\n+  private final ConstantPools constantPools;\n+  private final Types types;\n+  private final TypedValue nullValue = TypedValue.of(this, (Object) null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1OTU5NA==", "bodyText": "This algorithm is present multiple times, could be factored into a static function", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423559594", "createdAt": "2020-05-12T08:35:26Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Chunk.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package com.datadog.profiling.jfr;\n+\n+/** A representation of JFR chunk - self contained set of JFR data. */\n+public final class Chunk {\n+  private static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+  private static final short MAJOR_VERSION = 2;\n+  private static final short MINOR_VERSION = 0;\n+\n+  private static final long CHUNK_SIZE_OFFSET = 8;\n+  private static final long CONSTANT_OFFSET_OFFSET = 16;\n+  private static final long METADATA_OFFSET_OFFSET = 24;\n+  private static final long DURATION_NANOS_OFFSET = 40;\n+\n+  private final ByteArrayWriter writer = new ByteArrayWriter(65536);\n+  private final ConstantPools constantPools;\n+  private final Metadata metadata;\n+  private final long startTicks;\n+  private final long startNanos;\n+\n+  Chunk(Metadata metadata, ConstantPools constantPools) {\n+    this.metadata = metadata;\n+    this.constantPools = constantPools;\n+    this.startTicks = System.nanoTime();\n+    this.startNanos = System.currentTimeMillis() * 1_000_000L;\n+    writeHeader();\n+  }\n+\n+  /**\n+   * Write a custom event\n+   *\n+   * @param event the event value\n+   * @return {@literal this} for chaining\n+   * @throws IllegalArgumentException if the event type has not got 'jdk.jfr.Event' as its super\n+   *     type\n+   */\n+  public Chunk writeEvent(TypedValue event) {\n+    if (!\"jdk.jfr.Event\".equals(event.getType().getSupertype())) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    ByteArrayWriter eventWriter = new ByteArrayWriter(32767);\n+    eventWriter.writeLong(event.getType().getId());\n+    for (TypedFieldValue fieldValue : event.getFieldValues()) {\n+      writeTypedValue(eventWriter, fieldValue.getValue());\n+    }\n+\n+    int len = eventWriter.length();\n+    int extraLen = 0;\n+    do {\n+      extraLen = ByteArrayWriter.getPackedIntLen(len + extraLen);\n+    } while (ByteArrayWriter.getPackedIntLen(len + extraLen) != extraLen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng==", "bodyText": "Could it be resolve now?", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423582566", "createdAt": "2020-05-12T09:10:10Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/** JFR type repository class. */\n+final class Metadata {\n+  private static final String CLASS_KEY = \"class\";\n+  private static final String FIELD_KEY = \"field\";\n+  private static final String NAME_KEY = \"name\";\n+  private static final String ID_KEY = \"id\";\n+  private static final String VALUE_KEY = \"value\";\n+  private static final String SUPER_TYPE_KEY = \"superType\";\n+  private static final String CONSTANT_POOL_KEY = \"constantPool\";\n+  private static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+  private static final String ROOT_KEY = \"root\";\n+  private static final String METADATA_KEY = \"metadata\";\n+  private static final String TRUE_VALUE = \"true\";\n+  private static final String REGION_KEY = \"region\";\n+  private static final String DIMENSION_KEY = \"dimension\";\n+  private static final String ANNOTATION_KEY = \"annotation\";\n+  private static final String VAL_1_VALUE = \"1\";\n+\n+  private final AtomicLong typeCounter = new AtomicLong(1);\n+  private final ConstantPools constantPools;\n+  private final Map<String, Type> metadata = new HashMap<>();\n+  private final Map<String, Integer> stringTable = new HashMap<>();\n+  private final Map<Integer, String> reverseStringTable = new TreeMap<>();\n+  private final Set<ResolvableType> unresolvedTypes = new HashSet<>();\n+\n+  Metadata(ConstantPools constantPools) {\n+    this.constantPools = constantPools;\n+    fillStrings();\n+  }\n+\n+  /** Pre-fill the string constant pool with all used constant strings */\n+  private void fillStrings() {\n+    storeString(VAL_1_VALUE);\n+    storeString(CLASS_KEY);\n+    storeString(FIELD_KEY);\n+    storeString(NAME_KEY);\n+    storeString(ID_KEY);\n+    storeString(VALUE_KEY);\n+    storeString(SUPER_TYPE_KEY);\n+    storeString(CONSTANT_POOL_KEY);\n+    storeString(SIMPLE_TYPE_KEY);\n+    storeString(ROOT_KEY);\n+    storeString(METADATA_KEY);\n+    storeString(TRUE_VALUE);\n+    storeString(REGION_KEY);\n+    storeString(DIMENSION_KEY);\n+    storeString(ANNOTATION_KEY);\n+  }\n+\n+  /**\n+   * Register a built-in type\n+   *\n+   * @param typeDef a {@link com.datadog.profiling.jfr.Types.Builtin built-in} type\n+   */\n+  void registerBuiltin(Types.Builtin typeDef) {\n+    Type type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+    storeTypeStrings(type);\n+  }\n+\n+  /**\n+   * Register a {@linkplain Type} instance\n+   *\n+   * @param typeName the type name\n+   * @param supertype super type; may be {@literal null}\n+   * @param typeStructureProvider type structure provider to be called lazily when a new type is\n+   *     created\n+   * @return registered type - either a new type or or a previously registered with the same name\n+   */\n+  Type registerType(\n+      String typeName, String supertype, Supplier<TypeStructure> typeStructureProvider) {\n+    Type type = metadata.get(typeName);\n+    if (type == null) {\n+      type =\n+          createCustomType(\n+              typeName,\n+              supertype,\n+              typeStructureProvider != null ? typeStructureProvider.get() : TypeStructure.EMPTY);\n+      metadata.put(typeName, type);\n+    }\n+    storeTypeStrings(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Retrieve a type with the given name.\n+   *\n+   * @param name the type name\n+   * @param asResolvable if the type is not found to be registered should a {@link ResolvableType\n+   *     resolvable} wrapper be returned instead?\n+   * @return the type of the given name\n+   */\n+  Type getType(String name, boolean asResolvable) {\n+    Type found = metadata.get(name);\n+    if (found == null) {\n+      if (asResolvable) {\n+        found = new ResolvableType(name, this);\n+      }\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Create a new built-in type of the given name. !Package visibility only because of unit testing!\n+   *\n+   * @param name the type name\n+   * @return new built-in type\n+   * @throws IllegalArgumentException if a the type name is not representing a built-in\n+   */\n+  Type createBuiltinType(String name) {\n+    if (!Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    Types.Builtin type = Types.Builtin.ofName(name);\n+    return new BuiltinType(\n+        typeCounter.getAndIncrement(),\n+        type,\n+        type == Types.Builtin.STRING ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Create a new custom type of the given name and structure. !Package visibility only because of\n+   * unit testing!\n+   *\n+   * @param name the type name\n+   * @param supertype the super type name - may be {@literal null}\n+   * @param structure the type structure - fields, annotations\n+   * @return new custom type\n+   * @throws IllegalArgumentException if the name belongs to one of the built-in types\n+   */\n+  Type createCustomType(String name, String supertype, TypeStructure structure) {\n+    if (Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    return new CompositeType(\n+        typeCounter.getAndIncrement(),\n+        name,\n+        supertype,\n+        structure,\n+        // TODO hack for event types not to go to constant pool\n+        !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Retrieve a type from the metadata storage\n+   *\n+   * @param type the (enumerated) type to retrieve from the metadata storage\n+   * @param asResolvable should a {@linkplain ResolvableType} wrapper be returned if the requested\n+   *     type is not present in the metadata storage yet?\n+   * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+   *     the metadata storage yet and 'asResolvable' was {@literal false}\n+   */\n+  Type getType(NamedType type, boolean asResolvable) {\n+    return getType(type.getTypeName(), asResolvable);\n+  }\n+\n+  /**\n+   * Add a new unresolved {@linkplain ResolvableType} instance.\n+   *\n+   * @param type unresolved type\n+   */\n+  void addUnresolved(ResolvableType type) {\n+    unresolvedTypes.add(type);\n+  }\n+\n+  /**\n+   * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be done\n+   * if some of the type definitions are using forward references to not yet registered types.\n+   */\n+  void resolveTypes() {\n+    unresolvedTypes.removeIf(ResolvableType::resolve);\n+  }\n+\n+  private void storeTypeStrings(Type type) {\n+    storeString(type.getTypeName());\n+    if (type.getSupertype() != null) {\n+      storeString(type.getSupertype());\n+    }\n+    storeString(String.valueOf(type.getId()));\n+    for (TypedField field : type.getFields()) {\n+      storeString(field.getName());\n+      storeAnnotationStrings(field.getAnnotations());\n+    }\n+    storeAnnotationStrings(type.getAnnotations());\n+  }\n+\n+  private void storeAnnotationStrings(List<Annotation> annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.value != null) {\n+        storeString(annotation.value);\n+      }\n+    }\n+  }\n+\n+  private void storeString(String value) {\n+    stringTable.computeIfAbsent(\n+        value,\n+        k -> {\n+          int pointer = stringTable.size();\n+          reverseStringTable.put(pointer, k);\n+          return pointer;\n+        });\n+  }\n+\n+  private int stringIndex(String value) {\n+    // TODO handle NPE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjM4Ng==", "bodyText": "should return Collections.emptyList()\nas all other implementation of BaseType expect to return non-null\nsee BuiltinType", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662386", "createdAt": "2020-05-12T11:32:22Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjU0OA==", "bodyText": "same as above", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662548", "createdAt": "2020-05-12T11:32:40Z", "author": {"login": "jpbempel"}, "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;\n+  }\n+\n+  @Override\n+  public TypedField getField(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<Annotation> getAnnotations() {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49302a04263364698d021f96123fd67444b625bf", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/49302a04263364698d021f96123fd67444b625bf", "committedDate": "2020-05-12T16:23:53Z", "message": "Addressing review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22623334a8bab965c434dcf7dda13d741f82aed", "author": {"user": {"login": "jbachorik", "name": "Jaroslav Bachorik"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a22623334a8bab965c434dcf7dda13d741f82aed", "committedDate": "2020-05-12T16:56:02Z", "message": "Make format check happy again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDgzMDMz", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#pullrequestreview-411083033", "createdAt": "2020-05-13T16:11:01Z", "commit": {"oid": "a22623334a8bab965c434dcf7dda13d741f82aed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2466, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}