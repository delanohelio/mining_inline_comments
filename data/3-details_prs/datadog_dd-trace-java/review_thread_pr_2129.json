{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4NzA5MTIx", "number": 2129, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1Nzo1NFrOE-Dqvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDowNTo1MVrOE-qyHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA3MjYyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/jboss-logmanager/src/main/java/datadog/trace/instrumentation/jbosslogmanager/JBossLogManagerMDCInstrumentation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1Nzo1NFrOH7EWlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMjowMlrOH7EcmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5OTM0OA==", "bodyText": "This should only happen once, right?", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531699348", "createdAt": "2020-11-27T16:57:54Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/jboss-logmanager/src/main/java/datadog/trace/instrumentation/jbosslogmanager/JBossLogManagerMDCInstrumentation.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package datadog.trace.instrumentation.jbosslogmanager;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isTypeInitializer;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.log.LogContextScopeListener;\n+import datadog.trace.api.Config;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class JBossLogManagerMDCInstrumentation extends Instrumenter.Default {\n+  public static final String MDC_INSTRUMENTATION_NAME = \"jboss-logmanager\";\n+\n+  public JBossLogManagerMDCInstrumentation() {\n+    super(MDC_INSTRUMENTATION_NAME);\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return Config.get().isLogsInjectionEnabled();\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"org.jboss.logmanager.MDC\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isTypeInitializer(),\n+        JBossLogManagerMDCInstrumentation.class.getName() + \"$MDCContextAdvice\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\"datadog.trace.agent.tooling.log.LogContextScopeListener\"};\n+  }\n+\n+  public static class MDCContextAdvice {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMDg4OQ==", "bodyText": "Yes only once for the the MDC singleton.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531700889", "createdAt": "2020-11-27T17:02:02Z", "author": {"login": "bantonsson"}, "path": "dd-java-agent/instrumentation/jboss-logmanager/src/main/java/datadog/trace/instrumentation/jbosslogmanager/JBossLogManagerMDCInstrumentation.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package datadog.trace.instrumentation.jbosslogmanager;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isTypeInitializer;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.log.LogContextScopeListener;\n+import datadog.trace.api.Config;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class JBossLogManagerMDCInstrumentation extends Instrumenter.Default {\n+  public static final String MDC_INSTRUMENTATION_NAME = \"jboss-logmanager\";\n+\n+  public JBossLogManagerMDCInstrumentation() {\n+    super(MDC_INSTRUMENTATION_NAME);\n+  }\n+\n+  @Override\n+  protected boolean defaultEnabled() {\n+    return Config.get().isLogsInjectionEnabled();\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"org.jboss.logmanager.MDC\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isTypeInitializer(),\n+        JBossLogManagerMDCInstrumentation.class.getName() + \"$MDCContextAdvice\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\"datadog.trace.agent.tooling.log.LogContextScopeListener\"};\n+  }\n+\n+  public static class MDCContextAdvice {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY5OTM0OA=="}, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA3NzgyOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/quarkus/application/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjo1OTo1OFrOH7EZew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMzowMlrOH7Ed_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMDA5MQ==", "bodyText": "For it to work at all or to work better?", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531700091", "createdAt": "2020-11-27T16:59:58Z", "author": {"login": "richardstartin"}, "path": "dd-smoke-tests/quarkus/application/build.gradle", "diffHunk": "@@ -0,0 +1,46 @@\n+plugins {\n+  id 'java'\n+  id 'io.quarkus'\n+  id 'com.diffplug.gradle.spotless' version '4.3.0'\n+  id 'pl.allegro.tech.build.axion-release' version '1.10.3'\n+}\n+\n+def rootRootDir = \"$rootDir/../../../\"\n+def sharedConfigDirectory = \"$rootRootDir/gradle\"\n+rootProject.ext.sharedConfigDirectory = sharedConfigDirectory\n+\n+apply from: \"$sharedConfigDirectory/repositories.gradle\"\n+apply from: \"$sharedConfigDirectory/spotless.gradle\"\n+\n+// TODO need to set up build cache here as well for CI to work", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMTI0NQ==", "bodyText": "To not pollute the cache with the build cache. I remembered as soon as I opened the PR.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531701245", "createdAt": "2020-11-27T17:03:02Z", "author": {"login": "bantonsson"}, "path": "dd-smoke-tests/quarkus/application/build.gradle", "diffHunk": "@@ -0,0 +1,46 @@\n+plugins {\n+  id 'java'\n+  id 'io.quarkus'\n+  id 'com.diffplug.gradle.spotless' version '4.3.0'\n+  id 'pl.allegro.tech.build.axion-release' version '1.10.3'\n+}\n+\n+def rootRootDir = \"$rootDir/../../../\"\n+def sharedConfigDirectory = \"$rootRootDir/gradle\"\n+rootProject.ext.sharedConfigDirectory = sharedConfigDirectory\n+\n+apply from: \"$sharedConfigDirectory/repositories.gradle\"\n+apply from: \"$sharedConfigDirectory/spotless.gradle\"\n+\n+// TODO need to set up build cache here as well for CI to work", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMDA5MQ=="}, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA4NTEyOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/quarkus/quarkus.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMjo0MlrOH7Edkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMjo0MlrOH7Edkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMTEzOQ==", "bodyText": "Good to see a smoke test for this, it's what's been missing in the past", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531701139", "createdAt": "2020-11-27T17:02:42Z", "author": {"login": "richardstartin"}, "path": "dd-smoke-tests/quarkus/quarkus.gradle", "diffHunk": "@@ -0,0 +1,44 @@\n+ext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA4NjMyOnYy", "diffSide": "RIGHT", "path": "dd-smoke-tests/quarkus/src/test/groovy/datadog/smoketest/QuarkusSmokeTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMzoxNVrOH7EeUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowMzoxNVrOH7EeUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMTMyOA==", "bodyText": "This does indeed look wrong (but not the point of this PR)", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531701328", "createdAt": "2020-11-27T17:03:15Z", "author": {"login": "richardstartin"}, "path": "dd-smoke-tests/quarkus/src/test/groovy/datadog/smoketest/QuarkusSmokeTest.groovy", "diffHunk": "@@ -0,0 +1,99 @@\n+package datadog.smoketest\n+\n+import datadog.trace.agent.test.utils.ThreadUtils\n+import okhttp3.Request\n+import spock.lang.Shared\n+\n+import java.util.concurrent.ThreadLocalRandom\n+import java.util.regex.Pattern\n+\n+abstract class QuarkusSmokeTest extends AbstractServerSmokeTest {\n+\n+  @Override\n+  ProcessBuilder createProcessBuilder() {\n+    String quarkusUberJar = System.getProperty(\"datadog.smoketest.quarkus.uberJar.path\")\n+\n+    List<String> command = new ArrayList<>()\n+    command.add(javaPath())\n+    command.addAll(defaultJavaProperties)\n+    command.addAll((String[]) [\n+      \"-Ddd.writer.type=MultiWriter:TraceStructureWriter:${output.getAbsolutePath()},DDAgentWriter\",\n+      \"-Ddd.logs.injection=true\",\n+      \"-Ddd.app.customlogmanager=true\",\n+      \"-Dquarkus.http.port=${httpPort}\",\n+      \"-jar\",\n+      quarkusUberJar\n+    ])\n+    ProcessBuilder processBuilder = new ProcessBuilder(command)\n+    processBuilder.directory(new File(buildDirectory))\n+  }\n+\n+  @Override\n+  File createTemporaryFile() {\n+    return new File(\"${buildDirectory}/tmp/trace-structure-quarkus.out\")\n+  }\n+\n+  @Override\n+  protected Set<String> expectedTraces() {\n+    // TODO is this really how quarkus requests should look?\n+    return [\"[jax-rs.request]\", \"[netty.request]\"].toSet()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTA4OTQxOnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowNDoyOVrOH7EgFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzowNDoyOVrOH7EgFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwMTc4MA==", "bodyText": "\ud83d\udc4d I want a linter to find all the cases where we don't check the result of a CAS!", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531701780", "createdAt": "2020-11-27T17:04:29Z", "author": {"login": "richardstartin"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -35,11 +35,44 @@ public void addScopeListener(ScopeListener listener) {}\n \n   public static void registerIfAbsent(Tracer p) {\n     if (p != null && p != NO_OP) {\n-      provider.compareAndSet(NO_OP, p);\n+      boolean installed = provider.compareAndSet(NO_OP, p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTEwNzU0OnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzoxMjowMVrOH7EqgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzoxNDoyNlrOH7EtkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwNDQ0OQ==", "bodyText": "I don't really like this because this could break if the implementation of GlobalTracer.isTracerInstalled became reorderable. Should this all be delegated to GlobalTracer?", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531704449", "createdAt": "2020-11-27T17:12:01Z", "author": {"login": "richardstartin"}, "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.api;\n+\n+import static datadog.trace.api.GlobalTracer.isTracerInstalled;\n+\n+import java.util.LinkedList;\n+\n+public class WithGlobalTracer {\n+\n+  private static final Object lock = new Object();\n+  private static LinkedList<Callback> registeredCallbacks = null;\n+\n+  /**\n+   * Register a callback to be run when the global tracer is installed, or execute it right now if\n+   * the tracer is installed.\n+   */\n+  public static void registerOrExecute(Callback callback) {\n+    boolean shouldExecute = true;\n+    if (!isTracerInstalled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwNTIzMg==", "bodyText": "I would prefer to not expose this whole thing in the public api. That's why it isn't in the GlobalTracer. I can add comments about the relationships if that helps.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531705232", "createdAt": "2020-11-27T17:14:26Z", "author": {"login": "bantonsson"}, "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.api;\n+\n+import static datadog.trace.api.GlobalTracer.isTracerInstalled;\n+\n+import java.util.LinkedList;\n+\n+public class WithGlobalTracer {\n+\n+  private static final Object lock = new Object();\n+  private static LinkedList<Callback> registeredCallbacks = null;\n+\n+  /**\n+   * Register a callback to be run when the global tracer is installed, or execute it right now if\n+   * the tracer is installed.\n+   */\n+  public static void registerOrExecute(Callback callback) {\n+    boolean shouldExecute = true;\n+    if (!isTracerInstalled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwNDQ0OQ=="}, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTEyNzMzOnYy", "diffSide": "RIGHT", "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzoyMDo1MVrOH7E1pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwOTowODozN1rOH7xpbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwNzMwMw==", "bodyText": "I looked at this for a while and had some doubts about the implementation strategy, but think that this is probably among the best and simplest options, especially if this is rare.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r531707303", "createdAt": "2020-11-27T17:20:51Z", "author": {"login": "richardstartin"}, "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.api;\n+\n+import static datadog.trace.api.GlobalTracer.isTracerInstalled;\n+\n+import java.util.LinkedList;\n+\n+public class WithGlobalTracer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ0MTQ1Mw==", "bodyText": "Added comments to explain the assumption that it is very rare.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r532441453", "createdAt": "2020-11-30T09:08:37Z", "author": {"login": "bantonsson"}, "path": "internal-api/src/main/java/datadog/trace/api/WithGlobalTracer.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.api;\n+\n+import static datadog.trace.api.GlobalTracer.isTracerInstalled;\n+\n+import java.util.LinkedList;\n+\n+public class WithGlobalTracer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcwNzMwMw=="}, "originalCommit": {"oid": "700fc22b16679a6d1bf1daf9a76ef982bf0a88f6"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MTQ4MTI2OnYy", "diffSide": "RIGHT", "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDowNTo1MVrOH78k0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNDozNDo1N1rOH791dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYyMDQ5Nw==", "bodyText": "I have a nagging suspicion that there's a ! missing here, but I need to trace through this on paper to be sure", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r532620497", "createdAt": "2020-11-30T14:05:51Z", "author": {"login": "mcculls"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -35,11 +35,50 @@ public void addScopeListener(ScopeListener listener) {}\n \n   public static void registerIfAbsent(Tracer p) {\n     if (p != null && p != NO_OP) {\n-      provider.compareAndSet(NO_OP, p);\n+      boolean installed = provider.compareAndSet(NO_OP, p);\n+      if (installed) {\n+        Callback callback = installationCallback.getAndSet(null);\n+        if (callback != null) {\n+          callback.installed(p);\n+        }\n+      }\n     }\n   }\n \n   public static Tracer get() {\n     return provider.get();\n   }\n+\n+  // --------------------------------------------------------------------------------\n+  // All code below is to support the callback registration in WithGlobalTracer\n+  // --------------------------------------------------------------------------------\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isTracerInstalled() {\n+    return provider.get() != NO_OP;\n+  }\n+\n+  private static final AtomicReference<Callback> installationCallback = new AtomicReference<>(null);\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isCallbackInstalled() {\n+    return installationCallback.get() != null;\n+  }\n+\n+  static boolean registerInstallationCallback(Callback callback) {\n+    if (!isTracerInstalled()) {\n+      boolean installed = installationCallback.compareAndSet(null, callback);\n+      // Check if the tracer was installed while we were doing this, and try to back out\n+      if (installed && isTracerInstalled()) {\n+        installed = installationCallback.compareAndSet(callback, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f93a9a9de45e82e6460fe5addf1e6e567801393"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYyNDc0Mg==", "bodyText": "So the logic here is that if we installed the callback, but now someone has installed a tracer, isTracerInstalled(), then we try to remove our callback so we know if someone has picked up our callback. This is so we don't end up in the case where the someone that installed the tracer missed our callback, and it will never be called.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r532624742", "createdAt": "2020-11-30T14:11:59Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -35,11 +35,50 @@ public void addScopeListener(ScopeListener listener) {}\n \n   public static void registerIfAbsent(Tracer p) {\n     if (p != null && p != NO_OP) {\n-      provider.compareAndSet(NO_OP, p);\n+      boolean installed = provider.compareAndSet(NO_OP, p);\n+      if (installed) {\n+        Callback callback = installationCallback.getAndSet(null);\n+        if (callback != null) {\n+          callback.installed(p);\n+        }\n+      }\n     }\n   }\n \n   public static Tracer get() {\n     return provider.get();\n   }\n+\n+  // --------------------------------------------------------------------------------\n+  // All code below is to support the callback registration in WithGlobalTracer\n+  // --------------------------------------------------------------------------------\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isTracerInstalled() {\n+    return provider.get() != NO_OP;\n+  }\n+\n+  private static final AtomicReference<Callback> installationCallback = new AtomicReference<>(null);\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isCallbackInstalled() {\n+    return installationCallback.get() != null;\n+  }\n+\n+  static boolean registerInstallationCallback(Callback callback) {\n+    if (!isTracerInstalled()) {\n+      boolean installed = installationCallback.compareAndSet(null, callback);\n+      // Check if the tracer was installed while we were doing this, and try to back out\n+      if (installed && isTracerInstalled()) {\n+        installed = installationCallback.compareAndSet(callback, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYyMDQ5Nw=="}, "originalCommit": {"oid": "0f93a9a9de45e82e6460fe5addf1e6e567801393"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYzMzUxNA==", "bodyText": "So if someone hasn't picked up our callback then this CaS will return true, which then means shouldExecute == false in registerOrExecute? Won't that leave listeners waiting to be registered since the listener wasn't picked up?", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r532633514", "createdAt": "2020-11-30T14:24:16Z", "author": {"login": "mcculls"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -35,11 +35,50 @@ public void addScopeListener(ScopeListener listener) {}\n \n   public static void registerIfAbsent(Tracer p) {\n     if (p != null && p != NO_OP) {\n-      provider.compareAndSet(NO_OP, p);\n+      boolean installed = provider.compareAndSet(NO_OP, p);\n+      if (installed) {\n+        Callback callback = installationCallback.getAndSet(null);\n+        if (callback != null) {\n+          callback.installed(p);\n+        }\n+      }\n     }\n   }\n \n   public static Tracer get() {\n     return provider.get();\n   }\n+\n+  // --------------------------------------------------------------------------------\n+  // All code below is to support the callback registration in WithGlobalTracer\n+  // --------------------------------------------------------------------------------\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isTracerInstalled() {\n+    return provider.get() != NO_OP;\n+  }\n+\n+  private static final AtomicReference<Callback> installationCallback = new AtomicReference<>(null);\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isCallbackInstalled() {\n+    return installationCallback.get() != null;\n+  }\n+\n+  static boolean registerInstallationCallback(Callback callback) {\n+    if (!isTracerInstalled()) {\n+      boolean installed = installationCallback.compareAndSet(null, callback);\n+      // Check if the tracer was installed while we were doing this, and try to back out\n+      if (installed && isTracerInstalled()) {\n+        installed = installationCallback.compareAndSet(callback, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYyMDQ5Nw=="}, "originalCommit": {"oid": "0f93a9a9de45e82e6460fe5addf1e6e567801393"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY0MTE0MA==", "bodyText": "Yes! Thank you. Awesome catch. Messed it up during cleanup.", "url": "https://github.com/DataDog/dd-trace-java/pull/2129#discussion_r532641140", "createdAt": "2020-11-30T14:34:57Z", "author": {"login": "bantonsson"}, "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -35,11 +35,50 @@ public void addScopeListener(ScopeListener listener) {}\n \n   public static void registerIfAbsent(Tracer p) {\n     if (p != null && p != NO_OP) {\n-      provider.compareAndSet(NO_OP, p);\n+      boolean installed = provider.compareAndSet(NO_OP, p);\n+      if (installed) {\n+        Callback callback = installationCallback.getAndSet(null);\n+        if (callback != null) {\n+          callback.installed(p);\n+        }\n+      }\n     }\n   }\n \n   public static Tracer get() {\n     return provider.get();\n   }\n+\n+  // --------------------------------------------------------------------------------\n+  // All code below is to support the callback registration in WithGlobalTracer\n+  // --------------------------------------------------------------------------------\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isTracerInstalled() {\n+    return provider.get() != NO_OP;\n+  }\n+\n+  private static final AtomicReference<Callback> installationCallback = new AtomicReference<>(null);\n+\n+  // Needs to use a read that can't be reordered for the code in WithGlobalTracer to be correct\n+  static boolean isCallbackInstalled() {\n+    return installationCallback.get() != null;\n+  }\n+\n+  static boolean registerInstallationCallback(Callback callback) {\n+    if (!isTracerInstalled()) {\n+      boolean installed = installationCallback.compareAndSet(null, callback);\n+      // Check if the tracer was installed while we were doing this, and try to back out\n+      if (installed && isTracerInstalled()) {\n+        installed = installationCallback.compareAndSet(callback, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjYyMDQ5Nw=="}, "originalCommit": {"oid": "0f93a9a9de45e82e6460fe5addf1e6e567801393"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4638, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}