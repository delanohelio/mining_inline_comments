{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNDI5Mzk5", "number": 1752, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1OTozN1rOEV5ExQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo0Nzo0OVrOEXwLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzkwNjYxOnYy", "diffSide": "LEFT", "path": "dd-java-agent/instrumentation/java-concurrent/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1OTozN1rOG86AJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1OTozN1rOG86AJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxODA1NQ==", "bodyText": "You should probably have a cleanupSpec method that clear's the property when the test is done.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r466518055", "createdAt": "2020-08-06T15:59:37Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "diffHunk": "@@ -14,7 +14,7 @@ import static org.junit.Assume.assumeTrue\n class ThreadPoolExecutorInstrumentationTest extends AgentTestRunner {\n   static {\n     ConfigUtils.updateConfig {\n-      System.setProperty(\"dd.integration.thread-pool-executor.enabled\", \"false\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b0d06b7a47da97dcb97392305b434c47dc6b032"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjU5Njc5OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/java-threadpoolexecutor/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToxNzoyNFrOG_mGLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTozNzo0MlrOG_m-DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzNzY0Ng==", "bodyText": "Does this need to be cleared afterwards?", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469337646", "createdAt": "2020-08-12T15:17:24Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-threadpoolexecutor/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "diffHunk": "@@ -0,0 +1,75 @@\n+import datadog.trace.agent.test.AgentTestRunner\n+import datadog.trace.agent.test.utils.ConfigUtils\n+import datadog.trace.api.Trace\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper\n+import spock.lang.Shared\n+\n+import java.util.concurrent.Callable\n+import java.util.concurrent.ScheduledThreadPoolExecutor\n+import java.util.concurrent.TimeUnit\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope\n+\n+class ThreadPoolExecutorInstrumentationTest extends AgentTestRunner {\n+  static {\n+    ConfigUtils.updateConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MTk0OQ==", "bodyText": "Yeah, prob a good idea to add a cleanupSpec method to undo this.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469351949", "createdAt": "2020-08-12T15:37:42Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-threadpoolexecutor/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "diffHunk": "@@ -0,0 +1,75 @@\n+import datadog.trace.agent.test.AgentTestRunner\n+import datadog.trace.agent.test.utils.ConfigUtils\n+import datadog.trace.api.Trace\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper\n+import spock.lang.Shared\n+\n+import java.util.concurrent.Callable\n+import java.util.concurrent.ScheduledThreadPoolExecutor\n+import java.util.concurrent.TimeUnit\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope\n+\n+class ThreadPoolExecutorInstrumentationTest extends AgentTestRunner {\n+  static {\n+    ConfigUtils.updateConfig {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzNzY0Ng=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjYwMDkyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/java-threadpoolexecutor/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToxODoyM1rOG_mI0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToxODoyM1rOG_mI0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzODMyMw==", "bodyText": "Can you call toString on these so it works with any CharSequence equivalent to \"parent\" - you may need to rebase.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469338323", "createdAt": "2020-08-12T15:18:23Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/java-threadpoolexecutor/src/test/groovy/ThreadPoolExecutorInstrumentationTest.groovy", "diffHunk": "@@ -0,0 +1,75 @@\n+import datadog.trace.agent.test.AgentTestRunner\n+import datadog.trace.agent.test.utils.ConfigUtils\n+import datadog.trace.api.Trace\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.CallableWrapper\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper\n+import spock.lang.Shared\n+\n+import java.util.concurrent.Callable\n+import java.util.concurrent.ScheduledThreadPoolExecutor\n+import java.util.concurrent.TimeUnit\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope\n+\n+class ThreadPoolExecutorInstrumentationTest extends AgentTestRunner {\n+  static {\n+    ConfigUtils.updateConfig {\n+      System.setProperty(\"dd.trace.thread_pool_executor.wrapped_runnables.enabled\", \"false\")\n+    }\n+  }\n+\n+  @Shared\n+  def executeRunnable = { e, c -> e.execute((Runnable) c) }\n+  @Shared\n+  def submitRunnable = { e, c -> e.submit((Runnable) c) }\n+  @Shared\n+  def submitCallable = { e, c -> e.submit((Callable) c) }\n+  @Shared\n+  def scheduleRunnable = { e, c -> e.schedule((Runnable) c, 10, TimeUnit.MILLISECONDS) }\n+  @Shared\n+  def scheduleCallable = { e, c -> e.schedule((Callable) c, 10, TimeUnit.MILLISECONDS) }\n+\n+  def \"#poolImpl '#name' disabled\"() {\n+    setup:\n+    def pool = poolImpl\n+    def m = method\n+    def w = wrap\n+\n+    JavaAsyncChild child = new JavaAsyncChild(true, true)\n+    new Runnable() {\n+      @Override\n+      @Trace(operationName = \"parent\")\n+      void run() {\n+        activeScope().setAsyncPropagation(true)\n+        m(pool, w(child))\n+      }\n+    }.run()\n+    // We block in child to make sure spans close in predictable order\n+    child.unblock()\n+\n+    // Expect two traces because async propagation gets effectively disabled\n+    TEST_WRITER.waitForTraces(2)\n+\n+    expect:\n+    TEST_WRITER.size() == 2\n+    TEST_WRITER.get(0).size() == 1\n+    TEST_WRITER.get(0).get(0).operationName == \"parent\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjYxMDMzOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToyMDozM1rOG_mOrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyOTo1NFrOHAQ43Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzOTgyMw==", "bodyText": "Might it be possible/still correct to hoist this into a final boolean variable? Are rules updated on the fly?", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469339823", "createdAt": "2020-08-12T15:20:33Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MDMxMQ==", "bodyText": "This is called on construction, so I'm less worried about the cost, but I'm not sure isRuleEnabled is the right method to call.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469350311", "createdAt": "2020-08-12T15:35:19Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzOTgyMw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3NDA1Mw==", "bodyText": "I think you mean that isRuleEnabled was intended for the rule processors? I don't know that this isn't a tracing rule though so I think that method name could use some updating, this is enabling or disabling a flag for the tracer", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469374053", "createdAt": "2020-08-12T16:06:37Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzOTgyMw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzODc0OQ==", "bodyText": "yeah, it was intended originally for tag interceptors and renamed when I introduced rule processors.  I guess you can leave it as is.  Not that big of deal.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r470038749", "createdAt": "2020-08-13T15:29:54Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMzOTgyMw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjYzMzQ4OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNToyNTo0N1rOG_mdJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNjowMTowNlrOG_oG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw==", "bodyText": "OK, so this checks compatibility. How can we be sure a consumer doesn't see the value? Could it cause an error in the consumer?", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469343527", "createdAt": "2020-08-12T15:25:47Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MjM0Nw==", "bodyText": "This is definitely a possible issue source if people do weird things. I couldn't find a better way to test than this.\nI'm not entirely convinced this check is necessary actually. I can't think of a case in which a lambda would get wrapped (passed through execute/submit/etc.), and not be a plain Runnable. Maybe a custom ThreadPoolExecutor impl which has a submit/execute that takes a concrete type that implements runnable. I'm not sure how bytebuddy would view such a method", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469352347", "createdAt": "2020-08-12T15:38:15Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MjgwNA==", "bodyText": "I wonder if it would work reliably because of erasure of the queue's generic type. Where are you expecting the CCE to happen? Custom queues?", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469362804", "createdAt": "2020-08-12T15:49:50Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2MzQ5Ng==", "bodyText": "It might just result in generic type pollution and I suspect you couldn't detect incompatibility without being the consumer.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469363496", "createdAt": "2020-08-12T15:50:52Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM2NTQzMw==", "bodyText": "To be clear this code was already here, but yeah I would expect custom Queues", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469365433", "createdAt": "2020-08-12T15:53:42Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM3MDU4NQ==", "bodyText": "I thought this was new, sorry. I still wonder if it's correct and has no dangerous side effects.", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469370585", "createdAt": "2020-08-12T16:01:06Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call\n+      // disableExecutorForWrappedTasks. Therefore disabling the instrumentation explictly will not\n+      // work, for this instrumentation disabling for all executors is more of the intention\n+      if (!Config.get().isRuleEnabled(\"thread_pool_executor.wrapped_runnables\")) {\n+        ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n+      } else {\n+        if (queue.isEmpty()) {\n+          try {\n+            queue.offer(new GenericRunnable());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM0MzUyNw=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMjY4MzcyOnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTozNjo1M1rOG_m7wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNTo0MzowOFrOG_nRCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MTM2MQ==", "bodyText": "Why do we need a separate project to test this? Can't it be done in the main project?", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469351361", "createdAt": "2020-08-12T15:36:53Z", "author": {"login": "tylerbenson"}, "path": "settings.gradle", "diffHunk": "@@ -105,6 +105,7 @@ include ':dd-java-agent:instrumentation:jax-rs-client-2.0:connection-error-handl\n include ':dd-java-agent:instrumentation:jax-rs-client-2.0:connection-error-handling-resteasy'\n include ':dd-java-agent:instrumentation:java-concurrent'\n include ':dd-java-agent:instrumentation:java-concurrent:java-completablefuture'\n+include ':dd-java-agent:instrumentation:java-concurrent:java-threadpoolexecutor'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1NjgxMA==", "bodyText": "I was having issues with Config conflicting between test classes. cleanupSpec probably fixes it", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469356810", "createdAt": "2020-08-12T15:43:08Z", "author": {"login": "devinsba"}, "path": "settings.gradle", "diffHunk": "@@ -105,6 +105,7 @@ include ':dd-java-agent:instrumentation:jax-rs-client-2.0:connection-error-handl\n include ':dd-java-agent:instrumentation:jax-rs-client-2.0:connection-error-handling-resteasy'\n include ':dd-java-agent:instrumentation:java-concurrent'\n include ':dd-java-agent:instrumentation:java-concurrent:java-completablefuture'\n+include ':dd-java-agent:instrumentation:java-concurrent:java-threadpoolexecutor'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM1MTM2MQ=="}, "originalCommit": {"oid": "27a42b1520504c7aed3b0c656b674c2dc7e84196"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzQyMTEyOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo0Nzo0OVrOG_uGIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxODo0Nzo0OVrOG_uGIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2ODcwNw==", "bodyText": "disable", "url": "https://github.com/DataDog/dd-trace-java/pull/1752#discussion_r469468707", "createdAt": "2020-08-12T18:47:49Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/ThreadPoolExecutorInstrumentation.java", "diffHunk": "@@ -51,18 +52,24 @@ public ThreadPoolExecutorInstrumentation() {\n     public static void disableIfQueueWrongType(\n         @Advice.This final ThreadPoolExecutor executor,\n         @Advice.Argument(4) final BlockingQueue<Runnable> queue) {\n-\n-      if (queue.isEmpty()) {\n-        try {\n-          queue.offer(new GenericRunnable());\n-          queue.clear(); // Remove the Runnable we just added.\n-        } catch (final ClassCastException | IllegalArgumentException e) {\n-          // These errors indicate the queue is fundamentally incompatible with wrapped runnables.\n-          // We must disable the executor instance to avoid passing wrapped runnables later.\n-          ExecutorInstrumentationUtils.disableExecutorForWrappedTasks(executor);\n-        } catch (final Exception e) {\n-          // Other errors might indicate the queue is not fully initialized.\n-          // We might want to disable for those too, but for now just ignore.\n+      // We disabable this way because this instrumentation is only used to call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ed2a9bf2fd77bbac650a83691b4a51f66c5d2cb"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4999, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}