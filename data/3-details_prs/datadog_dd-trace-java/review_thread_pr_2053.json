{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2MTI1OTEx", "number": 2053, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMzoyMVrOE2KnTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowNTozN1rOE2KqYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMyNDYxOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowMzoyMVrOHu2KMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzozNjoxN1rOHu3RxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ==", "bodyText": "I'm not sure about this pattern. Especially given that the spans are being null checked anyway elsewhere, I think it's better to ensure that we always use the same span type.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518883891", "createdAt": "2020-11-06T17:03:21Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MDIyMA==", "bodyText": "This approach is based on the current reactor instrumentation - the idea is that we capture any active span at the time of construction and carry it with the reactive component to use as the parent of any follow-on work.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518890220", "createdAt": "2020-11-06T17:14:41Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MjIyMg==", "bodyText": "But I think it's better to do the null check rather than potentially carry around a differently typed span.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518892222", "createdAt": "2020-11-06T17:18:29Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5OTc3MA==", "bodyText": "You mean just not use noopSpan() at all here? Sure, I can look at that - I assume we'd also want to make the same change to reactor if it works as it uses noopSpan() in the same pattern at the moment.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518899770", "createdAt": "2020-11-06T17:31:42Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjIxMw==", "bodyText": "Exactly. We must do the null check elsewhere anyway, and I'd prefer to keep the code we're injecting monomorphic wherever possible.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518902213", "createdAt": "2020-11-06T17:36:17Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4Mzg5MQ=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMyODk3OnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowNDozOFrOHu2M1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzoyNTowOFrOHu25hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw==", "bodyText": "e.g. this really be an instanceof NoopSpan check, but I think it's much better to do a null check and use just one span type.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518884567", "createdAt": "2020-11-06T17:04:38Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {\n+        span = AgentTracer.noopSpan();\n+      }\n+      InstrumentationContext.get(Flowable.class, AgentSpan.class).put(thiz, span);\n+    }\n+  }\n+\n+  public static class SubscribeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope openScope(\n+        @Advice.This final Flowable<?> thiz,\n+        @Advice.Argument(value = 0, readOnly = false) Subscriber<?> observer) {\n+      if (observer != null) {\n+        AgentSpan span = InstrumentationContext.get(Flowable.class, AgentSpan.class).get(thiz);\n+        if (span != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5MjQ1Nw==", "bodyText": "This follows the reactor approach of using the captured span to wrap around any follow-on work, so instanceof NoopSpan would not be correct here as you'd then miss most of the cases we want to track. Note that we're not creating our own spans here - the goal is to try and carry the context with the reactive work.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518892457", "createdAt": "2020-11-06T17:18:56Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {\n+        span = AgentTracer.noopSpan();\n+      }\n+      InstrumentationContext.get(Flowable.class, AgentSpan.class).put(thiz, span);\n+    }\n+  }\n+\n+  public static class SubscribeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope openScope(\n+        @Advice.This final Flowable<?> thiz,\n+        @Advice.Argument(value = 0, readOnly = false) Subscriber<?> observer) {\n+      if (observer != null) {\n+        AgentSpan span = InstrumentationContext.get(Flowable.class, AgentSpan.class).get(thiz);\n+        if (span != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NjAwNw==", "bodyText": "You're not injecting a null span elsewhere but a NoOpSpan (and, yes, I understand that the intent here is context propagation).", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518896007", "createdAt": "2020-11-06T17:25:08Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(isConstructor(), packageName + \".FlowableInstrumentation$FlowableAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"subscribe\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, named(\"org.reactivestreams.Subscriber\"))),\n+        packageName + \".FlowableInstrumentation$SubscribeAdvice\");\n+    return transformers;\n+  }\n+\n+  public static class FlowableAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void onConstruct(@Advice.This final Flowable<?> thiz) {\n+      AgentSpan span = AgentTracer.activeSpan();\n+      if (span == null) {\n+        span = AgentTracer.noopSpan();\n+      }\n+      InstrumentationContext.get(Flowable.class, AgentSpan.class).put(thiz, span);\n+    }\n+  }\n+\n+  public static class SubscribeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope openScope(\n+        @Advice.This final Flowable<?> thiz,\n+        @Advice.Argument(value = 0, readOnly = false) Subscriber<?> observer) {\n+      if (observer != null) {\n+        AgentSpan span = InstrumentationContext.get(Flowable.class, AgentSpan.class).get(thiz);\n+        if (span != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NDU2Nw=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MjMzMjUwOnYy", "diffSide": "RIGHT", "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNzowNTozN1rOHu2PAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNDozMjoyNVrOHywkyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg==", "bodyText": "Rather than injecting the span, I would prefer for this to be State or ConcurrentState holding a Continuation, which at the very least makes it possible to write deterministic tests", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518885122", "createdAt": "2020-11-06T17:05:37Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg5NTkxNQ==", "bodyText": "I'd have to look into how that would work for the test scenarios - right now this is modelled as closely as possible to the reactor approach, which also stores spans. (ie. is there a reason the reactor approach stores spans instead of state - should that approach also be changed?)", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518895915", "createdAt": "2020-11-06T17:25:00Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjcxOA==", "bodyText": "I think that's worth looking in to, there is some inconsistency in asynchronous instrumentations but it's also not an area which has been bullet proof historically.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r518902718", "createdAt": "2020-11-06T17:37:18Z", "author": {"login": "richardstartin"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk4NjY5OA==", "bodyText": "I ran into a few issues using State/ConcurrentState so I'd prefer to merge this using the original approach and then iterate on it. I've also added a range of tests based on the ones from reactor which should help with future refactoring.", "url": "https://github.com/DataDog/dd-trace-java/pull/2053#discussion_r522986698", "createdAt": "2020-11-13T14:32:25Z", "author": {"login": "mcculls"}, "path": "dd-java-agent/instrumentation/rxjava-2/src/main/java/datadog/trace/instrumentation/rxjava2/FlowableInstrumentation.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.instrumentation.rxjava2;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import io.reactivex.Flowable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.reactivestreams.Subscriber;\n+\n+@AutoService(Instrumenter.class)\n+public final class FlowableInstrumentation extends Instrumenter.Default {\n+  public FlowableInstrumentation() {\n+    super(\"rxjava\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"io.reactivex.Flowable\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".TracingSubscriber\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"io.reactivex.Flowable\", AgentSpan.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4NTEyMg=="}, "originalCommit": {"oid": "ec6566d2e45ac0c7c12b4e2c764acfc01b2df4b2"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4787, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}