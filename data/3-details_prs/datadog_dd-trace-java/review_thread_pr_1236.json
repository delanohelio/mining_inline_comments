{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NzI2NDU4", "number": 1236, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzowOToyNFrODhhGjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDo0NDo0MFrODhjT2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NDcxOTUxOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMzowOToyNFrOFsSp9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDo0Mjo0NlrOFsV_SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4NzMxNw==", "bodyText": "You would need to make tracesUrl volatile or better yet do the if (tracesUrl == null) check inside the synchronized detectEndpoint() method which would then be called unconditionally from here.\nOtherwise you are risking data races.", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r381987317", "createdAt": "2020-02-20T13:09:24Z", "author": {"login": "jbachorik"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -128,6 +116,10 @@ Response sendTraces(final List<List<DDSpan>> traces) {\n \n   Response sendSerializedTraces(\n       final int representativeCount, final Integer sizeInBytes, final List<byte[]> traces) {\n+    if (tracesUrl == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8209a8830c0d2f82c45036f5082c57660abe2061"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5MzExNg==", "bodyText": "Good catch!\nLooks like I can just add another null check under synchronized block. With that after we have detected url there should be no contention.", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r381993116", "createdAt": "2020-02-20T13:21:18Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -128,6 +116,10 @@ Response sendTraces(final List<List<DDSpan>> traces) {\n \n   Response sendSerializedTraces(\n       final int representativeCount, final Integer sizeInBytes, final List<byte[]> traces) {\n+    if (tracesUrl == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4NzMxNw=="}, "originalCommit": {"oid": "8209a8830c0d2f82c45036f5082c57660abe2061"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0MTkyOQ==", "bodyText": "In this case, this would work without much coordination, since each thread would eventually make the null -> non-null transition.  This is how string hashCode works.\nvolatile alone will also have a race, but be a bit more clear.  On x86, it will compile to basically the same thing anyway.\nIn general, I'd like us to avoid adding synchronized blocks, since there's often a better way to achieve the same thing.  In this case, I don't think we really need synchronized.  There is a chance that two threads will make a network call, but reducing coordination overhead in the long run is probably a better choice overall.\nBut the real test is to measure the start-up and then we'll need to monitor throughput in perf env.", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r382041929", "createdAt": "2020-02-20T14:42:46Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -128,6 +116,10 @@ Response sendTraces(final List<List<DDSpan>> traces) {\n \n   Response sendSerializedTraces(\n       final int representativeCount, final Integer sizeInBytes, final List<byte[]> traces) {\n+    if (tracesUrl == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk4NzMxNw=="}, "originalCommit": {"oid": "8209a8830c0d2f82c45036f5082c57660abe2061"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTAyNDc1OnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDozMTozM1rOFsVivg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDozMTozM1rOFsVivg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzNDYyMg==", "bodyText": "This is probably a separate change but we probably want to lazy load this too. I seem to remember someone mentioning that this starts an executor at construction time", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r382034622", "createdAt": "2020-02-20T14:31:33Z", "author": {"login": "devinsba"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -60,30 +60,18 @@\n                   Types.newParameterizedType(Map.class, String.class, Double.class)));\n   private static final MediaType MSGPACK = MediaType.get(\"application/msgpack\");\n \n+  private final String host;\n+  private final int port;\n+  private final String unixDomainSocketPath;\n   private final OkHttpClient httpClient;\n-  private final HttpUrl tracesUrl;\n+  private HttpUrl tracesUrl;\n \n   public DDAgentApi(final String host, final int port, final String unixDomainSocketPath) {\n-    this(\n-        host,\n-        port,\n-        endpointAvailable(getUrl(host, port, TRACES_ENDPOINT_V4), unixDomainSocketPath, true),\n-        unixDomainSocketPath);\n-  }\n+    this.host = host;\n+    this.port = port;\n+    this.unixDomainSocketPath = unixDomainSocketPath;\n \n-  DDAgentApi(\n-      final String host,\n-      final int port,\n-      final boolean v4EndpointsAvailable,\n-      final String unixDomainSocketPath) {\n     httpClient = buildHttpClient(unixDomainSocketPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cddd368fc0315d181179935b2c968df0f8d2118f"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTA4MTIwOnYy", "diffSide": "RIGHT", "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDo0NDo0MFrOFsWEvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNDo0OTo0NlrOFsWR5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0MzMyNg==", "bodyText": "Maybe not for this PR, but a better overall approach might be to eliminate the endpoint sniffing as separate step.\nWe could simply wait until the first send.  If the first send fails with a 404, then we fallback to v3.  Then we remember whichever one succeeded.\nThis would require a fair amount of changes to the tests.", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r382043326", "createdAt": "2020-02-20T14:44:40Z", "author": {"login": "dougqh"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -298,6 +290,16 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n+  private synchronized void detectEndpoint() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8209a8830c0d2f82c45036f5082c57660abe2061"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0NjY5NQ==", "bodyText": "I thought about that, but it feels like it may not be worth the effort overall.", "url": "https://github.com/DataDog/dd-trace-java/pull/1236#discussion_r382046695", "createdAt": "2020-02-20T14:49:46Z", "author": {"login": "mar-kolya"}, "path": "dd-trace-ot/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -298,6 +290,16 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n+  private synchronized void detectEndpoint() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA0MzMyNg=="}, "originalCommit": {"oid": "8209a8830c0d2f82c45036f5082c57660abe2061"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 527, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}