{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0MzU3MDc0", "number": 2172, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNToyNjowOVrOFCaPag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0Nzo1MVrOFCdvgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDcxNDAyOnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/test/groovy/datadog/trace/common/metrics/OkHttpSinkTest.groovy", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNToyNjowOVrOIBjMHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjoyMzo0M1rOIBnM3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ5NjAyOQ==", "bodyText": "So I'm not completely sure about how we arrive at 100 seconds, with a queue of  10 elements.", "url": "https://github.com/DataDog/dd-trace-java/pull/2172#discussion_r538496029", "createdAt": "2020-12-08T15:26:09Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/common/metrics/OkHttpSinkTest.groovy", "diffHunk": "@@ -48,6 +51,53 @@ class OkHttpSinkTest extends DDSpecification {\n     OK          | 201\n   }\n \n+  def \"degrade to async mode when agent slow to respond\"() {\n+    // metrics payloads are relatively large and we don't want to copy them,\n+    // and we typically expect the agent to respond well within the aggregation\n+    // window, so will send synchronously whenever possible to avoid allocating\n+    // a copy of the payload. When the agent is slow to respond, we degrade to\n+    // an asynchronous mode where up to 100 seconds of requests are copied and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ce0e023b69e9fb937640484f5ee1a19561485f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUxMDk2OA==", "bodyText": "there's a 10 second aggregation interval and 10 slots in the queue", "url": "https://github.com/DataDog/dd-trace-java/pull/2172#discussion_r538510968", "createdAt": "2020-12-08T15:39:09Z", "author": {"login": "richardstartin"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/common/metrics/OkHttpSinkTest.groovy", "diffHunk": "@@ -48,6 +51,53 @@ class OkHttpSinkTest extends DDSpecification {\n     OK          | 201\n   }\n \n+  def \"degrade to async mode when agent slow to respond\"() {\n+    // metrics payloads are relatively large and we don't want to copy them,\n+    // and we typically expect the agent to respond well within the aggregation\n+    // window, so will send synchronously whenever possible to avoid allocating\n+    // a copy of the payload. When the agent is slow to respond, we degrade to\n+    // an asynchronous mode where up to 100 seconds of requests are copied and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ5NjAyOQ=="}, "originalCommit": {"oid": "d7ce0e023b69e9fb937640484f5ee1a19561485f"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU2MTc1Nw==", "bodyText": "Could you add a comment about that in the OkHttpSink referencing the interval in the ConflatingMetricsAggregator?", "url": "https://github.com/DataDog/dd-trace-java/pull/2172#discussion_r538561757", "createdAt": "2020-12-08T16:23:43Z", "author": {"login": "bantonsson"}, "path": "dd-trace-core/src/test/groovy/datadog/trace/common/metrics/OkHttpSinkTest.groovy", "diffHunk": "@@ -48,6 +51,53 @@ class OkHttpSinkTest extends DDSpecification {\n     OK          | 201\n   }\n \n+  def \"degrade to async mode when agent slow to respond\"() {\n+    // metrics payloads are relatively large and we don't want to copy them,\n+    // and we typically expect the agent to respond well within the aggregation\n+    // window, so will send synchronously whenever possible to avoid allocating\n+    // a copy of the payload. When the agent is slow to respond, we degrade to\n+    // an asynchronous mode where up to 100 seconds of requests are copied and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ5NjAyOQ=="}, "originalCommit": {"oid": "d7ce0e023b69e9fb937640484f5ee1a19561485f"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTI4NzY5OnYy", "diffSide": "RIGHT", "path": "dd-trace-core/src/main/java/datadog/trace/common/metrics/OkHttpSink.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0Nzo1MVrOIBo31Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0Nzo1MVrOIBo31Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU4OTE0MQ==", "bodyText": "This will only trigger when responses from the agent are slow (more than a second by default). Do we want to take error responses from the agent into account?", "url": "https://github.com/DataDog/dd-trace-java/pull/2172#discussion_r538589141", "createdAt": "2020-12-08T16:47:51Z", "author": {"login": "tylerbenson"}, "path": "dd-trace-core/src/main/java/datadog/trace/common/metrics/OkHttpSink.java", "diffHunk": "@@ -7,47 +7,112 @@\n import static datadog.trace.core.http.OkHttpUtils.buildHttpClient;\n import static datadog.trace.core.http.OkHttpUtils.msgpackRequestBodyOf;\n import static datadog.trace.core.http.OkHttpUtils.prepareRequest;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n \n+import datadog.trace.util.AgentTaskScheduler;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import lombok.extern.slf4j.Slf4j;\n import okhttp3.HttpUrl;\n import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import org.jctools.queues.SpscArrayQueue;\n \n+@Slf4j\n public final class OkHttpSink implements Sink, EventListener {\n \n   private final OkHttpClient client;\n   private final HttpUrl metricsUrl;\n   private final List<EventListener> listeners;\n+  private final SpscArrayQueue<Request> enqueuedRequests = new SpscArrayQueue<>(10);\n+  private final AtomicLong lastRequestTime = new AtomicLong();\n+  private final AtomicLong asyncRequestCounter = new AtomicLong();\n+  private final long asyncThresholdLatency;\n+\n+  private final AtomicBoolean asyncTaskStarted = new AtomicBoolean(false);\n+  private volatile AgentTaskScheduler.Scheduled<OkHttpSink> future;\n \n   public OkHttpSink(String agentUrl, long timeoutMillis) {\n     this(buildHttpClient(HttpUrl.get(agentUrl), timeoutMillis), agentUrl, \"v0.5/stats\");\n   }\n \n   public OkHttpSink(OkHttpClient client, String agentUrl, String path) {\n+    this(client, agentUrl, path, SECONDS.toNanos(1));\n+  }\n+\n+  public OkHttpSink(OkHttpClient client, String agentUrl, String path, long asyncThresholdLatency) {\n     this.client = client;\n     this.metricsUrl = HttpUrl.get(agentUrl).resolve(path);\n     this.listeners = new CopyOnWriteArrayList<>();\n+    this.asyncThresholdLatency = asyncThresholdLatency;\n   }\n \n   @Override\n   public void accept(int messageCount, ByteBuffer buffer) {\n-    try (final okhttp3.Response response =\n-        client\n-            .newCall(\n-                prepareRequest(metricsUrl)\n-                    .put(msgpackRequestBodyOf(Collections.singletonList(buffer)))\n-                    .build())\n-            .execute()) {\n+    // if the agent is healthy, then we can send on this thread,\n+    // without copying the buffer, otherwise this needs to be async,\n+    // so need to copy and buffer the request, and let it be executed\n+    // on the main task scheduler as a last resort\n+    if (lastRequestTime.get() < asyncThresholdLatency) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7ce0e023b69e9fb937640484f5ee1a19561485f"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4506, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}