{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NDM1MzQ1", "number": 2050, "title": "Akka Actor and Akka HTTP bindAndHandle instrumentation", "bodyText": "A number of changes to support bindAndHandle in akka-http:\n\nChange akka-actor instrumentation to not leak context between actors, and attach context to the messages instead of the mailboxes.\nInstrument the flow in bindAndHandle for akka-http to have one single place that covers all server bind* variants.\nChange the client instrumentation in akka-http to not rely on a thread local when checking for nesting to avoid repeated spans in preparation for client flow support.", "createdAt": "2020-11-04T14:49:53Z", "url": "https://github.com/DataDog/dd-trace-java/pull/2050", "merged": true, "mergeCommit": {"oid": "7c3ce9692c39aa69eaa000d616beed66b86306e9"}, "closed": true, "closedAt": "2020-11-13T16:45:34Z", "author": {"login": "bantonsson"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZjDgdgBqjM5NjI2MDY2OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdcJj2UgFqTUzMDE5NzQyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad5000c8022a08c6e21760acc2621879e6765b57", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ad5000c8022a08c6e21760acc2621879e6765b57", "committedDate": "2020-11-04T14:36:37Z", "message": "stash bindAndHandle"}, "afterCommit": {"oid": "a2a8a8acce98b8bf30461e952c9c9a1745096511", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a2a8a8acce98b8bf30461e952c9c9a1745096511", "committedDate": "2020-11-05T14:15:31Z", "message": "Clean up and expand akka-http server tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2a8a8acce98b8bf30461e952c9c9a1745096511", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/a2a8a8acce98b8bf30461e952c9c9a1745096511", "committedDate": "2020-11-05T14:15:31Z", "message": "Clean up and expand akka-http server tests"}, "afterCommit": {"oid": "89649cd1c01645602d7452b8e880649fde7bae80", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/89649cd1c01645602d7452b8e880649fde7bae80", "committedDate": "2020-11-09T11:51:07Z", "message": "Clean up and expand akka-http client instrumentation and tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89649cd1c01645602d7452b8e880649fde7bae80", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/89649cd1c01645602d7452b8e880649fde7bae80", "committedDate": "2020-11-09T11:51:07Z", "message": "Clean up and expand akka-http client instrumentation and tests"}, "afterCommit": {"oid": "7eac56abbc9a95ac3068144992a4467cda4f63b8", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/7eac56abbc9a95ac3068144992a4467cda4f63b8", "committedDate": "2020-11-09T16:58:14Z", "message": "Clean up and expand akka-http client instrumentation and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3MzE3Njc0", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#pullrequestreview-527317674", "createdAt": "2020-11-10T15:25:47Z", "commit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNToyNTo0OFrOHwh5ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoyODoxMVrOHwyGeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0OTE0Ng==", "bodyText": "This seems rather scary and will likely result in unexpected bugs elsewhere.  Do you know why this is necessary?", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520649146", "createdAt": "2020-11-10T15:25:48Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter TraceScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2NzQ2MA==", "bodyText": "lol... zis", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520667460", "createdAt": "2020-11-10T15:48:54Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaEnvelopeInstrumentation.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaEnvelopeInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaEnvelopeInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Envelope\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isConstructor(), getClass().getName() + \"$ConstructAdvice\");\n+  }\n+\n+  public static class ConstructAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void afterInit(@Advice.This Envelope zis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY4MDE1NQ==", "bodyText": "Same concern applies here.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520680155", "createdAt": "2020-11-10T16:05:00Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaMailboxInstrumentation.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.ExcludeFilterProvider;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaMailboxInstrumentation extends Instrumenter.Default\n+    implements ExcludeFilterProvider {\n+\n+  public AkkaMailboxInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.dispatch.Mailbox\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod().and(named(\"run\")), getClass().getName() + \"$SuppressMailboxRunAdvice\");\n+  }\n+\n+  @Override\n+  public Map<ExcludeFilter.ExcludeType, ? extends Collection<String>> excludedClasses() {\n+    List<String> excludedClass = singletonList(\"akka.dispatch.MailBox\");\n+    EnumMap<ExcludeFilter.ExcludeType, Collection<String>> excludedTypes =\n+        new EnumMap<>(ExcludeFilter.ExcludeType.class);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.RUNNABLE, excludedClass);\n+    excludedTypes.put(ExcludeFilter.ExcludeType.FORK_JOIN_TASK, excludedClass);\n+    return excludedTypes;\n+  }\n+\n+  public static final class SuppressMailboxRunAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope enter() {\n+      // Create our own noopSpan to make sure that we close all scopes up until this\n+      // position after exit\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      return activateSpan(span, false);\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(@Advice.Enter final AgentScope scope) {\n+      // Clean up any leaking scopes from akka-streams/akka-http et.c.\n+      TraceScope activeScope = activeScope();\n+      while (activeScope != null && activeScope != scope) {\n+        activeScope.close();\n+        activeScope = activeScope();\n+      }\n+      while (activeScope == scope) {\n+        scope.close();\n+        activeScope = activeScope();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe143a7916cfe72851921b105dbdfa41db303cfd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzExMg==", "bodyText": "This seems rather odd.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833112", "createdAt": "2020-11-10T19:50:17Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg==", "bodyText": "use noopSpan() instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520833612", "createdAt": "2020-11-10T19:51:10Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzc1Nw==", "bodyText": "Or maybe even AgentTracer.NoopAgentScope.INSTANCE instead.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520837757", "createdAt": "2020-11-10T19:58:38Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzYxMg=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ==", "bodyText": "This seems to be needed because the request handler which creates the span is separate from the response handler that finishes the span, so this queue is used to correlate the scopes?", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520839251", "createdAt": "2020-11-10T20:01:08Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDkxOA==", "bodyText": "This is interesting.  I guess this is the reason you need that logic to clear the scope stack.  I don't think I understand though why the scope can't be closed after the push.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520840918", "createdAt": "2020-11-10T20:04:11Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDU1Mw==", "bodyText": "Since the span is started when the request comes into the server, it would seem more logical to me to have it finish when it is returning the response to the server.  In practice I don't think there will be much difference though... just an incongruity.", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r520914553", "createdAt": "2020-11-10T22:28:11Z", "author": {"login": "tylerbenson"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);\n+\n+          // This is where the request comes in from the server and TCP layer\n+          setHandler(\n+              requestInlet,\n+              new AbstractInHandler() {\n                 @Override\n-                public HttpResponse apply(final HttpResponse response) {\n-                  DatadogWrapperHelper.finishSpan(scope.span(), response);\n-                  return response;\n+                public void onPush() throws Exception {\n+                  final HttpRequest request = grab(requestInlet);\n+                  final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n+                  if (scope != null) {\n+                    scopes.add(scope);\n+                  } else {\n+                    scopes.add(DUMMY_SCOPE);\n+                  }\n+                  push(requestOutlet, request);\n+                  // Since we haven't instrumented the akka stream state machine, we can't rely\n+                  // on spans and scopes being propagated during the push and pull of the\n+                  // element. Instead we let the scope leak intentionally here and clean it\n+                  // up when the user response comes back, or in the actor message processing\n+                  // instrumentation that drives this state machine.\n                 }\n-              },\n-              new AbstractFunction1<Throwable, Throwable>() {\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  complete(requestOutlet);\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception, Exception {\n+                  // We will not receive any more requests from the server and TCP layer so stop\n+                  // sending them\n+                  fail(requestOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the requests goes out to the user code\n+          setHandler(\n+              requestOutlet,\n+              new AbstractOutHandler() {\n+                @Override\n+                public void onPull() throws Exception {\n+                  pull(requestInlet);\n+                }\n+\n+                @Override\n+                public void onDownstreamFinish() throws Exception {\n+                  // We can not send out any more requests to the user code so stop receiving them\n+                  cancel(requestInlet);\n+                }\n+              });\n+\n+          // This is where the response comes back from the user code\n+          setHandler(\n+              responseInlet,\n+              new AbstractInHandler() {\n+                @Override\n+                public void onPush() throws Exception {\n+                  final HttpResponse response = grab(responseInlet);\n+                  final AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    DatadogWrapperHelper.finishSpan(scope.span(), response);\n+                    // Check if the active scope is still the scope from when the request came in,\n+                    // and close it. If it's not, then it will be cleaned up actor message\n+                    // processing instrumentation that drives this state machine\n+                    TraceScope activeScope = activeScope();\n+                    if (activeScope == scope) {\n+                      scope.close();\n+                    }\n+                  }\n+                  push(responseOutlet, response);\n+                }\n+\n+                @Override\n+                public void onUpstreamFinish() throws Exception {\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  AgentScope scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  completeStage();\n+                }\n+\n+                @Override\n+                public void onUpstreamFailure(final Throwable ex) throws Exception {\n+                  AgentScope scope = scopes.poll();\n+                  if (scope != null && scope != DUMMY_SCOPE) {\n+                    // Mark the span as failed\n+                    DatadogWrapperHelper.finishSpan(scope.span(), ex);\n+                  }\n+                  // We will not receive any more responses from the user code, so clean up any\n+                  // remaining spans\n+                  scope = scopes.poll();\n+                  while (scope != null) {\n+                    if (scope != DUMMY_SCOPE) {\n+                      scope.span().finish();\n+                    }\n+                    scope = scopes.poll();\n+                  }\n+                  fail(responseOutlet, ex);\n+                }\n+              });\n+\n+          // This is where the response goes back to the server and TCP layer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 331}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NDg5NTEy", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#pullrequestreview-528489512", "createdAt": "2020-11-11T19:55:33Z", "commit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTo1NTozM1rOHxcGlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDowMDo1NFrOHxcRYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwMjcwOA==", "bodyText": "AgentTracer.noopSpan() would be better here", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521602708", "createdAt": "2020-11-11T19:55:33Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/akka-concurrent/src/main/java/datadog/trace/instrumentation/akka/concurrent/AkkaActorCellInstrumentation.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.akka.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import akka.dispatch.Envelope;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.AdviceUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public class AkkaActorCellInstrumentation extends Instrumenter.Default {\n+\n+  public AkkaActorCellInstrumentation() {\n+    super(\"java_concurrent\", \"akka_concurrent\", \"akka_actor\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"akka.actor.ActorCell\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"akka.dispatch.Envelope\", State.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(isMethod().and(named(\"invoke\")), getClass().getName() + \"$InvokeAdvice\");\n+  }\n+\n+  public static class InvokeAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static TraceScope enter(@Advice.Argument(value = 0) Envelope envelope) {\n+      TraceScope scope =\n+          AdviceUtils.startTaskScope(\n+              InstrumentationContext.get(Envelope.class, State.class), envelope);\n+      if (scope != null) {\n+        return scope;\n+      }\n+      // If there is no scope created from the envelope, we create our own noopSpan to make sure\n+      // that we can close all scopes up until this position after exit.\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNTQ3Mg==", "bodyText": "In reference to the order, what I gathered from observing the behavior is that a new instance of the graph stage logic is created for each connection", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#discussion_r521605472", "createdAt": "2020-11-11T20:00:54Z", "author": {"login": "devinsba"}, "path": "dd-java-agent/instrumentation/akka-http-10.0/src/main/java/datadog/trace/instrumentation/akkahttp/AkkaHttpServerInstrumentation.java", "diffHunk": "@@ -125,79 +115,177 @@ public static void finishSpan(final AgentSpan span, final Throwable t) {\n       span.setTag(Tags.HTTP_STATUS, 500);\n       DECORATE.beforeFinish(span);\n \n-      final TraceScope scope = activeScope();\n-      if (scope != null) {\n-        scope.setAsyncPropagation(false);\n-      }\n       span.finish();\n     }\n   }\n \n-  public static class DatadogSyncWrapper extends AbstractFunction1<HttpRequest, HttpResponse> {\n-    private final Function1<HttpRequest, HttpResponse> userHandler;\n+  public static class DatadogServerRequestResponseFlowWrapper\n+      extends GraphStage<BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest>> {\n+    private final Inlet<HttpRequest> requestInlet = Inlet.create(\"Datadog.server.requestIn\");\n+    private final Outlet<HttpRequest> requestOutlet = Outlet.create(\"Datadog.server.requestOut\");\n+    private final Inlet<HttpResponse> responseInlet = Inlet.create(\"Datadog.server.responseIn\");\n+    private final Outlet<HttpResponse> responseOutlet = Outlet.create(\"Datadog.server.responseOut\");\n+    private final BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape =\n+        BidiShape.of(responseInlet, responseOutlet, requestInlet, requestOutlet);\n \n-    public DatadogSyncWrapper(final Function1<HttpRequest, HttpResponse> userHandler) {\n-      this.userHandler = userHandler;\n+    private final int pipeliningLimit;\n+    private final AgentScope DUMMY_SCOPE;\n+\n+    public DatadogServerRequestResponseFlowWrapper(final ServerSettings settings) {\n+      this.pipeliningLimit = settings.getPipeliningLimit();\n+      AgentSpan span = new AgentTracer.NoopAgentSpan();\n+      // Create a dummy scope that we can store in the queue if we can't create a scope\n+      DUMMY_SCOPE = activateSpan(span, false);\n+      DUMMY_SCOPE.close();\n     }\n \n     @Override\n-    public HttpResponse apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      try {\n-        final HttpResponse response = userHandler.apply(request);\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), response);\n-        return response;\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n+    public BidiShape<HttpResponse, HttpResponse, HttpRequest, HttpRequest> shape() {\n+      return shape;\n     }\n-  }\n \n-  public static class DatadogAsyncWrapper\n-      extends AbstractFunction1<HttpRequest, Future<HttpResponse>> {\n-    private final Function1<HttpRequest, Future<HttpResponse>> userHandler;\n-    private final ExecutionContext executionContext;\n-\n-    public DatadogAsyncWrapper(\n-        final Function1<HttpRequest, Future<HttpResponse>> userHandler,\n-        final ExecutionContext executionContext) {\n-      this.userHandler = userHandler;\n-      this.executionContext = executionContext;\n+    @Override\n+    public Attributes initialAttributes() {\n+      return Attributes.name(\"DatadogServerRequestResponseFlowWrapper\");\n     }\n \n     @Override\n-    public Future<HttpResponse> apply(final HttpRequest request) {\n-      final AgentScope scope = DatadogWrapperHelper.createSpan(request);\n-      Future<HttpResponse> futureResponse = null;\n-      try {\n-        futureResponse = userHandler.apply(request);\n-      } catch (final Throwable t) {\n-        scope.close();\n-        DatadogWrapperHelper.finishSpan(scope.span(), t);\n-        throw t;\n-      }\n-      final Future<HttpResponse> wrapped =\n-          futureResponse.transform(\n-              new AbstractFunction1<HttpResponse, HttpResponse>() {\n+    public GraphStageLogic createLogic(final Attributes inheritedAttributes) throws Exception {\n+      return new GraphStageLogic(shape) {\n+        {\n+          // The request/response is guaranteed to be in order according to the docs at\n+          // https://doc.akka.io/docs/akka-http/current/server-side/low-level-api.html#request-response-cycle\n+          // and there can never be more outstanding requests than the pipeliningLimit\n+          // that this connection was created with. This means that we can safely\n+          // close the span at the front of the queue when we receive the response\n+          // from the user code, since it will match up to the request for that span.\n+          final Queue<AgentScope> scopes = new ArrayBlockingQueue<>(pipeliningLimit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI1MQ=="}, "originalCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8"}, "originalPosition": 217}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/eb91c6488088d753e81f0cc00a412aa9b3bbfcda", "committedDate": "2020-11-12T16:51:23Z", "message": "Instrument akka-actor messaging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d77faecbf07767c204b5906abef03f8628881fdd", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/d77faecbf07767c204b5906abef03f8628881fdd", "committedDate": "2020-11-12T16:51:23Z", "message": "Instrument akka-http bindAndHandle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2db316dd5362aead035dddb9de63ea5fbdc99fc", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/b2db316dd5362aead035dddb9de63ea5fbdc99fc", "committedDate": "2020-11-12T16:51:24Z", "message": "Clean up and expand akka-http server tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a7522a031c4f5a6057ad3458ac10b75a13bc099", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/1a7522a031c4f5a6057ad3458ac10b75a13bc099", "committedDate": "2020-11-12T16:51:24Z", "message": "Clean up and expand akka-http client instrumentation and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba0b58a290d9cac6586637d0380e1e842e110b6f", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/ba0b58a290d9cac6586637d0380e1e842e110b6f", "committedDate": "2020-11-12T16:51:24Z", "message": "Add debug logging to TraceStructureWriter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f18e63868a377500da2bf6f1a42c72a5860793c4", "committedDate": "2020-11-12T16:51:24Z", "message": "Remove unnecessary code and add comments to instrumentations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "610cf62d2f0bbf5522423c17d67506c6858e9da8", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/610cf62d2f0bbf5522423c17d67506c6858e9da8", "committedDate": "2020-11-10T10:49:16Z", "message": "Add debug logging to TraceStructureWriter"}, "afterCommit": {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4", "author": {"user": {"login": "bantonsson", "name": "Bj\u00f6rn Antonsson"}}, "url": "https://github.com/DataDog/dd-trace-java/commit/f18e63868a377500da2bf6f1a42c72a5860793c4", "committedDate": "2020-11-12T16:51:24Z", "message": "Remove unnecessary code and add comments to instrumentations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMTkwMTI3", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#pullrequestreview-530190127", "createdAt": "2020-11-13T16:06:18Z", "commit": {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMTk3NDI4", "url": "https://github.com/DataDog/dd-trace-java/pull/2050#pullrequestreview-530197428", "createdAt": "2020-11-13T16:15:25Z", "commit": {"oid": "f18e63868a377500da2bf6f1a42c72a5860793c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3076, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}